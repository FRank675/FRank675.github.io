<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LangChain中的Runnable接口</title>
      <link href="/FRank675.github.io/posts/10a291913132/"/>
      <url>/FRank675.github.io/posts/10a291913132/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\FRank675.github.io\css\APlayer.min.css"><script src="\FRank675.github.io\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\FRank675.github.io\js\Meting.min.js"></script><p><code>Runnable</code> 接口是使用 <code>LangChain</code> 组件的基础，它在很多组件中实现，例如语言模型（<code>language models</code>）、输出解析器（<code>output parsers</code>）、检索器（<code>retrievers</code>）、编译的 <code>LangGraph</code> 图，该接口允许开发人员以一致且可预测的方式与各种 <code>LangChain</code> 组件进行交互。</p><h1 id="Runnable-接口概述"><a href="#Runnable-接口概述" class="headerlink" title="Runnable 接口概述"></a>Runnable 接口概述</h1><p>Runnable 的方式定义了一个标准的接口，允许 Runnable 组件：</p><ul><li><code>Invoked</code>：将单个输入转换为输出。</li><li><code>Batched</code>：多个输入被有效地转换为输出。</li><li><code>Streamed</code>：输出在生成时进行流式传输。</li><li><code>Inspected</code>：可以访问有关 <code>Runnable</code> 的输入、输出和配置的示意图信息。</li><li><code>Composed</code>：可以组合多个 <code>Runnable</code>，使用 <code>LangChain</code> 表达语言（<code>LCEL</code>)协同工作，以创建复杂的管道。</li></ul><h2 id="优化的并行执行（batch）"><a href="#优化的并行执行（batch）" class="headerlink" title="优化的并行执行（batch）"></a>优化的并行执行（batch）</h2><p><code>LangChain Runnables</code> 提供内置<code>batch</code>（和<code>batch_as_completed</code>）API，允许您并行处理多个输入。</p><p>当需要处理多个独立输入时，使用这些方法可以显著提高性能，因为处理可以并行进行而不是顺序进行。</p><p>两个批处理选项是：</p><ul><li><code>batch</code>：并行处理多个输入，按与输入相同的顺序返回结果。</li><li><code>batch_as_completed</code>：并行处理多个输入，并在完成后返回结果。结果可能无序到达，但每个结果都包含用于匹配的输入索引。</li></ul><p><code>batch</code>和<code>batch_as_completed</code>的默认实现使用线程池执行器来并行运行该<code>invoke</code>方法。这允许高效的并行执行，无需用户管理线程，并加速 I&#x2F;O 密集型代码（例如发出 API 请求、读取文件等）。对于 CPU 密集型操作，它的效果不佳，因为 Python 中的 GIL（全局解释器锁）会阻止真正的并行执行。</p><p>一些 Runnable 可能会针对其特定用例进行优化，提供自己的<code>batch</code>和<code>batch_as_completed</code>实现（例如，依赖<code>batch</code>模型提供者提供的 API）。</p><blockquote><p>[!note]</p><p><code>batch</code>和<code>batch_as_completed</code>的异步版本依赖于<code>asyncio</code>的<code>gather</code>和<code>as_completed</code>函数来并行允许<code>ainvoke</code>方法。</p></blockquote><blockquote><p>[!TIP]</p><p>当使用<code>batch</code>和<code>batch_as_completed</code>处理大量的输入时，用户可能会想控制最大并行调用数。这可以通过设置<code>RunnableConfig</code>字典中的<code>max_concurrency</code>参数来实现。</p><p>聊天模型还具有内置速率限制器，可用于控制请求的速率。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LangChain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何让 LLM 的返回值流式输出？</title>
      <link href="/FRank675.github.io/posts/c7da7bbb1a7b/"/>
      <url>/FRank675.github.io/posts/c7da7bbb1a7b/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\FRank675.github.io\css\APlayer.min.css"><script src="\FRank675.github.io\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\FRank675.github.io\js\Meting.min.js"></script><h1 id="如何让-LLM-的返回值流式输出？"><a href="#如何让-LLM-的返回值流式输出？" class="headerlink" title="如何让 LLM 的返回值流式输出？"></a>如何让 LLM 的返回值流式输出？</h1><h2 id="流式输出"><a href="#流式输出" class="headerlink" title="流式输出"></a>流式输出</h2><p>大模型收到输入后并不是一次性生成最终结果，而是逐步地生成中间结果，最终结果由中间结果拼接而成。用流式输出的方式调用大模型 API，能够实时返回中间结果，减少用户的阅读等待时间，并降低请求的超时风险。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>流式输出，也称为流式传输，指的是服务器持续地将数据推送到客户端，而不是一次性发送完毕。这种模式下，连接一旦建立，服务器就能实时地发送更新给客户端。</p><p>相比非流式输出，流式输出可以实时地将中间结果返回，您可以在模型进行输出的同时进行阅读，减少等待模型回复的时间；并且当输出内容较长时，有效降低请求超时的风险。</p><blockquote><p>请求超时错误的报错信息：Request timed out, please try again later. 或 Response timeout。</p></blockquote><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>流式输出的典型应用场景包括实时消息推送、股票行情更新、实时通知等，任何需要服务器向客户端实时传输数据的场合都可以使用。</p><h4 id="与普通请求的区别"><a href="#与普通请求的区别" class="headerlink" title="与普通请求的区别"></a>与普通请求的区别</h4><p>与传统的 HTTP 请求不同，普通请求是基于请求-响应模型，客户端发送请求后，服务器处理完毕即刻响应并关闭连接。流式输出则保持连接开放，允许服务器连续发送多个响应。</p><h2 id="如何创建一个-SSE"><a href="#如何创建一个-SSE" class="headerlink" title="如何创建一个 SSE"></a>如何创建一个 SSE</h2><p>在 Python 中，可以使用 fastAPI 框架来实现 Server-Sent Event。以下是一个示例：</p><ol><li>安装 FastAPI 和 Uvicorn 首先，确保你已经安装了 FastAPI 和 Uvicorn ：</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install fastapi uvicorn</span><br></pre></td></tr></table></figure><ol start="2"><li>创建 FastAPI 应用 接下来，创建一个 FastAPI 应用，并定义一个流式接口。我们将使用异步生成器来逐步生成数据，并使用 StreamingResponse 来流式发送数据给客户端。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> sse_starlette.sse <span class="keyword">import</span> EventSourceResponse</span><br><span class="line"><span class="keyword">import</span> uvicorn</span><br><span class="line"><span class="keyword">from</span> fastapi.middleware.cors <span class="keyword">import</span> CORSMiddleware</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line">app.add_middleware(</span><br><span class="line">    CORSMiddleware,</span><br><span class="line">    allow_origins=[<span class="string">&#x27;*&#x27;</span>], <span class="comment"># 设置允许跨域的域名列表，* 代表所有域名</span></span><br><span class="line">    allow_credentials=<span class="literal">True</span>,</span><br><span class="line">    allow_methods=[<span class="string">&#x27;*&#x27;</span>],</span><br><span class="line">    allow_headers=[<span class="string">&#x27;*&#x27;</span>],</span><br><span class="line">)</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">event_generator</span>():</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        data = &#123;<span class="string">&quot;count&quot;</span>: count&#125;</span><br><span class="line">        <span class="keyword">yield</span> json.dumps(data)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/events&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get_events</span>():</span><br><span class="line">    <span class="keyword">return</span> EventSourceResponse(event_generator())</span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/events&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">post_events</span>():</span><br><span class="line">      <span class="keyword">return</span> EventSourceResponse(event_generator())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    uvicorn.run(app, host=<span class="string">&#x27;0.0.0.0&#x27;</span>, port=<span class="number">4000</span>)</span><br></pre></td></tr></table></figure><ol start="3"><li>运行应用 保存上述代码到一个文件（例如main.py），然后运行应用：</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python main.py</span><br></pre></td></tr></table></figure><ol start="4"><li>测试流式接口</li></ol><ul><li>get 接口</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">curl http://<span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">4000</span>/events</span><br></pre></td></tr></table></figure><ul><li>post 接口</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">curl -X POST <span class="string">&quot;http://0.0.0.0:4000/events&quot;</span> -H <span class="string">&quot;Content-Type: application/json&quot;</span></span><br></pre></td></tr></table></figure><p>预期输出如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data: &#123;&quot;count&quot;: 1&#125;</span><br><span class="line"></span><br><span class="line">data: &#123;&quot;count&quot;: 2&#125;</span><br><span class="line"></span><br><span class="line">data: &#123;&quot;count&quot;: 3&#125;</span><br><span class="line"></span><br><span class="line">data: &#123;&quot;count&quot;: 4&#125;</span><br><span class="line"></span><br><span class="line">data: &#123;&quot;count&quot;: 5&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>为什么大模型需要使用 SSE ？</p><p>从某种意义上说，现阶段 LLM 模型采用 SSE 是历史遗留原因。</p><p>Transformer 前后内容是需要推理拼接的，且不说内容很多的时候，推理的时间会很长（还有 Max Token 的限制）。推理上下文的时候也是逐步推理生成的，因此默认就是流式输出进行包裹。如果哪天 AI 的速度可以不受这些内容的限制了，可能一次性返回是一个更好的交互。</p><h2 id="解析流式接口请求"><a href="#解析流式接口请求" class="headerlink" title="解析流式接口请求"></a>解析流式接口请求</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">fetchSSE</span> = <span class="keyword">async</span> (<span class="params">options: FetchSSEOptions = &#123;&#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; success, fail, complete &#125; = options;</span><br><span class="line">  <span class="comment">// fetch请求流式接口url，需传入接口url和参数</span></span><br><span class="line">  <span class="keyword">const</span> responsePromise = <span class="title function_">fetch</span>().<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> msg = e.<span class="title function_">toString</span>() || <span class="string">&#x27;流式接口异常&#x27;</span>;</span><br><span class="line">    complete?.(<span class="literal">false</span>, msg);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(e); <span class="comment">// 确保错误能够被后续的.catch()捕获</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  responsePromise</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!response?.<span class="property">ok</span>) &#123;</span><br><span class="line">        complete?.(<span class="literal">false</span>, response.<span class="property">statusText</span>);</span><br><span class="line">        fail?.();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Request failed&#x27;</span>); <span class="comment">// 抛出错误以便链式调用中的下一个.catch()处理</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> reader = response.<span class="property">body</span>.<span class="title function_">getReader</span>();</span><br><span class="line">      <span class="keyword">const</span> decoder = <span class="keyword">new</span> <span class="title class_">TextDecoder</span>();</span><br><span class="line">      <span class="keyword">if</span> (!reader) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;No reader available&#x27;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> <span class="attr">bufferArr</span>: string[] = [];</span><br><span class="line">      <span class="keyword">let</span> dataText = <span class="string">&#x27;&#x27;</span>; <span class="comment">// 记录数据</span></span><br><span class="line">      <span class="keyword">const</span> <span class="attr">event</span>: <span class="title class_">SSEEvent</span> = &#123; <span class="attr">type</span>: <span class="literal">null</span>, <span class="attr">data</span>: <span class="literal">null</span> &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">processText</span>(<span class="params">&#123; done, value &#125;: ReadableStreamReadResult&lt;<span class="built_in">Uint8Array</span>&gt;</span>): <span class="title class_">Promise</span>&lt;<span class="keyword">void</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (done) &#123;</span><br><span class="line">          complete?.(<span class="literal">true</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> chunk = decoder.<span class="title function_">decode</span>(value);</span><br><span class="line">        <span class="keyword">const</span> buffers = chunk.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="regexp">/\r?\n/</span>);</span><br><span class="line">        bufferArr.<span class="title function_">push</span>(...buffers);</span><br><span class="line">        <span class="keyword">const</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; bufferArr.<span class="property">length</span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> line = bufferArr[i];</span><br><span class="line">          <span class="keyword">if</span> (line) &#123;</span><br><span class="line">            dataText += line;</span><br><span class="line">            <span class="keyword">const</span> response = line.<span class="title function_">slice</span>(<span class="number">6</span>);</span><br><span class="line">            <span class="keyword">if</span> (response === <span class="string">&#x27;[DONE]&#x27;</span>) &#123;</span><br><span class="line">              event.<span class="property">type</span> = <span class="string">&#x27;finish&#x27;</span>;</span><br><span class="line">              dataText = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">const</span> choices = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(response.<span class="title function_">trim</span>())?.<span class="property">choices</span>?.[<span class="number">0</span>];</span><br><span class="line">              <span class="keyword">if</span> (choices.<span class="property">finish_reason</span> === <span class="string">&#x27;stop&#x27;</span>) &#123;</span><br><span class="line">                event.<span class="property">type</span> = <span class="string">&#x27;finish&#x27;</span>;</span><br><span class="line">                dataText = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                event.<span class="property">type</span> = <span class="string">&#x27;delta&#x27;</span>;</span><br><span class="line">                event.<span class="property">data</span> = choices;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (event.<span class="property">type</span> &amp;&amp; event.<span class="property">data</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> jsonData = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(event));</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;流式数据解析结果:&#x27;</span>, jsonData);</span><br><span class="line">            <span class="comment">// 回调更新数据</span></span><br><span class="line">            <span class="title function_">success</span>(jsonData);</span><br><span class="line">            event.<span class="property">type</span> = <span class="literal">null</span>;</span><br><span class="line">            event.<span class="property">data</span> = <span class="literal">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          bufferArr.<span class="title function_">splice</span>(i, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reader.<span class="title function_">read</span>().<span class="title function_">then</span>(processText);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> reader.<span class="title function_">read</span>().<span class="title function_">then</span>(processText);</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 处理整个链式调用过程中发生的任何错误</span></span><br><span class="line">      fail?.();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="如何让通义千问模型流式输出结果"><a href="#如何让通义千问模型流式输出结果" class="headerlink" title="如何让通义千问模型流式输出结果"></a>如何让通义千问模型流式输出结果</h2><h3 id="OpenAI-兼容"><a href="#OpenAI-兼容" class="headerlink" title="OpenAI 兼容"></a>OpenAI 兼容</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> openai <span class="keyword">import</span> OpenAI</span><br><span class="line"></span><br><span class="line">client = OpenAI(</span><br><span class="line">    <span class="comment"># 若没有配置环境变量，请用阿里云百炼API Key将下行替换为：api_key=&quot;sk-xxx&quot;,</span></span><br><span class="line">    api_key=os.getenv(<span class="string">&quot;DASHSCOPE_API_KEY&quot;</span>),</span><br><span class="line">    base_url=<span class="string">&quot;https://dashscope.aliyuncs.com/compatible-mode/v1&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">completion = client.chat.completions.create(</span><br><span class="line">    model=<span class="string">&quot;qwen-plus&quot;</span>,  <span class="comment"># 此处以qwen-plus为例，您可按需更换模型名称。模型列表：https://help.aliyun.com/zh/model-studio/getting-started/models</span></span><br><span class="line">    messages=[</span><br><span class="line">        &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;system&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;You are a helpful assistant.&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;你是谁？&quot;</span>&#125;</span><br><span class="line">    ],</span><br><span class="line">    stream=<span class="literal">True</span>,</span><br><span class="line">    <span class="comment"># Qwen3模型通过enable_thinking参数控制思考过程（开源版默认True，商业版默认False）</span></span><br><span class="line">    <span class="comment"># 使用Qwen3开源版模型时，请将下行取消注释，否则会报错</span></span><br><span class="line">    <span class="comment"># extra_body=&#123;&quot;enable_thinking&quot;: False&#125;,</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">full_content = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;流式输出内容为：&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> chunk <span class="keyword">in</span> completion:</span><br><span class="line">    <span class="comment"># 如果stream_options.include_usage为True，则最后一个chunk的choices字段为空列表，需要跳过（可以通过chunk.usage获取 Token 使用量）</span></span><br><span class="line">    <span class="keyword">if</span> chunk.choices:</span><br><span class="line">        full_content += chunk.choices[<span class="number">0</span>].delta.content</span><br><span class="line">        <span class="built_in">print</span>(chunk.choices[<span class="number">0</span>].delta.content)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;完整内容为：<span class="subst">&#123;full_content&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="DashScope"><a href="#DashScope" class="headerlink" title="DashScope"></a>DashScope</h3><blockquote><p>流式输出的内容默认是非增量式（即每次返回的内容都包含之前生成的内容），如果您需要使用增量式流式输出，请设置<code>incremental_output</code>（Java 为<code>incrementalOutput</code>）参数为 <code>true</code> 。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> dashscope <span class="keyword">import</span> Generation</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">messages = [</span><br><span class="line">    &#123;<span class="string">&#x27;role&#x27;</span>:<span class="string">&#x27;system&#x27;</span>,<span class="string">&#x27;content&#x27;</span>:<span class="string">&#x27;you are a helpful assistant&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;role&#x27;</span>: <span class="string">&#x27;user&#x27;</span>,<span class="string">&#x27;content&#x27;</span>: <span class="string">&#x27;你是谁？&#x27;</span>&#125;]</span><br><span class="line">responses = Generation.call(</span><br><span class="line">    <span class="comment"># 若没有配置环境变量，请用阿里云百炼API Key将下行替换为：api_key=&quot;sk-xxx&quot;,</span></span><br><span class="line">    api_key=os.getenv(<span class="string">&quot;DASHSCOPE_API_KEY&quot;</span>),</span><br><span class="line">    model=<span class="string">&quot;qwen-plus&quot;</span>, <span class="comment"># 此处以qwen-plus为例，您可按需更换模型名称。模型列表：https://help.aliyun.com/zh/model-studio/getting-started/models</span></span><br><span class="line">    messages=messages,</span><br><span class="line">    result_format=<span class="string">&#x27;message&#x27;</span>,</span><br><span class="line">    stream=<span class="literal">True</span>,</span><br><span class="line">    <span class="comment"># 增量式流式输出</span></span><br><span class="line">    incremental_output=<span class="literal">True</span>,</span><br><span class="line">    <span class="comment"># Qwen3模型通过enable_thinking参数控制思考过程（开源版默认True，商业版默认False）</span></span><br><span class="line">    <span class="comment"># 使用Qwen3开源版模型时，若未启用流式输出，请将下行取消注释，否则会报错</span></span><br><span class="line">    <span class="comment"># enable_thinking=False</span></span><br><span class="line">    )</span><br><span class="line">full_content = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;流式输出内容为：&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> response <span class="keyword">in</span> responses:</span><br><span class="line">    full_content += response.output.choices[<span class="number">0</span>].message.content</span><br><span class="line">    <span class="built_in">print</span>(response.output.choices[<span class="number">0</span>].message.content)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;完整内容为：<span class="subst">&#123;full_content&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><hr><blockquote><p><strong>参考内容：</strong></p><ul><li><a href="https://tdesign.tencent.com/chat/sse">https://tdesign.tencent.com/chat/sse</a></li><li><a href="https://help.aliyun.com/zh/model-studio/stream#62e34380ae0kg">https://help.aliyun.com/zh/model-studio/stream#62e34380ae0kg</a></li></ul></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LLM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>协程 &amp; 异步编程(asyncio)</title>
      <link href="/FRank675.github.io/posts/795db927122f/"/>
      <url>/FRank675.github.io/posts/795db927122f/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\FRank675.github.io\css\APlayer.min.css"><script src="\FRank675.github.io\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\FRank675.github.io\js\Meting.min.js"></script><h1 id="协程-amp-异步编程-asyncio"><a href="#协程-amp-异步编程-asyncio" class="headerlink" title="协程 &amp; 异步编程(asyncio)"></a>协程 &amp; 异步编程(asyncio)</h1><p>协程（Coroutine），也可以被称为微线程，是一种用户态内的上下文切换技术。简而言之，其实就是通过一个线程实现代码块相互切换执行。例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">    ...</span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>():</span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span>)</span><br><span class="line">    ...</span><br><span class="line"><span class="built_in">print</span>(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">func1()</span><br><span class="line">func2()</span><br></pre></td></tr></table></figure><p>上述代码是普通的函数定义和执行，按流程分别执行两个函数中的代码，并先后会输出：<code>1、2、3、4</code>。但如果介入协程技术那么就可以实现函数见代码切换执行，最终输入：<code>1、3、2、4</code> 。</p><h2 id="1-协程的实现"><a href="#1-协程的实现" class="headerlink" title="1. 协程的实现"></a>1. 协程的实现</h2><p>在Python中有多种方式可以实现协程，例如：</p><ul><li>greenlet，是一个第三方模块，用于实现协程代码（Gevent协程就是基于greenlet实现）</li><li>yield，生成器，借助生成器的特点也可以实现协程代码。</li><li>asyncio，在Python3.4中引入的模块用于编写协程代码。</li><li>async &amp; awiat，在Python3.5中引入的两个关键字，结合asyncio模块可以更方便的编写协程代码。</li></ul><h3 id="1-1-greenlet"><a href="#1-1-greenlet" class="headerlink" title="1.1 greenlet"></a>1.1 greenlet</h3><p>greentlet是一个第三方模块，需要提前安装 <code>pip3 install greenlet</code>才能使用。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> greenlet <span class="keyword">import</span> greenlet</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>)        <span class="comment"># 第1步：输出 1</span></span><br><span class="line">    gr2.switch()    <span class="comment"># 第3步：切换到 func2 函数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">2</span>)        <span class="comment"># 第6步：输出 2</span></span><br><span class="line">    gr2.switch()    <span class="comment"># 第7步：切换到 func2 函数，从上一次执行的位置继续向后执行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">3</span>)        <span class="comment"># 第4步：输出 3</span></span><br><span class="line">    gr1.switch()    <span class="comment"># 第5步：切换到 func1 函数，从上一次执行的位置继续向后执行</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">4</span>)        <span class="comment"># 第8步：输出 4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gr1 = greenlet(func1)</span><br><span class="line">gr2 = greenlet(func2)</span><br><span class="line">gr1.switch() <span class="comment"># 第1步：去执行 func1 函数</span></span><br></pre></td></tr></table></figure><p>注意：switch中也可以传递参数用于在切换执行时相互传递值。</p><h3 id="1-2-yield"><a href="#1-2-yield" class="headerlink" title="1.2 yield"></a>1.2 yield</h3><p>基于Python的生成器的yield和yield form关键字实现协程代码。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> func2()</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>():</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f1 = func1()</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> f1:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure><p>注意：yield form关键字是在Python3.3中引入的。</p><h3 id="1-3-asyncio"><a href="#1-3-asyncio" class="headerlink" title="1.3 asyncio"></a>1.3 asyncio</h3><p>在Python3.4之前官方未提供协程的类库，一般大家都是使用greenlet等其他来实现。在Python3.4发布后官方正式支持协程，即：asyncio模块。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">2</span>)  <span class="comment"># 遇到IO耗时操作，自动化切换到tasks中的其他任务</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">2</span>) <span class="comment"># 遇到IO耗时操作，自动化切换到tasks中的其他任务</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tasks = [</span><br><span class="line">    asyncio.ensure_future( func1() ),</span><br><span class="line">    asyncio.ensure_future( func2() )</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br></pre></td></tr></table></figure><p>注意：基于asyncio模块实现的协程比之前的要更厉害，因为他的内部还集成了遇到IO耗时操作自动切花的功能。</p><h3 id="1-4-async-amp-awit"><a href="#1-4-async-amp-awit" class="headerlink" title="1.4 async &amp; awit"></a>1.4 async &amp; awit</h3><p>async &amp; awit 关键字在Python3.5版本中正式引入，基于他编写的协程代码其实就是 上一示例 的加强版，让代码可以更加简便。</p><p>Python3.8之后 <code>@asyncio.coroutine</code> 装饰器就会被移除，推荐使用async &amp; awit 关键字实现协程代码。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tasks = [</span><br><span class="line">    asyncio.ensure_future(func1()),</span><br><span class="line">    asyncio.ensure_future(func2())</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br></pre></td></tr></table></figure><h3 id="1-5-小结"><a href="#1-5-小结" class="headerlink" title="1.5 小结"></a>1.5 小结</h3><p>关于协程有多种实现方式，目前主流使用是Python官方推荐的asyncio模块和async&amp;await关键字的方式，例如：在tonado、sanic、fastapi、django3 中均已支持。</p><p>接下来，我们也会针对 <code>asyncio模块</code> + <code>async &amp; await</code> 关键字进行更加详细的讲解。</p><h2 id="2-协程的意义"><a href="#2-协程的意义" class="headerlink" title="2.协程的意义"></a>2.协程的意义</h2><p>通过学习，我们已经了解到协程可以通过一个线程在多个上下文中进行来回切换执行。</p><p><span><strong>但是</strong></span>，协程来回切换执行的意义何在呢？（网上看到很多文章舔协程，协程牛逼之处是哪里呢？）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">计算型的操作，利用协程来回切换执行，没有任何意义，来回切换并保存状态 反倒会降低性能。</span><br><span class="line">IO型的操作，利用协程在IO等待时间就去切换执行其他任务，当IO操作结束后再自动回调，那么就会大大节省资源并提供性能，从而实现异步编程（不等待任务结束就可以去执行其他代码）。</span><br></pre></td></tr></table></figure><h3 id="2-1-爬虫案例"><a href="#2-1-爬虫案例" class="headerlink" title="2.1 爬虫案例"></a>2.1 爬虫案例</h3><p>例如：用代码实现下载 <code>url_list</code> 中的图片。</p><ul><li><p>方式一：同步编程实现</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">下载图片使用第三方模块requests，请提前安装：pip3 install requests</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download_image</span>(<span class="params">url</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;开始下载:&quot;</span>,url)</span><br><span class="line">    <span class="comment"># 发送网络请求，下载图片</span></span><br><span class="line">    response = requests.get(url)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;下载完成&quot;</span>)</span><br><span class="line">    <span class="comment"># 图片保存到本地文件</span></span><br><span class="line">    file_name = url.rsplit(<span class="string">&#x27;_&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_name, mode=<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">        file_object.write(response.content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    url_list = [</span><br><span class="line">        <span class="string">&#x27;https://www3.autoimg.cn/newsdfs/g26/M02/35/A9/120x90_0_autohomecar__ChsEe12AXQ6AOOH_AAFocMs8nzU621.jpg&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;https://www2.autoimg.cn/newsdfs/g30/M01/3C/E2/120x90_0_autohomecar__ChcCSV2BBICAUntfAADjJFd6800429.jpg&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;https://www3.autoimg.cn/newsdfs/g26/M0B/3C/65/120x90_0_autohomecar__ChcCP12BFCmAIO83AAGq7vK0sGY193.jpg&#x27;</span></span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> url_list:</span><br><span class="line">        download_image(item)</span><br></pre></td></tr></table></figure></li><li><p>方式二：基于协程的异步编程实现</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">下载图片使用第三方模块aiohttp，请提前安装：pip3 install aiohttp</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">fetch</span>(<span class="params">session, url</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;发送请求：&quot;</span>, url)</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> session.get(url, verify_ssl=<span class="literal">False</span>) <span class="keyword">as</span> response:</span><br><span class="line">        content = <span class="keyword">await</span> response.content.read()</span><br><span class="line">        file_name = url.rsplit(<span class="string">&#x27;_&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(file_name, mode=<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">            file_object.write(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        url_list = [</span><br><span class="line">            <span class="string">&#x27;https://www3.autoimg.cn/newsdfs/g26/M02/35/A9/120x90_0_autohomecar__ChsEe12AXQ6AOOH_AAFocMs8nzU621.jpg&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;https://www2.autoimg.cn/newsdfs/g30/M01/3C/E2/120x90_0_autohomecar__ChcCSV2BBICAUntfAADjJFd6800429.jpg&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;https://www3.autoimg.cn/newsdfs/g26/M0B/3C/65/120x90_0_autohomecar__ChcCP12BFCmAIO83AAGq7vK0sGY193.jpg&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">        tasks = [asyncio.create_task(fetch(session, url)) <span class="keyword">for</span> url <span class="keyword">in</span> url_list]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> asyncio.wait(tasks)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    asyncio.run(main())</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>上述两种的执行对比之后会发现，<code>基于协程的异步编程</code> 要比 <code>同步编程</code>的效率高了很多。因为：</p><ul><li>同步编程，按照顺序逐一排队执行，如果图片下载时间为2分钟，那么全部执行完则需要6分钟。</li><li>异步编程，几乎同时发出了3个下载任务的请求（遇到IO请求自动切换去发送其他任务请求），如果图片下载时间为2分钟，那么全部执行完毕也大概需要2分钟左右就可以了。</li></ul><h3 id="2-2-小结"><a href="#2-2-小结" class="headerlink" title="2.2 小结"></a>2.2 小结</h3><p>协程一般应用在有IO操作的程序中，因为协程可以利用IO等待的时间去执行一些其他的代码，从而提升代码执行效率。</p><p>生活中不也是这样的么，假设 你是一家制造汽车的老板，员工点击设备的【开始】按钮之后，在设备前需等待30分钟，然后点击【结束】按钮，此时作为老板的你一定希望这个员工在等待的那30分钟的时间去做点其他的工作。</p><h2 id="3-异步编程"><a href="#3-异步编程" class="headerlink" title="3.异步编程"></a>3.异步编程</h2><p>基于<code>async</code> &amp; <code>await</code>关键字的协程可以实现异步编程，这也是目前python异步相关的主流技术。</p><p>想要真正的了解Python中内置的异步编程，根据下文的顺序一点点来看。</p><h3 id="3-1-事件循环"><a href="#3-1-事件循环" class="headerlink" title="3.1 事件循环"></a>3.1 事件循环</h3><p>事件循环，可以把他当做是一个while循环，这个while循环在周期性的运行并执行一些<code>任务</code>，在特定条件下终止循环。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 伪代码</span></span><br><span class="line"></span><br><span class="line">任务列表 = [ 任务<span class="number">1</span>, 任务<span class="number">2</span>, 任务<span class="number">3</span>,... ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    可执行的任务列表，已完成的任务列表 = 去任务列表中检查所有的任务，将<span class="string">&#x27;可执行&#x27;</span>和<span class="string">&#x27;已完成&#x27;</span>的任务返回</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> 就绪任务 <span class="keyword">in</span> 已准备就绪的任务列表:</span><br><span class="line">        执行已就绪的任务</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> 已完成的任务 <span class="keyword">in</span> 已完成的任务列表:</span><br><span class="line">        在任务列表中移除 已完成的任务 </span><br><span class="line"></span><br><span class="line">如果 任务列表 中的任务都已完成，则终止循环</span><br></pre></td></tr></table></figure><p>在编写程序时候可以通过如下代码来获取和创建事件循环。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去生成或获取一个事件循环</span></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将任务放到任务列表</span></span><br><span class="line">loop.run_until_complete(任务)</span><br></pre></td></tr></table></figure><h3 id="3-2-协程和异步编程"><a href="#3-2-协程和异步编程" class="headerlink" title="3.2 协程和异步编程"></a>3.2 协程和异步编程</h3><p>协程函数，定义形式为 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#async-def"><code>async def</code></a> 的函数。</p><p>协程对象，调用 <em>协程函数</em> 所返回的对象。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义一个协程函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用协程函数，返回一个协程对象</span></span><br><span class="line">result = func()</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：调用协程函数时，函数内部代码不会执行，只是会返回一个协程对象。</p><h4 id="3-2-1-基本应用"><a href="#3-2-1-基本应用" class="headerlink" title="3.2.1 基本应用"></a>3.2.1 基本应用</h4><p>程序中，如果想要执行协程函数的内部代码，需要 <code>事件循环</code> 和 <code>协程对象</code> 配合才能实现，如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;协程内部代码&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用协程函数，返回一个协程对象。</span></span><br><span class="line">result = func()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式一</span></span><br><span class="line"><span class="comment"># loop = asyncio.get_event_loop() # 创建一个事件循环</span></span><br><span class="line"><span class="comment"># loop.run_until_complete(result) # 将协程当做任务提交到事件循环的任务列表中，协程执行完成之后终止。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式二</span></span><br><span class="line"><span class="comment"># 本质上方式一是一样的，内部先 创建事件循环 然后执行 run_until_complete，一个简便的写法。</span></span><br><span class="line"><span class="comment"># asyncio.run 函数在 Python 3.7 中加入 asyncio 模块，</span></span><br><span class="line">asyncio.run(result)</span><br></pre></td></tr></table></figure><p>这个过程可以简单理解为：将<code>协程</code>当做任务添加到 <code>事件循环</code> 的任务列表，然后事件循环检测列表中的<code>协程</code>是否 已准备就绪（默认可理解为就绪状态），如果准备就绪则执行其内部代码。</p><h4 id="3-2-2-await"><a href="#3-2-2-await" class="headerlink" title="3.2.2 await"></a>3.2.2 await</h4><p>await是一个只能在协程函数中使用的关键字，用于遇到IO操作时挂起 当前协程（任务），当前协程（任务）挂起过程中 事件循环可以去执行其他的协程（任务），当前协程IO处理完成时，可以再次切换回来执行await之后的代码。代码如下：</p><p><strong>示例1：</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;执行协程函数内部代码&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遇到IO操作挂起当前协程（任务），等IO操作完成之后再继续往下执行。</span></span><br><span class="line">    <span class="comment"># 当前协程挂起时，事件循环可以去执行其他协程（任务）。</span></span><br><span class="line">    response = <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;IO请求结束，结果为：&quot;</span>, response)</span><br><span class="line"></span><br><span class="line">result = func()</span><br><span class="line"></span><br><span class="line">asyncio.run(result)</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">others</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;返回值&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;执行协程函数内部代码&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遇到IO操作挂起当前协程（任务），等IO操作完成之后再继续往下执行。当前协程挂起时，事件循环可以去执行其他协程（任务）。</span></span><br><span class="line">    response = <span class="keyword">await</span> others()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;IO请求结束，结果为：&quot;</span>, response)</span><br><span class="line">    </span><br><span class="line">asyncio.run( func() )</span><br></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">others</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;返回值&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;执行协程函数内部代码&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遇到IO操作挂起当前协程（任务），等IO操作完成之后再继续往下执行。当前协程挂起时，事件循环可以去执行其他协程（任务）。</span></span><br><span class="line">    response1 = <span class="keyword">await</span> others()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;IO请求结束，结果为：&quot;</span>, response1)</span><br><span class="line">    </span><br><span class="line">    response2 = <span class="keyword">await</span> others()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;IO请求结束，结果为：&quot;</span>, response2)</span><br><span class="line">    </span><br><span class="line">asyncio.run( func() )</span><br></pre></td></tr></table></figure><p>上述的所有示例都只是创建了一个任务，即：事件循环的任务列表中只有一个任务，所以在IO等待时无法演示切换到其他任务效果。</p><p>在程序想要创建多个任务对象，需要使用Task对象来实现。</p><h4 id="3-2-3-Task对象"><a href="#3-2-3-Task对象" class="headerlink" title="3.2.3 Task对象"></a>3.2.3 Task对象</h4><blockquote><p><em>Tasks</em> are used to schedule coroutines <em>concurrently</em>.</p><p>When a coroutine is wrapped into a <em>Task</em> with functions like <a href="https://docs.python.org/3.8/library/asyncio-task.html#asyncio.create_task"><code>asyncio.create_task()</code></a> the coroutine is automatically scheduled to run soon。</p></blockquote><p>Tasks用于并发调度协程，通过<code>asyncio.create_task(协程对象)</code>的方式创建Task对象，这样可以让协程加入事件循环中等待被调度执行。除了使用 <code>asyncio.create_task()</code> 函数以外，还可以用低层级的 <code>loop.create_task()</code> 或 <code>ensure_future()</code> 函数。不建议手动实例化 Task 对象。</p><p>本质上是将协程对象封装成task对象，并将协程立即加入事件循环，同时追踪协程的状态。</p><p>注意：<code>asyncio.create_task()</code> 函数在 Python 3.7 中被加入。在 Python 3.7 之前，可以改用低层级的 <code>asyncio.ensure_future()</code> 函数。</p><p><strong>示例1：</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;返回值&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;main开始&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建协程，将协程封装到一个Task对象中并立即添加到事件循环的任务列表中，等待事件循环去执行（默认是就绪状态）。</span></span><br><span class="line">    task1 = asyncio.create_task(func())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建协程，将协程封装到一个Task对象中并立即添加到事件循环的任务列表中，等待事件循环去执行（默认是就绪状态）。</span></span><br><span class="line">    task2 = asyncio.create_task(func())</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;main结束&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 当执行某协程遇到IO操作时，会自动化切换执行其他任务。</span></span><br><span class="line">    <span class="comment"># 此处的await是等待相对应的协程全都执行完毕并获取结果</span></span><br><span class="line">    ret1 = <span class="keyword">await</span> task1</span><br><span class="line">    ret2 = <span class="keyword">await</span> task2</span><br><span class="line">    <span class="built_in">print</span>(ret1, ret2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;返回值&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;main开始&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建协程，将协程封装到Task对象中并添加到事件循环的任务列表中，等待事件循环去执行（默认是就绪状态）。</span></span><br><span class="line">    <span class="comment"># 在调用</span></span><br><span class="line">    task_list = [</span><br><span class="line">        asyncio.create_task(func(), name=<span class="string">&quot;n1&quot;</span>),</span><br><span class="line">        asyncio.create_task(func(), name=<span class="string">&quot;n2&quot;</span>)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;main结束&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 当执行某协程遇到IO操作时，会自动化切换执行其他任务。</span></span><br><span class="line">    <span class="comment"># 此处的await是等待所有协程执行完毕，并将所有协程的返回值保存到done</span></span><br><span class="line">    <span class="comment"># 如果设置了timeout值，则意味着此处最多等待的秒，完成的协程返回值写入到done中，未完成则写到pending中。</span></span><br><span class="line">    done, pending = <span class="keyword">await</span> asyncio.wait(task_list, timeout=<span class="literal">None</span>)</span><br><span class="line">    <span class="built_in">print</span>(done, pending)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>注意：<code>asyncio.wait</code> 源码内部会对列表中的每个协程执行ensure_future从而封装为Task对象，所以在和wait配合使用时task_list的值为<code>[func(),func()]</code> 也是可以的。</p><p><strong>示例3：</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;执行协程函数内部代码&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遇到IO操作挂起当前协程（任务），等IO操作完成之后再继续往下执行。当前协程挂起时，事件循环可以去执行其他协程（任务）。</span></span><br><span class="line">    response = <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;IO请求结束，结果为：&quot;</span>, response)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">coroutine_list = [func(), func()]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误：coroutine_list = [ asyncio.create_task(func()), asyncio.create_task(func()) ]  </span></span><br><span class="line"><span class="comment"># 此处不能直接 asyncio.create_task，因为将Task立即加入到事件循环的任务列表，</span></span><br><span class="line"><span class="comment"># 但此时事件循环还未创建，所以会报错。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用asyncio.wait将列表封装为一个协程，并调用asyncio.run实现执行两个协程</span></span><br><span class="line"><span class="comment"># asyncio.wait内部会对列表中的每个协程执行ensure_future，封装为Task对象。</span></span><br><span class="line">done,pending = asyncio.run( asyncio.wait(coroutine_list) )</span><br></pre></td></tr></table></figure><h4 id="3-2-4-asyncio-Future对象"><a href="#3-2-4-asyncio-Future对象" class="headerlink" title="3.2.4 asyncio.Future对象"></a>3.2.4 asyncio.Future对象</h4><blockquote><p>A <code>Future</code>is a special <strong>low-level</strong> awaitable object that represents an <strong>eventual result</strong> of an asynchronous operation.</p></blockquote><p>asyncio中的Future对象是一个相对更偏向底层的可对象，通常我们不会直接用到这个对象，而是直接使用Task对象来完成任务的并和状态的追踪。（ Task 是 Futrue的子类 ）</p><p>Future为我们提供了异步编程中的 最终结果 的处理（Task类也具备状态处理的功能）。</p><p>示例1：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 获取当前事件循环</span></span><br><span class="line">    loop = asyncio.get_running_loop()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># # 创建一个任务（Future对象），这个任务什么都不干。</span></span><br><span class="line">    fut = loop.create_future()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待任务最终结果（Future对象），没有结果则会一直等下去。</span></span><br><span class="line">    <span class="keyword">await</span> fut</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">set_after</span>(<span class="params">fut</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    fut.set_result(<span class="string">&quot;666&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 获取当前事件循环</span></span><br><span class="line">    loop = asyncio.get_running_loop()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建一个任务（Future对象），没绑定任何行为，则这个任务永远不知道什么时候结束。</span></span><br><span class="line">    fut = loop.create_future()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建一个任务（Task对象），绑定了set_after函数，函数内部在2s之后，会给fut赋值。</span></span><br><span class="line">    <span class="comment"># 即手动设置future任务的最终结果，那么fut就可以结束了。</span></span><br><span class="line">    <span class="keyword">await</span> loop.create_task(set_after(fut))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待 Future对象获取 最终结果，否则一直等下去</span></span><br><span class="line">    data = <span class="keyword">await</span> fut</span><br><span class="line">    <span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>Future对象本身函数进行绑定，所以想要让事件循环获取Future的结果，则需要手动设置。而Task对象继承了Future对象，其实就对Future进行扩展，他可以实现在对应绑定的函数执行完成之后，自动执行<code>set_result</code>，从而实现自动结束。</p><p>虽然，平时使用的是Task对象，但对于结果的处理本质是基于Future对象来实现的。</p><p>扩展：支持 <code>await 对象</code>语 法的对象课成为可等待对象，所以 <code>协程对象</code>、<code>Task对象</code>、<code>Future对象</code> 都可以被成为可等待对象。</p><h4 id="3-2-5-futures-Future对象"><a href="#3-2-5-futures-Future对象" class="headerlink" title="3.2.5 futures.Future对象"></a>3.2.5 futures.Future对象</h4><p>在Python的<code>concurrent.futures</code>模块中也有一个Future对象，这个对象是基于线程池和进程池实现异步操作时使用的对象。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> Future</span><br><span class="line"><span class="keyword">from</span> concurrent.futures.thread <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">from</span> concurrent.futures.process <span class="keyword">import</span> ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">value</span>):</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pool = ThreadPoolExecutor(max_workers=<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 或 pool = ProcessPoolExecutor(max_workers=5)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    fut = pool.submit(func, i)</span><br><span class="line">    <span class="built_in">print</span>(fut)</span><br></pre></td></tr></table></figure><p>两个Future对象是不同的，他们是为不同的应用场景而设计，例如：<code>concurrent.futures.Future</code>不支持await语法 等。</p><p>官方提示两对象之间不同：</p><ul><li><p>unlike asyncio Futures, <a href="https://docs.python.org/3.8/library/concurrent.futures.html#concurrent.futures.Future"><code>concurrent.futures.Future</code></a> instances cannot be awaited.</p></li><li><p><a href="https://docs.python.org/3.8/library/asyncio-future.html#asyncio.Future.result"><code>asyncio.Future.result()</code></a> and <a href="https://docs.python.org/3.8/library/asyncio-future.html#asyncio.Future.exception"><code>asyncio.Future.exception()</code></a> do not accept the <em>timeout</em> argument.</p></li><li><p><a href="https://docs.python.org/3.8/library/asyncio-future.html#asyncio.Future.result"><code>asyncio.Future.result()</code></a> and <a href="https://docs.python.org/3.8/library/asyncio-future.html#asyncio.Future.exception"><code>asyncio.Future.exception()</code></a> raise an <a href="https://docs.python.org/3.8/library/asyncio-exceptions.html#asyncio.InvalidStateError"><code>InvalidStateError</code></a> exception when the Future is not <em>done</em>.</p></li><li><p>Callbacks registered with <a href="https://docs.python.org/3.8/library/asyncio-future.html#asyncio.Future.add_done_callback"><code>asyncio.Future.add_done_callback()</code></a> are not called immediately. They are scheduled with <a href="https://docs.python.org/3.8/library/asyncio-eventloop.html#asyncio.loop.call_soon"><code>loop.call_soon()</code></a> instead.</p></li><li><p>asyncio Future is not compatible with the <a href="https://docs.python.org/3.8/library/concurrent.futures.html#concurrent.futures.wait"><code>concurrent.futures.wait()</code></a> and <a href="https://docs.python.org/3.8/library/concurrent.futures.html#concurrent.futures.as_completed"><code>concurrent.futures.as_completed()</code></a> functions.</p></li></ul><p>在Python提供了一个将<code>futures.Future</code> 对象包装成<code>asyncio.Future</code>对象的函数 <code>asynic.wrap_future</code>。</p><p>接下里你肯定问：为什么python会提供这种功能？</p><p>其实，一般在程序开发中我们要么统一使用 asycio 的协程实现异步操作、要么都使用进程池和线程池实现异步操作。但如果 <code>协程的异步</code>和 <code>进程池/线程池的异步</code> 混搭时，那么就会用到此功能了。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">    <span class="comment"># 某个耗时操作</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;SB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    loop = asyncio.get_running_loop()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. Run in the default loop&#x27;s executor ( 默认ThreadPoolExecutor )</span></span><br><span class="line">    <span class="comment"># 第一步：内部会先调用 ThreadPoolExecutor 的 submit 方法去线程池中申请一个线程去执行func1函数，并返回一个concurrent.futures.Future对象</span></span><br><span class="line">    <span class="comment"># 第二步：调用asyncio.wrap_future将concurrent.futures.Future对象包装为asycio.Future对象。</span></span><br><span class="line">    <span class="comment"># 因为concurrent.futures.Future对象不支持await语法，所以需要包装为 asycio.Future对象 才能使用。</span></span><br><span class="line">    fut = loop.run_in_executor(<span class="literal">None</span>, func1)</span><br><span class="line">    result = <span class="keyword">await</span> fut</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;default thread pool&#x27;</span>, result)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. Run in a custom thread pool:</span></span><br><span class="line">    <span class="comment"># with concurrent.futures.ThreadPoolExecutor() as pool:</span></span><br><span class="line">    <span class="comment">#     result = await loop.run_in_executor(</span></span><br><span class="line">    <span class="comment">#         pool, func1)</span></span><br><span class="line">    <span class="comment">#     print(&#x27;custom thread pool&#x27;, result)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. Run in a custom process pool:</span></span><br><span class="line">    <span class="comment"># with concurrent.futures.ProcessPoolExecutor() as pool:</span></span><br><span class="line">    <span class="comment">#     result = await loop.run_in_executor(</span></span><br><span class="line">    <span class="comment">#         pool, func1)</span></span><br><span class="line">    <span class="comment">#     print(&#x27;custom process pool&#x27;, result)</span></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>应用场景：当项目以协程式的异步编程开发时，如果要使用一个第三方模块，而第三方模块不支持协程方式异步编程时，就需要用到这个功能，例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">download_image</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="comment"># 发送网络请求，下载图片（遇到网络下载图片的IO请求，自动化切换到其他任务）</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始下载:&quot;</span>, url)</span><br><span class="line"></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    <span class="comment"># requests模块默认不支持异步操作，所以就使用线程池来配合实现了。</span></span><br><span class="line">    future = loop.run_in_executor(<span class="literal">None</span>, requests.get, url)</span><br><span class="line"></span><br><span class="line">    response = <span class="keyword">await</span> future</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;下载完成&#x27;</span>)</span><br><span class="line">    <span class="comment"># 图片保存到本地文件</span></span><br><span class="line">    file_name = url.rsplit(<span class="string">&#x27;_&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_name, mode=<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">        file_object.write(response.content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    url_list = [</span><br><span class="line">        <span class="string">&#x27;https://www3.autoimg.cn/newsdfs/g26/M02/35/A9/120x90_0_autohomecar__ChsEe12AXQ6AOOH_AAFocMs8nzU621.jpg&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;https://www2.autoimg.cn/newsdfs/g30/M01/3C/E2/120x90_0_autohomecar__ChcCSV2BBICAUntfAADjJFd6800429.jpg&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;https://www3.autoimg.cn/newsdfs/g26/M0B/3C/65/120x90_0_autohomecar__ChcCP12BFCmAIO83AAGq7vK0sGY193.jpg&#x27;</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    tasks = [download_image(url) <span class="keyword">for</span> url <span class="keyword">in</span> url_list]</span><br><span class="line"></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    loop.run_until_complete( asyncio.wait(tasks) )</span><br></pre></td></tr></table></figure><h4 id="3-2-6-异步迭代器"><a href="#3-2-6-异步迭代器" class="headerlink" title="3.2.6 异步迭代器"></a>3.2.6 异步迭代器</h4><p><strong>什么是异步迭代器</strong></p><p>实现了 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__aiter__"><code>__aiter__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__anext__"><code>__anext__()</code></a> 方法的对象。<code>__anext__</code> 必须返回一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-awaitable">awaitable</a> 对象。<a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#async-for"><code>async for</code></a> 会处理异步迭代器的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__anext__"><code>__anext__()</code></a> 方法所返回的可等待对象，直到其引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#StopAsyncIteration"><code>StopAsyncIteration</code></a> 异常。由 <a href="https://www.python.org/dev/peps/pep-0492"><strong>PEP 492</strong></a> 引入。</p><p><strong>什么是异步可迭代对象？</strong></p><p>可在 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#async-for"><code>async for</code></a> 语句中被使用的对象。必须通过它的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__aiter__"><code>__aiter__()</code></a> 方法返回一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-asynchronous-iterator">asynchronous iterator</a>。由 <a href="https://www.python.org/dev/peps/pep-0492"><strong>PEP 492</strong></a> 引入。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Reader</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 自定义异步迭代器（同时也是异步可迭代对象） &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">readline</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># await asyncio.sleep(1)</span></span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.count == <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.count</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__aiter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">__anext__</span>(<span class="params">self</span>):</span><br><span class="line">        val = <span class="keyword">await</span> self.readline()</span><br><span class="line">        <span class="keyword">if</span> val == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopAsyncIteration</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="comment"># 创建异步可迭代对象</span></span><br><span class="line">    async_iter = Reader()</span><br><span class="line">    <span class="comment"># async for 必须要放在async def函数内，否则语法错误。</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">for</span> item <span class="keyword">in</span> async_iter:</span><br><span class="line">        <span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line">asyncio.run(func())</span><br></pre></td></tr></table></figure><p>异步迭代器其实没什么太大的作用，只是支持了async for语法而已。</p><h4 id="3-2-6-异步上下文管理器"><a href="#3-2-6-异步上下文管理器" class="headerlink" title="3.2.6 异步上下文管理器"></a>3.2.6 异步上下文管理器</h4><p>此种对象通过定义 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__aenter__"><code>__aenter__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__aexit__"><code>__aexit__()</code></a> 方法来对 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#async-with"><code>async with</code></a> 语句中的环境进行控制。由 <a href="https://www.python.org/dev/peps/pep-0492"><strong>PEP 492</strong></a> 引入。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AsyncContextManager</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.conn = conn</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">do_something</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 异步操作数据库</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">666</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">__aenter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 异步链接数据库</span></span><br><span class="line">        self.conn = <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">__aexit__</span>(<span class="params">self, exc_type, exc, tb</span>):</span><br><span class="line">        <span class="comment"># 异步关闭数据库链接</span></span><br><span class="line"><span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> AsyncContextManager() <span class="keyword">as</span> f:</span><br><span class="line">        result = <span class="keyword">await</span> f.do_something()</span><br><span class="line">        <span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(func())</span><br></pre></td></tr></table></figure><p>这个异步的上下文管理器还是比较有用的，平时在开发过程中 打开、处理、关闭 操作时，就可以用这种方式来处理。</p><h3 id="3-3-小结"><a href="#3-3-小结" class="headerlink" title="3.3 小结"></a>3.3 小结</h3><p>在程序中只要看到<code>async</code>和<code>await</code>关键字，其内部就是基于协程实现的异步编程，这种异步编程是通过一个线程在IO等待时间去执行其他任务，从而实现并发。</p><p>以上就是异步编程的常见操作，内容参考官方文档。</p><ul><li>中文版：<a href="https://docs.python.org/zh-cn/3.8/library/asyncio.html">https://docs.python.org/zh-cn/3.8/library/asyncio.html</a></li><li>英文本：<a href="https://docs.python.org/3.8/library/asyncio.html">https://docs.python.org/3.8/library/asyncio.html</a></li></ul><h2 id="4-uvloop"><a href="#4-uvloop" class="headerlink" title="4. uvloop"></a>4. uvloop</h2><p>Python标准库中提供了<code>asyncio</code>模块，用于支持基于协程的异步编程。</p><p>uvloop是 asyncio 中的事件循环的替代方案，替换后可以使得asyncio性能提高。事实上，uvloop要比nodejs、gevent等其他python异步框架至少要快2倍，性能可以比肩Go语言。</p><p>安装uvloop</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install uvloop</span><br></pre></td></tr></table></figure><p>在项目中想要使用uvloop替换asyncio的事件循环也非常简单，只要在代码中这么做就行。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> uvloop</span><br><span class="line">asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编写asyncio的代码，与之前写的代码一致。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 内部的事件循环自动化会变为uvloop</span></span><br><span class="line">asyncio.run(...)</span><br></pre></td></tr></table></figure><p>注意：知名的asgi uvicorn内部就是使用的uvloop的事件循环。</p><h2 id="5-实战案例"><a href="#5-实战案例" class="headerlink" title="5.实战案例"></a>5.实战案例</h2><p>为了更好理解，上述所有示例的IO情况都是以 <code>asyncio.sleep</code> 为例，而真实的项目开发中会用到很多IO的情况。</p><h3 id="5-1-异步Redis"><a href="#5-1-异步Redis" class="headerlink" title="5.1 异步Redis"></a>5.1 异步Redis</h3><p>当通过python去操作redis时，链接、设置值、获取值 这些都涉及网络IO请求，使用asycio异步的方式可以在IO等待时去做一些其他任务，从而提升性能。</p><p>安装Python异步操作redis模块</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install aioredis</span><br></pre></td></tr></table></figure><p>示例1：异步操作redis。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aioredis</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">address, password</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始执行&quot;</span>, address)</span><br><span class="line">    <span class="comment"># 网络IO操作：创建redis连接</span></span><br><span class="line">    redis = <span class="keyword">await</span> aioredis.create_redis(address, password=password)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 网络IO操作：在redis中设置哈希值car，内部在设三个键值对，即： redis = &#123; car:&#123;key1:1,key2:2,key3:3&#125;&#125;</span></span><br><span class="line">    <span class="keyword">await</span> redis.hmset_dict(<span class="string">&#x27;car&#x27;</span>, key1=<span class="number">1</span>, key2=<span class="number">2</span>, key3=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 网络IO操作：去redis中获取值</span></span><br><span class="line">    result = <span class="keyword">await</span> redis.hgetall(<span class="string">&#x27;car&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line">    redis.close()</span><br><span class="line">    <span class="comment"># 网络IO操作：关闭redis连接</span></span><br><span class="line">    <span class="keyword">await</span> redis.wait_closed()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;结束&quot;</span>, address)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(execute(<span class="string">&#x27;redis://47.93.4.198:6379&#x27;</span>, <span class="string">&quot;root!2345&quot;</span>))</span><br></pre></td></tr></table></figure><p>示例2：连接多个redis做操作（遇到IO会切换其他任务，提供了性能）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aioredis</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">address, password</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始执行&quot;</span>, address)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 网络IO操作：先去连接 47.93.4.197:6379，遇到IO则自动切换任务，去连接47.93.4.198:6379</span></span><br><span class="line">    redis = <span class="keyword">await</span> aioredis.create_redis_pool(address, password=password)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 网络IO操作：遇到IO会自动切换任务</span></span><br><span class="line">    <span class="keyword">await</span> redis.hmset_dict(<span class="string">&#x27;car&#x27;</span>, key1=<span class="number">1</span>, key2=<span class="number">2</span>, key3=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 网络IO操作：遇到IO会自动切换任务</span></span><br><span class="line">    result = <span class="keyword">await</span> redis.hgetall(<span class="string">&#x27;car&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line">    redis.close()</span><br><span class="line">    <span class="comment"># 网络IO操作：遇到IO会自动切换任务</span></span><br><span class="line">    <span class="keyword">await</span> redis.wait_closed()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;结束&quot;</span>, address)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">task_list = [</span><br><span class="line">    execute(<span class="string">&#x27;redis://47.93.4.197:6379&#x27;</span>, <span class="string">&quot;root!2345&quot;</span>),</span><br><span class="line">    execute(<span class="string">&#x27;redis://47.93.4.198:6379&#x27;</span>, <span class="string">&quot;root!2345&quot;</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">asyncio.run(asyncio.wait(task_list))</span><br></pre></td></tr></table></figure><p>更多redis操作参考aioredis官网：<a href="https://aioredis.readthedocs.io/en/v1.3.0/start.html">https://aioredis.readthedocs.io/en/v1.3.0/start.html</a></p><h3 id="5-2-异步MySQL"><a href="#5-2-异步MySQL" class="headerlink" title="5.2 异步MySQL"></a>5.2 异步MySQL</h3><p>当通过python去操作MySQL时，连接、执行SQL、关闭都涉及网络IO请求，使用asycio异步的方式可以在IO等待时去做一些其他任务，从而提升性能。</p><p>安装Python异步操作redis模块</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install aiomysql</span><br></pre></td></tr></table></figure><p>示例1：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiomysql</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">execute</span>():</span><br><span class="line">    <span class="comment"># 网络IO操作：连接MySQL</span></span><br><span class="line">    conn = <span class="keyword">await</span> aiomysql.connect(host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">3306</span>, user=<span class="string">&#x27;root&#x27;</span>, password=<span class="string">&#x27;123&#x27;</span>, db=<span class="string">&#x27;mysql&#x27;</span>, )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 网络IO操作：创建CURSOR</span></span><br><span class="line">    cur = <span class="keyword">await</span> conn.cursor()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 网络IO操作：执行SQL</span></span><br><span class="line">    <span class="keyword">await</span> cur.execute(<span class="string">&quot;SELECT Host,User FROM user&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 网络IO操作：获取SQL结果</span></span><br><span class="line">    result = <span class="keyword">await</span> cur.fetchall()</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 网络IO操作：关闭链接</span></span><br><span class="line">    <span class="keyword">await</span> cur.close()</span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(execute())</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiomysql</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">host, password</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始&quot;</span>, host)</span><br><span class="line">    <span class="comment"># 网络IO操作：先去连接 47.93.40.197，遇到IO则自动切换任务，去连接47.93.40.198:6379</span></span><br><span class="line">    conn = <span class="keyword">await</span> aiomysql.connect(host=host, port=<span class="number">3306</span>, user=<span class="string">&#x27;root&#x27;</span>, password=password, db=<span class="string">&#x27;mysql&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 网络IO操作：遇到IO会自动切换任务</span></span><br><span class="line">    cur = <span class="keyword">await</span> conn.cursor()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 网络IO操作：遇到IO会自动切换任务</span></span><br><span class="line">    <span class="keyword">await</span> cur.execute(<span class="string">&quot;SELECT Host,User FROM user&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 网络IO操作：遇到IO会自动切换任务</span></span><br><span class="line">    result = <span class="keyword">await</span> cur.fetchall()</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 网络IO操作：遇到IO会自动切换任务</span></span><br><span class="line">    <span class="keyword">await</span> cur.close()</span><br><span class="line">    conn.close()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;结束&quot;</span>, host)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">task_list = [</span><br><span class="line">    execute(<span class="string">&#x27;47.93.40.197&#x27;</span>, <span class="string">&quot;root!2345&quot;</span>),</span><br><span class="line">    execute(<span class="string">&#x27;47.93.40.197&#x27;</span>, <span class="string">&quot;root!2345&quot;</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">asyncio.run(asyncio.wait(task_list))</span><br></pre></td></tr></table></figure><h3 id="5-3-FastAPI框架"><a href="#5-3-FastAPI框架" class="headerlink" title="5.3 FastAPI框架"></a>5.3 FastAPI框架</h3><p>FastAPI是一款用于构建API的高性能web框架，框架基于Python3.6+的 <code>type hints</code>搭建。</p><p>接下里的异步示例以<code>FastAPI</code>和<code>uvicorn</code>来讲解（uvicorn是一个支持异步的asgi）。</p><p>安装FastAPI web 框架，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install fastapi</span><br></pre></td></tr></table></figure><p>安装uvicorn，本质上为web提供socket server的支持的asgi（一般支持异步称asgi、不支持异步称wsgi）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install uvicorn</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> uvicorn</span><br><span class="line"><span class="keyword">import</span> aioredis</span><br><span class="line"><span class="keyword">from</span> aioredis <span class="keyword">import</span> Redis</span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line">REDIS_POOL = aioredis.ConnectionsPool(<span class="string">&#x27;redis://47.193.14.198:6379&#x27;</span>, password=<span class="string">&quot;root123&quot;</span>, minsize=<span class="number">1</span>, maxsize=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 普通操作接口 &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello World&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/red&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">red</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 异步操作接口 &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;请求来了&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="comment"># 连接池获取一个连接</span></span><br><span class="line">    conn = <span class="keyword">await</span> REDIS_POOL.acquire()</span><br><span class="line">    redis = Redis(conn)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置值</span></span><br><span class="line">    <span class="keyword">await</span> redis.hmset_dict(<span class="string">&#x27;car&#x27;</span>, key1=<span class="number">1</span>, key2=<span class="number">2</span>, key3=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取值</span></span><br><span class="line">    result = <span class="keyword">await</span> redis.hgetall(<span class="string">&#x27;car&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 连接归还连接池</span></span><br><span class="line">    REDIS_POOL.release(conn)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    uvicorn.run(<span class="string">&quot;luffy:app&quot;</span>, host=<span class="string">&quot;127.0.0.1&quot;</span>, port=<span class="number">5000</span>, log_level=<span class="string">&quot;info&quot;</span>)</span><br></pre></td></tr></table></figure><p>在有多个用户并发请求的情况下，异步方式来编写的接口可以在IO等待过程中去处理其他的请求，提供性能。</p><p>例如：同时有两个用户并发来向接口 <code>http://127.0.0.1:5000/red</code> 发送请求，服务端只有一个线程，同一时刻只有一个请求被处理。  异步处理可以提供并发是因为：当视图函数在处理第一个请求时，第二个请求此时是等待被处理的状态，当第一个请求遇到IO等待时，会自动切换去接收并处理第二个请求，当遇到IO时自动化切换至其他请求，一旦有请求IO执行完毕，则会再次回到指定请求向下继续执行其功能代码。</p><h3 id="5-4-爬虫"><a href="#5-4-爬虫" class="headerlink" title="5.4 爬虫"></a>5.4 爬虫</h3><p>在编写爬虫应用时，需要通过网络IO去请求目标数据，这种情况适合使用异步编程来提升性能，接下来我们使用支持异步编程的aiohttp模块来实现。</p><p>安装aiohttp模块</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install aiohttp</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">fetch</span>(<span class="params">session, url</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;发送请求：&quot;</span>, url)</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> session.get(url, verify_ssl=<span class="literal">False</span>) <span class="keyword">as</span> response:</span><br><span class="line">        text = <span class="keyword">await</span> response.text()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;得到结果：&quot;</span>, url, <span class="built_in">len</span>(text))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        url_list = [</span><br><span class="line">            <span class="string">&#x27;https://python.org&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;https://www.baidu.com&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;https://www.pythonav.com&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">        tasks = [asyncio.create_task(fetch(session, url)) <span class="keyword">for</span> url <span class="keyword">in</span> url_list]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> asyncio.wait(tasks)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    asyncio.run(main())</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>为了提升性能越来越多的框架都在向异步编程靠拢，例如：sanic、tornado、django3.0、django channels组件 等，用更少资源可以做处理更多的事，何乐而不为呢。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>舜桀的算法笔记</title>
      <link href="/FRank675.github.io/posts/91e582f5bac5/"/>
      <url>/FRank675.github.io/posts/91e582f5bac5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>这里主要记录我学习算法的历程~</p><p>主要参考资料为<strong>labuladong的算法笔记</strong></p><p>下面开始学习算法吧！</p><h2 id="数据结构基础"><a href="#数据结构基础" class="headerlink" title="数据结构基础"></a>数据结构基础</h2><h3 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h3><h4 id="Java标准库数据结构的基本用法"><a href="#Java标准库数据结构的基本用法" class="headerlink" title="Java标准库数据结构的基本用法"></a>Java标准库数据结构的基本用法</h4><h5 id="1-数组"><a href="#1-数组" class="headerlink" title="1.数组"></a>1.数组</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">5</span>, n = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个大小为 10 的 int 数组</span></span><br><span class="line"><span class="comment">// 其中的值默认初始化为 0</span></span><br><span class="line"><span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 初始化一个 m * n 的二维布尔数组</span></span><br><span class="line"><span class="comment">// 其中的元素默认初始化为 false</span></span><br><span class="line"><span class="type">boolean</span>[][] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[m][n];</span><br></pre></td></tr></table></figure><h5 id="2-字符串String"><a href="#2-字符串String" class="headerlink" title="2.字符串String"></a>2.字符串String</h5><p>Java 字符串不支持用 [] 直接访问其中的字符，且不能直接修改，需要转化为 char[] 类型才能修改。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="comment">// 获取 s1[2] 的那个字符</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s1.charAt(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>[] chars = s1.toCharArray();</span><br><span class="line">chars[<span class="number">1</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line"><span class="comment">// 输出：hallo world</span></span><br><span class="line">System.out.println(s2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，一定要使用 equals 方法判断字符串是否相同</span></span><br><span class="line"><span class="keyword">if</span>(s1.equals(s2))&#123;</span><br><span class="line">    <span class="comment">// s1 和 s2 相同</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// s1 和 s2 不相同</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串可以用加号进行拼接</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s1 + <span class="string">&quot;!&quot;</span>;</span><br><span class="line"><span class="comment">// 输出：hello world!</span></span><br><span class="line">System.out.println(s3);</span><br></pre></td></tr></table></figure><p>Java 的字符串不能直接修改，要用 toCharArray 转化成 char[] 的数组进行修改，然后再转换成 String 类型。</p><p>另外，虽然字符串支持用 + 进行拼接，但是效率并不高，并不建议在for循环中使用。</p><p>如果要进行频繁的字符串拼接，推荐使用 StringBuilder&#x2F;StringBuffer：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>; c &lt;= <span class="string">&#x27;f&#x27;</span>; c++)&#123;</span><br><span class="line">    sb.append(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// append 方法支持拼接字符、字符串、数字等类型</span></span><br><span class="line">sb.append(<span class="string">&#x27;g&#x27;</span>).append(<span class="string">&quot;hij&quot;</span>).append0(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> sb.toString();</span><br><span class="line"><span class="comment">// 输出：abcdefghij123</span></span><br><span class="line">System.out.println(res);</span><br></pre></td></tr></table></figure><p>一定要用字符串的 equals 方法比较两个字符是否相同，不要用 &#x3D;&#x3D; 比较。</p><h5 id="3-动态数组-ArrayList"><a href="#3-动态数组-ArrayList" class="headerlink" title="3.动态数组 ArrayList"></a>3.动态数组 ArrayList</h5><p>ArrayList 相当于把Java内置的数组类型做了包装，初始化方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化一个存储 String 类型的动态数组</span></span><br><span class="line">ArrayList&lt;String&gt; strings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个存储 int 类型的动态数组</span></span><br><span class="line">ArrayList&lt;Integer&gt; nums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>常用方法如下：（ E 代表元素类型）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断数组是否为空</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回数组的元素个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回索引 index 的元素</span></span><br><span class="line">E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 在数组尾部添加元素 e</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span></span><br></pre></td></tr></table></figure><h5 id="4-双链表-LinkedList"><a href="#4-双链表-LinkedList" class="headerlink" title="4.双链表 LinkedList"></a>4.双链表 LinkedList</h5><p>ArrayList 列表底层是数组实现的，而 LinkedList 底层是双链表实现的，初始化方法也是类似的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化一个存储 int 类型的双链表</span></span><br><span class="line">LinkedList&lt;Integer&gt; nums = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个存储 String 类型的双链表</span></span><br><span class="line">LinkedList&lt;String&gt; strings = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>双链表常用方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断链表是否为空</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 返回链表的元素个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 判断链表中是否存在元素 o</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 在链表尾部添加元素 e</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 在链表尾部添加元素 e</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(E e)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 在链表头部添加元素 e</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 删除链表头部第一个元素</span></span><br><span class="line">E <span class="title function_">removeFirst</span><span class="params">()</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 删除链表尾部最后一个元素</span></span><br><span class="line">E <span class="title function_">removeLast</span><span class="params">()</span></span><br></pre></td></tr></table></figure><p>和 ArrayList 不同，在 LinkedList 中更多地使用了对于头部和尾部元素地操作，因为底层数据结构为链表，直接操作头尾地元素效率较高。</p><p>其中只有 contains 方法的时间复杂度是 O(n)， 因为必须遍历整个链表才能判断元素是否存在。</p><h5 id="5-哈希表-HashMap"><a href="#5-哈希表-HashMap" class="headerlink" title="5.哈希表 HashMap"></a>5.哈希表 HashMap</h5><p>哈希表是常用的数据结构，用于存储键值对映射，初始化方法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 整数映射到字符串的哈希表</span></span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串映射到数组的哈希表</span></span><br><span class="line">HashMap&lt;String, <span class="type">int</span>[]&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>常用方法如下：（ K 代表键的类型， V 代表值得类型）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断哈希表中是否存在键 Key</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 获得键 Key 对应得值，若 Key 不存在，则返回 null</span></span><br><span class="line">V <span class="title function_">get</span><span class="params">(Object key)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 将 key， value 键值对存入哈希表</span></span><br><span class="line">V <span class="title function_">put</span><span class="params">(K key, V value)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 key 存在，则删除 key 并返回对应的值</span></span><br><span class="line">V <span class="title function_">remove</span><span class="params">(Object key)</span></span><br></pre></td></tr></table></figure><h5 id="6-哈希集合-HashSet"><a href="#6-哈希集合-HashSet" class="headerlink" title="6.哈希集合 HashSet"></a>6.哈希集合 HashSet</h5><p>初始化方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新建一个存储 String 的哈希集合</span></span><br><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>可能使用的方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果 e 不存在，则添加 e 到哈希集合</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 判断元素 o 是否存在于哈希集合中</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">// 如果元素 o 存在，再删除元素 o</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span></span><br></pre></td></tr></table></figure><h4 id="Java类基本用法"><a href="#Java类基本用法" class="headerlink" title="Java类基本用法"></a>Java类基本用法</h4><h5 id="泛型编程"><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h5><p>泛型是 Java 提供的一种模板，能够将数据结构的实现和数据类型解耦。</p><p>比如在使用 LinkedList 双链表时，可以随意设置其中的元素类型。</p><p>不过需要注意，在泛型中只能使用类，不能使用原始类型。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 装整数的双链表</span></span><br><span class="line">LinkedList&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//报错，不能用 int 这种原始类型作为泛型</span></span><br><span class="line">LinkedList&lt;<span class="type">int</span>&gt; list2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 装字符串的双链表</span></span><br><span class="line">LinkedList&lt;String&gt; list3 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>在实现自己的数据结构类时，也需要使用泛型，以便实现的数据结构能够装任何类型。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLinkedList</span>&lt;E&gt;&#123;</span><br><span class="line">    <span class="comment">// 在链表尾部添加元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(E e)</span>&#123;</span><br><span class="line">        <span class="comment">// ..</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line">MyLinkedList&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">MyLinkedList</span>&lt;&gt;();</span><br><span class="line">MyLinkedList&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">MyLinkedList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>需要注意的是，某些特殊的数据结构对存储的数据类型有要求。</p><p>比如 TreeMap 这种数据结构，由于底层是用 BST （二叉搜索树）来存储键值对，所以 TreeMap 要求存入其中的键必须是可比较的，即对于任意两个键，必须能够知道它俩谁大谁小。</p><p>在 Java 中，可以给泛型变量添加 extends 来指定该泛型的某些特性。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MyTreeMap 接受两个泛型 K 和 V，其中 K 必须实现 Comparable 接口</span></span><br><span class="line"><span class="comment">// 即必须实现 compareTo 方法，这样才可以比较大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTreeMap</span>&lt;K <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;K&gt;, V&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, v val)</span>&#123;</span><br><span class="line">        <span class="comment">// ..</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方法：</span></span><br><span class="line">MyTreeMap&lt;Integer, Integer&gt; map1 = <span class="keyword">new</span> <span class="title class_">MyTreeMap</span>&lt;&gt;();</span><br><span class="line">MyTreeMap&lt;String, Integer&gt; map2 = <span class="keyword">new</span> <span class="title class_">MyTreeMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>Comparable 是 Java 标准库提供的一个接口，实现如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(T o)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以 K extends Comparable<K> 的意思是泛型 K 实现了这个接口，即类型 K 有compareTo这个方法，意味着这两个 K 类型的数据可以比较大小。</p><h5 id="Java接口"><a href="#Java接口" class="headerlink" title="Java接口"></a>Java接口</h5><p>有时候可能看到以下写法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue&lt;String&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>实际 new 出来对的是 LinkedList 类型，但为什么使用 Queue 类型和 List 类型接受呢？</p><p>因为 Queue 和 List 都是 Java 标准库中的接口类型：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Queue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Collection</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span>;</span><br><span class="line">    E <span class="title function_">poll</span><span class="params">()</span>;</span><br><span class="line">    E <span class="title function_">peek</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 还有若干方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Collection</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">// 若干方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所谓接口，就是一组方法的集合，只要一个类使用 implements 关键词申明自己实现了接口中的所有方法，那么就可以用这个接口的类型来接受这个类的实例化对象。</p><p>具体地，标准库提供的 LinkedList 类实现了List 接口中的所有方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Deque 是 Queue 的子接口，包含了 Queue 接口的所有方法，所以实现了 Deque 就等于实现了 Queue 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;&#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Queue 接口中声明的若干方法都会被实现</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span>&#123;...&#125;</span><br><span class="line">    E <span class="title function_">poll</span><span class="params">()</span>&#123;...&#125;</span><br><span class="line">    E <span class="title function_">peek</span><span class="params">()</span>&#123;...&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// List 接口的若干方法也会被实现</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以可以用 List 接口接受 LinkedList 类型，Queue 接口同理。</p><h3 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h3><h4 id="数组（顺序存储）基本原理"><a href="#数组（顺序存储）基本原理" class="headerlink" title="数组（顺序存储）基本原理"></a>数组（顺序存储）基本原理</h4><p>数组可以分为静态数组和动态数组。</p><p>静态数组就是一块连续的内存空间，可以通过索引来访问这块内存空间中的元素。</p><p>动态数组是编程语言为了方便用户使用，在静态数组的基础上增加了一些常用的API，例如 push ， insert ， remove 等方法，通过这些 API 可以更方便地操作数组元素，不需要自己去写代码完成这些操作。</p><p>基于动态数组，可以实现更复杂地数据结构如队列、栈、哈希表等。</p><h5 id="静态数组"><a href="#静态数组" class="headerlink" title="静态数组"></a>静态数组</h5><p>静态数组在创建时就确定数组的元素类型和元素数量。</p><p>只有 C++ 、Java 、 Golang 这类语言才提供了创建静态数组的方式，类似 Python 、 JavaScript 等并没有提供静态数组的定义方式。</p><p>定义一个静态数组的方法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个大小为 10 的静态数组</span></span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用索引赋值</span></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用索引取值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>以 C++ 为例， int arr[10] 这段代码主要完成以下功能：</p><ol><li>在内存中开辟出一段连续的内存空间，大小为 10 * sizeof(int) 字节。一个 int 在计算机内存中占 4 字节，也就是总共 40 字节。</li><li>定义一个名为 arr 的数组指针，指向这段内存空间的首地址。</li></ol><p>arr[1] &#x3D; 2 这段代码做了以下事情：</p><ol><li>计算 arr 的首地址加上 1 * sizeof(int) 字节（ 4 字节）的偏移量，找到内存空间中的第二个元素的地址。</li><li>从这个地址开始的 4 个字节的内存空间中写入整数 2 。</li></ol><p>静态数组本质上是一块连续的内存空间，可以随机访问，即：只要给定任何一个数组索引，我们可以在 O(1) 的时间内直接获取到对应元素的值。</p><h5 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h5><h6 id="增"><a href="#增" class="headerlink" title="增"></a>增</h6><p>给静态数组增加元素，分为以下情况：</p><p>情况一，数组末尾追加（append）元素</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 大小为 10 的数组已经装了 4 个元素</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">    arr[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在想在数组末尾追加一个元素 4</span></span><br><span class="line">arr[<span class="number">4</span>] = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再在数组末尾追加一个元素 5</span></span><br><span class="line">arr[<span class="number">5</span>] = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>可以看到，由于只是对索引赋值，所以在数组末尾追加元素的时间复杂度为 O(1)</p><p>情况二，数组中间插入（insert）元素</p><p>例如，有一个大小为 10 的数组 arr ，前四个索引装了元素，现在想在第 3 个位置（arr[2]）插入一个新元素。</p><p>这部分操作涉及数据搬移，给新元素腾出空位，然后才能插入新元素。基本代码逻辑如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 大小为 10 的数组已经装了 4 个元素</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">    arr[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在第 3 个位置插入元素 666</span></span><br><span class="line"><span class="comment">// 需要把第 3 个位置及之后的元素都往后移动一位</span></span><br><span class="line"><span class="comment">// 注意要倒着遍历数组中已有元素避免覆盖</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">4</span>; i &gt; <span class="number">2</span>; i--)&#123;</span><br><span class="line">    arr[i] = arr[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在第 3 个位置空出，可以插入新元素</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="number">666</span>;</span><br></pre></td></tr></table></figure><p>综上，在数组中间插入元素的时间复杂度为 O(N) ，因为涉及到数据搬移，需要给新元素腾出地方。</p><p>情况三，数组空间已满</p><p>由于静态数组在创建时就需要确定大小，所以会存在插入数据时数组空间已满的情况。</p><p>由于连续内存必须一次性分配，分配完了就不能随意增减，所以只能重新申请一块更大的内存空间，把原来的数据复制过去，再插入新的元素，也就是数组的扩容操作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 大小为 10 的数组已经装满</span></span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">    arr[i] = i;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在想在数组末尾追加一个元素 10</span></span><br><span class="line"><span class="comment">// 需要先扩容数组</span></span><br><span class="line"><span class="type">int</span>[] newArr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">20</span>];</span><br><span class="line"><span class="comment">// 把原来的 10 个元素复制过去</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">    newArr[i] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放旧数组的内存空间</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在新的数组中追加新元素</span></span><br><span class="line">newArr[<span class="number">10</span>] = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>综上，数组的扩容操作会涉及到数组的开辟和数据的复制，时间复杂度为 O(N) 。</p><h5 id="删"><a href="#删" class="headerlink" title="删"></a>删</h5><p>情况一，删除末尾元素</p><p>简单的方法，直接把末尾元素标记为一个特殊值代表已删除即可，例如使用 -1 作为特殊值代表已删除。</p><p>删除数组尾部元素本质就是进行一次随机访问，时间复杂度为 O(1) 。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 大小为 10 的数组已经装了 5 个元素</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">    arr[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除末尾元素，暂时用 -1 代表元素已删除</span></span><br><span class="line">arr[<span class="number">4</span>] = -<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>情况二，删除中间元素</p><p>删除中间元素涉及到数据搬移，把被删元素后面的元素都往前移动一位，保持数组元素的连续性。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 大小为 10 的数组已经装了 5 个元素</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">    arr[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除 arr[1]</span></span><br><span class="line"><span class="comment">// 需要把 arr[1] 之后的元素都往前移动一位</span></span><br><span class="line"><span class="comment">// 主要要正着遍历数组中已有的元素避免覆盖</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">    arr[i] = arr[i + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后一个元素置为 -1 代表已删除</span></span><br><span class="line">arr[<span class="number">4</span>] = -<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>综上，在数组中间删除元素的时间复杂度是 O(N) ，因为涉及了数据搬移。</p><h5 id="动态数组-1"><a href="#动态数组-1" class="headerlink" title="动态数组"></a>动态数组</h5><p>动态数组无法解决静态数组在中间增删元素效率差的问题。</p><p>数组之所以能够随机访问是由于数组连续的内存空间，而连续的内存空间就不可避免地面对数据搬移和扩缩容的问题。</p><p>动态数组底层还是静态数组，但是它能够自动帮助进行数组空间的扩缩容，并把增删改查操作进行了封装，使得使用起来更加方便。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建动态数组</span></span><br><span class="line"><span class="comment">// 不用显示指定数组大小，它会根据实际存储的元素数量进行自动扩缩容</span></span><br><span class="line">ArrayList&lt;Integer&gt; arr = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">    <span class="comment">// 在末尾追加元素，时间复杂度为 O(1)</span></span><br><span class="line">    arr.add(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在中间插入元素，时间复杂度为 O(N)</span></span><br><span class="line"><span class="comment">// 在索引 2 的位置插入元素 666</span></span><br><span class="line">arr.add(<span class="number">2</span>, <span class="number">666</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在头部插入元素，时间复杂度为 O(N)</span></span><br><span class="line">arr.add(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除末尾元素，时间复杂度为 O(1)</span></span><br><span class="line">arr.remove(arr.size() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除中间元素，时间复杂度为 O(N)</span></span><br><span class="line"><span class="comment">// 删除索引为 2 的元素</span></span><br><span class="line">arr.remove(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据索引查询元素，时间复杂度为 O(1)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> arr.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据索引修改元素，时间复杂度为 O(1)</span></span><br><span class="line">arr.set(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据元素值查找索引，时间复杂度为 O(N)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> arr.indexOf(<span class="number">666</span>);</span><br></pre></td></tr></table></figure><h4 id="动态数组代码实现"><a href="#动态数组代码实现" class="headerlink" title="动态数组代码实现"></a>动态数组代码实现</h4><h5 id="关键点一、自动扩缩容"><a href="#关键点一、自动扩缩容" class="headerlink" title="关键点一、自动扩缩容"></a>关键点一、自动扩缩容</h5><h5 id="关键点二、索引越界的检查"><a href="#关键点二、索引越界的检查" class="headerlink" title="关键点二、索引越界的检查"></a>关键点二、索引越界的检查</h5><h5 id="关键点三、删除元素谨防内存泄露"><a href="#关键点三、删除元素谨防内存泄露" class="headerlink" title="关键点三、删除元素谨防内存泄露"></a>关键点三、删除元素谨防内存泄露</h5><h5 id="其他细节优化"><a href="#其他细节优化" class="headerlink" title="其他细节优化"></a>其他细节优化</h5><h3 id="单-x2F-双链表"><a href="#单-x2F-双链表" class="headerlink" title="单&#x2F;双链表"></a>单&#x2F;双链表</h3><h4 id="链表（链式存储）基本原理"><a href="#链表（链式存储）基本原理" class="headerlink" title="链表（链式存储）基本原理"></a>链表（链式存储）基本原理</h4><h4 id="链表代码实现"><a href="#链表代码实现" class="headerlink" title="链表代码实现"></a>链表代码实现</h4><h3 id="队列-x2F-栈"><a href="#队列-x2F-栈" class="headerlink" title="队列&#x2F;栈"></a>队列&#x2F;栈</h3><h4 id="队列-x2F-栈基本原理"><a href="#队列-x2F-栈基本原理" class="headerlink" title="队列&#x2F;栈基本原理"></a>队列&#x2F;栈基本原理</h4><h4 id="用链表实现队列-x2F-栈"><a href="#用链表实现队列-x2F-栈" class="headerlink" title="用链表实现队列&#x2F;栈"></a>用链表实现队列&#x2F;栈</h4><h4 id="环形数组技巧"><a href="#环形数组技巧" class="headerlink" title="环形数组技巧"></a>环形数组技巧</h4><h4 id="用数组实现队列-x2F-栈"><a href="#用数组实现队列-x2F-栈" class="headerlink" title="用数组实现队列&#x2F;栈"></a>用数组实现队列&#x2F;栈</h4><h4 id="双端队列（Deque）原理及实现"><a href="#双端队列（Deque）原理及实现" class="headerlink" title="双端队列（Deque）原理及实现"></a>双端队列（Deque）原理及实现</h4><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><h4 id="哈希表基本原理"><a href="#哈希表基本原理" class="headerlink" title="哈希表基本原理"></a>哈希表基本原理</h4><h4 id="用拉链法实现哈希表"><a href="#用拉链法实现哈希表" class="headerlink" title="用拉链法实现哈希表"></a>用拉链法实现哈希表</h4><h4 id="线性探查法的两个难点"><a href="#线性探查法的两个难点" class="headerlink" title="线性探查法的两个难点"></a>线性探查法的两个难点</h4><h4 id="线性探查法的两种代码实现"><a href="#线性探查法的两种代码实现" class="headerlink" title="线性探查法的两种代码实现"></a>线性探查法的两种代码实现</h4><h3 id="哈希集合"><a href="#哈希集合" class="headerlink" title="哈希集合"></a>哈希集合</h3><h4 id="哈希集合的原理"><a href="#哈希集合的原理" class="headerlink" title="哈希集合的原理"></a>哈希集合的原理</h4><h4 id="哈希集合的代码实现"><a href="#哈希集合的代码实现" class="headerlink" title="哈希集合的代码实现"></a>哈希集合的代码实现</h4><h3 id="二叉树结构"><a href="#二叉树结构" class="headerlink" title="二叉树结构"></a>二叉树结构</h3><h4 id="二叉树基础及常见类型"><a href="#二叉树基础及常见类型" class="headerlink" title="二叉树基础及常见类型"></a>二叉树基础及常见类型</h4><h3 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h3><h4 id="二叉堆的基本原理"><a href="#二叉堆的基本原理" class="headerlink" title="二叉堆的基本原理"></a>二叉堆的基本原理</h4><h4 id="二叉堆的代码实现"><a href="#二叉堆的代码实现" class="headerlink" title="二叉堆的代码实现"></a>二叉堆的代码实现</h4>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-课后习题</title>
      <link href="/FRank675.github.io/posts/d12a26c6e3b8/"/>
      <url>/FRank675.github.io/posts/d12a26c6e3b8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="操作系统-课后习题-答案版"><a href="#操作系统-课后习题-答案版" class="headerlink" title="操作系统-课后习题-答案版"></a>操作系统-课后习题-答案版</h1><h2 id="第一章-操作系统引论"><a href="#第一章-操作系统引论" class="headerlink" title="第一章 操作系统引论"></a>第一章 操作系统引论</h2><h3 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h3><p>1.在计算机系统中配置操作系统的主要目的是<strong>提高系统资源的利用率</strong>，操作系统的主要功能是管理计算机系统中的<strong>资源</strong>，其中包括<strong>处理机</strong>、<strong>存储器</strong>，以及文件和设备。这里的处理机管理主要是对进程进行管理。</p><p>2.操作系统有多种类型：允许多个用户以交互方式使用计算机的操作系统，称为<strong>分时操作系统</strong>；允许多个用户将若干个作业提交给计算机系统集中处理的操作系统称为<strong>批处理操作系统</strong>；在<strong>实时操作系统</strong>的控制下，计算机系统能及时处理由过程控制反馈的数据，并做出响应；在IBM-PC机上的操作系统称为<strong>微机操作系统</strong>。</p><p>3.操作系统是一种<strong>系统软件</strong>，它负责为用户和用户程序完成所有<strong>与硬件相关并与应用无关</strong>的工作，<strong>高级程序设计语言的编译</strong>不是操作系统关心的主要问题。</p><p>4.用户在程序设计过程中，可通过<strong>系统调用</strong>获得操作系统的服务。</p><p>5.在OS中采用多道程序设计技术，能有效地提高CPU，内存和DO设备的<strong>利用率</strong>，为实现多道程序设计需要<strong>有更大的内存</strong>。</p><p>6.推动批处理系统形成和发展的主要动力是<strong>提高系统资源利用率</strong>，推动分时系统形成和发展的动力是<strong>方便用户</strong>，推动微机OS发展的主要动力是<strong>计算机硬件的不断更新换代</strong>。</p><p>7.在设计分时操作系统时，首先要考虑的是<strong>交互性和响应时间</strong>；在设计批处理操作系统时，首先要考虑的是<strong>周转时间和系统吞吐量</strong>；在设计实时操作系统时，首先要考虑的是<strong>实时性和可靠性</strong>。</p><p>8.在多道批处理系统中，为了充分利用各种资源，系统总是优先选择<strong>计算型和1&#x2F;O型均衡的</strong>多个作业投入运行；为了提高吞吐量，系统总是想方设法缩短用户作业的<strong>周转时间</strong>。</p><p>9.从下面关于操作系统的论述中，选出一条正确的论述。</p><p>(1)对批处理作业，必须提供相应的作业控制信息。<strong>（对）</strong></p><p>(2)对于分时系统，不一定全部提供人机交互功能。<strong>（错）</strong></p><p>(3)从响应角度看，分时系统与实时系统的要求相似。<strong>（错）</strong></p><p>(4)采用分时操作系统的计算机系统中，用户可以独占计算机操作系统中的文件系统。<strong>（错）</strong></p><p>(5)从交互角度看，分时系统与实时系统相似。<strong>（错）</strong></p><p>10.分时系统的响应时间(及时性)主要是根据<strong>用户所能接受的等待时间</strong>确定的，而实时系统的响应时间则是由<strong>控制对象所能接受的时延</strong>确定的。</p><p>11.在分时系统中，为使多个用户能够同时与系统交互，最关键的问题是<strong>能在一较短的时间内，使所有用户程序都得到运行</strong>：当用户数目为100时，为保证响应时间不超过2秒，此时的时间片最大应为<strong>20ms</strong>。</p><p>12.分时系统和实时系统都具有交互性，实时系统的交互性允许用户访问<strong>专用服务程序</strong>；分时系统的交互性允许用户请求系统提供<strong>多方面的服务</strong>。</p><p>13.实时操作系统必须在<strong>规定时间</strong>内处理完来自外部的事件，<strong>资源利用率</strong>不是设计实时系统主要追求的目标。</p><p>14.在下列系统中，<strong>民航售票系统</strong>是实时信息系统，<strong>火箭飞行控制系统</strong>是实时控制系统。</p><p>15、现有以下计算机的应用场合，请为其选择适当的操作系统：(1)航空航天，核变研究：<strong>配置实时操作系统</strong>；(2)国家统计局数据处理中心：<strong>配置批处理操作系统；</strong>(3)机房学生上机学习编程：<strong>配置分时操作系统</strong>；(4)民航机票订购系统：<strong>配置实时操作系统；</strong>(5)两个不同地区之间发送电子邮件：<strong>配置网络操作系统</strong>。</p><p>16.从下面关于并发性的论述中，选出一条正确的论述。</p><p>(1)并发性是指若干事件在同一时刻发生。<strong>（错）</strong></p><p>(2)并发性是指若干事件在不同时刻发生。<strong>（错）</strong></p><p>(3)并发性是指若干事件在同一时间间隔内发生。<strong>（对）</strong></p><p>(4)并发性是指若干事件在不同时间间隔内发生。<strong>（错）</strong></p><p>17.在单处理器系统中，可以并发但不可以并行工作的是<strong>进程与进程</strong>。</p><p>18.从下述关于模块化程序的叙述中，选出5条正确的叙述。</p><p>(1)使程序设计更为方便，但比较难维护。<strong>（错）</strong></p><p>(2)便于由多人分工编制大型程序。<strong>（对）</strong></p><p>(3)便于软件功能扩充。<strong>（对）</strong></p><p>(4)在内存能够容纳的前提下，应使模块尽可能大，以减少模块的个数。<strong>（错）</strong></p><p>(5)模块之间的接口叫数据文件。<strong>（错）</strong></p><p>(6)只要模块接口不变，各模块内部实现细节的修改，不会影响别的模块。<strong>（对）</strong></p><p>(7)使程序易于理解，也利于排错。<strong>（对）</strong></p><p>(8)模块间的单向调用关系，形成了模块的层次式结构。<strong>（对）</strong></p><p>(9)模块愈小，模块化的优点愈明显，一般说来，一个模块的大小在10行以下。<strong>（错）</strong></p><p>(10)一个模块实际上是一个进程。<strong>（错）</strong></p><p>19.采用<strong>微内核</strong>结构时，将OS分成用于实现OS最基本功能的内核和提供各种服务的服务器两个部分：通常，下列模块中必须包含在操作系统内核中的是<strong>中断处理</strong>模块。</p><p>20.与早期的OS相比，采用微内核结构的OS具有很多优点，但这些优点有<strong>提高了系统的可扩展性</strong>，<strong>增强了系统的可靠性</strong>，<strong>使OS的可移植性更好</strong>，不包含<strong>提高了OS的运行效率</strong></p><p>21.在8位微机上占据统治地位的操作系统是<strong>CP&#x2F;M</strong>，16位微机事实上的操作系统标准是<strong>MS-DOS</strong>。</p><p>22、在3.X版本以前的MS-DOS 是<strong>单用户单任务</strong>操作系统，Windows 95是<strong>单用户多任务</strong>操作系统，Windows XP、Windows7及Windows 8是<strong>多用户多任务</strong>，它们都是由<strong>Microsoft公司</strong>开发的。</p><p>23.UNIX操作系统最初是由<strong>Bell实验室</strong>推出的，它属于<strong>多用户多任务</strong>类操作系统。</p><p>24.Linux是一个<strong>多用户多任务</strong>类型的操作系统，其内核的创始人是<strong>Linus Torvalds</strong>：所谓Linux是一个“Free Software”，这意味着<strong>Linux 可以自由修改和发布</strong>。</p><h3 id="填空题"><a href="#填空题" class="headerlink" title="填空题"></a>填空题</h3><p>1.设计现代OS的主要目标是<strong>提高资源利用率</strong>和<strong>方便用户</strong>。</p><p>2.单道批处理系统是在解决<strong>人机矛盾</strong>和<strong>CPU与I&#x2F;O设备速度不匹配</strong>的矛盾中发展起来的。</p><p>3.在单处理机环境下的多道程序设计具有多道、<strong>宏观上同时运行</strong>和<strong>微观上交替运行</strong>的特点。</p><p>4.现代操作系统的两个最基本的特征是<strong>并发</strong>和<strong>资源共享</strong>，除此之外，它还具有<strong>虚拟性</strong>和<strong>异步性</strong>的特征。</p><p>5.从资源管理的角度看，操作系统具有四大功能：<strong>处理机管理</strong>、<strong>存储器管理</strong>、<strong>设备管理</strong>和<strong>文件管理</strong>；而为了方便用户，操作系统还必须提供<strong>友好的用户接口</strong>。</p><p>6.除了传统操作系统中的进程管理、存储器管理、设备管理、文件管理等基本功能外，现代操作系统中还增加了<strong>系统安全</strong>、<strong>网络</strong>和<strong>多媒体</strong>等功能。</p><p>7.操作系统的基本类型主要有<strong>批处理系统</strong>、<strong>分时系统</strong>和<strong>实时系统</strong>。</p><p>8.批处理系统的主要优点是<strong>资源利用率高</strong>和<strong>系统吞吐量大</strong>；主要缺点是<strong>无交互作用能力</strong>和<strong>作业平均周转时间长</strong>。</p><p>9.实现分时系统的关键问题是<strong>人机交互</strong>，为此必须引入<strong>时间片</strong>的概念，并采用<strong>时间片轮转</strong>调度算法。</p><p>10.分时系统的基本特征是：<strong>多路性</strong>、<strong>独立性</strong>、<strong>交互性</strong>和<strong>及时性</strong>。</p><p>11.若干事件在同一时间间隔内发生称为<strong>并发</strong>；若干事件在同一时刻发生称为<strong>并行</strong>。</p><p>12.实时系统可分为<strong>实时信息处理系统</strong>、<strong>实时控制系统</strong>、多媒体系统和嵌入式系统等类型；民航售票系统属于<strong>实时信息处理系统</strong>，而导弹飞行控制系统则属于<strong>实时控制系统</strong>。</p><p>13.为了使实时系统高度可靠和安全，通常不强求<strong>资源利用率</strong>。</p><p>14.当前比较流行的微内核的操作系统结构，是建立在层次化结构的基础上的，而且还采用了<strong>客户机&#x2F;服务器</strong>模式和<strong>面向对象程序设计</strong>技术。</p><h2 id="第二章-进程的描述与控制"><a href="#第二章-进程的描述与控制" class="headerlink" title="第二章 进程的描述与控制"></a>第二章 进程的描述与控制</h2><h3 id="选择题-1"><a href="#选择题-1" class="headerlink" title="选择题"></a>选择题</h3><h3 id="填空题-1"><a href="#填空题-1" class="headerlink" title="填空题"></a>填空题</h3><p>1.在单用户单任务环境下，用户独占全机，此时机内资源的状态，只能由运行程序的操作加以改变，此时的程序执行具有①性和②性特征。</p><p>2.并发进程之间的相互制约，是由于它们①和②而产生的，因而导致程序在并发执行时具有 ③特征。</p><p>3.程序并发执行与顺序执行时相比产生了一些新特征，分别是 ①、②和③。</p><p>4.引入进程的目的是①，而引入线程的目的是②。</p><p>5.进程由①、②和③组成，其中_④是进程存在的唯一标志。_</p><p>6.进程最基本的特征是①和②，除此之外，它还有③和④特征。</p><p>7.由于进程的实质是程序的一次执行，故进程有①的基本特征，该特征还表现在进程由②而产生，由③而执行，由④而消亡，即进程具有一定的生命期。</p><p>8.引入进程带来的好处①和②</p><p>9.当前正在执行的进程由于时间片用完而暂停执行时，该进程应转变为①状态；若因发生某种事件而不能继续执行时，应转为②状态；若应终端用户的请求而暂停执行时，它应转为③状态。</p><p>10.用户为阻止进程继续运行，应利用①原语，若进程正在执行，应转变为②状态；以后，若用户要恢复其运行，应利用③原语，此时进程应转变为④状态。</p><p>11.系统中共有5个用户进程，且当前CPU在用户态下执行，则最多可有①个用户进程处于就绪状态，最多可有②个用户进程处于阻塞状态；若当前在核心态下执行，则最多可有_③个用户进程处于就绪状态，最多可有④个用户进程处于阻塞状态。_</p><p>12.为了防止OS本身及关键数据(如PCB等)，遭受到应用程序有意或无意的破坏，通常也将处理机的执行状态分成①和②两种状态。</p><p>13.进程同步主要是对多个相关进程在①上进行协调。</p><p>14、同步机制应遵循的准则有是①、②、③和④。</p><p>15.在记录型信号量机制中，S.value&gt;0时的值表示①；每次wait操作意味着②，因此应将S.value ③，当S.value ④时，进程应阻塞。</p><p>16.在记录型信号量机制中，每次signal操作意味着①，因此应将 S.value②，当S.value≤0时，表示③，此时应④。</p><p>17.在利用信号量实现进程互斥时，应将①置于②和③之间。</p><p>18.在每个进程中访问①的那段代码称为临界区。为实现对它的共享，应保证进程②地进入自己的临界区，为此在每个进程的临界区前应设置③，临界区后应设置④。</p><p>19.利用共享的文件进行进程通信的方式被称作①，除此之外，进程通信的类型还有②、③和④三种类型。_</p><p>20.客户机一服务器系统通信机制主要的实现方法有是①、②和③三种。</p><p>21.为实现消息缓冲队列通信，应在PCB中增加①、②、③三个数据项。</p><p>22.引入线程概念后，操作系统以①作为资源分配的基本单位，以②作为CPU调度和分派的基本单位。</p><p>23.在采用用户级线程的系统中，OS进行CPU调度的对象是①；在采用内核支持的线程的系统中，CPU 调度的对象是②。</p><p>24.线程之所以能减少并发执行的开销是因为①。</p><h3 id="第三章-处理机调度与死锁"><a href="#第三章-处理机调度与死锁" class="headerlink" title="第三章 处理机调度与死锁"></a>第三章 处理机调度与死锁</h3><h3 id="选择题-2"><a href="#选择题-2" class="headerlink" title="选择题"></a>选择题</h3><h3 id="填空题-2"><a href="#填空题-2" class="headerlink" title="填空题"></a>填空题</h3><p>1.高级调度又称作①调度，其主要功能是②：低级调度又称作③调度，其主功能是④。</p><p>2.作业调度必须做①和两个决定。</p><p>3.进程调度的主要任务是①、②和③，进程调度的方式主要有④和种方式。</p><p>4.在抢占调度方式中，抢占的原则主要有：①、②和③</p><p>5.在设计进程调度程序时，应考虑①②和③二个问题。</p><p>6.为了使作业的平均周转时间最短，应该选择①调度算法；为了使当前执行的进程总是优先权最高的进程，则应选择②调度算法；而分时系统则常采用_③调度算法。_</p><p>7.分时系统中，时间片选得太小会造成①的现象，因此，时间片的大小一般选择为②。</p><p>8.在采用动态优先权时，为了避免一个低优先权的进程处于饥饿状态，可以①；而为了避免一个高优先权的长作业长期垄断CPU，则可以②。</p><p>9.高响应比优先调度算法综合考虑了作业的①和②，因此会兼顾到长、短作业。</p><p>10.死锁产生的主要原因是①和②。</p><p>11.死锁产生的必要条件是①、②、③和④。</p><p>12.通过破坏死锁产生的四个必要条件可进行死锁的预防，其中①条件一般是不允许破坏的，一次性分配所有资源破坏的是其中的②条件，资源的有序分配破坏的是其中的③条件。</p><p>13.避免死锁，允许进程动态地申请资源，但系统在进行分配时应先计算资源分配的①。若此次分配不会导致系统进入②，便将资源分配给它，否则便让进程③。</p><p>14.解决死锁问题的方法有预防、避免、检测并解除等，一次性分配所有的资源采用的是其中的①方法，银行家算法采用的是其中的②方法。</p><p>15.根据死锁定理，一个状态为死锁状态的充分条件是当且仅当该状态的资源分配图是①时。</p><p>16.①和②是解除死锁的两种常用方法。</p><h3 id="第四章-存储器管理"><a href="#第四章-存储器管理" class="headerlink" title="第四章 存储器管理"></a>第四章 存储器管理</h3><h3 id="选择题-3"><a href="#选择题-3" class="headerlink" title="选择题"></a>选择题</h3><h3 id="填空题-3"><a href="#填空题-3" class="headerlink" title="填空题"></a>填空题</h3><h3 id="第五章-虚拟存储器"><a href="#第五章-虚拟存储器" class="headerlink" title="第五章 虚拟存储器"></a>第五章 虚拟存储器</h3><h3 id="选择题-4"><a href="#选择题-4" class="headerlink" title="选择题"></a>选择题</h3><h3 id="填空题-4"><a href="#填空题-4" class="headerlink" title="填空题"></a>填空题</h3><h3 id="第六章-输入输出系统"><a href="#第六章-输入输出系统" class="headerlink" title="第六章 输入输出系统"></a>第六章 输入输出系统</h3><h3 id="选择题-5"><a href="#选择题-5" class="headerlink" title="选择题"></a>选择题</h3><h3 id="填空题-5"><a href="#填空题-5" class="headerlink" title="填空题"></a>填空题</h3><h3 id="第七章-文件管理"><a href="#第七章-文件管理" class="headerlink" title="第七章 文件管理"></a>第七章 文件管理</h3><h3 id="选择题-6"><a href="#选择题-6" class="headerlink" title="选择题"></a>选择题</h3><h3 id="填空题-6"><a href="#填空题-6" class="headerlink" title="填空题"></a>填空题</h3><h3 id="第八章-磁盘存储器的管理"><a href="#第八章-磁盘存储器的管理" class="headerlink" title="第八章 磁盘存储器的管理"></a>第八章 磁盘存储器的管理</h3><h3 id="选择题-7"><a href="#选择题-7" class="headerlink" title="选择题"></a>选择题</h3><h3 id="填空题-7"><a href="#填空题-7" class="headerlink" title="填空题"></a>填空题</h3><h3 id="第九章-操作系统接口"><a href="#第九章-操作系统接口" class="headerlink" title="第九章 操作系统接口"></a>第九章 操作系统接口</h3><h3 id="选择题-8"><a href="#选择题-8" class="headerlink" title="选择题"></a>选择题</h3><h3 id="填空题-8"><a href="#填空题-8" class="headerlink" title="填空题"></a>填空题</h3>]]></content>
      
      
      <categories>
          
          <category> learning考研数学常用公式结论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动手学习深度学习-记录</title>
      <link href="/FRank675.github.io/posts/4ae195802452/"/>
      <url>/FRank675.github.io/posts/4ae195802452/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h3 id="torch-arange"><a href="#torch-arange" class="headerlink" title="torch.arange"></a>torch.arange</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.arange(start, end, step=<span class="number">1</span>, out=<span class="literal">None</span>) -&gt; Tensor</span><br><span class="line"><span class="comment">#返回一个1维张量，长度floor((end - start)/step)</span></span><br><span class="line"><span class="comment">#包含从start到end，以step为步长的一组序列值（默认步长为1）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#参数</span></span><br><span class="line"><span class="comment">##start(float) - 序列的起始点</span></span><br><span class="line"><span class="comment">##end(float) - 序列的终止点</span></span><br><span class="line"><span class="comment">##step(float) - 相邻点的间隔大小</span></span><br><span class="line"><span class="comment">##out(Tensor, optional) - 结果张量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#例子</span></span><br><span class="line">x = torch.arange(<span class="number">12</span>)</span><br><span class="line">y = torch.arange(<span class="number">2</span>, <span class="number">9</span>)</span><br><span class="line">z = torch.arange(<span class="number">2</span>, <span class="number">9</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"><span class="built_in">print</span>(z)</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">tensor([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>])</span><br><span class="line">tensor([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])</span><br><span class="line">tensor([<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>])</span><br></pre></td></tr></table></figure><h3 id="torch-zeros"><a href="#torch-zeros" class="headerlink" title="torch.zeros"></a>torch.zeros</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.zeros(*sizes, out=<span class="literal">None</span>) -&gt; Tensor</span><br><span class="line"><span class="comment">#返回一个全为标量0的张量，形状可由可变参数sizes定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#参数</span></span><br><span class="line"><span class="comment">##sizes(int...) - 整数序列，定义了输出形状</span></span><br><span class="line"><span class="comment">##out(Tensor, optional) - 结果张量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#例子</span></span><br><span class="line">x = torch.zeros(<span class="number">3</span>)</span><br><span class="line">y = torch.zeros(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">z = torch.zeros(<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"><span class="built_in">print</span>(z)</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">tensor([<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>])</span><br><span class="line">tensor([[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">        [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>]])</span><br><span class="line">tensor([[[<span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">         [<span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">         [<span class="number">0.</span>, <span class="number">0.</span>]],</span><br><span class="line">        [[<span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">         [<span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">         [<span class="number">0.</span>, <span class="number">0.</span>]]])</span><br></pre></td></tr></table></figure><h3 id="torch-ones"><a href="#torch-ones" class="headerlink" title="torch.ones"></a>torch.ones</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.ones(*sizes, out=<span class="literal">None</span>) -&gt; Tensor</span><br><span class="line"><span class="comment">#返回一个全为1的张量，形状由可变参数sizes定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#参数</span></span><br><span class="line"><span class="comment">##sizes(int...) - 整数序列，定义了输出形状</span></span><br><span class="line"><span class="comment">##out(Tensor, optional) - 结果张量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#例子</span></span><br><span class="line">x = torch.ones(<span class="number">3</span>)</span><br><span class="line">y = torch.ones(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">z = torch.ones(<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"><span class="built_in">print</span>(z)</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">tensor([<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>])</span><br><span class="line">tensor([[<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>]])</span><br><span class="line">tensor([[[<span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">         [<span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">         [<span class="number">1.</span>, <span class="number">1.</span>]],</span><br><span class="line">        [[<span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">         [<span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">         [<span class="number">1.</span>, <span class="number">1.</span>]]])</span><br></pre></td></tr></table></figure><h3 id="torch-randn"><a href="#torch-randn" class="headerlink" title="torch.randn"></a>torch.randn</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.randn(*sizes, out=<span class="literal">None</span>) -&gt; Tensor</span><br><span class="line"><span class="comment">#返回一个张量，包含了从标准正态分布（均值为0，方差为1，即高斯白噪声）种抽取一组随机数</span></span><br><span class="line"><span class="comment">#形状由可变参数sizes定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#参数</span></span><br><span class="line"><span class="comment">##sizes(int...) - 整数序列，定义了输出形状</span></span><br><span class="line"><span class="comment">##out(Tensor, optional) - 结果张量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#例子</span></span><br><span class="line">x = torch.randn(<span class="number">3</span>)</span><br><span class="line">y = torch.randn(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">z = torch.randn(<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"><span class="built_in">print</span>(z)</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">tensor([ <span class="number">1.6708</span>, -<span class="number">0.9269</span>, -<span class="number">0.6244</span>])</span><br><span class="line">tensor([[ <span class="number">0.0745</span>, -<span class="number">1.1297</span>, -<span class="number">0.8780</span>],</span><br><span class="line">        [ <span class="number">0.0630</span>, -<span class="number">1.0166</span>, -<span class="number">1.8237</span>]])</span><br><span class="line">tensor([[[-<span class="number">0.8598</span>,  <span class="number">0.7275</span>],</span><br><span class="line">         [-<span class="number">0.3070</span>,  <span class="number">0.0244</span>],</span><br><span class="line">         [ <span class="number">0.8968</span>,  <span class="number">1.4401</span>]],</span><br><span class="line">        [[ <span class="number">1.5100</span>,  <span class="number">2.2971</span>],</span><br><span class="line">         [-<span class="number">0.2009</span>, -<span class="number">1.5679</span>],</span><br><span class="line">         [-<span class="number">0.4775</span>, -<span class="number">0.4814</span>]]])</span><br></pre></td></tr></table></figure><h3 id="torch-cat"><a href="#torch-cat" class="headerlink" title="torch.cat"></a>torch.cat</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.cat(inputs, dimension=<span class="number">0</span>) -&gt; Tensor</span><br><span class="line"><span class="comment">#在给定维度上对输入的张量序列sep进行连接操作</span></span><br><span class="line"><span class="comment">#把多个张量连结（concatenate）在一起， 把它们端对端地叠起来形成一个更大的张量。</span></span><br><span class="line"><span class="comment">#只需要提供张量列表，并给出沿哪个轴连结</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#torch.cat()可以看作torch.split()和torch.chunk()的反操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#参数</span></span><br><span class="line"><span class="comment">##inputs(sequence of Tensors) - 可以是任意相同Tensor类型的python序列</span></span><br><span class="line"><span class="comment">##dimension(int,optional) - 沿着此维连接张量序列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#例子</span></span><br><span class="line">X = torch.arange(<span class="number">12</span>, dtype=torch.float32).reshape((<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(X)</span><br><span class="line">Y = torch.tensor([[<span class="number">2.0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line"><span class="built_in">print</span>(Y)</span><br><span class="line"><span class="built_in">print</span>(torch.cat((X, Y), dim=<span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(torch.cat((X, Y), dim=<span class="number">1</span>))</span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">tensor([[ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>],</span><br><span class="line">        [ <span class="number">4.</span>,  <span class="number">5.</span>,  <span class="number">6.</span>,  <span class="number">7.</span>],</span><br><span class="line">        [ <span class="number">8.</span>,  <span class="number">9.</span>, <span class="number">10.</span>, <span class="number">11.</span>]])</span><br><span class="line">tensor([[<span class="number">2.</span>, <span class="number">1.</span>, <span class="number">4.</span>, <span class="number">3.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>, <span class="number">4.</span>],</span><br><span class="line">        [<span class="number">4.</span>, <span class="number">3.</span>, <span class="number">2.</span>, <span class="number">1.</span>]])</span><br><span class="line">tensor([[ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>],</span><br><span class="line">        [ <span class="number">4.</span>,  <span class="number">5.</span>,  <span class="number">6.</span>,  <span class="number">7.</span>],</span><br><span class="line">        [ <span class="number">8.</span>,  <span class="number">9.</span>, <span class="number">10.</span>, <span class="number">11.</span>],</span><br><span class="line">        [ <span class="number">2.</span>,  <span class="number">1.</span>,  <span class="number">4.</span>,  <span class="number">3.</span>],</span><br><span class="line">        [ <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>,  <span class="number">4.</span>],</span><br><span class="line">        [ <span class="number">4.</span>,  <span class="number">3.</span>,  <span class="number">2.</span>,  <span class="number">1.</span>]])</span><br><span class="line">tensor([[ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>,  <span class="number">2.</span>,  <span class="number">1.</span>,  <span class="number">4.</span>,  <span class="number">3.</span>],</span><br><span class="line">        [ <span class="number">4.</span>,  <span class="number">5.</span>,  <span class="number">6.</span>,  <span class="number">7.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>,  <span class="number">4.</span>],</span><br><span class="line">        [ <span class="number">8.</span>,  <span class="number">9.</span>, <span class="number">10.</span>, <span class="number">11.</span>,  <span class="number">4.</span>,  <span class="number">3.</span>,  <span class="number">2.</span>,  <span class="number">1.</span>]])</span><br></pre></td></tr></table></figure><h3 id="torch-shape"><a href="#torch-shape" class="headerlink" title="torch.shape"></a>torch.shape</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#通过张量的shape属性来访问张量（沿每个轴的长度）的形状</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#例子</span></span><br><span class="line">x = torch.zeros(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(x.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">torch.Size([<span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure><h3 id="torch-numel"><a href="#torch-numel" class="headerlink" title="torch.numel"></a>torch.numel</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.numel(<span class="built_in">input</span>) -&gt; <span class="built_in">int</span></span><br><span class="line"><span class="comment">#返回input张量中的元素个数，即形状的所有元素乘积，可以检查它的大小（size）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#参数</span></span><br><span class="line"><span class="comment">##input(Tnsor) - 输入张量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#例子</span></span><br><span class="line">x = torch.randn(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">y = torch.zeros(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(torch.numel(x))</span><br><span class="line"><span class="built_in">print</span>(torch.numel(y))</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line"><span class="number">120</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="torch-reshape"><a href="#torch-reshape" class="headerlink" title="torch.reshape"></a>torch.reshape</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#要想改变一个张量的形状而不改变元素数量和元素值，可以调用reshape函数。 </span></span><br><span class="line"><span class="comment">#例如，可以把张量x从形状为（12,）的行向量转换为形状为（3,4）的矩阵。 </span></span><br><span class="line"><span class="comment">#这个新的张量包含与转换前相同的值，但是它被看成一个3行4列的矩阵。 </span></span><br><span class="line"><span class="comment">#要重点说明一下，虽然张量的形状发生了改变，但其元素值并没有变。 </span></span><br><span class="line"><span class="comment">#注意，通过改变张量的形状，张量的大小不会改变。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#例子</span></span><br><span class="line">x = torch.arange(<span class="number">12</span>)</span><br><span class="line">y = torch.reshape(x, [<span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">tensor([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>])</span><br><span class="line">tensor([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">        [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">        [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment">#我们不需要通过手动指定每个维度来改变形状。 </span></span><br><span class="line"><span class="comment">#也就是说，如果我们的目标形状是（高度,宽度）， 那么在知道宽度后，高度会被自动计算得出，不必我们自己做除法。 </span></span><br><span class="line"><span class="comment">#在上面的例子中，为了获得一个3行的矩阵，我们手动指定了它有3行和4列。 </span></span><br><span class="line"><span class="comment">#幸运的是，我们可以通过-1来调用此自动计算出维度的功能。 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#例子</span></span><br><span class="line">x = torch.arange(<span class="number">12</span>)</span><br><span class="line">y = torch.reshape(x, [-<span class="number">1</span>, <span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">tensor([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>])</span><br><span class="line">tensor([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">        [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">        [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br></pre></td></tr></table></figure><h3 id="torch-tensor"><a href="#torch-tensor" class="headerlink" title="torch.tensor"></a>torch.tensor</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#可以通过提供包含数值的Python列表（或嵌套列表），来为所需张量中的每个元素赋予确定值。 </span></span><br><span class="line"><span class="comment">#在这里，最外层的列表对应于轴0，内层的列表对应于轴1。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#例子</span></span><br><span class="line">x = torch.tensor([[<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">tensor([[<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">        [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br></pre></td></tr></table></figure><h3 id="在相同形状的两个张量上执行按元素操作"><a href="#在相同形状的两个张量上执行按元素操作" class="headerlink" title="在相同形状的两个张量上执行按元素操作"></a>在相同形状的两个张量上执行按元素操作</h3><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#例子</span></span><br><span class="line">x = torch.tensor([<span class="number">1.0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>])</span><br><span class="line">y = torch.tensor([<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x:\n&quot;</span>, x)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;y:\n&quot;</span>, y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x+y:\n&quot;</span>, x + y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x-y:\n&quot;</span>, x + y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x*y:\n&quot;</span>, x * y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x**y:\n&quot;</span>, x ** y)  <span class="comment"># **运算符是求幂运算</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;e^x:\n&quot;</span>, torch.exp(x))</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">x:</span><br><span class="line"> tensor([<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">4.</span>, <span class="number">8.</span>])</span><br><span class="line">y:</span><br><span class="line"> tensor([<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>])</span><br><span class="line">x+y:</span><br><span class="line"> tensor([ <span class="number">3.</span>,  <span class="number">4.</span>,  <span class="number">6.</span>, <span class="number">10.</span>])</span><br><span class="line">x-y:</span><br><span class="line"> tensor([ <span class="number">3.</span>,  <span class="number">4.</span>,  <span class="number">6.</span>, <span class="number">10.</span>])</span><br><span class="line">x*y:</span><br><span class="line"> tensor([ <span class="number">2.</span>,  <span class="number">4.</span>,  <span class="number">8.</span>, <span class="number">16.</span>])</span><br><span class="line">x**y:</span><br><span class="line"> tensor([ <span class="number">1.</span>,  <span class="number">4.</span>, <span class="number">16.</span>, <span class="number">64.</span>])</span><br><span class="line">e^x:</span><br><span class="line"> tensor([<span class="number">2.7183e+00</span>, <span class="number">7.3891e+00</span>, <span class="number">5.4598e+01</span>, <span class="number">2.9810e+03</span>])</span><br></pre></td></tr></table></figure><h4 id="逻辑运算符构建二元张量"><a href="#逻辑运算符构建二元张量" class="headerlink" title="逻辑运算符构建二元张量"></a>逻辑运算符构建二元张量</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#通过逻辑运算符构建二元张量。 </span></span><br><span class="line"><span class="comment">#以X == Y为例： </span></span><br><span class="line"><span class="comment">#对于每个位置，如果X和Y在该位置相等，则新张量中相应项的值为1。 </span></span><br><span class="line"><span class="comment">#这意味着逻辑语句X == Y在该位置处为真，否则该位置为0。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#例子</span></span><br><span class="line">x = torch.arange(<span class="number">12</span>, dtype=torch.float32).reshape((<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">y = torch.tensor([[<span class="number">2.0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"><span class="built_in">print</span>(x == y)</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">tensor([[ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>],</span><br><span class="line">        [ <span class="number">4.</span>,  <span class="number">5.</span>,  <span class="number">6.</span>,  <span class="number">7.</span>],</span><br><span class="line">        [ <span class="number">8.</span>,  <span class="number">9.</span>, <span class="number">10.</span>, <span class="number">11.</span>]])</span><br><span class="line">tensor([[<span class="number">2.</span>, <span class="number">1.</span>, <span class="number">4.</span>, <span class="number">3.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>, <span class="number">4.</span>],</span><br><span class="line">        [<span class="number">4.</span>, <span class="number">3.</span>, <span class="number">2.</span>, <span class="number">1.</span>]])</span><br><span class="line">tensor([[<span class="literal">False</span>,  <span class="literal">True</span>, <span class="literal">False</span>,  <span class="literal">True</span>],</span><br><span class="line">        [<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>],</span><br><span class="line">        [<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>]])</span><br></pre></td></tr></table></figure><h4 id="对张量所有元素求和"><a href="#对张量所有元素求和" class="headerlink" title="对张量所有元素求和"></a>对张量所有元素求和</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#对张量中的所有元素进行求和，会产生一个单元素张量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#例子</span></span><br><span class="line">x = torch.arange(<span class="number">12</span>, dtype=torch.float32).reshape((<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="built_in">print</span>(x.<span class="built_in">sum</span>())</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">tensor([[ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>],</span><br><span class="line">        [ <span class="number">4.</span>,  <span class="number">5.</span>,  <span class="number">6.</span>,  <span class="number">7.</span>],</span><br><span class="line">        [ <span class="number">8.</span>,  <span class="number">9.</span>, <span class="number">10.</span>, <span class="number">11.</span>]])</span><br><span class="line">tensor(<span class="number">66.</span>)</span><br></pre></td></tr></table></figure><h3 id="在不同形状的两个张量上执行按元素操作（广播机制）"><a href="#在不同形状的两个张量上执行按元素操作（广播机制）" class="headerlink" title="在不同形状的两个张量上执行按元素操作（广播机制）"></a>在不同形状的两个张量上执行按元素操作（广播机制）</h3><p><strong>广播机制工作方式如下：</strong></p><ol><li><strong>通过适当复制元素来扩展一个或两个数组，以便在转换之后，两个张量具有相同的形状；</strong></li><li><strong>对生成的数组执行按元素操作。</strong></li></ol><h3 id="torch-numel-1"><a href="#torch-numel-1" class="headerlink" title="torch.numel"></a>torch.numel</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在大多数情况下，沿着数组中长度为1的轴进行广播</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#例子</span></span><br><span class="line">a = torch.arange(<span class="number">3</span>).reshape((<span class="number">3</span>, <span class="number">1</span>))</span><br><span class="line">b = torch.arange(<span class="number">2</span>).reshape((<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(a + b)</span><br><span class="line"></span><br><span class="line"><span class="comment">#由于a和b分别是3*1和1*2矩阵，如果让它们相加，它们的形状不匹配。 </span></span><br><span class="line"><span class="comment">#故将两个矩阵广播为一个更大的矩阵</span></span><br><span class="line"><span class="comment">#矩阵a将复制列， 矩阵b将复制行，然后再按元素相加</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">tensor([[<span class="number">0</span>],</span><br><span class="line">        [<span class="number">1</span>],</span><br><span class="line">        [<span class="number">2</span>]])</span><br><span class="line">tensor([[<span class="number">0</span>, <span class="number">1</span>]])</span><br><span class="line">tensor([[<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">        [<span class="number">2</span>, <span class="number">3</span>]])</span><br></pre></td></tr></table></figure><h2 id="索引和切片"><a href="#索引和切片" class="headerlink" title="索引和切片"></a>索引和切片</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#像在任何其他Python数组中一样，张量中的元素可以通过索引访问。 </span></span><br><span class="line"><span class="comment">#与任何Python数组一样：第一个元素的索引是0，最后一个元素索引是-1； </span></span><br><span class="line"><span class="comment">#可以指定范围以包含第一个元素和最后一个之前的元素。</span></span><br><span class="line"><span class="comment">#可以用[-1]选择最后一个元素，可以用[1:3]选择第二个和第三个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#例子</span></span><br><span class="line">x = torch.tensor([[<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line"><span class="built_in">print</span>(x[-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(x[<span class="number">1</span>:<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">tensor([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br><span class="line">tensor([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">        [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#除读取外，还可以通过指定索引来将元素写入矩阵。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#例子</span></span><br><span class="line">x = torch.tensor([[<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line">x[<span class="number">1</span>, <span class="number">2</span>] = <span class="number">6</span></span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">tensor([[<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>],</span><br><span class="line">        [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#如果我们想为多个元素赋值相同的值，我们只需要索引所有元素，然后为它们赋值。 </span></span><br><span class="line"><span class="comment">#例如，[0:2, :]访问第1行和第2行，其中“:”代表沿轴1（列）的所有元素。</span></span><br><span class="line"><span class="comment">#虽然我们讨论的是矩阵的索引，但这也适用于向量和超过2个维度的张量。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#例子</span></span><br><span class="line">x = torch.tensor([[<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line">x[<span class="number">0</span>:<span class="number">2</span>, :] = <span class="number">12</span></span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">tensor([[<span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>],</span><br><span class="line">        [<span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>],</span><br><span class="line">        [ <span class="number">4</span>,  <span class="number">3</span>,  <span class="number">2</span>,  <span class="number">1</span>]])</span><br></pre></td></tr></table></figure><h3 id="节省内存"><a href="#节省内存" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#运行一些操作可能会导致为新结果分配内存。 </span></span><br><span class="line"><span class="comment">#例如，如果我们用x = x + y，我们将取消引用x指向的张量，而是指向新分配的内存处的张量。</span></span><br><span class="line"><span class="comment">#在下面的例子中，我们用Python的id()函数演示了这一点， 它给我们提供了内存中引用对象的确切地址。 运行x = x + y后，我们会发现id(x)指向另一个位置。 这是因为Python首先计算x + y，为结果分配新的内存，然后使x指向内存中的这个新位置。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##这可能是不可取的，原因有两个：</span></span><br><span class="line"><span class="comment">###首先，我们不想总是不必要地分配内存。在机器学习中，我们可能有数百兆的参数，并且在一秒内多次更新所有参数。通常情况下，我们希望原地执行这些更新；</span></span><br><span class="line"><span class="comment">###如果我们不原地更新，其他引用仍然会指向旧的内存位置，这样我们的某些代码可能会无意中引用旧的参数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##要执行原地操作，我们可以使用切片表示法将操作的结果分配给先前分配的数组，例如x[:] = &lt;expression&gt;。 为了说明这一点，我们首先创建一个新的矩阵z，其形状与另一个z相同， 使用zeros_like来分配一个全0的块。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果在后续计算中没有重复使用X， 我们也可以使用x[:] = x + y或x += y来减少操作的内存开销。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#例子</span></span><br><span class="line">x = torch.tensor([[<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line">y = torch.tensor([[<span class="number">2.0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line">before = <span class="built_in">id</span>(x)</span><br><span class="line">x = x + y</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(x) == before)</span><br><span class="line"></span><br><span class="line">z = torch.zeros_like(x)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;id(z):&quot;</span>, <span class="built_in">id</span>(z))</span><br><span class="line">z[:] = x + y</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;id(z):&quot;</span>, <span class="built_in">id</span>(z))</span><br><span class="line"></span><br><span class="line">before = <span class="built_in">id</span>(x)</span><br><span class="line">x[:] = x + y</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(x) == before)</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="built_in">id</span>(z): <span class="number">1590385395328</span></span><br><span class="line"><span class="built_in">id</span>(z): <span class="number">1590385395328</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h3 id="节省内存-1"><a href="#节省内存-1" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-2"><a href="#节省内存-2" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-3"><a href="#节省内存-3" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-4"><a href="#节省内存-4" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-5"><a href="#节省内存-5" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-6"><a href="#节省内存-6" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-7"><a href="#节省内存-7" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-8"><a href="#节省内存-8" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-9"><a href="#节省内存-9" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-10"><a href="#节省内存-10" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-11"><a href="#节省内存-11" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-12"><a href="#节省内存-12" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-13"><a href="#节省内存-13" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-14"><a href="#节省内存-14" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-15"><a href="#节省内存-15" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-16"><a href="#节省内存-16" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-17"><a href="#节省内存-17" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-18"><a href="#节省内存-18" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-19"><a href="#节省内存-19" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-20"><a href="#节省内存-20" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-21"><a href="#节省内存-21" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-22"><a href="#节省内存-22" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-23"><a href="#节省内存-23" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-24"><a href="#节省内存-24" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-25"><a href="#节省内存-25" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-26"><a href="#节省内存-26" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-27"><a href="#节省内存-27" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-28"><a href="#节省内存-28" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-29"><a href="#节省内存-29" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-30"><a href="#节省内存-30" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-31"><a href="#节省内存-31" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-32"><a href="#节省内存-32" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-33"><a href="#节省内存-33" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-34"><a href="#节省内存-34" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-35"><a href="#节省内存-35" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-36"><a href="#节省内存-36" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-37"><a href="#节省内存-37" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-38"><a href="#节省内存-38" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-39"><a href="#节省内存-39" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-40"><a href="#节省内存-40" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-41"><a href="#节省内存-41" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-42"><a href="#节省内存-42" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-43"><a href="#节省内存-43" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-44"><a href="#节省内存-44" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-45"><a href="#节省内存-45" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-46"><a href="#节省内存-46" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-47"><a href="#节省内存-47" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-48"><a href="#节省内存-48" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-49"><a href="#节省内存-49" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-50"><a href="#节省内存-50" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-51"><a href="#节省内存-51" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-52"><a href="#节省内存-52" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-53"><a href="#节省内存-53" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-54"><a href="#节省内存-54" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-55"><a href="#节省内存-55" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-56"><a href="#节省内存-56" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-57"><a href="#节省内存-57" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-58"><a href="#节省内存-58" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-59"><a href="#节省内存-59" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-60"><a href="#节省内存-60" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-61"><a href="#节省内存-61" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-62"><a href="#节省内存-62" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-63"><a href="#节省内存-63" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-64"><a href="#节省内存-64" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-65"><a href="#节省内存-65" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-66"><a href="#节省内存-66" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-67"><a href="#节省内存-67" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构算法总结-自用</title>
      <link href="/FRank675.github.io/posts/36da8636de8d/"/>
      <url>/FRank675.github.io/posts/36da8636de8d/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="数据结构算法整理"><a href="#数据结构算法整理" class="headerlink" title="数据结构算法整理"></a>数据结构算法整理</h1><h2 id="By-舜桀BB"><a href="#By-舜桀BB" class="headerlink" title="By 舜桀BB"></a><strong>By 舜桀BB</strong></h2><h2 id="循环双链表的存储结构"><a href="#循环双链表的存储结构" class="headerlink" title="循环双链表的存储结构"></a>循环双链表的存储结构</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>,*<span class="title">next</span>;</span></span><br><span class="line">&#125;DNode,*DLinklist;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化空的循环双链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitDLinkList</span><span class="params">(DLinklist &amp;L)</span>&#123;</span><br><span class="line">    L = (DNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));     <span class="comment">//分配一个头结点</span></span><br><span class="line">    <span class="keyword">if</span>(L==<span class="literal">NULL</span>)     <span class="comment">//内存不足，分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;prior = L;    <span class="comment">//头结点的prior指向头结点</span></span><br><span class="line">    L-&gt;next = L;     <span class="comment">//头结点的next指向头结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断循环双链表是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Empty</span><span class="params">(DLinklist L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next==L)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断结点p是否为循环单链表的表尾结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isTail</span><span class="params">(DLinklist L, DNode *p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next==L)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在p结点之后插入s结点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertNextDNode</span><span class="params">(DNode *p, DNode *s)</span>&#123;</span><br><span class="line">    s-&gt;next=p-&gt;next;  <span class="comment">//s的下一个结点为当前p的下一个结点，即把s插到p后面</span></span><br><span class="line">    p-&gt;next-&gt;prior=s; <span class="comment">//将第三个结点的头接到s</span></span><br><span class="line">    s-&gt;prior=p;       <span class="comment">//将s的头接到p</span></span><br><span class="line">    p-&gt;next=s;        <span class="comment">//将p的尾接到s</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在带头结点的双向循环链表L中第i个位置之前插入元素e</span></span><br><span class="line"><span class="comment">//i的合法值为1=&lt;i=&lt;表长+1</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InsertBeforeI</span><span class="params">(DLinklist &amp;L, <span class="type">int</span> i,Elemtype e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(p=GetElem(L,i))) <span class="comment">//GetElem(L,i):获取表中第i个位置的元素的值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//插入位置不合法</span></span><br><span class="line">    <span class="keyword">if</span>(!(s=(DLinklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode))))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//内存空间不足，无法创建新结点</span></span><br><span class="line">    s-&gt;data=e;</span><br><span class="line">    s-&gt;prior=p-&gt;prior;</span><br><span class="line">    p-&gt;prior-&gt;next=s;</span><br><span class="line">    s-&gt;next=p;</span><br><span class="line">    p-&gt;prior=s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除p的后继节点q</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">deleteNextDNode</span><span class="params">(DNode *p, DNode *q)</span>&#123;</span><br><span class="line">    p-&gt;next=q-&gt;next;  <span class="comment">//将p的尾接到q的下一个结点</span></span><br><span class="line">    q-&gt;next-&gt;prior=p; <span class="comment">//将q的下一个结点的头接到p</span></span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除带头结点的双向循环链表L中第i个元素</span></span><br><span class="line"><span class="comment">//i的合法值为1=&lt;i=&lt;表长</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeleteElemI</span><span class="params">(DLinklist &amp;L, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(p=GetElem(L,i)))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    p-&gt;prior-&gt;next=p-&gt;next;</span><br><span class="line">    p-&gt;next-&gt;prior=p-&gt;prior;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栈、队列和数组"><a href="#栈、队列和数组" class="headerlink" title="栈、队列和数组"></a>栈、队列和数组</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//队列是一种操作受限的线性表，只允许在表的一端插入，在表的另一端删除（先进先出）</span></span><br><span class="line"><span class="comment">//队列常见基本操作</span></span><br><span class="line"><span class="comment">//InitQueue(&amp;Q):初始化队列，构造一个空队列Q</span></span><br><span class="line"><span class="comment">//QueueEmpty(Q):判队列空，若队列为空则返回true，否则返回false</span></span><br><span class="line"><span class="comment">//EnQueue(&amp;Q,x):入队，若队列Q未满，将x加入，使其成为新的队尾</span></span><br><span class="line"><span class="comment">//DeQueue(&amp;Q,&amp;x):出队，若队列Q非空，删除队头元素，并用x返回</span></span><br><span class="line"><span class="comment">//GetHead(Q,&amp;x):读队头元素，若队列Q非空，则将队头元素赋值给x</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//队列的顺序存储</span></span><br><span class="line"><span class="comment">//分配一块连续的存储单元存放队列中的元素，并附设两个指针：队头指针front指向队头元素，队尾指针rear指向队尾元素的下一个位置</span></span><br><span class="line"><span class="comment">//循环队列：把存储队列元素的表从逻辑上视为一个环</span></span><br><span class="line"><span class="comment">//当队首指针Q.front=MaxSize-1后，再前进一个位置就自动到0，通过除数取余运算%实现</span></span><br><span class="line"><span class="comment">//初始时：Q.front=Q.rear=0</span></span><br><span class="line"><span class="comment">//队首指针进1：Q.front=(Q.front+1)%MaxSize</span></span><br><span class="line"><span class="comment">//队尾指针进1：Q.rear=(Q.rear+1)%MaxSize</span></span><br><span class="line"><span class="comment">//队列长度：(Q.rear+MaxSize-Q.front)%MaxSize</span></span><br><span class="line"><span class="comment">//出队入队时：指针都按顺时针方向进1</span></span><br><span class="line"><span class="comment">//判断队空队满：牺牲一个单元来区分队空队满，入队时少用一个队列单元</span></span><br><span class="line"><span class="comment">//队头指针在队尾指针的下一位置为队满的标志</span></span><br><span class="line"><span class="comment">//队满条件：(Q.rear+1)%MaxSize==Q.front</span></span><br><span class="line"><span class="comment">//队空条件：Q.front==Q.rear</span></span><br><span class="line"><span class="comment">//队列中元素的个数：(Q.rear+MaxSize-Q.front)%MaxSize</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//循环队列的操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50      <span class="comment">//定义队列中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];   <span class="comment">//存放队列元素</span></span><br><span class="line">    <span class="type">int</span> front,rear;           <span class="comment">//队头指针和队尾指针</span></span><br><span class="line">&#125;SqQueue;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(SqQueue &amp;Q)</span>&#123;</span><br><span class="line">    Q.rear=Q.front=<span class="number">0</span>;       <span class="comment">//初始化队首队尾指/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判队空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(SqQueue Q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear=Q.front) <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">//队空条件</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">EnQueue</span><span class="params">(SqQueue &amp;Q,ElemType x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MaxSize==Q.front) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//队满则报错</span></span><br><span class="line">    Q.data[Q.rear]=x;</span><br><span class="line">    Q.rear=(Q.rear+<span class="number">1</span>)%MaxSize;     <span class="comment">//队尾指针加一取模</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(SqQueue &amp;Q,ElemType &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear==Q.front) <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//队空则报错</span></span><br><span class="line">    x=Q.data[Q.front];</span><br><span class="line">    Q.front=(Q.front+<span class="number">1</span>)%MaxSize;   <span class="comment">//队头指针加一取模</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h2 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h2><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//树中的结点数=所有结点的度数之和+1=分支数+1</span></span><br><span class="line"><span class="comment">//n个结点的树中由n-1条边</span></span><br><span class="line"><span class="comment">//度为m的树中第i层至多有m^(i-1)个结点</span></span><br><span class="line"><span class="comment">//高度为h的m叉树至多有(m^h-1)/(m-1)个结点</span></span><br><span class="line"><span class="comment">//具有n个结点的m叉树的最小高度为⌈logm(n(m-1)+1)⌉ </span></span><br></pre></td></tr></table></figure><h3 id="特殊的二叉树"><a href="#特殊的二叉树" class="headerlink" title="特殊的二叉树"></a>特殊的二叉树</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//满二叉树</span></span><br><span class="line"><span class="comment">//高度为h，含有2^h-1个结点的二叉树</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//完全二叉树</span></span><br><span class="line"><span class="comment">//高度为h、有n个结点的二叉树，且每个结点都与高度为h的满二叉树中编号为1-n的结点一一对应。</span></span><br><span class="line"><span class="comment">//对于完全二叉树，若i&lt;=⌊n/2⌋,则结点i为分支结点，否则为叶节点</span></span><br><span class="line"><span class="comment">//若有度为1的结点，则只有可能有一个，且该结点有左孩子无右孩子</span></span><br><span class="line"><span class="comment">//若n为奇数，则每个分支结点都有左右孩子，</span></span><br><span class="line"><span class="comment">//若n为偶数，则编号最大的分支结点（编号为n/2）只有左孩子，无右孩子，其余分支结点左右孩子都有</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉排序树</span></span><br><span class="line"><span class="comment">//左子树上所有结点的关键字均小于根结点的关键字；右子树上所有结点的关键字均大于根结点的关键字</span></span><br><span class="line"><span class="comment">//左子树和右子树又各是一棵二叉排序树</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//平衡二叉树</span></span><br><span class="line"><span class="comment">//树上任意一个结点的左子树和右子树的深度之差不超过1</span></span><br></pre></td></tr></table></figure><h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉树</span></span><br><span class="line"><span class="comment">//非空二叉树上的叶结点数等于度为2的结点数加1，即n0=n2+1</span></span><br><span class="line"><span class="comment">//非空二叉树上第k层上至多2^(k-1)个结点</span></span><br><span class="line"><span class="comment">//高度为h的二叉树至多有2^h-1个结点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//完全二叉树</span></span><br><span class="line"><span class="comment">//具有n个结点的完全二叉树的高度h为⌈log2(n+1)⌉或⌊log2n⌋+1</span></span><br><span class="line"><span class="comment">//对于完全二叉树，可以由结点数推出度为0、1和2的结点个数n0、n1、n2（突破口：完全二叉树最多只有会有一个度为1的结点；n0=n2+1，所以n0+n2为奇数，若结点数为偶数，则n1=1；若结点数为奇数，则n1=0）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树的链式存储结构</span></span><br><span class="line"><span class="comment">// |lchid|data|rchild|</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span>&#123;</span></span><br><span class="line">    ElemType data;                    <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span>    <span class="comment">//左右孩子指针</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"><span class="comment">//在含有n个结点的二叉链表中，含有n+1个空链域</span></span><br></pre></td></tr></table></figure><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉树的遍历是指按某条搜索路径访问树中的每个结点，使得每个结点均被访问一次，而且仅被访问一次</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//三种遍历算法中，遍历递归左右子树的顺序都是固定的，只是访问根结点的顺序不同。</span></span><br><span class="line"><span class="comment">//不管采用哪种遍历算法，每个结点都访问一次且仅访问一次，所以时间复杂度为O(n)</span></span><br><span class="line"><span class="comment">//在递归遍历中，递归工作栈的栈深恰好为树的深度，所以在最坏情况下，二叉树是由n个结点且深度为n的单支树，遍历算法的空间复杂度为O(n)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTree)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        visit(T);             <span class="comment">//访问根节点</span></span><br><span class="line">        PreOrder(T-&gt;lchild);  <span class="comment">//递归遍历左子树</span></span><br><span class="line">        PreOrder(T-&gt;rchild);  <span class="comment">//递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTree)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        PreOrder(T-&gt;lchild);  <span class="comment">//递归遍历左子树</span></span><br><span class="line">        visit(T);             <span class="comment">//访问根节点</span></span><br><span class="line">        PreOrder(T-&gt;rchild);  <span class="comment">//递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTree)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        PreOrder(T-&gt;lchild);  <span class="comment">//递归遍历左子树</span></span><br><span class="line">        PreOrder(T-&gt;rchild);  <span class="comment">//递归遍历右子树</span></span><br><span class="line">        visit(T);             <span class="comment">//访问根节点        </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历非递归算法</span></span><br><span class="line"><span class="comment">//1.沿着根的左孩子，依次入栈，直到左孩子为空，说明已找到可以输出的结点</span></span><br><span class="line"><span class="comment">//2.栈顶元素出栈并访问：若其右孩子为空，继续执行2，若其右孩子不为空，将右子树执行1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrder2</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    InitStack(S);           <span class="comment">//初始化栈S</span></span><br><span class="line">    BiTree p = T;           <span class="comment">//p是遍历指针</span></span><br><span class="line">    <span class="keyword">while</span>(p||!IsEmpty(S))&#123;  <span class="comment">//栈不为空或p不空时循环</span></span><br><span class="line">        <span class="keyword">if</span>(p)&#123;              <span class="comment">//一路向左</span></span><br><span class="line">            Push(S,p);      <span class="comment">//当前结点入栈</span></span><br><span class="line">            p=p-&gt;lchild;    <span class="comment">//左孩子不空，一直向左走</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;               <span class="comment">//出栈，并转向出栈结点的右子树</span></span><br><span class="line">            Pop(S,p);       <span class="comment">//栈顶元素出栈</span></span><br><span class="line">            visit(p);       <span class="comment">//访问出栈结点</span></span><br><span class="line">            p=p-&gt;rchild;    <span class="comment">//向右子树走，p赋值为当前结点的右孩子</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序遍历非递归算法</span></span><br><span class="line"><span class="comment">//1.访问该结点，沿着根的左孩子，依次入栈，直到左孩子为空，说明已找到可以输出的结点</span></span><br><span class="line"><span class="comment">//2.栈顶元素出栈：若其右孩子为空，继续执行2，若其右孩子不为空，将右子树执行1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder2</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    InitStack(S);           <span class="comment">//初始化栈S</span></span><br><span class="line">    BiTree p = T;           <span class="comment">//p是遍历指针</span></span><br><span class="line">    <span class="keyword">while</span>(p||!IsEmpty(S))&#123;  <span class="comment">//栈不为空或p不空时循环</span></span><br><span class="line">        <span class="keyword">if</span>(p)&#123;              <span class="comment">//一路向左</span></span><br><span class="line">            visit(p);       <span class="comment">//访问结点</span></span><br><span class="line">            Push(S,p);      <span class="comment">//当前结点入栈</span></span><br><span class="line">            p=p-&gt;lchild;    <span class="comment">//左孩子不空，一直向左走</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;               <span class="comment">//出栈，并转向出栈结点的右子树</span></span><br><span class="line">            Pop(S,p);       <span class="comment">//栈顶元素出栈</span></span><br><span class="line">            p=p-&gt;rchild;    <span class="comment">//向右子树走，p赋值为当前结点的右孩子</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树的层次遍历算法</span></span><br><span class="line"><span class="comment">//进行层次遍历需要借助一个队列。</span></span><br><span class="line"><span class="comment">//首先将二叉树根结点入队，然后出队，访问出队结点</span></span><br><span class="line"><span class="comment">//若它有左子树，则将左子树根结点入队；若它有右子树，则将右子树根结点入队。</span></span><br><span class="line"><span class="comment">//完成入队后出队，访问出队结点</span></span><br><span class="line"><span class="comment">//如此反复，直到队列为空</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LevelOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    InitQueue(Q);                  <span class="comment">//初始化辅助队列</span></span><br><span class="line">    BiTree p;                      </span><br><span class="line">    EnQueue(Q,T);                  <span class="comment">//将根结点入队</span></span><br><span class="line">    <span class="keyword">while</span>(!isEmpty(Q))&#123;            <span class="comment">//队列不为空则循环</span></span><br><span class="line">        DeQueue(Q,p);              <span class="comment">//队头结点出队</span></span><br><span class="line">        visit(p);                  <span class="comment">//访问队头结点</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild!=<span class="literal">NULL</span>)</span><br><span class="line">            EnQueue(Q,p-&gt;lchild);  <span class="comment">//左子树不为空，则左子树根结点入队</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild!=<span class="literal">NULL</span>)</span><br><span class="line">            EnQueue(Q,p-&gt;rchild);  <span class="comment">//右子树不为空，则右子树根结点入队</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由遍历构造二叉树</span></span><br><span class="line"><span class="comment">//先序+中序 后序+中序 层序+中序</span></span><br></pre></td></tr></table></figure><h3 id="二叉树常见应用"><a href="#二叉树常见应用" class="headerlink" title="二叉树常见应用"></a>二叉树常见应用</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//求树的深度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">treeDepth</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> l = treeDepth(T-&gt;lchild);</span><br><span class="line">        <span class="type">int</span> r = treeDepth(T-&gt;rchild);</span><br><span class="line">        <span class="comment">//树的深度=Max(左子树深度，右子树深度)+1</span></span><br><span class="line">        <span class="keyword">return</span> l&gt;r ? l+<span class="number">1</span> : r+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//求二叉树带权路径长度</span></span><br><span class="line"><span class="comment">//二叉树带权路径长度为每个叶结点的深度与权值之积的总和，可以使用先序遍历或者层次遍历解决问题</span></span><br><span class="line"><span class="comment">//先序遍历思想：</span></span><br><span class="line"><span class="comment">//用一个static变量记录wpl，把每个结点的深度作为递归函数的一个参数传递</span></span><br><span class="line"><span class="comment">//若该结点为叶结点，则变量wpl加上该结点的深度与权值之和</span></span><br><span class="line"><span class="comment">//若该结点为非叶结点，则左子树不为空，对左子树调用递归算法，右子树不为空，对右子树调用递归算法，深度参数均为本结点的深度参数加1</span></span><br><span class="line"><span class="comment">//最后返回计算出的wpl即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树结点的数据结构定义如下</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">WPL</span><span class="params">(BiTree root)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> wpl_PreOrder(root,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">wpl_PreOrder</span><span class="params">(BiTree root,<span class="type">int</span> deep)</span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> wpl=<span class="number">0</span>;      <span class="comment">//定义变量存储wpl</span></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;lchild==<span class="literal">NULL</span>&amp;&amp;root-&gt;rchild==<span class="literal">NULL</span>)    <span class="comment">//若为叶结点，则累积wpl</span></span><br><span class="line">        <span class="keyword">return</span> wpl+=deep*root-&gt;weight;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;lchild!=<span class="literal">NULL</span>)                        <span class="comment">//若左子树不为空，则对左子树递归遍历</span></span><br><span class="line">        wpl_PreOrder(root-&gt;lchild,deep+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;rchild!=<span class="literal">NULL</span>)                        <span class="comment">//若右子树不为空，则对右子树递归遍历</span></span><br><span class="line">        wpl_PreOrder(root-&gt;rchild,deep+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> wpl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判定给定二叉树是否为完全二叉树</span></span><br><span class="line"><span class="comment">//根据完全二叉树定义，具有n个结点的完全二叉树与满二叉树中编号从1-n的结点一一对应</span></span><br><span class="line"><span class="comment">//算法思想：采用层次遍历算法，将所有结点加入队列（包括空结点）。遇到空结点时，查看其后是否有非空结点。若有，则二叉树不是完全二叉树。</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsComplete</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    InitQueue(Q);</span><br><span class="line">    <span class="keyword">if</span>(!T)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;      <span class="comment">//空树为满二叉树</span></span><br><span class="line">    EnQueue(Q,T);</span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))&#123;</span><br><span class="line">        DeQueue(Q,p);</span><br><span class="line">        <span class="keyword">if</span>(p)&#123;                       <span class="comment">//p不为空结点</span></span><br><span class="line">            EnQueue(Q,p-&gt;lchild);    <span class="comment">//将结点左子树加入队列（可能是空结点）</span></span><br><span class="line">            EnQueue(Q,p-&gt;rchild);    <span class="comment">//将结点右子树加入队列（可能是空结点）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>                         <span class="comment">//结点为空结点</span></span><br><span class="line">            <span class="keyword">while</span>(!IsEmpty(Q))&#123;      <span class="comment">//遇到空结点，就将队列中的元素全部输出，看是否有非空结点</span></span><br><span class="line">                DeQueue(Q,p);</span><br><span class="line">                <span class="keyword">if</span>(p)                <span class="comment">//有非空结点，说明不是完全二叉树</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//采用递归算法实现交换二叉树左右子树</span></span><br><span class="line"><span class="comment">//首先交换b结点的左孩子的左右子树，然后交换b结点的右孩子的左右子树，最后交换b结点的左右子树，当结点为空时递归结束（后序遍历的思想）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(BiTree b)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b)&#123;</span><br><span class="line">        swap(b-&gt;lchild);     <span class="comment">//递归交换左子树</span></span><br><span class="line">        swap(b-&gt;rchild);     <span class="comment">//递归交换右子树</span></span><br><span class="line">        temp=b-&gt;lchild;      <span class="comment">//交换左右孩子结点</span></span><br><span class="line">        b-&gt;lchild=b-&gt;rchild;</span><br><span class="line">        b-&gt;rchild=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//孩子兄弟表示法，求叶子节点个数之和</span></span><br><span class="line"><span class="comment">//当森林以孩子兄弟表示法存储时，若结点没有孩子（fch=NULL），则它必是叶子结点。</span></span><br><span class="line"><span class="comment">//总的叶子结点个数是孩子子树(fch)上的叶子数和兄弟子树(nsib)上的叶结点数之和</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    ElemType data;    <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">fch</span>,*<span class="title">nsib</span>;</span>    <span class="comment">//孩子与兄弟域 </span></span><br><span class="line">&#125;*Tree;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Leaves</span><span class="params">(Tree t)</span>&#123;                 <span class="comment">//计算以孩子兄弟表示法存储的森林的叶子数</span></span><br><span class="line">    <span class="keyword">if</span>(t==<span class="literal">NULL</span>)                     <span class="comment">//树空返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">if</span>(t-&gt;fch==<span class="literal">NULL</span>)                <span class="comment">//若结点无孩子，则该结点必是叶子</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+Leaves(t-&gt;nsib);   <span class="comment">//返回叶结点和其兄弟子树中的叶结点数</span></span><br><span class="line">    <span class="keyword">else</span>                            <span class="comment">//若结点有孩子，则返回孩子子树和兄弟子树中叶子结点个数</span></span><br><span class="line">        <span class="keyword">return</span> Leaves(t-&gt;fch)+Leaves(t-&gt;nsib);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传统的二叉链表存储仅能体现一种父子关系，不能直接得到结点在遍历中的前驱或后继</span></span><br><span class="line"><span class="comment">//在含n个结点的二叉树中，有n+1个空指针，可以利用这些空指针存放指向其前驱或者后驱的指针</span></span><br><span class="line"><span class="comment">//引入线索二叉树就是为了加快查找结点前驱和后继的速度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//规定：若无左子树，令lchild指向其前驱结点；若无右子树，令rchild指向其后继结点</span></span><br><span class="line"><span class="comment">//线索二叉树的结点结构：|lchild|ltag|data|rtag|rchild|</span></span><br><span class="line"><span class="comment">//ltag=0,lchild域指示结点的左孩子；ltag=1,lchild域指示结点的前驱</span></span><br><span class="line"><span class="comment">//rtag=0,rchild域指示结点的右孩子；rtag=1,rchild域指示结点的后继</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线索化的实质就是遍历一次二叉树</span></span><br><span class="line"><span class="comment">//pre指向刚刚访问过的结点，p指向正在访问的结点，即pre指向p的前驱</span></span><br><span class="line"><span class="comment">//中序遍历过程中，检查p的左指针是否为空，若为空则将它指向pre；检查pre的右指针是否为空，若为空则将它指向p</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线索二叉树结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">    ElemType data;                      <span class="comment">//数据元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span>  <span class="comment">//左、右孩子指针</span></span><br><span class="line">    <span class="type">int</span> ltag,rtag;                      <span class="comment">//左、右线索标志</span></span><br><span class="line">&#125;ThreadNode,*ThreadTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量pre，指向当前访问结点的前驱</span></span><br><span class="line">ThreadNode *pre=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序线索化二叉树T</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreatInThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">    pre=<span class="literal">NULL</span>;            <span class="comment">//pre初始为NULL</span></span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;         <span class="comment">//非空二叉树才能线索化</span></span><br><span class="line">        InThread(T);     <span class="comment">//中序线索化二叉树</span></span><br><span class="line">        <span class="keyword">if</span>(pre-&gt;rchild==<span class="literal">NULL</span>)</span><br><span class="line">            pre-&gt;rtag=<span class="number">1</span>;  <span class="comment">//处理遍历的最后一个结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历二叉树，一边遍历一边线索化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        InThread(T-&gt;lchild);   <span class="comment">//中序遍历左子树，线索化左子树</span></span><br><span class="line">        visit(T);              <span class="comment">//访问根结点</span></span><br><span class="line">        InThread(T-&gt;rchild);   <span class="comment">//中序遍历右子树，线索化右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(ThreadNode *q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;lchild==<span class="literal">NULL</span>)&#123; <span class="comment">//左子树为空，建立前驱线索</span></span><br><span class="line">        q-&gt;lchild=pre;</span><br><span class="line">        q-&gt;ltag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre!=<span class="literal">NULL</span>&amp;&amp;pre-&gt;rchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        pre-&gt;rchild=q;   <span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">        pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre=q;               <span class="comment">//标记当前结点成为刚刚访问过的结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//在线索二叉树中找前驱后继</span></span><br><span class="line"><span class="comment">//若ltag/rtag=0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//中序线索二叉树（左根右）</span></span><br><span class="line"><span class="comment">//后继：p的右子树最左下结点；</span></span><br><span class="line"><span class="comment">//前驱：p的左子树最右下结点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//先序线索二叉树（根左右）</span></span><br><span class="line"><span class="comment">//后继</span></span><br><span class="line"><span class="comment">//1.若p有左孩子，则先序后继为其左孩子</span></span><br><span class="line"><span class="comment">//2.若p没有左孩子，则先序后继为其右孩子</span></span><br><span class="line"><span class="comment">//前驱：</span></span><br><span class="line"><span class="comment">//1.若有父结点，且p为左孩子，则前驱为父结点</span></span><br><span class="line"><span class="comment">//2.若有父结点，且p为右孩子，其左兄弟为空，则前驱为父结点</span></span><br><span class="line"><span class="comment">//3.若有父结点，且p为右孩子，其左兄弟非空，则前驱为其左兄弟子树的最后一个被先序遍历的结点</span></span><br><span class="line"><span class="comment">//4.若p为根结点，则p没有先序前驱</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//后序线索二叉树（左右根）</span></span><br><span class="line"><span class="comment">//后继</span></span><br><span class="line"><span class="comment">//1.若p有父结点，且p为右孩子，则其后继为父结点</span></span><br><span class="line"><span class="comment">//2.若p有父结点，且p为左孩子，其右兄弟为空，则其后继为父结点</span></span><br><span class="line"><span class="comment">//3.若p有父结点，且p为左孩子，其右兄弟非空，则其后继为其右兄弟子树中第一个被后序遍历的结点</span></span><br><span class="line"><span class="comment">//4.若p为根结点，则p没有后序后继</span></span><br><span class="line"><span class="comment">//前驱</span></span><br><span class="line"><span class="comment">//1.若p有右孩子，则其前驱为右孩子</span></span><br><span class="line"><span class="comment">//2.若p没有右孩子，则其前驱为左孩子</span></span><br></pre></td></tr></table></figure><h3 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双亲表示法</span></span><br><span class="line"><span class="comment">//顺序存储结点数据，结点中保存父结点在数组中的下标</span></span><br><span class="line"><span class="comment">//利用了每个结点（根结点除外）只有唯一双亲的性质，找父结点很方便，但是求结点的孩子时则需要遍历整个结构</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//孩子表示法</span></span><br><span class="line"><span class="comment">//顺序存储结点数据，结点中保存孩子链表头指针（顺序存储+链式存储）</span></span><br><span class="line"><span class="comment">//寻找子女方便，但是寻找双亲需要遍历n个结点中孩子链表指针域所指向的n个孩子链表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//孩子兄弟表示法（二叉树表示法）</span></span><br><span class="line"><span class="comment">//用二叉链表存储树--左孩子右兄弟</span></span><br><span class="line"><span class="comment">//每个结点包括三部分：结点值，指向结点第一个孩子结点的指针，以及指向结点下一个兄弟结点的指针（沿此域可以找到结点的所有兄弟结点）</span></span><br><span class="line"><span class="comment">//方便实现树转换为二叉树，易于查找结点的孩子</span></span><br></pre></td></tr></table></figure><h3 id="树、森林和二叉树的相互转换"><a href="#树、森林和二叉树的相互转换" class="headerlink" title="树、森林和二叉树的相互转换"></a>树、森林和二叉树的相互转换</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//树转换为二叉树</span></span><br><span class="line"><span class="comment">//左孩子右兄弟</span></span><br><span class="line"><span class="comment">//由于根结点没有兄弟，所以对应二叉树没有右子树</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//森林转换为二叉树</span></span><br><span class="line"><span class="comment">//先将森林中的每棵树转换为二叉树（左孩子右兄弟），把第二棵树根视为第一棵树的右兄弟</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树转换为森林</span></span><br><span class="line"><span class="comment">//二叉树的根和其右子树为第一棵树的二叉树形式，将根的右链断开，以此类推直到最后只剩一棵没有右子树的二叉树为止，再将每棵二叉树转换为树，即得到森林</span></span><br></pre></td></tr></table></figure><h3 id="树和森林的遍历"><a href="#树和森林的遍历" class="headerlink" title="树和森林的遍历"></a>树和森林的遍历</h3><table><thead><tr><th align="center">树</th><th align="center">森林</th><th align="center">二叉树</th></tr></thead><tbody><tr><td align="center">先根遍历</td><td align="center">先序遍历</td><td align="center">先序遍历</td></tr><tr><td align="center"><u><strong>后根遍历</strong></u></td><td align="center">中序遍历</td><td align="center">中序遍历</td></tr></tbody></table><h3 id="哈夫曼树和哈夫曼编码"><a href="#哈夫曼树和哈夫曼编码" class="headerlink" title="哈夫曼树和哈夫曼编码"></a>哈夫曼树和哈夫曼编码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//树的带权路径长度(WPL)=树中所有叶子结点的带权路径长度之和</span></span><br><span class="line"><span class="comment">//哈夫曼树（最优二叉树）：在含有给定的n个带权叶结点的二叉树中，WPL最小的二叉树</span></span><br><span class="line"><span class="comment">//构造哈夫曼树：每次选两个根结点权值最小的树合并，并将二者权值之和作为新的根结点的权值</span></span><br><span class="line"><span class="comment">//哈夫曼树不唯一，但WPL必然都是最小值</span></span><br><span class="line"><span class="comment">//每个初始结点最终都成为叶结点，且权值越小的结点到根结点的路径长度越大</span></span><br><span class="line"><span class="comment">//构建过程中共新建了n-1个结点，哈夫曼树结点总数为2n-1</span></span><br><span class="line"><span class="comment">//哈夫曼树不存在度为1的结点（每次构造都选择两棵树作为新结点的孩子）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//哈夫曼编码</span></span><br><span class="line"><span class="comment">//将每个出现的字符当作一个独立结点，其权值为出现的频数，构造对应的哈夫曼树</span></span><br><span class="line"><span class="comment">//所有的字符结点都会出现在叶结点</span></span><br><span class="line"><span class="comment">//边标记0表示转向左孩子，边标记1表示转向右孩子</span></span><br></pre></td></tr></table></figure><h2 id="图算法"><a href="#图算法" class="headerlink" title="图算法"></a>图算法</h2><h3 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h3><h4 id="邻接矩阵法"><a href="#邻接矩阵法" class="headerlink" title="邻接矩阵法"></a>邻接矩阵法</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//图的邻接矩阵存储结构定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100               <span class="comment">//顶点数目的最大值</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VertexType;               <span class="comment">//顶点的数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> EdgeType;                  <span class="comment">//带权图中边上权值的数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    VertextType Vex[MaxVertexNum];     <span class="comment">//顶点表</span></span><br><span class="line">    EdgeType Edge[MaxVertexNum][MaxVertexNum];  <span class="comment">//邻接矩阵，边表</span></span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;                 <span class="comment">//图的当前顶点数和弧数</span></span><br><span class="line">&#125;MGraph;</span><br><span class="line"><span class="comment">//当邻接矩阵的元素仅表示相应边是否存在时，EdgeType可采用0和1的枚举类型</span></span><br><span class="line"><span class="comment">//无向图的邻接矩阵是对称矩阵，对规模特大的邻接矩阵可采用压缩存储</span></span><br><span class="line"><span class="comment">//邻接矩阵表示法的空间复杂度为O(n^2)，其中n为图的顶点数|V|</span></span><br><span class="line"><span class="comment">//对于无向图，邻接矩阵的第i行（或第i列）的非零元素的个数正好是顶点i的度TD(vi)</span></span><br><span class="line"><span class="comment">//对于有向图，邻接矩阵的第i行的非零元素的个数正好是顶点i的出度OD(vi)，第i列的非零元素个数正好是顶点i的入度ID(vi)</span></span><br><span class="line"><span class="comment">//邻接矩阵存储法容易确定任意两个顶点之间是否有边相连，但是确定多少条边必须按行、按列对各个元素进行检测，所花费时间代价很大</span></span><br><span class="line"><span class="comment">//稠密图适合邻接矩阵的存储表示</span></span><br></pre></td></tr></table></figure><h4 id="邻接表法"><a href="#邻接表法" class="headerlink" title="邻接表法"></a>邻接表法</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//邻接表结合了顺序存储和链式存储方法，减少了空间的浪费</span></span><br><span class="line"><span class="comment">//邻接表是指对每个顶点建立一个单链表，单链表中的结点表示依附于该顶点的边（对于有向图则是以该顶点为尾的弧），这个单链表称为该顶点的边表（对于有向图称为出边表）</span></span><br><span class="line"><span class="comment">//边表的头指针和顶点的数据信息采用顺序存储，称为顶点表</span></span><br><span class="line"><span class="comment">//邻接表中存在两种结点：顶点表结点和边表结点</span></span><br><span class="line"><span class="comment">//顶点表结点由顶点域(data)和指向第一条邻接表的指针(firstarc)构成</span></span><br><span class="line"><span class="comment">//边表结点由邻接点域(adjvex)和指向下一条邻接边的指针域(nextarc)构成</span></span><br><span class="line"><span class="comment">//图的邻接表存储结构定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100               <span class="comment">//顶点数目的最大值</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span>                <span class="comment">//边表结点</span></span><br><span class="line">    <span class="type">int</span> adjvex;                        <span class="comment">//该弧所指向的顶点位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">next</span>;</span>              <span class="comment">//指向下一条弧的指针</span></span><br><span class="line">    <span class="comment">//InfoType info;                   //网的边权值</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span>                  <span class="comment">//顶点表结点</span></span><br><span class="line">    VertextType data;                  <span class="comment">//顶点信息</span></span><br><span class="line">    ArcNode *first;                    <span class="comment">//指向第一条依附于该顶点的弧的指针</span></span><br><span class="line">&#125;VNode,AdjList[MaxVertexNum];</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    AdjList vertices;                  <span class="comment">//邻接表</span></span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;                 <span class="comment">//图的顶点数和弧数</span></span><br><span class="line">&#125;ALGraph;                              <span class="comment">//ALGraph是以邻接表存储的图类型</span></span><br><span class="line"><span class="comment">//对于无向图，邻接表所需存储空间为O(|V|+2|E|)</span></span><br><span class="line"><span class="comment">//对于有向图，邻接表所需存储空间为O(|V|+|E|)</span></span><br><span class="line"><span class="comment">//前者的倍数2是由于在无向图中，每条边在邻接表中出现了两次</span></span><br><span class="line"><span class="comment">//对于稀疏图，采用邻接表将大大节省存储空间</span></span><br><span class="line"><span class="comment">//在邻接表中很容易找到给定一个顶点的所有邻边，因为只需要读取邻接表，而在邻接矩阵中则需要扫描一行，花费的时间为O(n)。</span></span><br><span class="line"><span class="comment">//确定给定两个顶点是否存在边，在邻接矩阵中可以立刻查到，在邻接表中则需要在相应结点对应的边表中查找另一个结点，效率较低</span></span><br><span class="line"><span class="comment">//在有向图的邻接表表示中，求一个给定点的出度只需计算其邻接表中的结点个数；但求入度就要遍历全部的邻接表（可采用逆邻接表的存储方式加速求解入度）</span></span><br><span class="line"><span class="comment">//图的邻接表不唯一</span></span><br></pre></td></tr></table></figure><h3 id="图的基本操作"><a href="#图的基本操作" class="headerlink" title="图的基本操作"></a>图的基本操作</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Adjacent(G,x,y)          //判断图G是否存在边&lt;x,y&gt;</span></span><br><span class="line"><span class="comment">//Neighbors(G,X)           //列出图G中与结点x邻接的边</span></span><br><span class="line"><span class="comment">//InsertVertex(G.x)        //在图G中插入顶点x</span></span><br><span class="line"><span class="comment">//DeleteVertex(G,x)        //从图G中删除顶点x</span></span><br><span class="line"><span class="comment">//AddEdge(G,x,y)           //若无向边(x,y)或有向边&lt;x,y&gt;不存在，则向图G中添加该边</span></span><br><span class="line"><span class="comment">//RemoveEdge(G,x,y)        //若无向边(x,y)或有向边&lt;x,y&gt;存在，则从图G中删除该边</span></span><br><span class="line"><span class="comment">//FirstNeighbor(G,x)       //求图G中顶点x的第一个邻接点，若有则返回顶点号。若x没有邻接点或者图中不存在x则返回-1</span></span><br><span class="line"><span class="comment">//NextNeighbor(G,x,y)      //假设图G中顶点y是顶点x的一个邻接点，返回除y外顶点x的下一个邻接点的顶点号，若y是x的最后一个邻接点，则返回-1</span></span><br><span class="line"><span class="comment">//Get_edge_value(G,x,y)    //获取图G中边(x,y)或&lt;x,y&gt;对应的权值</span></span><br><span class="line"><span class="comment">//Set_edge_value(G,x,y,v)  //设置图G中边(x,y)或&lt;x,y&gt;对应的权值为v</span></span><br></pre></td></tr></table></figure><h3 id="广度优先搜索-BFS"><a href="#广度优先搜索-BFS" class="headerlink" title="广度优先搜索-BFS"></a>广度优先搜索-BFS</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> visited[MAX_VERTEX_NUM];   <span class="comment">//访问标记数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFSTraverse</span><span class="params">(Graph G)</span>&#123;      <span class="comment">//对图G进行广度优先遍历</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i)</span><br><span class="line">        visited[i]=FALSE;       <span class="comment">//访问标记数组初始化</span></span><br><span class="line">    InitQueue(Q);               <span class="comment">//初始化辅助队列Q</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++<span class="number">1</span>)&#123;    <span class="comment">//从0号顶点开始遍历</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[i])&#123;        <span class="comment">//对每个连通分量调用一次BFS</span></span><br><span class="line">            visit(i);           <span class="comment">//访问初始顶点i</span></span><br><span class="line">            visited[i]=TRUE;    <span class="comment">//对i做已访问标记</span></span><br><span class="line">            Enqueue(Q,i);       <span class="comment">//顶点i入队列</span></span><br><span class="line">            <span class="keyword">while</span>(!isEmpty(Q))&#123;</span><br><span class="line">                DeQueue(Q,i);   <span class="comment">//顶点i出队列</span></span><br><span class="line">                <span class="comment">//检测i所有的邻接点</span></span><br><span class="line">                <span class="keyword">for</span>(w=FirstNeighbor(G,i);w&gt;=<span class="number">0</span>;w=NextNeighbor(G,i,w))</span><br><span class="line">                    <span class="keyword">if</span>(!visited[w])&#123;  <span class="comment">//w为i的尚未被访问的邻接顶点</span></span><br><span class="line">                        visit(w);     <span class="comment">//访问顶点w</span></span><br><span class="line">                        visited[w]=TRUE; <span class="comment">//对w做已访问标记</span></span><br><span class="line">                        EnQueue(Q,w);    <span class="comment">//顶点w入队列</span></span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BFS求解单源最短路径问题"><a href="#BFS求解单源最短路径问题" class="headerlink" title="BFS求解单源最短路径问题"></a>BFS求解单源最短路径问题</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//求顶点u到其他顶点的最短路径</span></span><br><span class="line"><span class="comment">//使用BFS可以求解非带权图的单源最短路径问题，因为广度优先搜索总是按照距离由近到远来遍历图中的每一个顶点</span></span><br><span class="line"><span class="comment">//BFS需要一个辅助队列Q，n个顶点均需入队一次，在最坏情况下，空间复杂度为O(|V|)</span></span><br><span class="line"><span class="comment">//采用邻接表存储方式时，每个顶点均需搜索一次（或入队一次），故时间复杂度为O(|V|)，在搜索任意一个顶点的邻接点时，每条边至少访问一次，故时间复杂度为O(|E|)，算法总的时间复杂度为O(|V|+|E|)</span></span><br><span class="line"><span class="comment">//采用邻接矩阵存储方式时，查找每个顶点的邻接点所需时间为O(|V|)，故算法总的时间复杂度为O(|V|^2)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS_MIN_Distance</span><span class="params">(Graph G,<span class="type">int</span> u)</span>&#123;</span><br><span class="line">    <span class="comment">//d[i]表示从u到i结点的最短路径</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++<span class="number">1</span>)&#123;</span><br><span class="line">        d[i]=∞;       <span class="comment">//初始化路径长度</span></span><br><span class="line">        path[i]=<span class="number">-1</span>;   <span class="comment">//最短路径从哪个顶点d过来</span></span><br><span class="line">    &#125;</span><br><span class="line">    d[u]=<span class="number">0</span>;</span><br><span class="line">    visited[u]=TRUE;</span><br><span class="line">    EnQueue(Q,u);</span><br><span class="line">    <span class="keyword">while</span>(!isEmpty(Q))&#123;          <span class="comment">//BFS算法主过程</span></span><br><span class="line">        DeQueue(Q,u);            <span class="comment">//队头元素u出队</span></span><br><span class="line">        <span class="keyword">for</span>(w=FirstNeighbor(G,u);w&gt;=<span class="number">0</span>;w=NextNeighbor(G,u,w))</span><br><span class="line">            <span class="keyword">if</span>(!visited[w])&#123;     <span class="comment">//w为u尚未访问的邻接顶点</span></span><br><span class="line">                d[w]=d[u]+<span class="number">1</span>;     <span class="comment">//路径长度加1</span></span><br><span class="line">                path[w]=u;       <span class="comment">//最短路径应从u到w</span></span><br><span class="line">                visited[w]=TRUE; <span class="comment">//设已访问标记</span></span><br><span class="line">                EnQueue(Q,w);    <span class="comment">//顶点w入队</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="深度优先搜索-DFS"><a href="#深度优先搜索-DFS" class="headerlink" title="深度优先搜索-DFS"></a>深度优先搜索-DFS</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DFS算法是一个递归算法，需要借助一个递归工作栈，故其空间复杂度为O(|V|)</span></span><br><span class="line"><span class="comment">//遍历图的过程实质上是对每个顶点查找其邻接点的过程，其耗费时间取决于所用的存储结构</span></span><br><span class="line"><span class="comment">//以邻接矩阵表示时，查找每个顶点的邻接点所需的时间为O(|V|)，故总的时间复杂度为O(|V|^2)</span></span><br><span class="line"><span class="comment">//以邻接表表示时，查找所有顶点的邻接点所需的时间为O(|E|)，访问顶点所需的时间为O(|V|),总的时间复杂度为O(|V|+|E|)</span></span><br><span class="line"><span class="type">bool</span> visited[MAX_VERTEX_NUM];     <span class="comment">//访问标记数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFSTraverse</span><span class="params">(Graph G)</span>&#123;        <span class="comment">//对图G进行深度优先遍历</span></span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vexnum;++v)</span><br><span class="line">        visited[v]=FALSE;         <span class="comment">//初始化已访问标记数组</span></span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vexnum;++v)</span><br><span class="line">        <span class="keyword">if</span>(!visited[v])</span><br><span class="line">            DFS(G,v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(Graph G,<span class="type">int</span> v)</span>&#123;          <span class="comment">//从顶点v出发，深度优先遍历图G</span></span><br><span class="line">    visit(v);                     <span class="comment">//访问顶点v</span></span><br><span class="line">    visited[v]=TRUE;              <span class="comment">//设已访问标记</span></span><br><span class="line">    <span class="keyword">for</span>(w=FirstNeighbor(G,v);w&gt;=<span class="number">0</span>;w=NextNeighbor(G,v,w))</span><br><span class="line">        <span class="keyword">if</span>(!visited[w])&#123;          <span class="comment">//w为v的尚未访问的邻接顶点</span></span><br><span class="line">            DFS(G,w);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//图的遍历算法可以用来判断图的连通性。</span></span><br><span class="line"><span class="comment">//对于无向图，调用BFS(G,i)或DFS(G,i)的次数等于该图的连通分量；对于有向图并非如此。</span></span><br></pre></td></tr></table></figure><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入排序</span></span><br><span class="line"><span class="comment">//算法思想：每次将一个待排序的记录按其关键字大小插入到前面已排好序的子序列中，直到全部记录插入完成</span></span><br><span class="line"><span class="comment">//直接插入排序</span></span><br><span class="line"><span class="comment">//空间复杂度：O(1)</span></span><br><span class="line"><span class="comment">//时间复杂度：主要来自于对比关键字、移动元素。若有n个元素，则需要n-1趟处理</span></span><br><span class="line"><span class="comment">//最好时间复杂度（全部有序）：O(n)</span></span><br><span class="line"><span class="comment">//共n-1趟处理，每一趟只需要对比关键字一次，不用移动元素</span></span><br><span class="line"><span class="comment">//最坏时间复杂度（全部逆序）：O(n^2)</span></span><br><span class="line"><span class="comment">//共n-1趟处理，每一趟需要对比关键字i+1次，移动元素i+2次</span></span><br><span class="line"><span class="comment">//平均时间复杂度：O(n^2)</span></span><br><span class="line"><span class="comment">//算法稳定性：稳定</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,temp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)            <span class="comment">//将各元素插入已排好序的序列中</span></span><br><span class="line">        <span class="keyword">if</span>(A[i]&lt;A[i<span class="number">-1</span>])&#123;        <span class="comment">//若A[i]关键字小于前驱</span></span><br><span class="line">            temp=A[i];          <span class="comment">//用temp暂存A[i]</span></span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span> &amp;&amp; A[j]&gt;temp;--j)    <span class="comment">//检查所有前面已排好序的元素</span></span><br><span class="line">                A[j+<span class="number">1</span>]=A[j];    <span class="comment">//所有大于temp的元素都向后挪位</span></span><br><span class="line">            A[j+<span class="number">1</span>]=temp;        <span class="comment">//复制到插入位置</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//优化--折半插入排序</span></span><br><span class="line"><span class="comment">//算法思想：先用折半查找找到应该插入的位置，再移动元素</span></span><br><span class="line"><span class="comment">//当low&gt;high时折半查找停止，应将[low,i-1]内的元素全部右移，并将A[0]复制到low所指位置</span></span><br><span class="line"><span class="comment">//当A[mid]==A[0]时，为了保证算法稳定性，应继续在mid所指位置右边寻找插入位置</span></span><br><span class="line"><span class="comment">//比起直接插入排序，比较关键字的次数减少了，但是移动元素的次数没变，整体来看时间复杂度依然是O(n^2)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,low,high,mid;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)&#123;       <span class="comment">//依次将A[2]-A[n]插入前面的已排序序列</span></span><br><span class="line">        A[<span class="number">0</span>]=A[i];           <span class="comment">//将A[i]暂存到A[0]</span></span><br><span class="line">        low=<span class="number">1</span>;               <span class="comment">//设置折半查找的范围</span></span><br><span class="line">        high=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)&#123;    <span class="comment">//折半查找（默认递增有序）</span></span><br><span class="line">            mid=(low+high)/<span class="number">2</span>;<span class="comment">//取中间点</span></span><br><span class="line">            <span class="keyword">if</span>(A[mid]&gt;A[<span class="number">0</span>])  <span class="comment">//查找左半子表</span></span><br><span class="line">                high=mid<span class="number">-1</span>;  </span><br><span class="line">            <span class="keyword">else</span>             <span class="comment">//查找右半子表</span></span><br><span class="line">                low=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=high;--j)</span><br><span class="line">            A[j+<span class="number">1</span>]=A[j];     <span class="comment">//统一后移元素，空出插入位置</span></span><br><span class="line">        A[high+<span class="number">1</span>]=A[<span class="number">0</span>];      <span class="comment">//插入操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="comment">//算法思想：先将待排序表分割成若干形如L[i,i+d,i+2d,...,i+kd]的特殊子表；对每个子表分别进行直接插入排序。缩小增量d，重复上述过程，直到d=1为止。</span></span><br><span class="line"><span class="comment">//空间复杂度：O(1)</span></span><br><span class="line"><span class="comment">//时间复杂度：优于直接插入排序</span></span><br><span class="line"><span class="comment">//稳定性：不稳定</span></span><br><span class="line"><span class="comment">//适用性：仅可用于顺序表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShellSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> d,i,j;</span><br><span class="line">    <span class="comment">//A[0]只是暂存单元，当j&lt;=0时，插入位置已到</span></span><br><span class="line">    <span class="keyword">for</span>(d=n/<span class="number">2</span>;d&gt;=<span class="number">1</span>;d=d/<span class="number">2</span>)     <span class="comment">//步长变化</span></span><br><span class="line">        <span class="keyword">for</span>(i=d+<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="keyword">if</span>(A[i]&lt;A[i-d])&#123;  <span class="comment">//需要将A[i]插入有序增量子表</span></span><br><span class="line">                A[<span class="number">0</span>]=A[i];    <span class="comment">//暂存在A[0]</span></span><br><span class="line">                <span class="keyword">for</span>(j=i-d;j&gt;<span class="number">0</span>&amp;&amp;A[<span class="number">0</span>]&lt;A[j];j-=d)</span><br><span class="line">                    A[j+d]=A[j];  <span class="comment">//记录后移，查找要插入的位置</span></span><br><span class="line">                A[j+d]=A[<span class="number">0</span>];      <span class="comment">//插入</span></span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="comment">//算法思想：从后往前（或从前往后）两两比较相邻元素的值，若为逆序，则交换它们，直到序列比较完，称这样过程为一趟冒泡排序，最多只需n-1趟排序</span></span><br><span class="line"><span class="comment">//每一趟排序都可以使一个元素移动到最终位置，已经确定最终位置的元素在之后的处理中无需再对比</span></span><br><span class="line"><span class="comment">//如果某一趟排序过程中未发生交换，则算法可提前结束</span></span><br><span class="line"><span class="comment">//空间复杂度：O(1)</span></span><br><span class="line"><span class="comment">//时间复杂度：</span></span><br><span class="line"><span class="comment">//最好情况（有序）：O(n)，比较次数=n-1，交换次数=0</span></span><br><span class="line"><span class="comment">//最坏情况（逆序）：O(n^2)，比较次数=(n-1)+(n-2)+...+1=n(n-1)/2=交换次数,</span></span><br><span class="line"><span class="comment">//最坏情况下要移动3n(n-1)/2（每次交换都需要移动元素三次）</span></span><br><span class="line"><span class="comment">//平均时间复杂度=O(n^2)</span></span><br><span class="line"><span class="comment">//稳定性：稳定（只有A[j-1]&gt;A[i]时才交换）</span></span><br><span class="line"><span class="comment">//适用性：顺序表、链表都可以</span></span><br><span class="line"><span class="comment">//在i所指位置之前的元素都已经有序了</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="type">bool</span> flag=<span class="literal">false</span>;          <span class="comment">//表示本趟冒泡是否发生交换的标志</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=n<span class="number">-1</span>;j&gt;i;j--)    <span class="comment">//一趟冒泡排序</span></span><br><span class="line">            <span class="keyword">if</span>(A[j<span class="number">-1</span>]&gt;A[j])&#123;      <span class="comment">//若为逆序</span></span><br><span class="line">                swap(A[j<span class="number">-1</span>],A[j]);<span class="comment">//交换</span></span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span>;               <span class="comment">//本趟遍历后没有发生交换，说明表已经有序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="comment">//算法思想：在待排序表L[1..n]中任取一个元素pivot作为枢轴（或基准，通常取首元素），通过一趟排序将待排序表划分成独立的两部分L[1...k-1]和L[k+1...n],使得L[1...k-1]中的所有元素小于pivot，L[k+1...n]中的所有元素大于等于pivot，则pivot放在了其最终位置L[k]上，这个过程称为一次划分，然后分别递归地对这两个子表重复上述过程，直至每部分内只有一个元素或空为止，即所有元素放在了其最终位置上</span></span><br><span class="line"><span class="comment">//快速排序是所有内部排序算法中平均性能最优的排序算法</span></span><br><span class="line"><span class="comment">//其算法表现主要取决于递归深度，若每次划分越均匀，则递归深度越低；划分越不均匀，递归深度越深</span></span><br><span class="line"><span class="comment">//n个结点的二叉树，最小高度=⌊log2n⌋+1，最大高度=n</span></span><br><span class="line"><span class="comment">//空间复杂度=O(递归层数)：最好（O(log2n)）；最坏（O(n)）</span></span><br><span class="line"><span class="comment">//时间复杂度=O(n*递归层数)</span></span><br><span class="line"><span class="comment">//最好时间复杂度（O(nlog2n)）-每次选的枢轴元素都能将序列划分成均匀地两部分；</span></span><br><span class="line"><span class="comment">//最坏时间复杂度（O(n^2)）-若序列原本就有序或者逆序，则时间、空间复杂度最高</span></span><br><span class="line"><span class="comment">//平均时间复杂度（O(nlog2n)）</span></span><br><span class="line"><span class="comment">//稳定性：不稳定</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">        <span class="type">int</span> pivotpos=Partition(A,low,high);  <span class="comment">//划分</span></span><br><span class="line">        QuickSort(A,low,pivotpos<span class="number">-1</span>);         <span class="comment">//划分左子表</span></span><br><span class="line">        QuickSort(A,pivotpos+<span class="number">1</span>，high);        <span class="comment">//划分右子表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用第一个元素将待排序序列划分成左右两个部分</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Partition</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot=A[low];       <span class="comment">//第一个元素作为枢轴</span></span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)&#123;        <span class="comment">//用low和high搜索枢轴的最终位置</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;A[high]&gt;=pivot) </span><br><span class="line">            --high;</span><br><span class="line">        A[low]=A[high];     <span class="comment">//比枢轴小的元素移动到左端</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;A[low]&lt;=pivot)</span><br><span class="line">            ++low;          <span class="comment">//比枢轴大的元素移动到右端</span></span><br><span class="line">        A[high]=A[low];</span><br><span class="line">    &#125;</span><br><span class="line">    A[low]=pivot;           <span class="comment">//枢轴元素存放到最终位置</span></span><br><span class="line">    <span class="keyword">return</span> low;             <span class="comment">//返回存放枢轴的最终位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//选择排序（简单选择排序、堆排序）</span></span><br><span class="line"><span class="comment">//算法思想：每一趟（如第i趟）在后面n-i+1(i=1,2,..,n-1)个待排序元素中选取关键字最小的元素，作为有序子序列的第i个元素，直到第n-1趟做完，待排序元素就剩下一个，就不需要再选。</span></span><br><span class="line"><span class="comment">//简单选择排序</span></span><br><span class="line"><span class="comment">//算法思想：每趟在待排序元素中选取关键字最小的元素加入有序子序列，第i趟排序即从L[i...n]中选取关键字最小的元素与L(i)交换，每一趟排序可以确定一个元素的最终位置，这样经过n-1趟排序就可以使得整个排序表有序</span></span><br><span class="line"><span class="comment">//必须进行n-1趟处理</span></span><br><span class="line"><span class="comment">//空间复杂度：O(1)</span></span><br><span class="line"><span class="comment">//时间复杂度：O(n^2)</span></span><br><span class="line"><span class="comment">//元素移动次数不会超过3(n-1)次，最好的情况是移动0次（初始有序）</span></span><br><span class="line"><span class="comment">//元素间比较的次数与序列初始状态无关，始终为n(n-1)/2</span></span><br><span class="line"><span class="comment">//稳定性：不稳定</span></span><br><span class="line"><span class="comment">//适用性：顺序表、链表都可以</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(EmlemType A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;      <span class="comment">//一共进行n-1趟</span></span><br><span class="line">        <span class="type">int</span> min=i;               <span class="comment">//记录最小元素位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)   <span class="comment">//在A[i..n-1]中选择最小元素</span></span><br><span class="line">            <span class="keyword">if</span>(A[j]&lt;A[min])      <span class="comment">//更新最小元素位置</span></span><br><span class="line">                min=j; </span><br><span class="line">        <span class="keyword">if</span>(min!=i)              </span><br><span class="line">            swap(A[i],A[min]);   <span class="comment">//封装的swap()共移动元素3次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="comment">//堆-顺序存储的完全二叉树</span></span><br><span class="line"><span class="comment">//结点i的左孩子是2i；右孩子是2i+1；父节点是⌊i/2⌋</span></span><br><span class="line"><span class="comment">//编号=&lt;n/2的结点都是分支结点</span></span><br><span class="line"><span class="comment">//大根堆（根&gt;=左、右）小根堆（根&lt;=左、右）</span></span><br><span class="line"><span class="comment">//空间复杂度：O(1)</span></span><br><span class="line"><span class="comment">//时间复杂度：建堆：O(n)+排序：O(nlog2n)=O(nlog2n)</span></span><br><span class="line"><span class="comment">//结论：一个结点，每下坠一层，最多只需对比关键字两次</span></span><br><span class="line"><span class="comment">//若树高为h，某结点在第i层，则将这个结点向下调整最多只需要下坠h-i层，关键字对比次数不超过2(h-i)</span></span><br><span class="line"><span class="comment">//n个结点的完全二叉树树高h=⌊log2n⌋+1</span></span><br><span class="line"><span class="comment">//建堆的过程，关键字对比次数不超过4n，建堆时间复杂度=O(n)</span></span><br><span class="line"><span class="comment">//堆排序总共需要n-1趟，每一趟交换后都需要将根结点下坠调整</span></span><br><span class="line"><span class="comment">//根结点最多下坠h-1层，每下坠一层，最多需要对比关键字2次，所以每一趟排序复杂度不超过O(h)=O(log2n)</span></span><br><span class="line"><span class="comment">//共n-1趟，总的时间复杂度=O(nlog2n)</span></span><br><span class="line"><span class="comment">//稳定性：不稳定</span></span><br><span class="line"><span class="comment">//基于大根堆的堆排序得到递增序列，基于小根堆的堆排序得到递减序列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//首先建堆，建堆的主要思想是从后调整所有的非终端结点，即结点数除以二向下取整，对于每个结点调用HeadAdjust算法，调整恢复堆的性质，通过这样来建立大根堆；然后第一个元素和最后一个元素交换破环堆，然后调整，如此n-1次（最后一个结点无需排序），每次都是先将堆顶元素和堆底元素交换，然后进行调整，交换一次就能获得一个最大（小）值，排好了一次序</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//建立大根堆</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BuildMaxHeap</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--)  <span class="comment">//从后往前调整所有非终端结点</span></span><br><span class="line">        HeadAdjust(A,i,len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆排序的完整逻辑</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> len)</span>&#123;</span><br><span class="line">    BuildMaxHeap(A,len);       <span class="comment">//初始建堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len;i&gt;<span class="number">1</span>;i--)&#123;    <span class="comment">//n-1趟的交换和建堆过程</span></span><br><span class="line">        swap(A[i],A[<span class="number">1</span>]);       <span class="comment">//堆顶元素和堆底元素交换</span></span><br><span class="line">        HeadAdjust(A,<span class="number">1</span>,i<span class="number">-1</span>);   <span class="comment">//把剩余的待排序元素整理成堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将以k为根的子树调整成大根堆</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeadAdjust</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> k,<span class="type">int</span> len)</span>&#123;</span><br><span class="line">    A[<span class="number">0</span>]=A[k];                  <span class="comment">//A[0]暂存子树的根结点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>*k;i&lt;=len;i*=<span class="number">2</span>)&#123; <span class="comment">//沿key较大的子结点向下筛选</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;len&amp;&amp;A[i]&lt;A[i+<span class="number">1</span>])  <span class="comment">//左孩子2i小于右孩子2i+1（左右孩子一样大，优先和左孩子交换）</span></span><br><span class="line">            i++;                <span class="comment">//取key较大的子结点的下标</span></span><br><span class="line">        <span class="keyword">if</span>(A[<span class="number">0</span>]&gt;=A[i])          <span class="comment">//筛选结束</span></span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        <span class="keyword">else</span>&#123;       </span><br><span class="line">            A[k]=A[i];          <span class="comment">//将A[i]调整到双亲结点上</span></span><br><span class="line">            k=i;                <span class="comment">//修改k值，以便继续向下筛选</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[k]=A[<span class="number">0</span>];                  <span class="comment">//被筛选结点的值放入最终位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="comment">//归并是将两个或两个以上的有序表合并成一个新的有序表</span></span><br><span class="line"><span class="comment">//2路归并排序：假设待排序表含有n个记录，则可将其视为n个有序的子表，每个子表长度为1，然后两两归并，得到⌈n/2⌉个长度为2或1的有序表；继续两两归并，如此重复直到合并成一个长度为n的有序表为止</span></span><br><span class="line"><span class="comment">//Merge()的功能是将前后相邻的两个有序表归并成一个有序表</span></span><br><span class="line"><span class="comment">//设两段有序表A[low...mid]、A[mid+1...high]存放在同一顺序表中的相邻位置，先将它们复制到辅助数组B中。每次从对应B中的两个段取出一个记录进行关键字的比较，把较小者放入A中。当数组B中有一段的下标超过其对应的表长（即该段的所有元素都已复制到A中）时，将另一段中的剩余部分直接复制到A中。</span></span><br><span class="line">ElemType *B=(ElemType *)<span class="built_in">malloc</span>((n+<span class="number">1</span>)*<span class="keyword">sizeof</span>(ElemType)); <span class="comment">//辅助数组B</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge</span><span class="params">(ElemType A[],<span class="type">int</span> low,<span class="type">int</span> mid,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="comment">//表A的两段A[low...mid]和A[mid+1...high]各自有序，把他们合成一个有序表</span></span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">for</span>(k=low;k&lt;=high;k++)</span><br><span class="line">        B[k]=A[k];          <span class="comment">//将A所有元素复制到B中</span></span><br><span class="line">    <span class="comment">//每次从B的两段取出一个记录进行关键字比较，较小的放入A中</span></span><br><span class="line">    <span class="comment">//限制条件：i、j不超过各自的段；k是A的下标；一轮比较出A的一个元素</span></span><br><span class="line">    <span class="keyword">for</span>(i=low,j=mid+<span class="number">1</span>,k=i;i&lt;=mid&amp;&amp;j&lt;=high;k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(B[i]&lt;=B[j])      <span class="comment">//比较B的左右两段中的元素</span></span><br><span class="line">            A[k]=B[i++];    <span class="comment">//将较小值复制到A中</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            A[k]=B[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以下两个while循环只会执行一个</span></span><br><span class="line">    <span class="keyword">while</span>(j&lt;=mid)           <span class="comment">//若第一个表未检测完，复制</span></span><br><span class="line">        A[k++]=B[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=high)          <span class="comment">//若第二个表未检测完，复制</span></span><br><span class="line">        A[k++]=B[j++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一趟归并排序会调用⌈n/2h⌉次算法merge()，将L[1...n]中前后相邻且长度为h的有序段进行两两归并，得到前后相邻、长度为2h的有序段，整个归并排序需要进行⌈log2n⌉趟</span></span><br><span class="line"><span class="comment">//递归形式的2路归并排序算法基于分治，分为分解和合并两个过程</span></span><br><span class="line"><span class="comment">//分解：将含有n个元素的待排序表分为各含n/2个元素的子表，采用2路归并排序算法对两个子表递归地进行排序</span></span><br><span class="line"><span class="comment">//合并：合并两个已排序的子表得到排序结果</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSort</span><span class="params">(Elemtype A[],<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(low+high)/<span class="number">2</span>;     <span class="comment">//从中间划分成两个子序列</span></span><br><span class="line">        MergeSort(A,low,mid);     <span class="comment">//对左侧子序列进行递归排序</span></span><br><span class="line">        MergeSort(A,mid+<span class="number">1</span>,high);  <span class="comment">//对右侧子序列进行递归排序</span></span><br><span class="line">        Merge(A,low,mid,high);    <span class="comment">//归并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2路归并的归并树在形态上是一棵倒立的二叉树</span></span><br><span class="line"><span class="comment">//二叉树的第h层最多有2^(h-1)个结点</span></span><br><span class="line"><span class="comment">//若树高为h，则应满足n&lt;=2^(h-1)，即h-1=⌈log2n⌉</span></span><br><span class="line"><span class="comment">//结论：n个元素进行2路归并排序，归并趟数等于⌈log2n⌉</span></span><br><span class="line"><span class="comment">//每趟归并时间复杂度为O(n),则算法时间复杂度为O(nlog2n)</span></span><br><span class="line"><span class="comment">//空间复杂度=O(n),来自于辅助数组B</span></span><br><span class="line"><span class="comment">//稳定性：稳定</span></span><br></pre></td></tr></table></figure><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基数排序</span></span><br><span class="line"><span class="comment">//基数排序不是基于比较的排序算法</span></span><br><span class="line"><span class="comment">//算法思想：将整个关键字拆分成d位，按照各个关键字位权重递增的次序（如：个，十，百），做d趟分配和收集</span></span><br><span class="line"><span class="comment">//若当前处理的关键字位可能取得r个值，则需要建立r个队列</span></span><br><span class="line"><span class="comment">//分配：顺序扫描各个元素，根据当前处理的关键字位，将元素插入相应队列，一趟分配耗时O(n)</span></span><br><span class="line"><span class="comment">//收集：把各个队列中的结点依次出队并链接，一趟收集耗时O(r)</span></span><br><span class="line"><span class="comment">//空间复杂度：O(r)[r个队列]</span></span><br><span class="line"><span class="comment">//时间复杂度：O(d(n+r))[做d趟分配和收集，一趟分配耗时O(n)，一趟收集耗时O(r)，所以时间复杂度为O(d(n+r))]</span></span><br><span class="line"><span class="comment">//稳定性：稳定</span></span><br><span class="line"><span class="comment">//擅长处理：</span></span><br><span class="line"><span class="comment">//1.数据元素关键字可方便拆分为d组，且d较小</span></span><br><span class="line"><span class="comment">//2.每组关键字取值范围不大，即r较小</span></span><br><span class="line"><span class="comment">//3.数据元素个数n较大</span></span><br></pre></td></tr></table></figure><h3 id="排序算法总结"><a href="#排序算法总结" class="headerlink" title="排序算法总结"></a>排序算法总结</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//平均时间复杂度（时间快）：快些归队（快速排序[O(nlog2n)]，希尔排序[O(n^(1/3))]，归并排序[O(nlog2n)]，堆排序[O(nlog2n)]）</span></span><br><span class="line"><span class="comment">//不稳定的算法：快些选一堆好友来聊天（快速排序，希尔排序，选择排序，堆排序）</span></span><br><span class="line"><span class="comment">//折半插入排序是在直接插入排序的基础上建立的，只是通过使用折半查找算法减少了数据对象的比较次数，但移动次数没有发生改变，所以时间复杂度为O(n^2)</span></span><br><span class="line"><span class="comment">//直接插入，直接比元素，找插入位置平均时间复杂度为O(n)</span></span><br><span class="line"><span class="comment">//折半插入，对半比元素，找插入位置平均时间复杂度为O(log2n)</span></span><br><span class="line"><span class="comment">//每次排序都能至少确定一个元素在其最终位置上的排序算法有：快速排序，选择排序，堆排序，冒泡排序（快速选择一堆帽子）</span></span><br><span class="line"><span class="comment">//元素的移动次数与关键字的初始序列无关的是：基数排序（基数排序不是基于比较的排序算法）</span></span><br><span class="line"><span class="comment">//元素的比较次数与关键字的初始序列无关的是：选择排序（简单选择排序，堆排序）、归并排序、折半插入排序</span></span><br><span class="line"><span class="comment">//算法时间复杂度与关键字初始序列无关的是：选择排序（简单选择排序O(n^2)、堆排序O(nlog2n)）、归并排序(2路O(nlog2n))、基数排序O(d(n+r))</span></span><br><span class="line"><span class="comment">//算法的排序趟数与关键字初始序列无关的是：插入排序（直接插入排序，折半插入排序，希尔排序）、选择排序（简单选择排序、堆排序）、归并排序、基数排序</span></span><br><span class="line"><span class="comment">//算法的排序趟数与关键字初始序列有关的是：冒泡排序、快速排序</span></span><br><span class="line"><span class="comment">//简单选择排序比较次数始终为n(n-1)/2，与关键字的初始序列无关，选择或交换次数为n-1趟（交换次数≠移动次数，待排序序列中确定了最小元素，再与第一个元素交换，因为交换次数与趟数一样）</span></span><br><span class="line"><span class="comment">//简单选择排序记录移动次数较少，当待排序列为正序时，移动次数最少，为0次，当为逆序时，移动次数最多，为3(n-1)次</span></span><br><span class="line"><span class="comment">//m路归并，每选出一个元素需要比较关键字m-1次</span></span><br><span class="line"><span class="comment">//快速排序：时间复杂度=O(n*递归层数) 最好：O(nlog2n) 最坏：O(n^2)</span></span><br><span class="line"><span class="comment">//空间复杂度=O(递归层数) 最好：O(log2n) 最坏：O(n)</span></span><br><span class="line"><span class="comment">//若n较小，可以采用直接插入排序或简单选择排序</span></span><br><span class="line"><span class="comment">//当记录本身信息量较大时，用简单选择排序较好（直接插入排序所需的记录移动次数较简单选择排序的多）</span></span><br><span class="line"><span class="comment">//若文件的初始状态已按关键字基本有序，则采用直接插入排序或冒泡排序（若此时采用快速排序，时间复杂度为O(n^2)）</span></span><br><span class="line"><span class="comment">//快速排序被认为是目前基于比较的内部排序方法中最好的方法，待排序的关键字随机分布时，快速排序的平均时间最短</span></span><br><span class="line"><span class="comment">//若n较大，则应该采用时间复杂度为O(nlog2n)的排序算法：快速排序、堆排序、归并排序</span></span><br><span class="line"><span class="comment">//要求排序稳定且时间复杂度为O(nlog2n)，则选用归并排序</span></span><br><span class="line"><span class="comment">//若n很大，记录的关键字位数较少且可以分解时，采用基数排序</span></span><br><span class="line"><span class="comment">//当记录本身信息量较大，为避免耗费大量时间移动记录，可用链表作为存储结构</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-总结-自用</title>
      <link href="/FRank675.github.io/posts/443ccf2bc426/"/>
      <url>/FRank675.github.io/posts/443ccf2bc426/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="1、操作系统引论"><a href="#1、操作系统引论" class="headerlink" title="1、操作系统引论"></a>1、操作系统引论</h2><p>​<strong>操作系统是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充。</strong></p><p>​<strong>其主要作用是管理好这些设备，提高它们的利用率和系统的吞吐量，并为用户和应用程序提供一个简单的接口，便于用户使用。</strong></p><h3 id="1-1-操作系统的目标和作用"><a href="#1-1-操作系统的目标和作用" class="headerlink" title="1.1 操作系统的目标和作用"></a>1.1 操作系统的目标和作用</h3><h4 id="1-1-1-操作系统的目标"><a href="#1-1-1-操作系统的目标" class="headerlink" title="1.1.1 操作系统的目标"></a>1.1.1 操作系统的目标</h4><p><strong>目标</strong></p><ul><li>方便性<ul><li>操作系统使计算机系统更易于使用</li></ul></li><li>有效性<ul><li>操作系统使资源的利用率更高，系统吞吐量更大</li></ul></li><li>可扩充性<ul><li>操作系统必须能方便地增加新的功能和模块，并能修改老的功能和模块，以适应计算机硬件、体系结构以及应用发展的要求</li></ul></li><li>开放性<ul><li>操作系统的开发应该遵循世界标准规范，特别是遵循开放系统互连OSI国际标准，从而使其与其它系统之间能彼此兼容、方便地实现互连</li></ul></li></ul><h3 id="1-2-操作系统的发展过程"><a href="#1-2-操作系统的发展过程" class="headerlink" title="1.2 操作系统的发展过程"></a>1.2 操作系统的发展过程</h3><h3 id="1-3-操作系统的基本特性"><a href="#1-3-操作系统的基本特性" class="headerlink" title="1.3 操作系统的基本特性"></a>1.3 操作系统的基本特性</h3><h3 id="1-4-操作系统的主要功能"><a href="#1-4-操作系统的主要功能" class="headerlink" title="1.4 操作系统的主要功能"></a>1.4 操作系统的主要功能</h3><h3 id="1-5-OS结构设计"><a href="#1-5-OS结构设计" class="headerlink" title="1.5 OS结构设计"></a>1.5 OS结构设计</h3><h2 id="2、进程的描述与控制"><a href="#2、进程的描述与控制" class="headerlink" title="2、进程的描述与控制"></a>2、进程的描述与控制</h2><h3 id="2-1-前趋图和程序执行"><a href="#2-1-前趋图和程序执行" class="headerlink" title="2.1 前趋图和程序执行"></a>2.1 前趋图和程序执行</h3><h3 id="2-2-进程的描述"><a href="#2-2-进程的描述" class="headerlink" title="2.2 进程的描述"></a>2.2 进程的描述</h3><h3 id="2-3-进程控制"><a href="#2-3-进程控制" class="headerlink" title="2.3 进程控制"></a>2.3 进程控制</h3><h3 id="2-4-进程同步"><a href="#2-4-进程同步" class="headerlink" title="2.4 进程同步"></a>2.4 进程同步</h3><h3 id="2-5-经典进程的同步问题"><a href="#2-5-经典进程的同步问题" class="headerlink" title="2.5 经典进程的同步问题"></a>2.5 经典进程的同步问题</h3><h3 id="2-6-进程通信"><a href="#2-6-进程通信" class="headerlink" title="2.6 进程通信"></a>2.6 进程通信</h3><h3 id="2-7-线程（Threads）的基本概念"><a href="#2-7-线程（Threads）的基本概念" class="headerlink" title="2.7 线程（Threads）的基本概念"></a>2.7 线程（Threads）的基本概念</h3><h3 id="2-8-线程的实现"><a href="#2-8-线程的实现" class="headerlink" title="2.8 线程的实现"></a>2.8 线程的实现</h3><h2 id="3、处理机调度与死锁"><a href="#3、处理机调度与死锁" class="headerlink" title="3、处理机调度与死锁"></a>3、处理机调度与死锁</h2><h3 id="3-1-处理机调度的层次和调度算法的目标"><a href="#3-1-处理机调度的层次和调度算法的目标" class="headerlink" title="3.1 处理机调度的层次和调度算法的目标"></a>3.1 处理机调度的层次和调度算法的目标</h3><h3 id="3-2-作业与作业调度"><a href="#3-2-作业与作业调度" class="headerlink" title="3.2 作业与作业调度"></a>3.2 作业与作业调度</h3><h3 id="3-3-进程调度"><a href="#3-3-进程调度" class="headerlink" title="3.3 进程调度"></a>3.3 进程调度</h3><h3 id="3-4-实时调度"><a href="#3-4-实时调度" class="headerlink" title="3.4 实时调度"></a>3.4 实时调度</h3><h3 id="3-5-死锁概述"><a href="#3-5-死锁概述" class="headerlink" title="3.5 死锁概述"></a>3.5 死锁概述</h3><h3 id="3-6-预防死锁"><a href="#3-6-预防死锁" class="headerlink" title="3.6 预防死锁"></a>3.6 预防死锁</h3><h3 id="3-7-避免死锁"><a href="#3-7-避免死锁" class="headerlink" title="3.7 避免死锁"></a>3.7 避免死锁</h3><h3 id="3-8-死锁的检测与解除"><a href="#3-8-死锁的检测与解除" class="headerlink" title="3.8 死锁的检测与解除"></a>3.8 死锁的检测与解除</h3><h2 id="4、存储器管理"><a href="#4、存储器管理" class="headerlink" title="4、存储器管理"></a>4、存储器管理</h2><h3 id="4-1-存储器的层次结构"><a href="#4-1-存储器的层次结构" class="headerlink" title="4.1 存储器的层次结构"></a>4.1 存储器的层次结构</h3><h3 id="4-2-程序的装入和链接"><a href="#4-2-程序的装入和链接" class="headerlink" title="4.2 程序的装入和链接"></a>4.2 程序的装入和链接</h3><h3 id="4-3-连续分配存储管理-方式"><a href="#4-3-连续分配存储管理-方式" class="headerlink" title="4.3 连续分配存储管理 方式"></a>4.3 连续分配存储管理 方式</h3><h3 id="4-4-对换（Swapping）"><a href="#4-4-对换（Swapping）" class="headerlink" title="4.4 对换（Swapping）"></a>4.4 对换（Swapping）</h3><h3 id="4-5-分页存储管理方式"><a href="#4-5-分页存储管理方式" class="headerlink" title="4.5 分页存储管理方式"></a>4.5 分页存储管理方式</h3><h3 id="4-6-分段存储管理方式"><a href="#4-6-分段存储管理方式" class="headerlink" title="4.6 分段存储管理方式"></a>4.6 分段存储管理方式</h3><h2 id="5、虚拟存储器"><a href="#5、虚拟存储器" class="headerlink" title="5、虚拟存储器"></a>5、虚拟存储器</h2><h3 id="5-1-虚拟存储器概述"><a href="#5-1-虚拟存储器概述" class="headerlink" title="5.1 虚拟存储器概述"></a>5.1 虚拟存储器概述</h3><h3 id="5-2-请求分页存储管理方式"><a href="#5-2-请求分页存储管理方式" class="headerlink" title="5.2 请求分页存储管理方式"></a>5.2 请求分页存储管理方式</h3><h3 id="5-3-页面置换算法"><a href="#5-3-页面置换算法" class="headerlink" title="5.3 页面置换算法"></a>5.3 页面置换算法</h3><h3 id="5-4-“抖动”与工作集"><a href="#5-4-“抖动”与工作集" class="headerlink" title="5.4 “抖动”与工作集"></a>5.4 “抖动”与工作集</h3><h3 id="5-5-请求分段存储管理方式"><a href="#5-5-请求分段存储管理方式" class="headerlink" title="5.5 请求分段存储管理方式"></a>5.5 请求分段存储管理方式</h3><h2 id="6、输入输出系统"><a href="#6、输入输出系统" class="headerlink" title="6、输入输出系统"></a>6、输入输出系统</h2><h3 id="6-1-I-x2F-O-系统的功能、模型和接口"><a href="#6-1-I-x2F-O-系统的功能、模型和接口" class="headerlink" title="6.1 I&#x2F;O 系统的功能、模型和接口"></a>6.1 I&#x2F;O 系统的功能、模型和接口</h3><h3 id="6-2-I-x2F-O-设备和设备控制器"><a href="#6-2-I-x2F-O-设备和设备控制器" class="headerlink" title="6.2 I&#x2F;O 设备和设备控制器"></a>6.2 I&#x2F;O 设备和设备控制器</h3><h3 id="6-3-中断机构和中断处理程序"><a href="#6-3-中断机构和中断处理程序" class="headerlink" title="6.3 中断机构和中断处理程序"></a>6.3 中断机构和中断处理程序</h3><h3 id="6-4-设备驱动程序"><a href="#6-4-设备驱动程序" class="headerlink" title="6.4 设备驱动程序"></a>6.4 设备驱动程序</h3><h3 id="6-5-与设备无关的-I-x2F-O-软件"><a href="#6-5-与设备无关的-I-x2F-O-软件" class="headerlink" title="6.5 与设备无关的 I&#x2F;O 软件"></a>6.5 与设备无关的 I&#x2F;O 软件</h3><h3 id="6-6-用户层的-I-x2F-O-软件"><a href="#6-6-用户层的-I-x2F-O-软件" class="headerlink" title="6.6 用户层的 I&#x2F;O 软件"></a>6.6 用户层的 I&#x2F;O 软件</h3><h3 id="6-7-缓冲区管理"><a href="#6-7-缓冲区管理" class="headerlink" title="6.7 缓冲区管理"></a>6.7 缓冲区管理</h3><h3 id="6-8-磁盘存储器的性能和调度"><a href="#6-8-磁盘存储器的性能和调度" class="headerlink" title="6.8 磁盘存储器的性能和调度"></a>6.8 磁盘存储器的性能和调度</h3><h2 id="7、文件管理"><a href="#7、文件管理" class="headerlink" title="7、文件管理"></a>7、文件管理</h2><h3 id="7-1-文件和文件系统"><a href="#7-1-文件和文件系统" class="headerlink" title="7.1 文件和文件系统"></a>7.1 文件和文件系统</h3><h3 id="7-2-文件的逻辑结构"><a href="#7-2-文件的逻辑结构" class="headerlink" title="7.2 文件的逻辑结构"></a>7.2 文件的逻辑结构</h3><h3 id="7-3-文件目录"><a href="#7-3-文件目录" class="headerlink" title="7.3 文件目录"></a>7.3 文件目录</h3><h3 id="7-4-文件共享"><a href="#7-4-文件共享" class="headerlink" title="7.4 文件共享"></a>7.4 文件共享</h3><h3 id="7-5-文件保护"><a href="#7-5-文件保护" class="headerlink" title="7.5 文件保护"></a>7.5 文件保护</h3><h2 id="8、磁盘存储器的管理"><a href="#8、磁盘存储器的管理" class="headerlink" title="8、磁盘存储器的管理"></a>8、磁盘存储器的管理</h2><h3 id="8-1-外存的组织方式"><a href="#8-1-外存的组织方式" class="headerlink" title="8.1 外存的组织方式"></a>8.1 外存的组织方式</h3><h3 id="8-2-文件存储空间的管理"><a href="#8-2-文件存储空间的管理" class="headerlink" title="8.2 文件存储空间的管理"></a>8.2 文件存储空间的管理</h3><h3 id="8-3-提高磁盘-I-x2F-O-速度的途径"><a href="#8-3-提高磁盘-I-x2F-O-速度的途径" class="headerlink" title="8.3 提高磁盘 I&#x2F;O 速度的途径"></a>8.3 提高磁盘 I&#x2F;O 速度的途径</h3><h3 id="8-4-提高磁盘可靠性的技术"><a href="#8-4-提高磁盘可靠性的技术" class="headerlink" title="8.4 提高磁盘可靠性的技术"></a>8.4 提高磁盘可靠性的技术</h3><h3 id="8-5-数据一致性控制"><a href="#8-5-数据一致性控制" class="headerlink" title="8.5 数据一致性控制"></a>8.5 数据一致性控制</h3><h2 id="9、操作系统接口"><a href="#9、操作系统接口" class="headerlink" title="9、操作系统接口"></a>9、操作系统接口</h2><h3 id="9-1-用户接口"><a href="#9-1-用户接口" class="headerlink" title="9.1 用户接口"></a>9.1 用户接口</h3><h3 id="9-2-Shell命令语言"><a href="#9-2-Shell命令语言" class="headerlink" title="9.2 Shell命令语言"></a>9.2 Shell命令语言</h3><h3 id="9-3-联机命令接口的实现"><a href="#9-3-联机命令接口的实现" class="headerlink" title="9.3 联机命令接口的实现"></a>9.3 联机命令接口的实现</h3><h3 id="9-4-系统调用的概念和类型"><a href="#9-4-系统调用的概念和类型" class="headerlink" title="9.4 系统调用的概念和类型"></a>9.4 系统调用的概念和类型</h3><h3 id="9-5-UNIX系统调用"><a href="#9-5-UNIX系统调用" class="headerlink" title="9.5 UNIX系统调用"></a>9.5 UNIX系统调用</h3><h3 id="9-6-系统调用的实现"><a href="#9-6-系统调用的实现" class="headerlink" title="9.6 系统调用的实现"></a>9.6 系统调用的实现</h3><p><strong><u>参考书目： 《计算机操作系统（第四版）》汤小丹、梁红兵、哲凤屏、汤子瀛，西安电子科技大学出版社</u></strong> </p>]]></content>
      
      
      <categories>
          
          <category> 考研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/FRank675.github.io/posts/6ba94eb7cefa/"/>
      <url>/FRank675.github.io/posts/6ba94eb7cefa/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>在实习的经历中，我的leader是个非常喜欢复盘、反思的人，向他学习，在这里反思自己的缺点，希望可以监督自己修改吧</p><h2 id="拖延症"><a href="#拖延症" class="headerlink" title="拖延症"></a>拖延症</h2><p><strong>具体表现：</strong>经常把事情拖延到ddl前才匆忙把事情做完，导致自己难受也使得事情做的不好不完善；每次都想着提前做完，但是总是拖延，没有给自己规定一个时间去完成，导致拖拖拉拉。</p><p><strong>解决办法：</strong>提前规划，比如说下周一要截至的任务，把它提前到这周六，提前完成任务，一方面给自己成就感，另一方面避免因为拖延而导致任务无法及时完成。</p><h2 id="意志力不够坚定"><a href="#意志力不够坚定" class="headerlink" title="意志力不够坚定"></a>意志力不够坚定</h2><p><strong>具体表现：</strong>在做一件事情的时候，遇到一点阻力就想放弃，阻力常常表现为不熟悉的领域、不确定的结论、不充足的时间，导致事情越来越糟糕。</p><p><strong>解决办法：</strong></p><h2 id="懒散"><a href="#懒散" class="headerlink" title="懒散"></a>懒散</h2><p><strong>具体表现：</strong>间歇性踌躇满志，持续性混吃等死。心里是对美好的未来有憧憬的，但是经常无法坚持，会间歇地努力几天，但是没办法一直坚持，容易思想懒散。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hdw-dubbo微服务开发平台-搭建记录</title>
      <link href="/FRank675.github.io/posts/47cf844ae0b7/"/>
      <url>/FRank675.github.io/posts/47cf844ae0b7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="DUBBO系统搭建"><a href="#DUBBO系统搭建" class="headerlink" title="DUBBO系统搭建"></a>DUBBO系统搭建</h1><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><ul><li>hdw-dubbo微服务开发平台，具有统一授权、认证后台管理系统，其中包含具备用户管理、资源权限管理等多个模块，支持多业务系统并行开发，可以作为后端服务的开发脚手架。代码简洁，架构清晰，适合学习和直接项目中使用。</li><li>核心技术采用SpringBoot、Dubbo、Mybatis、Mybatis-plus、Druid、Redis、ActiveMQ、Quartz、JWT Token等主要框架和中间件。前端采用vue-element-ui组件。</li><li>前后端分离，通过token进行数据交互，可独立部署</li><li>灵活的权限控制，可控制到页面或按钮，满足绝大部分的权限需求</li><li>页面交互使用Vue2.x，极大的提高了开发效率</li><li>完善的代码生成机制，可在线生成entity、xml、dao、service、vue、sql代码，减少70%以上的开发任务</li><li>引入dubbo服务治理</li><li>引入quartz定时任务，可动态完成任务的添加、修改、删除、暂停、恢复及日志查看等功能</li><li>引入API模板，根据token作为登录令牌，极大的方便了APP接口开发</li><li>引入Hibernate Validator校验框架，轻松实现后端校验</li><li>引入swagger文档支持，方便编写API接口文档</li></ul><h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><table><thead><tr><th>平台</th><th>hdw-dubbo（后端）</th><th>hdw-dubbo-ui（前端）</th></tr></thead><tbody><tr><td>GitHub</td><td><a href="https://gitee.com/link?target=https://github.com/JacksonTu/hdw-dubbo">https://github.com/JacksonTu/hdw-dubbo</a></td><td><a href="https://gitee.com/link?target=https://github.com/JacksonTu/hdw-dubbo-ui">https://github.com/JacksonTu/hdw-dubbo-ui</a></td></tr><tr><td>Gitee</td><td><a href="https://gitee.com/tumao2/hdw-dubbo">https://gitee.com/tumao2/hdw-dubbo</a></td><td><a href="https://gitee.com/tumao2/hdw-dubbo-ui">https://gitee.com/tumao2/hdw-dubbo-ui</a></td></tr></tbody></table><h2 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h2><h3 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h3><ul><li>Java1.8 (v1.8.0_131+)</li><li>Nacos服务发现和注册中心(v1.4.2+)<a href="https://gitee.com/link?target=https://github.com/alibaba/nacos/releases/download/2.0.3/nacos-server-2.0.3.zip">下载地址</a></li><li>Redis (v3.2.100+)</li><li>ActiveMQ(v5.15.8+)<a href="https://gitee.com/link?target=http://activemq.apache.org/components/classic/download/">下载地址</a></li><li>RabbitMq (v3.7+)（需安装rabbitmq_delayed_message_exchange插件 <a href="https://gitee.com/link?target=https://www.rabbitmq.com/community-plugins.html">下载地址</a>）</li><li>Mysql (v5.7.26+)</li><li>Maven (v3+)</li><li>Nodejs (v10.16.0+)</li></ul><h3 id="后端配置"><a href="#后端配置" class="headerlink" title="后端配置"></a>后端配置</h3><h4 id="数据库配置"><a href="#数据库配置" class="headerlink" title="数据库配置"></a>数据库配置</h4><p>数据库sql文件：后端项目下的docs&#x2F;sql&#x2F;hdw_dubbo.sql</p><p>1.进入MySQL：mysql -u root -p (其中root是指我们的数据库用户名为root，后续可视具体情况修改)</p><p>然后输入密码Anxin@123即可进入数据库</p><p>2.进入数据库后创建数据库hdw_dubbo；</p><p>执行create database hdw_dubbo; （分号别漏了）</p><p>3.修改所有的涉及到Mysql的yml文件（可以全局搜索driver-class-name来定位），</p><p>修改为如下内容：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">jdbc:mysql://172.21.3.144:3306/hdw_dubbo?autoReconnect=true&amp;useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line"><span class="attr">username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">Anxin@123</span></span><br></pre></td></tr></table></figure><h4 id="Redis配置"><a href="#Redis配置" class="headerlink" title="Redis配置"></a>Redis配置</h4><p>修改yml文件中的redis配置，参考如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">redis:</span></span><br><span class="line">  <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">host:</span> <span class="number">172.21</span><span class="number">.6</span><span class="number">.217</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">gxltest123</span></span><br><span class="line">  <span class="attr">timeout:</span> <span class="string">3600ms</span></span><br><span class="line">  <span class="comment">#    cluster:</span></span><br><span class="line">  <span class="comment">#      max-redirects: 3</span></span><br><span class="line">  <span class="comment">#      nodes: 127.0.0.1:7000, 127.0.0.1:7001, 127.0.0.1:7002, 127.0.0.1:7003, 127.0.0.1:7004,127.0.0.1:7005</span></span><br><span class="line">  <span class="attr">lettuce:</span></span><br><span class="line">    <span class="attr">pool:</span></span><br><span class="line">      <span class="attr">max-active:</span> <span class="number">100</span></span><br><span class="line">      <span class="attr">max-idle:</span> <span class="number">100</span></span><br><span class="line">      <span class="attr">min-idle:</span> <span class="number">50</span></span><br><span class="line">      <span class="attr">max-wait:</span> <span class="string">6000ms</span></span><br><span class="line">    <span class="attr">shutdown-timeout:</span> <span class="string">100ms</span></span><br></pre></td></tr></table></figure><h4 id="Nacos配置"><a href="#Nacos配置" class="headerlink" title="Nacos配置"></a>Nacos配置</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cloud:</span></span><br><span class="line">  <span class="attr">nacos:</span></span><br><span class="line">    <span class="attr">discovery:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">172.21</span><span class="number">.2</span><span class="number">.198</span><span class="string">:8848</span></span><br></pre></td></tr></table></figure><h4 id="dubbo配置"><a href="#dubbo配置" class="headerlink" title="dubbo配置"></a>dubbo配置</h4><p>只要修改registry即可，主要是修改address：将其中的ip改完你的nacos地址</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">registry:</span></span><br><span class="line">  <span class="attr">id:</span> <span class="string">hdw-registry</span></span><br><span class="line">  <span class="attr">address:</span> <span class="string">spring-cloud://172.21.2.198</span></span><br><span class="line">  <span class="attr">file:</span> <span class="string">/output/cache/$&#123;dubbo.application.id&#125;.cache</span></span><br><span class="line">  <span class="attr">timeout:</span> <span class="number">5000</span></span><br><span class="line">  <span class="attr">session:</span> <span class="number">60000</span></span><br><span class="line">  <span class="attr">check:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>修改完这些配置后，初始化maven项目：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn clean</span><br><span class="line">mvn package</span><br></pre></td></tr></table></figure><p>得到的jar包可以在docker目录下看到</p><p>将项目传输到&#x2F;root&#x2F;gxl&#x2F;dubbo目录下（172.21.1.189）</p><p>依次执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nohup java -jar /root/gxl/dubbo/hdw-dubbo-master/docker/sever-base/hdw-server-base.jar &amp;</span><br><span class="line">nohup java -jar /root/gxl/dubbo/hdw-dubbo-master/docker/server-notice/hdw-server-notice.jar &amp;</span><br><span class="line">nohup java -jar /root/gxl/dubbo/hdw-dubbo-master/docker/web-base/hdw-web-base.jar &amp;</span><br></pre></td></tr></table></figure><p>需要注意必须依次执行，且必须保证前一个jar包执行完毕才能执行下一个</p><p>可以通过命令查看jar包执行情况：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tail -f nohup.out</span><br></pre></td></tr></table></figure><p>需要注意的是：部署该系统时需要打开外网！</p><p>以下是部署后端时可能遇到的问题以及尝试可行的解决办法：</p><p>报错：[com.alibaba.dubbo.config.AbstractConfig|]-[WARN] [DUBBO] Connection refused,</p><p><a href="https://github.com/alibaba/spring-cloud-alibaba/issues/1243">dubbo. registry.address:配置spring-cloud:&#x2F;&#x2F;localhost或者不配置启动会报错，但最终能注册成功 · Issue #1243 · alibaba&#x2F;spring-cloud-alibaba · GitHub</a></p><p><a href="https://blog.csdn.net/u014636209/article/details/88983118?spm=1001.2101.3001.6650.3&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-3-88983118-blog-103926113.235%5Ev28%5Epc_relevant_t0_download&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-3-88983118-blog-103926113.235%5Ev28%5Epc_relevant_t0_download&amp;utm_relevant_index=4">https://blog.csdn.net/u014636209/article/details/88983118?spm=1001.2101.3001.6650.3&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-3-88983118-blog-103926113.235%5Ev28%5Epc_relevant_t0_download&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-3-88983118-blog-103926113.235%5Ev28%5Epc_relevant_t0_download&amp;utm_relevant_index=4</a></p><h3 id="前端配置"><a href="#前端配置" class="headerlink" title="前端配置"></a>前端配置</h3><p>1.安装淘宝NPM镜像</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line">npm config set registry  https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>2.将locallhost换成本地IP地址，具体操作参考如下：</p><p><a href="https://blog.csdn.net/weixin_41620505/article/details/123229597">(115条消息) vue2 配置本地IP地址访问项目_can be overwritten by process.env.host_夢鑰的博客-CSDN博客</a></p><p>4.修改请求接口地址</p><p>简单操作，可以直接搜索localhost，将包括的接口里的localhost全部修改为172.21.1.189，即你要部署的服务器的ip地址</p><p>3.运行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cnpm install </span><br><span class="line">npm run dev</span><br><span class="line">npm run build  #打包</span><br></pre></td></tr></table></figure><p>打包后可以得到dist文件</p><p>将前端项目传输到&#x2F;root&#x2F;gxl&#x2F;dubbo路径下（172.21.1.189）</p><p>执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nohup npm start &amp;</span><br></pre></td></tr></table></figure><p>等待部署完成后即可</p><p>以下是部署前端时可能遇到的问题以及尝试可行的解决办法：</p><p>前端node-sass安装失败，请关注node-sass和node版本的对应关系</p><p><a href="https://blog.csdn.net/fwdwqdwq/article/details/123191380?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-4-123191380-blog-129423760.235%5Ev28%5Epc_relevant_t0_download&spm=1001.2101.3001.4242.3&utm_relevant_index=7">(115条消息) node node-sass sass-loader版本对应问题_查看nodesass版本_普通网友的博客-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 系统搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/FRank675.github.io/posts/c77bbda04774/"/>
      <url>/FRank675.github.io/posts/c77bbda04774/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="本科毕业设计（论文）"><a href="#本科毕业设计（论文）" class="headerlink" title="本科毕业设计（论文）"></a><strong>本科毕业设计（论文）</strong></h1><p>[TOC]</p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><h2 id="1引言"><a href="#1引言" class="headerlink" title="1引言"></a>1引言</h2><h3 id="1-1写作背景"><a href="#1-1写作背景" class="headerlink" title="1.1写作背景"></a>1.1写作背景</h3><h3 id="1-2国内外研究现状"><a href="#1-2国内外研究现状" class="headerlink" title="1.2国内外研究现状"></a>1.2国内外研究现状</h3><h4 id="1-2-1传统路面检测方法"><a href="#1-2-1传统路面检测方法" class="headerlink" title="1.2.1传统路面检测方法"></a>1.2.1传统路面检测方法</h4><h4 id="1-2-2基于机器视觉的路面检测方法"><a href="#1-2-2基于机器视觉的路面检测方法" class="headerlink" title="1.2.2基于机器视觉的路面检测方法"></a>1.2.2基于机器视觉的路面检测方法</h4><h4 id="1-2-3基于道路设备传感器的路面检测方法"><a href="#1-2-3基于道路设备传感器的路面检测方法" class="headerlink" title="1.2.3基于道路设备传感器的路面检测方法"></a>1.2.3基于道路设备传感器的路面检测方法</h4><h3 id="1-3群智感知"><a href="#1-3群智感知" class="headerlink" title="1.3群智感知"></a>1.3群智感知</h3><h3 id="1-4基于加速度传感器的道路状况分析"><a href="#1-4基于加速度传感器的道路状况分析" class="headerlink" title="1.4基于加速度传感器的道路状况分析"></a>1.4基于加速度传感器的道路状况分析</h3><h3 id="1-5研究设想"><a href="#1-5研究设想" class="headerlink" title="1.5研究设想"></a>1.5研究设想</h3><h3 id="1-6本文内容与结构"><a href="#1-6本文内容与结构" class="headerlink" title="1.6本文内容与结构"></a>1.6本文内容与结构</h3><h3 id="1-7本章小结"><a href="#1-7本章小结" class="headerlink" title="1.7本章小结"></a>1.7本章小结</h3><h2 id="2相关技术及算法概述"><a href="#2相关技术及算法概述" class="headerlink" title="2相关技术及算法概述"></a>2相关技术及算法概述</h2><h3 id="2-1加速度传感器"><a href="#2-1加速度传感器" class="headerlink" title="2.1加速度传感器"></a>2.1加速度传感器</h3><h3 id="2-2全球定位系统"><a href="#2-2全球定位系统" class="headerlink" title="2.2全球定位系统"></a>2.2全球定位系统</h3><h3 id="2-3卡尔曼滤波"><a href="#2-3卡尔曼滤波" class="headerlink" title="2.3卡尔曼滤波"></a>2.3卡尔曼滤波</h3><h3 id="2-4k-means-算法"><a href="#2-4k-means-算法" class="headerlink" title="2.4k-means++算法"></a>2.4k-means++算法</h3><h3 id="2-5DBSCAN算法"><a href="#2-5DBSCAN算法" class="headerlink" title="2.5DBSCAN算法"></a>2.5DBSCAN算法</h3><h3 id="2-6BP神经网络"><a href="#2-6BP神经网络" class="headerlink" title="2.6BP神经网络"></a>2.6BP神经网络</h3><h2 id="3实验设备与前期准备"><a href="#3实验设备与前期准备" class="headerlink" title="3实验设备与前期准备"></a>3实验设备与前期准备</h2><h3 id="3-1手机选取"><a href="#3-1手机选取" class="headerlink" title="3.1手机选取"></a>3.1手机选取</h3><h3 id="3-2车辆选取"><a href="#3-2车辆选取" class="headerlink" title="3.2车辆选取"></a>3.2车辆选取</h3><h3 id="3-3路线选择"><a href="#3-3路线选择" class="headerlink" title="3.3路线选择"></a>3.3路线选择</h3><h3 id="3-4数据采集终端"><a href="#3-4数据采集终端" class="headerlink" title="3.4数据采集终端"></a>3.4数据采集终端</h3><h2 id="4实验设计"><a href="#4实验设计" class="headerlink" title="4实验设计"></a>4实验设计</h2><h3 id="4-1数据收集"><a href="#4-1数据收集" class="headerlink" title="4.1数据收集"></a>4.1数据收集</h3><h3 id="4-2数据处理"><a href="#4-2数据处理" class="headerlink" title="4.2数据处理"></a>4.2数据处理</h3><h3 id="4-3数据分析"><a href="#4-3数据分析" class="headerlink" title="4.3数据分析"></a>4.3数据分析</h3><h4 id="4-3-1K-means-聚类分析"><a href="#4-3-1K-means-聚类分析" class="headerlink" title="4.3.1K-means++聚类分析"></a>4.3.1K-means++聚类分析</h4><h4 id="4-3-2BP神经网络"><a href="#4-3-2BP神经网络" class="headerlink" title="4.3.2BP神经网络"></a>4.3.2BP神经网络</h4><h4 id="4-3-3DBSCAN聚类"><a href="#4-3-3DBSCAN聚类" class="headerlink" title="4.3.3DBSCAN聚类"></a>4.3.3DBSCAN聚类</h4><h3 id="4-4结果验证"><a href="#4-4结果验证" class="headerlink" title="4.4结果验证"></a>4.4结果验证</h3><h4 id="4-4-1与实际道路状况对比"><a href="#4-4-1与实际道路状况对比" class="headerlink" title="4.4.1与实际道路状况对比"></a>4.4.1与实际道路状况对比</h4><h4 id="4-4-2道路状况感知系统展示"><a href="#4-4-2道路状况感知系统展示" class="headerlink" title="4.4.2道路状况感知系统展示"></a>4.4.2道路状况感知系统展示</h4><h2 id="5结论与展望"><a href="#5结论与展望" class="headerlink" title="5结论与展望"></a>5结论与展望</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><h2 id="致-谢"><a href="#致-谢" class="headerlink" title="致   谢"></a>致   谢</h2><h2 id="参考文献-1"><a href="#参考文献-1" class="headerlink" title="参考文献"></a>参考文献</h2><h3 id="注意力机制"><a href="#注意力机制" class="headerlink" title="注意力机制"></a>注意力机制</h3><p>Graph Attention Networks</p><p> [<a href="https://arxiv.org/abs/1710.10903">1710.10903] Graph Attention Networks (arxiv.org)</a> </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>软件能效平台-搭建记录</title>
      <link href="/FRank675.github.io/posts/e3ba0bc0895e/"/>
      <url>/FRank675.github.io/posts/e3ba0bc0895e/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="Software-Engineering-Productivity-Platform"><a href="#Software-Engineering-Productivity-Platform" class="headerlink" title="Software Engineering Productivity Platform"></a>Software Engineering Productivity Platform</h1><h1 id="软件能效平台"><a href="#软件能效平台" class="headerlink" title="软件能效平台"></a>软件能效平台</h1><h2 id="系统介绍"><a href="#系统介绍" class="headerlink" title="系统介绍"></a>系统介绍</h2><p>基于Vue2、Element UI、SpringBoot框架，用于软件研发流程管理支持以及其过程数据分析度量、质量保证技术的集成</p><h2 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h2><p>前端：<a href="https://github.com/purang-fintech/seppf.git">https://github.com/purang-fintech/seppf.git</a><br>后端：<a href="https://github.com/purang-fintech/seppb.git">https://github.com/purang-fintech/seppb.git</a></p><h2 id="配置教程"><a href="#配置教程" class="headerlink" title="配置教程"></a>配置教程</h2><h3 id="数据库配置"><a href="#数据库配置" class="headerlink" title="数据库配置"></a>数据库配置</h3><p>（服务器ip：172.21.3.144；MySQL登录账户密码：root Anxin@123）</p><p>1.进入MySQL：mysql -u root -p (其中root是指我们的数据库用户名为root，后续可视具体情况修改)</p><p>然后输入密码Anxin@123即可进入数据库</p><p>2.进入数据库后执行create database sepp; （分号别漏了）</p><p>3.修改spring.properties文件，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jdbc.url=jdbc:mysql:<span class="comment">//172.21.3.144:3306/sepp？useUnicode=true&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;autoReconnect=true&amp;useSSL=false jdbc.username=root jdbc.password=Anxin@123</span></span><br></pre></td></tr></table></figure><p>需要注意的是，由于原作者数据库使用的账户密码是加密后的，所以在后续调用时会进行解密，我们使用的是未加密的所以不需要解密这一步，因此需执行以下操作</p><p>修改src&#x2F;main&#x2F;java&#x2F;com&#x2F;pr&#x2F;sepp&#x2F;common&#x2F;config&#x2F;factory&#x2F;DefinitionPropertySourceFactory.java文件，</p><p>将buildDecryptProperties方法修改为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Properties <span class="title function_">buildDecryptProperties</span><span class="params">(InputStream inputStream)</span> <span class="keyword">throws</span> IOException &#123; <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>(); properties.load(inputStream); properties.setProperty(JDBC_UNAME_PROP, properties.getProperty(JDBC_UNAME_PROP)); properties.setProperty(JDBC_PWD_PROP,properties.getProperty(JDBC_PWD_PROP));                                                                                                       <span class="keyword">return</span> properties; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>4.数据库文件导入</p><p>将conf&#x2F;database&#x2F;whole目录下的两个sql文件sepp_ddl.sql和sepp_dml.sql文件传输到机器172.21.3.144 gxl目录下，cd ~&#x2F;gxl，执行mysql -u root -p，输入密码，然后执行以下命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use sepp；</span><br><span class="line"></span><br><span class="line">source sepp_ddl.sql;</span><br><span class="line"></span><br><span class="line">source sepp_dml.sql;</span><br></pre></td></tr></table></figure><p>至此则将数据库导入并建立好表</p><p>5.若数据库库版本较高（大于7），则需要以下操作：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select @@global.sql_mode</span><br><span class="line"></span><br><span class="line">set global sql_mode=&#x27;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#x27;; </span><br></pre></td></tr></table></figure><p>但该方法在重启Mysql服务后会失效，重启服务后会失效，需要重复进行该操作</p><h3 id="前端配置"><a href="#前端配置" class="headerlink" title="前端配置"></a>前端配置</h3><p>node版本：v12.22.10</p><p>npm版本：6.14.16</p><p>进入node官网 node.js官网 选择v12.22.10下载安装node，具体配置参考(102条消息) node.js和npm的安装与环境配置（2021最新版）安装npm小绵杨Yancy的博客-CSDN博客</p><p>安装后可以在控制台输入node -v以及npm -v查看是否安装成功</p><p>安装成功后执行npm install</p><p>将config&#x2F;dev.env.js中的ROOT_URL修改为你的后端接口，<a href="http://172.18.0.64:8082/sepp/">http://172.18.0.64:8082/sepp/</a></p><p>将config&#x2F;prod.env.js中的ROOT_URL修改为你的后端接口，<a href="http://172.18.0.64:8082/sepp/">http://172.18.0.64:8082/sepp/</a></p><p>将前端项目传输到172.21.1.189的&#x2F;root&#x2F;gxl&#x2F;seppf-master路径下</p><p>在&#x2F;root&#x2F;gxl&#x2F;seppf-master路径下执行</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">nohup npm start &amp;</span><br></pre></td></tr></table></figure><p>至此前端配置完成</p><h3 id="后端配置"><a href="#后端配置" class="headerlink" title="后端配置"></a>后端配置</h3><p>修改日志文件路径：</p><p>修改src&#x2F;main&#x2F;java&#x2F;com&#x2F;pr&#x2F;sepp&#x2F;common&#x2F;config&#x2F;factory&#x2F;DefinitionPropertySourceFactory.java的postProcessEnvironment方法默认路径，”&#x2F;opt&#x2F;sqcs_backend&#x2F;spring.properties”，没有的话需要自己创建目录</p><p>在quartz添加节点</p><p>修改pom.xml文件，ctr+F搜索quartz，在quartz的exclusions节点下添加如下代码：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zaxxer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>HikariCP-java7<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br></pre></td></tr></table></figure><p>执行mvn clean package，得到jar包sepp-1.0.jar</p><p>将后端项目传输到172.21.1.189的&#x2F;root&#x2F;gxl&#x2F;seppb-master路径下</p><p>在根目录下创建目录&#x2F;opt&#x2F;sqcs_backend，执行以下目录</p><p>cd &#x2F;</p><p>mkdir -r &#x2F;opt&#x2F;sqcs_backend</p><p>然后启动</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">nohup java -jar /root/gxl/seppb-master/target/sepp-<span class="number">1.0</span>.jar &amp;</span><br></pre></td></tr></table></figure><p>在谷歌浏览器中打开 <a href="http://http//172.21.1.189/:8080">http://http://172.21.1.189/:8080</a></p>]]></content>
      
      
      <categories>
          
          <category> 系统搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令——touch命令</title>
      <link href="/FRank675.github.io/posts/d98ea350b62e/"/>
      <url>/FRank675.github.io/posts/d98ea350b62e/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="Linux命令——touch命令"><a href="#Linux命令——touch命令" class="headerlink" title="Linux命令——touch命令"></a>Linux命令——touch命令</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>touch命令用于修改文件或者目录的时间属性，包括访问时间、状态更改时间和内容修改时间。</p><p>默认情况，若文件不存在，系统会建立一个新的文件。</p><h2 id="2-命令格式"><a href="#2-命令格式" class="headerlink" title="2.命令格式"></a>2.命令格式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">touch [<span class="variable constant_">OPTION</span>]... <span class="variable constant_">FILE</span>...</span><br></pre></td></tr></table></figure><h2 id="3-选项说明"><a href="#3-选项说明" class="headerlink" title="3.选项说明"></a>3.选项说明</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">-a：改变档案的访问时间。</span><br><span class="line">-c,--no-create：假如目的档案不存在，不会建立新的档案。</span><br><span class="line">-d, --date=<span class="variable constant_">STRING</span>：使用指定的时间修改文件时间属性，而非当前时间。</span><br><span class="line">-f：不使用，是为了与其他<span class="title class_">Unix</span>系统的相容性而保留。</span><br><span class="line">-h, --no-dereference：只改变符号链接的时间属性，而不是链接的文件。</span><br><span class="line">-m：改变档案的修改时间。</span><br><span class="line">-r,--reference=<span class="variable constant_">FILE</span>：使用参考档的时间记录，而不是当前时间。</span><br><span class="line">-t <span class="variable constant_">STAMP</span>：设定档案的时间记录，格式与date指令相同。</span><br><span class="line">--help 列出指令格式。</span><br><span class="line">--version 列出版本信息。</span><br></pre></td></tr></table></figure><h2 id="4-常用示例"><a href="#4-常用示例" class="headerlink" title="4.常用示例"></a>4.常用示例</h2><h3 id="（1）改变文件为当前系统时间。"><a href="#（1）改变文件为当前系统时间。" class="headerlink" title="（1）改变文件为当前系统时间。"></a>（1）改变文件为当前系统时间。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">touch filename</span><br></pre></td></tr></table></figure><h3 id="（2）如果目标文件不存在，则新建一个文件"><a href="#（2）如果目标文件不存在，则新建一个文件" class="headerlink" title="（2）如果目标文件不存在，则新建一个文件"></a>（2）如果目标文件不存在，则新建一个文件</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">touch filename</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令——sed命令</title>
      <link href="/FRank675.github.io/posts/86e40a8114e1/"/>
      <url>/FRank675.github.io/posts/86e40a8114e1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="Linux命令——sed命令"><a href="#Linux命令——sed命令" class="headerlink" title="Linux命令——sed命令"></a>Linux命令——sed命令</h1><h2 id="1-功能简介"><a href="#1-功能简介" class="headerlink" title="1.功能简介"></a>1.功能简介</h2><p>sed(Stream EDitor)是一种流文件编辑器，它一次处理一行内容。</p><p>处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。</p><p>接着处理下一行，直到文件末尾。文件内容并没有改变，除非使用-i选项。sed主要用来编辑一个或多个文件，简化对文件的反复操作或者用来编写转换程序等。</p><p>sed功能同awk类似，差别在于，sed简单，对列处理的功能要差一些，awk功能复杂，对列处理的功能比较强大。</p><h2 id="2-命令格式"><a href="#2-命令格式" class="headerlink" title="2.命令格式"></a>2.命令格式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sed [-nefr] [动作]</span><br></pre></td></tr></table></figure><h2 id="3-选项说明"><a href="#3-选项说明" class="headerlink" title="3.选项说明"></a>3.选项说明</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">选项：</span><br><span class="line">-n,--quiet,--silent：使用安静模式。sed的一般用法中，所有来自<span class="variable constant_">STDIN</span> 的数据一般都会被打印到终端上，如果加上-n后，则只有经过sed特殊处理的那一行(或者动作)才会被列出来。</span><br><span class="line">-e &lt;script&gt;,--expression=&lt;script&gt;：将脚本文件作为sed的命令来执行；</span><br><span class="line">-f &lt;script-file&gt;,--file=&lt;script-file&gt;：直接将sed的动作写在一个文件内，-f filename则可以运行filename 内的sed动作；</span><br><span class="line">-r,--regexp-extended：sed支持扩展正则表达式(默认是基础正则表达式)。</span><br><span class="line">-i ：直接修改读取的文件内容，而不是输出到终端。</span><br><span class="line">--help：显示帮助。</span><br><span class="line">--version：显示版本。</span><br><span class="line"></span><br><span class="line">动作说明：[n1[,n2]]<span class="keyword">function</span></span><br><span class="line">n1, n2 ：不见得会存在，一般代表『选择进行动作的行数』，举例来说，如果我的动作是需要在 <span class="number">10</span> 到 <span class="number">20</span> 行之间进行的，则『 <span class="number">10</span>,<span class="number">20</span>[动作行为] 』</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>：</span><br><span class="line">a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～</span><br><span class="line">c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！</span><br><span class="line">d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；</span><br><span class="line">i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；</span><br><span class="line">p ：列印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～</span><br><span class="line">s ：替换，通常这个s的动作可以搭配正规表示法！例如 <span class="number">1</span>,20s/old/<span class="keyword">new</span>/g。</span><br></pre></td></tr></table></figure><h2 id="4-典型示例"><a href="#4-典型示例" class="headerlink" title="4.典型示例"></a>4.典型示例</h2><h3 id="4-1删除行操作"><a href="#4-1删除行操作" class="headerlink" title="4.1删除行操作"></a>4.1删除行操作</h3><h4 id="（1）将-x2F-etc-x2F-passwd-的内容列出并且列印行号，同时，请将第-2-5-行删除。"><a href="#（1）将-x2F-etc-x2F-passwd-的内容列出并且列印行号，同时，请将第-2-5-行删除。" class="headerlink" title="（1）将 &#x2F;etc&#x2F;passwd 的内容列出并且列印行号，同时，请将第 2~5 行删除。"></a>（1）将 &#x2F;etc&#x2F;passwd 的内容列出并且列印行号，同时，请将第 2~5 行删除。</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[b3335@<span class="variable constant_">MIC</span> ~]$ nl -n ln /etc/passwd | sed <span class="string">&#x27;2,5d&#x27;</span></span><br><span class="line"><span class="number">1</span> <span class="attr">root</span>:<span class="attr">x</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="attr">root</span>:<span class="regexp">/root:/</span>bin/bash</span><br><span class="line"><span class="number">6</span> <span class="attr">sync</span>:<span class="attr">x</span>:<span class="number">5</span>:<span class="number">0</span>:<span class="attr">sync</span>:<span class="regexp">/sbin:/</span>bin/sync</span><br><span class="line"><span class="number">7</span> <span class="attr">shutdown</span>:<span class="attr">x</span>:<span class="number">6</span>:<span class="number">0</span>:<span class="attr">shutdown</span>:<span class="regexp">/sbin:/</span>sbin/shutdown</span><br><span class="line">.....(后面省略).....</span><br></pre></td></tr></table></figure><p>注意：原本应该是要下达 sed -e 才对，当只有一个动作的时候，没有 -e 也行，但是多于一个动作时必须要使用-e选项来指定动作。同时也要注意的是， sed 后面接的动作，请务必以两个单引号括住。</p><h4 id="（2）只要删除第-2-行。"><a href="#（2）只要删除第-2-行。" class="headerlink" title="（2）只要删除第 2 行。"></a>（2）只要删除第 2 行。</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">nl /etc/passwd | sed <span class="string">&#x27;2d&#x27;</span> </span><br></pre></td></tr></table></figure><h4 id="（3）要删除第-3-到最后一行"><a href="#（3）要删除第-3-到最后一行" class="headerlink" title="（3）要删除第 3 到最后一行"></a>（3）要删除第 3 到最后一行</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">nl /etc/passwd | sed <span class="string">&#x27;3,$d&#x27;</span> </span><br></pre></td></tr></table></figure><h3 id="4-2新增行操作"><a href="#4-2新增行操作" class="headerlink" title="4.2新增行操作"></a>4.2新增行操作</h3><h4 id="（1）在第二行后加上”I-like-drinking-tea”。"><a href="#（1）在第二行后加上”I-like-drinking-tea”。" class="headerlink" title="（1）在第二行后加上”I like drinking tea”。"></a>（1）在第二行后加上”I like drinking tea”。</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[b3335@<span class="variable constant_">MIC</span> ~]$ nl -n ln /etc/passwd | sed <span class="string">&#x27;2a I like drinking tea&#x27;</span></span><br><span class="line"><span class="number">1</span>   <span class="attr">root</span>:<span class="attr">x</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="attr">root</span>:<span class="regexp">/root:/</span>bin/bash</span><br><span class="line"><span class="number">2</span>   <span class="attr">bin</span>:<span class="attr">x</span>:<span class="number">1</span>:<span class="number">1</span>:<span class="attr">bin</span>:<span class="regexp">/bin:/</span>sbin/nologin</span><br><span class="line">I like drinking tea</span><br><span class="line"><span class="number">3</span>   <span class="attr">daemon</span>:<span class="attr">x</span>:<span class="number">2</span>:<span class="number">2</span>:<span class="attr">daemon</span>:<span class="regexp">/sbin:/</span>sbin/nologin</span><br><span class="line">.....(后面省略).....</span><br></pre></td></tr></table></figure><h4 id="（2）那如果是要在第二行前加入。"><a href="#（2）那如果是要在第二行前加入。" class="headerlink" title="（2）那如果是要在第二行前加入。"></a>（2）那如果是要在第二行前加入。</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">nl /etc/passwd | sed <span class="string">&#x27;2i drink tea&#x27;</span></span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">nl /etc/passwd | sed <span class="string">&#x27;1a drink tea&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="（3）在第二行后面加入两行，”I-like-drinking-tea”与”I-like-drinking-beer”。"><a href="#（3）在第二行后面加入两行，”I-like-drinking-tea”与”I-like-drinking-beer”。" class="headerlink" title="（3）在第二行后面加入两行，”I like drinking tea”与”I like drinking beer”。"></a>（3）在第二行后面加入两行，”I like drinking tea”与”I like drinking beer”。</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[b3335@<span class="variable constant_">MIC</span> ~]$ nl -n ln /etc/passwd | sed <span class="string">&#x27;2a I like drinking tea\nI like drinking beer&#x27;</span></span><br><span class="line"><span class="number">1</span>       <span class="attr">root</span>:<span class="attr">x</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="attr">root</span>:<span class="regexp">/root:/</span>bin/bash</span><br><span class="line"><span class="number">2</span>       <span class="attr">bin</span>:<span class="attr">x</span>:<span class="number">1</span>:<span class="number">1</span>:<span class="attr">bin</span>:<span class="regexp">/bin:/</span>sbin/nologin</span><br><span class="line">I like drinking tea</span><br><span class="line">I like drinking beer</span><br><span class="line"><span class="number">3</span>       <span class="attr">daemon</span>:<span class="attr">x</span>:<span class="number">2</span>:<span class="number">2</span>:<span class="attr">daemon</span>:<span class="regexp">/sbin:/</span>sbin/nologin</span><br><span class="line">…（后面省略）…</span><br></pre></td></tr></table></figure><p>或者每一行使用反斜杠\来分开，就可以在命令行中将一条命令分开多行输入，如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[b3335@<span class="variable constant_">MIC</span> ~]$ nl -n ln /etc/passwd | sed <span class="string">&#x27;2a I like drinking tea\</span></span><br><span class="line"><span class="string">&gt; I like drinking beer&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="4-3替换行操作"><a href="#4-3替换行操作" class="headerlink" title="4.3替换行操作"></a>4.3替换行操作</h3><h4 id="（1）将第2-5行的内容替换成为”No-2-5-number”。"><a href="#（1）将第2-5行的内容替换成为”No-2-5-number”。" class="headerlink" title="（1）将第2-5行的内容替换成为”No 2-5 number”。"></a>（1）将第2-5行的内容替换成为”No 2-5 number”。</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[b3335@<span class="variable constant_">MIC</span> ~]$ nl -nln /etc/passwd | sed <span class="string">&#x27;2,5c No 2-5 number&#x27;</span></span><br><span class="line"><span class="number">1</span>       <span class="attr">root</span>:<span class="attr">x</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="attr">root</span>:<span class="regexp">/root:/</span>bin/bash</span><br><span class="line"><span class="title class_">No</span> <span class="number">2</span>-<span class="number">5</span> number</span><br><span class="line"><span class="number">6</span>       <span class="attr">sync</span>:<span class="attr">x</span>:<span class="number">5</span>:<span class="number">0</span>:<span class="attr">sync</span>:<span class="regexp">/sbin:/</span>bin/sync</span><br><span class="line">.....(后面省略).....</span><br></pre></td></tr></table></figure><h3 id="4-4选择行打印"><a href="#4-4选择行打印" class="headerlink" title="4.4选择行打印"></a>4.4选择行打印</h3><h4 id="（1）仅列出-x2F-etc-x2F-passwd-文件内的第-5-7-行。"><a href="#（1）仅列出-x2F-etc-x2F-passwd-文件内的第-5-7-行。" class="headerlink" title="（1）仅列出 &#x2F;etc&#x2F;passwd 文件内的第 5-7 行。"></a>（1）仅列出 &#x2F;etc&#x2F;passwd 文件内的第 5-7 行。</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[root@www ~]# nl -nln /etc/passwd | sed -n <span class="string">&#x27;5,7p&#x27;</span></span><br><span class="line"><span class="number">5</span> <span class="attr">lp</span>:<span class="attr">x</span>:<span class="number">4</span>:<span class="number">7</span>:<span class="attr">lp</span>:<span class="regexp">/var/</span>spool/<span class="attr">lpd</span>:<span class="regexp">/sbin/</span>nologin</span><br><span class="line"><span class="number">6</span> <span class="attr">sync</span>:<span class="attr">x</span>:<span class="number">5</span>:<span class="number">0</span>:<span class="attr">sync</span>:<span class="regexp">/sbin:/</span>bin/sync</span><br><span class="line"><span class="number">7</span> <span class="attr">shutdown</span>:<span class="attr">x</span>:<span class="number">6</span>:<span class="number">0</span>:<span class="attr">shutdown</span>:<span class="regexp">/sbin:/</span>sbin/shutdown</span><br></pre></td></tr></table></figure><h3 id="4-5数据的查找并进行相关操作"><a href="#4-5数据的查找并进行相关操作" class="headerlink" title="4.5数据的查找并进行相关操作"></a>4.5数据的查找并进行相关操作</h3><h4 id="（1）数据的查找并显示"><a href="#（1）数据的查找并显示" class="headerlink" title="（1）数据的查找并显示"></a>（1）数据的查找并显示</h4><p>搜索 &#x2F;etc&#x2F;passwd有root关键字的行并输出。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[b3335@<span class="variable constant_">MIC</span> ~]$ nl /etc/passwd | sed -n <span class="string">&#x27;/root/p&#x27;</span></span><br><span class="line"><span class="number">1</span>   <span class="attr">root</span>:<span class="attr">x</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="attr">root</span>:<span class="regexp">/root:/</span>bin/bash</span><br><span class="line"><span class="number">11</span>  <span class="attr">operator</span>:<span class="attr">x</span>:<span class="number">11</span>:<span class="number">0</span>:<span class="attr">operator</span>:<span class="regexp">/root:/</span>sbin/nologin</span><br></pre></td></tr></table></figure><h4 id="（2）数据的查找并删除"><a href="#（2）数据的查找并删除" class="headerlink" title="（2）数据的查找并删除"></a>（2）数据的查找并删除</h4><p>删除&#x2F;etc&#x2F;passwd所有包含root的行，其他行输出。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[b3335@<span class="variable constant_">MIC</span> ~]$ nl /etc/passwd | sed  <span class="string">&#x27;/root/d&#x27;</span></span><br><span class="line"><span class="number">2</span>  <span class="attr">daemon</span>:<span class="attr">x</span>:<span class="number">1</span>:<span class="number">1</span>:<span class="attr">daemon</span>:<span class="regexp">/usr/</span><span class="attr">sbin</span>:<span class="regexp">/bin/</span>sh</span><br><span class="line"><span class="number">3</span>  <span class="attr">bin</span>:<span class="attr">x</span>:<span class="number">2</span>:<span class="number">2</span>:<span class="attr">bin</span>:<span class="regexp">/bin:/</span>bin/sh</span><br><span class="line">…（下面忽略）…</span><br></pre></td></tr></table></figure><p>如果想删除匹配的字符串，使用如下命令：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[b3335@<span class="variable constant_">MIC</span> ~]$ nl /etc/passwd | sed  <span class="string">&#x27;s/root//g&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="（3）数据的查找并替换"><a href="#（3）数据的查找并替换" class="headerlink" title="（3）数据的查找并替换"></a>（3）数据的查找并替换</h4><p>除了整行的处理模式之外， sed 还可以用行为单位进行部分数据的搜寻并取代。基本上 sed 的搜寻与替代的与 vi 相当的类似！他有点像这样：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/被取代的字串/新的字串/g&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="（4）数据的搜寻并执行命令"><a href="#（4）数据的搜寻并执行命令" class="headerlink" title="（4）数据的搜寻并执行命令"></a>（4）数据的搜寻并执行命令</h4><p>搜索&#x2F;etc&#x2F;passwd,找到root对应的行，执行后面花括号中的一组命令，每个命令之间用分号分隔，这里把bash替换为blueshell，再输出这行：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">nl /etc/passwd | sed -n <span class="string">&#x27;/root/&#123;s/bash/blueshell/;p&#125;&#x27;</span></span><br><span class="line"><span class="number">1</span>  <span class="attr">root</span>:<span class="attr">x</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="attr">root</span>:<span class="regexp">/root:/</span>bin/blueshell</span><br></pre></td></tr></table></figure><p>如果只替换&#x2F;etc&#x2F;passwd的第一个bash关键字为blueshell，就退出</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">nl /etc/passwd | sed -n <span class="string">&#x27;/bash/&#123;s/bash/blueshell/;p;q&#125;&#x27;</span>    </span><br><span class="line"><span class="number">1</span>  <span class="attr">root</span>:<span class="attr">x</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="attr">root</span>:<span class="regexp">/root:/</span>bin/blueshell</span><br></pre></td></tr></table></figure><h3 id="4-6多点编辑"><a href="#4-6多点编辑" class="headerlink" title="4.6多点编辑"></a>4.6多点编辑</h3><p>一条sed命令，删除&#x2F;etc&#x2F;passwd第三行到末尾的数据，并把bash替换为blueshell</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">nl /etc/passwd | sed -e <span class="string">&#x27;3,$d&#x27;</span> -e <span class="string">&#x27;s/bash/blueshell/&#x27;</span></span><br><span class="line"><span class="number">1</span>  <span class="attr">root</span>:<span class="attr">x</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="attr">root</span>:<span class="regexp">/root:/</span>bin/blueshell</span><br><span class="line"><span class="number">2</span>  <span class="attr">daemon</span>:<span class="attr">x</span>:<span class="number">1</span>:<span class="number">1</span>:<span class="attr">daemon</span>:<span class="regexp">/usr/</span><span class="attr">sbin</span>:<span class="regexp">/bin/</span>sh</span><br></pre></td></tr></table></figure><p>-e表示多点编辑，第一个编辑命令删除&#x2F;etc&#x2F;passwd第三行到末尾的数据，第二条命令搜索bash替换为blueshell。</p><h3 id="4-7直接修改文件"><a href="#4-7直接修改文件" class="headerlink" title="4.7直接修改文件"></a>4.7直接修改文件</h3><p>sed 可以直接修改文件的内容，不必使用管道命令或数据流重导向！ </p><p>不过，由於这个动作会直接修改到原始的文件，</p><p>所以请你千万不要随便拿系统配置来测试，使用时也要慎重。</p><p>我们使用下载的regular_express.txt 文件来测试看看吧！</p><p>利用 sed 将 regular_express.txt 内每一行结尾若为 . 则换成 !</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[root@www ~]# sed -i <span class="string">&#x27;s/\.$/!/g&#x27;</span> regular_express.<span class="property">txt</span></span><br></pre></td></tr></table></figure><p>利用 sed 直接在 regular_express.txt 最后一行加入”# This is a test”。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[root@www ~]# sed -i <span class="string">&#x27;$a # This is a test&#x27;</span> regular_express.<span class="property">txt</span></span><br></pre></td></tr></table></figure><p>由於 $ 代表的是最后一行，而 a 的动作是新增，因此该文件最后新增”# This is a test”。</p><p>sed 的-i选项可以直接修改文件内容，这功能非常有帮助！</p><p>举例来说，如果你有一个 100 万行的文件，你要在第 100 行加某些文字，此时使用 vim 可能会疯掉！因为文件太大了！那怎办？就利用 sed 啊！透过 sed 直接修改&#x2F;取代的功能，你甚至不需要使用 vim 去修订！</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令——scp命令</title>
      <link href="/FRank675.github.io/posts/3b4e095cdd12/"/>
      <url>/FRank675.github.io/posts/3b4e095cdd12/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="Linux命令——scp命令"><a href="#Linux命令——scp命令" class="headerlink" title="Linux命令——scp命令"></a>Linux命令——scp命令</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>scp（secure copy）命令是一个基于SSH安全的进行远程文件拷贝命令，用于在Linux下进行远程拷贝文件，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp支持对传输的数据进行加密。</p><h2 id="2-命令格式"><a href="#2-命令格式" class="headerlink" title="2.命令格式"></a>2.命令格式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">scp [-1246BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file] [-l limit] [-o ssh_option] [-P port] [-S program][[user@]<span class="attr">host1</span>:]file1 ... [[user@]<span class="attr">host2</span>:]file2</span><br></pre></td></tr></table></figure><h2 id="3-选项说明"><a href="#3-选项说明" class="headerlink" title="3.选项说明"></a>3.选项说明</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">-<span class="number">1</span>：使用ssh协议版本<span class="number">1</span>；</span><br><span class="line">-<span class="number">2</span>：使用ssh协议版本<span class="number">2</span>；</span><br><span class="line">-<span class="number">4</span>：使用ipv4；</span><br><span class="line">-<span class="number">6</span>：使用ipv6；</span><br><span class="line">-B：以批处理模式运行，阻止scp询问口令；</span><br><span class="line">-C：使用压缩，将-C标志传递给ssh，从而打开压缩功能；</span><br><span class="line">-c [cipher]：使用指定的秘钥对传输的文件进行加密；</span><br><span class="line">-F [ssh_config]：指定ssh配置文件；</span><br><span class="line">-i [identity_file]：从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh；</span><br><span class="line">-l [limit]：指定宽带限制；</span><br><span class="line">-o [ssh_option]：指定使用的ssh选项，可以使用ssh_config中使用的ssh选项；</span><br><span class="line">-P [port]：指定远程主机的端口号；</span><br><span class="line">-p：保留文件的最后修改时间，最后访问时间和权限模式；</span><br><span class="line">-q：<span class="title class_">Quiet</span> mode，不显示复制进度以及来自ssh的警告和诊断消息；</span><br><span class="line">-r：以递归方式复制整个目录;</span><br><span class="line">-S [program]：指定加密传输时所使用的程序。此程序必须能够理解ssh的选项；</span><br><span class="line">-v：使用冗余模式，使scp和ssh打印调试信息以及进度。</span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong>  </p><p>（1）scp返回0成功，&gt;0失败；  </p><p>（2）使用scp在不同主机之间进行文件传输，需要确保两台设备都开启了ssh远程登录服务，且两台设备能互相通信；  </p><p>（3）使用scp命令要确保使用的用户具有可读取远程服务器相应文件的权限，否则scp命令是无法起作用的。</p><h2 id="4-常用示例"><a href="#4-常用示例" class="headerlink" title="4.常用示例"></a>4.常用示例</h2><h3 id="（1）远程主机之间，使用scp拷贝多个文件。"><a href="#（1）远程主机之间，使用scp拷贝多个文件。" class="headerlink" title="（1）远程主机之间，使用scp拷贝多个文件。"></a>（1）远程主机之间，使用scp拷贝多个文件。</h3><p><strong>方法一：</strong>将多个文件放在同一个目录中，使用<code>scp -r</code> 来拷贝，参考如下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">scp -r uername@<span class="attr">sourceHostName</span>:sourcedir username@<span class="attr">destinationHostName</span>:destinationdir</span><br></pre></td></tr></table></figure><p><strong>方法二：</strong> 将多个文件或者目录使用tar打包后作为单个文件传输。</p><p><strong>方法三：</strong> scp支持同时拷贝多个文件的功能，示例如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">scp file1  file2 remote_username@<span class="attr">remote_ip</span>:remote_folder </span><br></pre></td></tr></table></figure><h3 id="（2）从本地复制文件到远程。"><a href="#（2）从本地复制文件到远程。" class="headerlink" title="（2）从本地复制文件到远程。"></a>（2）从本地复制文件到远程。</h3><p>命令格式：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">scp local_file  remote_username@<span class="attr">remote_ip</span>:remote_folder </span><br><span class="line">或者 </span><br><span class="line">scp local_file remote_username@<span class="attr">remote_ip</span>:remote_file </span><br><span class="line">或者 </span><br><span class="line">scp local_file <span class="attr">remote_ip</span>:remote_folder </span><br><span class="line">或者 </span><br><span class="line">scp local_file <span class="attr">remote_ip</span>:remote_file </span><br></pre></td></tr></table></figure><p>第1,2个指定了用户名，命令执行后需要再输入密码，第1个仅指定了远程的目录，文件名字不变，第2个指定了文件名；  </p><p>第3,4个没有指定用户名，命令执行后需要输入用户名和密码，第3个仅指定了远程的目录，文件名字不变，第4个指定了文件名；</p><p>应用实例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">scp /home/space/music/<span class="number">1.</span>mp3 root@www.<span class="property">runoob</span>.<span class="property">com</span>:<span class="regexp">/home/</span>root/others/music </span><br><span class="line">scp /home/space/music/<span class="number">1.</span>mp3 root@www.<span class="property">runoob</span>.<span class="property">com</span>:<span class="regexp">/home/</span>root/others/music/<span class="number">001</span>.<span class="property">mp3</span> </span><br><span class="line">scp /home/space/music/<span class="number">1.</span>mp3 www.<span class="property">runoob</span>.<span class="property">com</span>:<span class="regexp">/home/</span>root/others/music </span><br><span class="line">scp /home/space/music/<span class="number">1.</span>mp3 www.<span class="property">runoob</span>.<span class="property">com</span>:<span class="regexp">/home/</span>root/others/music/<span class="number">001</span>.<span class="property">mp3</span> </span><br></pre></td></tr></table></figure><h3 id="（3）使用scp复制目录。"><a href="#（3）使用scp复制目录。" class="headerlink" title="（3）使用scp复制目录。"></a>（3）使用scp复制目录。</h3><p>命令格式：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">scp -r local_folder remote_username@<span class="attr">remote_ip</span>:remote_folder </span><br><span class="line">或者 </span><br><span class="line">scp -r local_folder <span class="attr">remote_ip</span>:remote_folder</span><br></pre></td></tr></table></figure><p>第1个指定了用户名，命令执行后需要再输入密码；  </p><p>第2个没有指定用户名，命令执行后需要输入用户名和密码；</p><p>应用实例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">scp -r /home/space/music/ root@www.<span class="property">runoob</span>.<span class="property">com</span>:<span class="regexp">/home/</span>root/others/ </span><br><span class="line">scp -r /home/space/music/ www.<span class="property">runoob</span>.<span class="property">com</span>:<span class="regexp">/home/</span>root/others/ </span><br></pre></td></tr></table></figure><p>上面命令将本地 music 目录复制到远程 others 目录下。</p><h3 id="（4）从远程复制到本地。"><a href="#（4）从远程复制到本地。" class="headerlink" title="（4）从远程复制到本地。"></a>（4）从远程复制到本地。</h3><p>从远程复制到本地，只要将从本地复制到远程的命令的后2个参数调换顺序即可，如下实例 </p><p>应用实例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">scp root@www.<span class="property">runoob</span>.<span class="property">com</span>:<span class="regexp">/home/</span>root/others/music /home/space/music/<span class="number">1.</span>mp3 </span><br><span class="line">scp -r www.<span class="property">runoob</span>.<span class="property">com</span>:<span class="regexp">/home/</span>root/others/ <span class="regexp">/home/</span>space/music/</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>如果远程服务器防火墙有为scp命令设置了指定的端口，我们需要使用 -P 参数来设置命令的端口号，命令格式如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#scp 命令使用端口号 <span class="number">4588</span></span><br><span class="line">scp -P <span class="number">4588</span> remote@www.<span class="property">runoob</span>.<span class="property">com</span>:<span class="regexp">/usr/</span>local/sin.<span class="property">sh</span> /home/administrator</span><br></pre></td></tr></table></figure><h3 id="（5）使用expect和scp实现不同主机之间文件的自动传输。"><a href="#（5）使用expect和scp实现不同主机之间文件的自动传输。" class="headerlink" title="（5）使用expect和scp实现不同主机之间文件的自动传输。"></a>（5）使用expect和scp实现不同主机之间文件的自动传输。</h3><p>脚本如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#!<span class="regexp">/usr/</span>bin/expect</span><br><span class="line">set timeout <span class="number">5</span></span><br><span class="line">spawn scp dablelv@<span class="number">172.25</span><span class="number">.44</span><span class="number">.22</span>:<span class="regexp">/yourpath/y</span>ourfile root@<span class="number">10.130</span><span class="number">.89</span><span class="number">.104</span>:/destinationpath</span><br><span class="line">expect <span class="string">&quot;dablelv@172.25.44.22&#x27;s password:&quot;</span></span><br><span class="line">send <span class="string">&quot;123456\n&quot;</span></span><br><span class="line">expect <span class="string">&quot;root@10.130.89.104&#x27;s password:&quot;</span></span><br><span class="line">send <span class="string">&quot;123456\n&quot;</span></span><br><span class="line">interact eof</span><br></pre></td></tr></table></figure><p>脚本解释：  </p><p><strong>第一行</strong>：<code>#!/usr/bin/expect</code> 指明该脚本由expect来解析。这里的expect其实和linux下的bash、Windows下的cmd.exe是一类东西，都是可执行程序，也可用于脚本的解析器。expect的主要作用是解析自动交互的脚本，比如实现ssh的自动登录，无需手动输入密码等。</p><p><strong>第二行</strong>：<code>set timeout 5</code> 用于设置expect的expect命令的等待时间为5秒，如果expect等待的值在5秒内没有出现在标准输出，那么expect脚本继续执行。expect的默认timeout为10s。</p><p><strong>第三行</strong>：<code>spawn scp dablelv@172.25.44.22:/yourpath/yourfile</code>。spawn是expect的内置命令，不是Linux可执行程序，使用<code>which spawn</code> 是查不到spawn所在路径的。这个就好比cd是shell的内建命令，离开shell，就无法执行cd一样。 它主要的功能是给ssh运行进程加个壳，用来传递交互指令。 它主要的功能是给后面需要执行的命令加个壳，用来传递交互指令。</p><p><strong>第四行</strong>：<code>expect &quot;dablelv@172.25.44.22&#39;s password:&quot;</code> expect命令也是expect的内建命令，其作用就是等待标准输出出现指定的值，如果有则立即返回，向下执行；否则就一直等待，等待的最长时间由上面的<code>set timeout</code>来指定。</p><p><strong>第五行</strong>：<code>send &quot;123456\n&quot;</code>就是在expect等待到指定的值之后向标准输出发送的值，这里就是执行交互动作，与手工输入密码的动作等效。效果上跟用户手动在终端上输入123456之后敲一个回车一样。</p><p><strong>第六、七行</strong>实现的功能同第五六行，因为scp需要登录到两个主机实现文件的网络传输，所以这里是登录第二台主机需要输入的密码。</p><p><strong>第八行</strong>：<code>interact eof</code> 表示expect脚本执行结束。执行完成上述命令后，此时Expect会把控制权交给控制台，这个时候就变回手工操作。如果是使用ssh登录其它主机的话，需要保持在交互状态，那么此时需要<code>interact</code>，如果没有这一句登录完成后会立刻退出，而不是留在远程终端上。如果你只是登录过去执行一段命令就退出，可将其改为<code>expect eof</code>。</p><p>如果出现 “: no such file or directory 这样的错误，很可能是因为在本地Windows环境编辑，上传到Linux下执行因文件格式不同导致的，可使用vi或者vim在末行模式使用<code>:set ff</code>来查看文件格式，如果是dos格式的话，那么需要使用<code>:set ff=unix</code> 来改变文件格式。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令——ping命令</title>
      <link href="/FRank675.github.io/posts/c0d06b4cf0bc/"/>
      <url>/FRank675.github.io/posts/c0d06b4cf0bc/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="Linux命令——ping命令"><a href="#Linux命令——ping命令" class="headerlink" title="Linux命令——ping命令"></a>Linux命令——ping命令</h1><h2 id="1-命令简介"><a href="#1-命令简介" class="headerlink" title="1.命令简介"></a>1.命令简介</h2><p>ping（Packet Internet Groper 命令是因特网包探索器，用于测试网络连通性，是常用的网络命令之一。</p><p>ping 命令用于向指定的网络主机发送特殊数据报 IMCP 回应请求报文（IMCP ECHO_REQUEST），多数网络设备收到该数据包后会回应 ICMP 回应回复报文 （ICMP Echo-Reply），以此来验证网络连接是否正常。</p><p>注意：</p><p>Linux 系统下的 ping 命令与 Windows 系统下的 ping 命令稍有不同。</p><p>Windows 下运行 ping 命令一般会发出 4 个请求就结束运行该命令；</p><p>而 Linux 下不会自动终止，此时需要我们按 Ctrl+C 终止或者使用 -c 参数为 ping 命令指定发送的请求数目。</p><h2 id="2-命令格式"><a href="#2-命令格式" class="headerlink" title="2.命令格式"></a>2.命令格式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ping</span><br><span class="line">ping [<span class="variable constant_">OPTIONS</span>] <span class="variable constant_">DESTINATION</span></span><br></pre></td></tr></table></figure><p>不跟参数单独执行 ping 命令将显示简短用法。其中参数为零到多个，目标主机可以是主机 IP 或者域名。</p><h2 id="3-选项说明"><a href="#3-选项说明" class="headerlink" title="3.选项说明"></a>3.选项说明</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">-<span class="number">4</span></span><br><span class="line">只使用 <span class="title class_">IPv4</span></span><br><span class="line">-<span class="number">6</span></span><br><span class="line">只使用 <span class="title class_">IPv6</span></span><br><span class="line">-A</span><br><span class="line">探测包发送间隔自适应往返时间，这样网络中存在的未应答的探测请求一般不会超过一个</span><br><span class="line">-a</span><br><span class="line">　　每次发送数据时发出鸣响（<span class="title class_">Audible</span>）</span><br><span class="line">-B</span><br><span class="line">不允许 ping 改变包头的源地址</span><br><span class="line">-b</span><br><span class="line">允许 ping 一个广播地址</span><br><span class="line">-c <span class="variable constant_">COUNT</span></span><br><span class="line">　　发送 count 个 <span class="variable constant_">ECHO_REQUEST</span> 数据包后结束 ping 程序</span><br><span class="line">-D</span><br><span class="line">在每行前打印时间戳</span><br><span class="line">-d</span><br><span class="line">　　使用 socket 的 <span class="variable constant_">SO_DEBUG</span> 选项。实际上，<span class="title class_">Linux</span> 内核不使用这个套接字选项</span><br><span class="line">-F <span class="variable constant_">FLOW_LABEL</span></span><br><span class="line">仅 <span class="title class_">IPv6</span> 有效。为请求包分配一个 <span class="number">20</span> 比特的 flow label。如果 <span class="variable constant_">FLOW_LABEL</span> 为 <span class="number">0</span>，内核会随机分配</span><br><span class="line">-f</span><br><span class="line">　　采用洪泛模式大量且快速地向目标发送数据包。如果发送间隔没有设置，则默认设置为 <span class="number">0</span>，并按照报文接受的速度和一百次每秒的速度来发送报文（以最快的为准）。只有超级用户能够将此选项和 -i <span class="number">0</span> 选项一起使用</span><br><span class="line">-h</span><br><span class="line">显示帮助信息</span><br><span class="line">-I <span class="variable constant_">INTERFACE</span></span><br><span class="line">　　使用指定的网络接口地址发送数据包</span><br><span class="line">-i <span class="variable constant_">INTERVAL</span></span><br><span class="line">　　每隔 <span class="variable constant_">INTERVAL</span> 秒发送一次数据包，默认一秒 ping 一次。只有超级用户可以将间隔设置为小于<span class="number">0.2</span> 秒的值</span><br><span class="line">-L</span><br><span class="line">抑制组播报文回送，只适用于 ping 的目标为一个组播地址</span><br><span class="line">-l <span class="variable constant_">PRELOAD</span></span><br><span class="line">在没有接受到回复报文之前能发送的最多报文。非超级用户最多只能设置为 <span class="number">3</span></span><br><span class="line">-M <span class="variable constant_">PMTUDISC_OPT</span></span><br><span class="line">选择 <span class="title class_">Path</span> <span class="variable constant_">MTU</span> <span class="title class_">Discovery</span> 策略模式。<span class="variable constant_">PMTUDISC_OPT</span> 取值可以为 <span class="keyword">do</span>（不允许分段，甚至不允许在本地分段）、want（找出 <span class="variable constant_">PMTU</span>，在如果包太大就在本地分段） 或 dont（不要设置 <span class="variable constant_">IP</span> 包首部中的 <span class="variable constant_">DF</span> 位，即允许分段）</span><br><span class="line">-m <span class="variable constant_">MARK</span></span><br><span class="line">使用标记来标记发送的数据包</span><br><span class="line">-n</span><br><span class="line">　　只输出主机 <span class="variable constant_">IP</span> 地址，不通过查询 <span class="variable constant_">DNS</span> 获知 <span class="variable constant_">IP</span> 地址对应的主机名，以节省时间</span><br><span class="line">-O</span><br><span class="line">在发送下一个数据包之前报告未完成的 <span class="variable constant_">ICMP</span> <span class="title class_">Echo</span> 请求</span><br><span class="line">-p <span class="variable constant_">PATTERN</span></span><br><span class="line">　　最多指定 <span class="number">16</span> 个字节去填充发送的数据包，这对于诊断网络中数据依赖问题很有用。例如，-p ff 会将所有的填充数据设置为 <span class="number">1</span></span><br><span class="line">-Q <span class="variable constant_">TOS</span></span><br><span class="line"> 用来设置服务质量（<span class="title class_">Quality</span> <span class="keyword">of</span> <span class="title class_">Service</span> ）。<span class="variable constant_">ICMP</span> 协议有一个 <span class="number">8</span> bits 的区分服务（<span class="title class_">Differentiated</span> <span class="title class_">Services</span>）。低两位用于分离数据，高 <span class="number">6</span> 位表示区分服务，一般有最小时延、最大吞吐量、最高可靠性、最小代价</span><br><span class="line">-q</span><br><span class="line">　　静态输出。仅程序启动和结束时显示摘要行</span><br><span class="line">-R</span><br><span class="line">　　记录路由过程</span><br><span class="line">-r</span><br><span class="line">　　忽略正常的路由表，而直接向主机发送数据包。如果目标主机不再直连的网络上，则返回异常</span><br><span class="line">-S <span class="variable constant_">SNDBUF</span></span><br><span class="line">设置套接字的发送缓冲区大小。如果没有设置，则被设定为不超过一个报文长度</span><br><span class="line">-s <span class="variable constant_">PACKETSIZE</span></span><br><span class="line">　　指定要发送的数据的字节数。默认是 <span class="number">56</span> 字节，与 <span class="number">8</span> 字节的 <span class="variable constant_">ICMP</span> 头部结合刚好是 <span class="number">64</span> 字节的 <span class="variable constant_">ICMP</span> 数据包</span><br><span class="line">-T <span class="variable constant_">TIMESTAMP_OPTION</span></span><br><span class="line">设置 <span class="variable constant_">IP</span> 报文的时间戳选项。选项可以是以下三种：</span><br><span class="line">（<span class="number">1</span>）-T tsonly 只记录时间戳；</span><br><span class="line">（<span class="number">2</span>）-T tsandaddr 收集时间戳和 <span class="variable constant_">IP</span> 地址；</span><br><span class="line">（<span class="number">3</span>）-T tsprespec [host1 [host2 [host3[host4]]]] 收集来自预定的网络地址的时间戳</span><br><span class="line">-t <span class="variable constant_">TTL</span></span><br><span class="line">　　设置 <span class="variable constant_">IP</span> 包的 <span class="variable constant_">TTL</span> 值</span><br><span class="line">-U</span><br><span class="line">打印完整的用户对用户延迟</span><br><span class="line">-V</span><br><span class="line">显示版本信息并退出</span><br><span class="line">-v</span><br><span class="line">　　详细模式输出</span><br><span class="line">-W <span class="variable constant_">TIMEOUT</span></span><br><span class="line">　　设置等待 <span class="variable constant_">ICMP</span> 响应的超时时间，单位秒</span><br><span class="line">-w <span class="variable constant_">DEADLINE</span></span><br><span class="line">　　ping 程序在 <span class="variable constant_">DEADLINE</span> 秒后退出，不管发送或接收多少数据包</span><br></pre></td></tr></table></figure><h2 id="4-常用示例"><a href="#4-常用示例" class="headerlink" title="4.常用示例"></a>4.常用示例</h2><h3 id="（1）显示-ping-的简要用法。"><a href="#（1）显示-ping-的简要用法。" class="headerlink" title="（1）显示 ping 的简要用法。"></a>（1）显示 ping 的简要用法。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ping</span><br><span class="line"><span class="title class_">Usage</span>: ping [-aAbBdDfhLnOqrRUvV] [-c count] [-i interval] [-I interface]</span><br><span class="line">            [-m mark] [-M pmtudisc_option] [-l preload] [-p pattern] [-Q tos]</span><br><span class="line">            [-s packetsize] [-S sndbuf] [-t ttl] [-T timestamp_option]</span><br><span class="line">            [-w deadline] [-W timeout] [hop1 ...] destination</span><br></pre></td></tr></table></figure><h3 id="（2）测试能否-ping-通-IP。"><a href="#（2）测试能否-ping-通-IP。" class="headerlink" title="（2）测试能否 ping 通 IP。"></a>（2）测试能否 ping 通 IP。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ping <span class="number">9.134</span><span class="number">.114</span><span class="number">.170</span></span><br><span class="line"><span class="variable constant_">PING</span> <span class="number">9.134</span><span class="number">.114</span><span class="number">.170</span> (<span class="number">9.134</span><span class="number">.114</span><span class="number">.170</span>) <span class="number">56</span>(<span class="number">84</span>) bytes <span class="keyword">of</span> data.</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">9.134</span><span class="number">.114</span><span class="number">.170</span>: icmp_seq=<span class="number">1</span> ttl=<span class="number">64</span> time=<span class="number">0.033</span> ms</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">9.134</span><span class="number">.114</span><span class="number">.170</span>: icmp_seq=<span class="number">2</span> ttl=<span class="number">64</span> time=<span class="number">0.040</span> ms</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>回包正常，表示网络链路通畅。</p><h3 id="（3）测试能否-ping-通域名。"><a href="#（3）测试能否-ping-通域名。" class="headerlink" title="（3）测试能否 ping 通域名。"></a>（3）测试能否 ping 通域名。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ping baidu.<span class="property">com</span></span><br><span class="line"><span class="variable constant_">PING</span> baidu.<span class="property">com</span> (<span class="number">220.181</span><span class="number">.38</span><span class="number">.148</span>) <span class="number">56</span>(<span class="number">84</span>) bytes <span class="keyword">of</span> data.</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">220.181</span><span class="number">.38</span><span class="number">.148</span>: icmp_seq=<span class="number">1</span> ttl=<span class="number">249</span> time=<span class="number">39.4</span> ms</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">220.181</span><span class="number">.38</span><span class="number">.148</span>: icmp_seq=<span class="number">2</span> ttl=<span class="number">249</span> time=<span class="number">39.3</span> ms</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>回包正常，表示网络链路通畅。</p><h3 id="（4）每隔-0-5-秒-ping-一次，一共-ping-3-次。"><a href="#（4）每隔-0-5-秒-ping-一次，一共-ping-3-次。" class="headerlink" title="（4）每隔 0.5 秒 ping 一次，一共 ping 3 次。"></a>（4）每隔 0.5 秒 ping 一次，一共 ping 3 次。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ping -i <span class="number">0.5</span> -c <span class="number">3</span> baidu.<span class="property">com</span></span><br><span class="line"><span class="variable constant_">PING</span> baidu.<span class="property">com</span> (<span class="number">220.181</span><span class="number">.38</span><span class="number">.148</span>) <span class="number">56</span>(<span class="number">84</span>) bytes <span class="keyword">of</span> data.</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">220.181</span><span class="number">.38</span><span class="number">.148</span>: icmp_seq=<span class="number">1</span> ttl=<span class="number">249</span> time=<span class="number">39.3</span> ms</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">220.181</span><span class="number">.38</span><span class="number">.148</span>: icmp_seq=<span class="number">2</span> ttl=<span class="number">249</span> time=<span class="number">39.3</span> ms</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">220.181</span><span class="number">.38</span><span class="number">.148</span>: icmp_seq=<span class="number">3</span> ttl=<span class="number">249</span> time=<span class="number">39.3</span> ms</span><br><span class="line"></span><br><span class="line">--- baidu.<span class="property">com</span> ping statistics ---</span><br><span class="line"><span class="number">3</span> packets transmitted, <span class="number">3</span> received, <span class="number">0</span>% packet loss, time 1001ms</span><br><span class="line">rtt min/avg/max/mdev = <span class="number">39.375</span>/<span class="number">39.390</span>/<span class="number">39.399</span>/<span class="number">0.010</span> ms</span><br></pre></td></tr></table></figure><p>下面简单地介绍一下 ping 产生的响应内容的含义：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">PING</span> baidu.<span class="property">com</span> (<span class="number">220.181</span><span class="number">.38</span><span class="number">.148</span>) <span class="number">56</span>(<span class="number">84</span>) bytes <span class="keyword">of</span> data.</span><br><span class="line">表示 ping 目标主机的域名和 <span class="variable constant_">IP</span>，以及不带包头的包大小和带包头的包大小，参考 -s 选项</span><br><span class="line"></span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">220.181</span><span class="number">.38</span><span class="number">.148</span>: icmp_seq=<span class="number">1</span> ttl=<span class="number">249</span> time=<span class="number">39.3</span> ms</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">220.181</span><span class="number">.38</span><span class="number">.148</span>: icmp_seq=<span class="number">2</span> ttl=<span class="number">249</span> time=<span class="number">39.3</span> ms</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">220.181</span><span class="number">.38</span><span class="number">.148</span>: icmp_seq=<span class="number">3</span> ttl=<span class="number">249</span> time=<span class="number">39.3</span> ms</span><br><span class="line">icmp_seq：ping 序列，从 <span class="number">1</span> 开始；如果数字不是按顺序递增也就意味着丢包了</span><br><span class="line">ttl：剩余的 ttl；见下文的 <span class="variable constant_">TTL</span> 解释</span><br><span class="line"><span class="attr">time</span>: 响应时间，数值越小，通信速度越快</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> packets transmitted, <span class="number">3</span> received, <span class="number">0</span>% packet loss, time 1001ms</span><br><span class="line">发出去的包数，返回的包数，丢包率，总耗费时间</span><br><span class="line"></span><br><span class="line">rtt min/avg/max/mdev = <span class="number">39.375</span>/<span class="number">39.390</span>/<span class="number">39.399</span>/<span class="number">0.010</span> ms</span><br><span class="line">最小/最大/平均响应时间和本机硬件耗费时间</span><br></pre></td></tr></table></figure><h3 id="（5）综合实例，每隔-0-5-秒-ping-一次，一共-ping-3-次，并且设置发送包的大小为-1024-和-TTL-值为-255。"><a href="#（5）综合实例，每隔-0-5-秒-ping-一次，一共-ping-3-次，并且设置发送包的大小为-1024-和-TTL-值为-255。" class="headerlink" title="（5）综合实例，每隔 0.5 秒 ping 一次，一共 ping 3 次，并且设置发送包的大小为 1024 和 TTL 值为 255。"></a>（5）综合实例，每隔 0.5 秒 ping 一次，一共 ping 3 次，并且设置发送包的大小为 1024 和 TTL 值为 255。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ping -i <span class="number">0.5</span> -c <span class="number">3</span> -s <span class="number">1024</span> -t <span class="number">255</span> baidu.<span class="property">com</span></span><br><span class="line"><span class="variable constant_">PING</span> baidu.<span class="property">com</span> (<span class="number">39.156</span><span class="number">.69</span><span class="number">.79</span>) <span class="number">1024</span>(<span class="number">1052</span>) bytes <span class="keyword">of</span> data.</span><br><span class="line"><span class="number">1032</span> bytes <span class="keyword">from</span> <span class="number">39.156</span><span class="number">.69</span><span class="number">.79</span>: icmp_seq=<span class="number">1</span> ttl=<span class="number">249</span> time=<span class="number">44.8</span> ms</span><br><span class="line"><span class="number">1032</span> bytes <span class="keyword">from</span> <span class="number">39.156</span><span class="number">.69</span><span class="number">.79</span>: icmp_seq=<span class="number">2</span> ttl=<span class="number">249</span> time=<span class="number">40.5</span> ms</span><br><span class="line"><span class="number">1032</span> bytes <span class="keyword">from</span> <span class="number">39.156</span><span class="number">.69</span><span class="number">.79</span>: icmp_seq=<span class="number">3</span> ttl=<span class="number">249</span> time=<span class="number">40.4</span> ms</span><br><span class="line"></span><br><span class="line">--- baidu.<span class="property">com</span> ping statistics ---</span><br><span class="line"><span class="number">3</span> packets transmitted, <span class="number">3</span> received, <span class="number">0</span>% packet loss, time 1001ms</span><br><span class="line">rtt min/avg/max/mdev = <span class="number">40.441</span>/<span class="number">41.927</span>/<span class="number">44.810</span>/<span class="number">2.045</span> ms</span><br></pre></td></tr></table></figure><h3 id="（6）综合实例，使用-i-指定发送数据包时间间隔，-c-指定一共发送多少个数据包，-I-指定源地址，-q-直接显示程序的启动和最后结果。"><a href="#（6）综合实例，使用-i-指定发送数据包时间间隔，-c-指定一共发送多少个数据包，-I-指定源地址，-q-直接显示程序的启动和最后结果。" class="headerlink" title="（6）综合实例，使用 -i 指定发送数据包时间间隔，-c 指定一共发送多少个数据包，-I 指定源地址，-q 直接显示程序的启动和最后结果。"></a>（6）综合实例，使用 -i 指定发送数据包时间间隔，-c 指定一共发送多少个数据包，-I 指定源地址，-q 直接显示程序的启动和最后结果。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ping -i <span class="number">0.2</span> -c <span class="number">3</span> -I <span class="number">9.134</span><span class="number">.114</span><span class="number">.170</span> baidu.<span class="property">com</span> -q</span><br><span class="line"><span class="variable constant_">PING</span> baidu.<span class="property">com</span> (<span class="number">39.156</span><span class="number">.69</span><span class="number">.79</span>) <span class="keyword">from</span> <span class="number">9.134</span><span class="number">.114</span><span class="number">.170</span> : <span class="number">56</span>(<span class="number">84</span>) bytes <span class="keyword">of</span> data.</span><br><span class="line"></span><br><span class="line">--- baidu.<span class="property">com</span> ping statistics ---</span><br><span class="line"><span class="number">3</span> packets transmitted, <span class="number">3</span> received, <span class="number">0</span>% packet loss, time 400ms</span><br><span class="line">rtt min/avg/max/mdev = <span class="number">40.476</span>/<span class="number">40.541</span>/<span class="number">40.588</span>/<span class="number">0.171</span> ms</span><br></pre></td></tr></table></figure><h3 id="（7）以最快的速度，使用最大的包进行-ping，可用于测试目标主机的承压能力。"><a href="#（7）以最快的速度，使用最大的包进行-ping，可用于测试目标主机的承压能力。" class="headerlink" title="（7）以最快的速度，使用最大的包进行 ping，可用于测试目标主机的承压能力。"></a>（7）以最快的速度，使用最大的包进行 ping，可用于测试目标主机的承压能力。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ping -f -s <span class="number">65507</span> baidu.<span class="property">com</span></span><br></pre></td></tr></table></figure><p>注意：此用法非常危险，65535（包头+内容）*100个包每秒&#x3D;6.25MB，每秒发送 6.25MB 的数据，相当于 50Mbps 的带宽，完全可能导致目标主机拒绝服务，请谨慎使用。</p><h3 id="（8）ping-不通的情况。"><a href="#（8）ping-不通的情况。" class="headerlink" title="（8）ping 不通的情况。"></a>（8）ping 不通的情况。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ping -c <span class="number">3</span> <span class="number">9.9</span><span class="number">.9</span><span class="number">.9</span></span><br><span class="line"><span class="variable constant_">PING</span> <span class="number">9.9</span><span class="number">.9</span><span class="number">.9</span> (<span class="number">9.9</span><span class="number">.9</span><span class="number">.9</span>) <span class="number">56</span>(<span class="number">84</span>) bytes <span class="keyword">of</span> data.</span><br><span class="line"></span><br><span class="line">--- <span class="number">9.9</span><span class="number">.9</span><span class="number">.9</span> ping statistics ---</span><br><span class="line"><span class="number">3</span> packets transmitted, <span class="number">0</span> received, <span class="number">100</span>% packet loss, time 1999ms</span><br></pre></td></tr></table></figure><h3 id="ping-不通目标主机的常见原因："><a href="#ping-不通目标主机的常见原因：" class="headerlink" title="ping 不通目标主机的常见原因："></a>ping 不通目标主机的常见原因：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">No</span> <span class="title class_">Answer</span>：原因可能是，对方主机没工作，双方网络配置不正确，路由问题等</span><br><span class="line"><span class="title class_">Request</span> <span class="title class_">Time</span> <span class="title class_">Out</span>：对方主机已关机，路由问题或对端防火墙设置禁止ping</span><br><span class="line"><span class="title class_">Unknown</span> <span class="title class_">Host</span> <span class="title class_">Name</span>：<span class="variable constant_">DNS</span>设置问题，或者对方主机不存在</span><br><span class="line"><span class="title class_">Destination</span> <span class="title class_">Net</span> <span class="title class_">Unreachable</span>：双方没有建立连接，或对方主机不存在</span><br><span class="line"><span class="title class_">Bad</span> <span class="variable constant_">IP</span> <span class="title class_">Address</span>：<span class="variable constant_">IP</span> 地址不存在或 <span class="variable constant_">IP</span> 不能被 <span class="variable constant_">DNS</span> 服务器解析</span><br><span class="line">transmit failed，error code：网卡驱动问题</span><br><span class="line">no rout to host：网卡工作不正常</span><br><span class="line"><span class="title class_">Ping</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> 如果ping不通，表明本地机 <span class="variable constant_">TCP</span>/<span class="variable constant_">IP</span> 协议不能正常工作</span><br></pre></td></tr></table></figure><h2 id="5-拓展知识"><a href="#5-拓展知识" class="headerlink" title="5.拓展知识"></a>5.拓展知识</h2><h3 id="5-1-TTL"><a href="#5-1-TTL" class="headerlink" title="5.1 TTL"></a>5.1 TTL</h3><p>当我们在使用 ping 命令时，返回结果里会带一个 TTL 值。</p><p>这个东西的含义其实就是Time To Live，指的是报文在网络中能够存活的限制。</p><p>以前这个限制方式是设定一个时间（Time To Live中的Time就是这样来的），当报文在网络中转发时，时间超过这个限制，最后一个收到报文的‘路由点’就会把它扔掉，而不继续转发。</p><p>后来把时间限制改为了跳数限制，就是当报文在网络中转发时，每经过一个‘路由点‘，就把预先设定的这个TTL数值减 1，直到最后 TTL&#x3D;1 时报文就被扔掉，不向下转发。</p><p>路由点：我这里是指完成路由功能的机器，因为并不是只有路由器才可以完成路由转发功能，比如主机可以配置路由转发。</p><p>所以，回包中的 TTL 表示目标主机返回的报文到达本机后，从它预设的 TTL 值减小到现在的值。</p><h3 id="5-2-开启和禁用-ping-响应"><a href="#5-2-开启和禁用-ping-响应" class="headerlink" title="5.2 开启和禁用 ping 响应"></a>5.2 开启和禁用 ping 响应</h3><p>有时为了保护主机，很多时候我们需要禁止 ICMP 协议，在这种情况下，终端再使用ping命令检测，服务器不会再做出任何响应。</p><h3 id="（1）临时开启-ping。"><a href="#（1）临时开启-ping。" class="headerlink" title="（1）临时开启 ping。"></a>（1）临时开启 ping。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">echo <span class="number">0</span> &gt; <span class="regexp">/proc/</span>sys/net/ipv4/icmp_echo_ignore_all</span><br></pre></td></tr></table></figure><h3 id="（2）临时禁用-ping。"><a href="#（2）临时禁用-ping。" class="headerlink" title="（2）临时禁用 ping。"></a>（2）临时禁用 ping。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">echo <span class="number">1</span> &gt; <span class="regexp">/proc/</span>sys/net/ipv4/icmp_echo_ignore_all </span><br></pre></td></tr></table></figure><h3 id="（3）永久禁用-ping。"><a href="#（3）永久禁用-ping。" class="headerlink" title="（3）永久禁用 ping。"></a>（3）永久禁用 ping。</h3><p>在配置文件 &#x2F;etc&#x2F;sysctl.conf 中增加如下一行。修改完成后执行sysctl -p使新配置生效</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">net.<span class="property">ipv4</span>.<span class="property">icmp_echo_ignore_all</span>=<span class="number">1</span>          # <span class="number">1</span> 表示禁止</span><br></pre></td></tr></table></figure><h3 id="（4）永久开启-ping。"><a href="#（4）永久开启-ping。" class="headerlink" title="（4）永久开启 ping。"></a>（4）永久开启 ping。</h3><p>在配置文件 &#x2F;etc&#x2F;sysctl.conf 中增加如下一行。修改完成后执行 sysctl -p 使新配置生效。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">net.<span class="property">ipv4</span>.<span class="property">icmp_echo_ignore_all</span>=<span class="number">0</span>          # <span class="number">0</span> 表示允许</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令——ls命令</title>
      <link href="/FRank675.github.io/posts/5399fdb078dd/"/>
      <url>/FRank675.github.io/posts/5399fdb078dd/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="Linux命令——ls命令"><a href="#Linux命令——ls命令" class="headerlink" title="Linux命令——ls命令"></a>Linux命令——ls命令</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>ls命令用来显示目录内容，在Linux中是使用率较高的命令。ls命令的输出信息可以进行彩色加亮显示，以分区不同类型的文件。</p><h2 id="2-命令格式"><a href="#2-命令格式" class="headerlink" title="2.命令格式"></a>2.命令格式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ls [<span class="variable constant_">OPTION</span>]... [<span class="variable constant_">FILE</span>]...</span><br></pre></td></tr></table></figure><h2 id="3-选项说明"><a href="#3-选项说明" class="headerlink" title="3.选项说明"></a>3.选项说明</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">-a,--all：显示所有档案及目录（ls内定将档案名或目录名称以“.”开头的文件视为影藏文件，默认不会列出）； </span><br><span class="line">-A,--almost-all：显示除影藏文件“.”和“..”以外的所有文件列表； </span><br><span class="line">--<span class="attr">author</span>:与-l选项结合使用，打印出每一个文件的作者；</span><br><span class="line">-b, --<span class="built_in">escape</span>：将文件中的不可输出的字符以反斜线“\”加字符编码的方式输出；</span><br><span class="line">--block-size=<span class="attr">SIZE</span>:使用指定的<span class="variable constant_">SIZE</span>作为统计文件大小的单位。<span class="variable constant_">SIZE</span>可以取如下字符串，或对应的数值: <span class="variable constant_">KB</span> <span class="number">1000</span>, K <span class="number">1024</span>, <span class="variable constant_">MB</span> <span class="number">1000</span>*<span class="number">1000</span>, M <span class="number">1024</span>*<span class="number">1024</span>,以及G, T, P, E, Z, Y等；</span><br><span class="line">-B, --ignore-backups：不要列出以~结尾的隐含条目，默认列出；</span><br><span class="line">-c：与“-l”选项连用时，展示ctime；与“-lt”选项连用时，输出按照文件状态改变时间排序，排序的依据是文件的索引节点中的ctime字段；</span><br><span class="line">-C：多列显示输出结果。这是默认选项； </span><br><span class="line">--color[=<span class="variable constant_">WHEN</span>]：使用不同的颜色高亮显示不同类型文件，<span class="variable constant_">WHEN</span>的默认取值为<span class="string">&#x27;always&#x27;</span>，也可以是<span class="string">&#x27;never&#x27;</span>或<span class="string">&#x27;auto&#x27;</span>；</span><br><span class="line">-d, --<span class="attr">directory</span>:仅显示目录名，而不显示目录下的内容列表。显示符号链接文件本身，而不显示其所指向的目录或文件； </span><br><span class="line">-D, --dired：以<span class="title class_">Emacs</span>的dired模式输出；</span><br><span class="line">-f：此参数的效果和同时指定“aU”参数相同，并关闭“-ls --color”参数效果； </span><br><span class="line">-F, --classify：在每个输出项后追加文件的类型标识符，具体含义：“*”表示具有可执行权限的普通文件，“/”表示目录，“@”表示符号链接，“|”表示命令管道<span class="variable constant_">FIFO</span>，“=”表示sockets套接字。当文件为普通文件时，不输出任何标识符； </span><br><span class="line">--file-type：与“-F”选项的功能相同，但是不显示“*”； </span><br><span class="line">--format=<span class="variable constant_">WORD</span>：<span class="variable constant_">WORD</span>可取值为across，等价于-x选项。取值为commas,等价于-m。取值为horizontal，等价于-x。取值为long，等价于-l。取值为single-column，等价于-<span class="number">1</span>。取值为verbose，等价于-l。取值为vertical，等价于-C；</span><br><span class="line">--full-time：列出完整的日期与时间；</span><br><span class="line">-g：类似于-l,但不列出所属者；</span><br><span class="line">--group-directories-first：目录排在文件之前列出；</span><br><span class="line">-G, --no-group：在长格式(-l)输出时，不输出组名；</span><br><span class="line">-h, --human-readable：以可读方式显示文件大小；</span><br><span class="line">--si：以<span class="number">1000</span>代替<span class="number">1024</span>计算文件大小；</span><br><span class="line">-H, --dereference-command-line：使用命令列中的符号链接指示的真正目的地；</span><br><span class="line">--dereference-command-line-symlink-to-dir：遵循命令行中列出的符号链接；</span><br><span class="line">--hide=<span class="variable constant_">PATTERN</span>：不列出符合<span class="variable constant_">PATTERN</span>模型的隐藏文件；</span><br><span class="line">--indicator-style=<span class="variable constant_">WORD</span>：追加指示符<span class="variable constant_">WORD</span>到每一个文件或目录名称后，none默认 slash (-p), file-type (--file-type), classify (-F)；</span><br><span class="line">-i, --inode：显示文件索引节点号（inode）。一个索引节点代表一个文件； </span><br><span class="line">-I, --ignore=<span class="variable constant_">PATTERN</span>：不列出匹配<span class="variable constant_">PATTERN</span>的文件或目录名；</span><br><span class="line">-k：以<span class="variable constant_">KB</span>（千字节）为单位显示文件大小，类似于--block-size=1K；</span><br><span class="line">-<span class="number">1</span>：数字<span class="number">1</span>，与“-C”选项功能相反，所有输出信息用单列格式输出，不输出为多列；</span><br><span class="line">-l：以长格式显示目录下的内容列表。输出的信息从左到右依次包括文件名，文件类型、权限模式、硬连接数、所有者、组、文件大小和文件的最后修改时间等； </span><br><span class="line">-L,--dereference：如果遇到性质为符号链接的文件或目录，直接列出该链接所指向的原始文件或目录； </span><br><span class="line">-m：用“,”号区隔每个文件和目录的名称； </span><br><span class="line">-n：以用户识别码和群组识别码替代其名称； </span><br><span class="line">-N,--<span class="attr">literal</span>: 直接列出文件和目录名称，包括控制字符；</span><br><span class="line">-<span class="attr">o</span>: 此参数的效果类似于<span class="string">&quot;-l&quot;</span>，但不列出用户组信息；</span><br><span class="line">-p, --indicator-style=<span class="attr">slash</span>:追加斜杠/指示符到目录名后；</span><br><span class="line">-q, --hide-control-<span class="attr">chars</span>:用<span class="string">&quot;?&quot;</span>号取代控制字符，列出文件和目录名称；</span><br><span class="line">--show-control-<span class="attr">chars</span>:显示文件和目录名称中的控制字符；</span><br><span class="line">-Q, --quote-<span class="attr">name</span>:把文件和目录名称以双引号“”标示起来；</span><br><span class="line">--quoting-style=<span class="attr">WORD</span>:使用指定的引号模式来标识档案名称，<span class="variable constant_">WORD</span>的取值有：literal, locale, shell, shell-always, c, <span class="built_in">escape</span>；</span><br><span class="line">-r, --<span class="attr">reverse</span>:以文件名反序排列并输出目录内容；</span><br><span class="line">-R, --<span class="attr">recursive</span>:递归处理，将指定目录下的所有文件及子目录一并处理； </span><br><span class="line">-s,--size：显示文件和目录的大小，以区块为单位； </span><br><span class="line">-S：以文件大小进行排序；</span><br><span class="line">--sort=<span class="variable constant_">WORD</span>：以指定的内容进行排序，而非默认的档案名称，<span class="variable constant_">WORD</span>可取值：none（不排序，等于-U）；extension（以条目名的最后一个扩展名排序，等于-X）；<span class="title function_">size</span>(以用条目大小排序，等于-S）;<span class="title function_">time</span>(以条目内容最后被修改时间排序，等于-t);<span class="title function_">version</span>(以条目版本进行排序，等于-v);</span><br><span class="line">--time=<span class="variable constant_">WORD</span>：当使用-t或--sort=time来按照时间排序时，<span class="variable constant_">WORD</span>可取值为atime、access、<span class="title function_">use</span>(表示使用访问时间排序)；或者ctime、status（状态改变时间排序），来取代默认以内容修改时间排序；</span><br><span class="line">--time-style=<span class="variable constant_">STYLE</span>：使用-l选项时，显示时间使用指定的样式风格<span class="variable constant_">STYLE</span>，可取值为full-iso,long-iso,iso,locale，还有+<span class="variable constant_">FORMAT</span>,<span class="variable constant_">FORMAT</span>，这两项设置格式可以参考date命令的设置方法；</span><br><span class="line">-t：用文件和目录的内容修改时间排序； </span><br><span class="line">-T, --tabsize=<span class="variable constant_">COLS</span>：设置每一列之间的<span class="title class_">Tab</span>间隔符代表的宽度为<span class="variable constant_">COLS</span>，默认为<span class="number">8</span>个空格；</span><br><span class="line">-u：与-lt同用，表示使用访问时间排序，与-l同用，显示访问时间而非内容修改时间；</span><br><span class="line">-U：列出文件和目录名称时不予排序；</span><br><span class="line">-v：文件和目录的名称列表以版本进行排序；</span><br><span class="line">-w,--width=<span class="variable constant_">COLS</span>：设置每列的最大字符数为<span class="variable constant_">COLS</span>；</span><br><span class="line">-x：以从左到右，由上至下的横列方式显示文件和目录名称；</span><br><span class="line">-X：以文件和目录的最后一个扩展名排序；</span><br><span class="line">--help：显示帮助信息；</span><br><span class="line">--<span class="attr">version</span>:显示版本信息；</span><br></pre></td></tr></table></figure><h2 id="4-常用示例"><a href="#4-常用示例" class="headerlink" title="4.常用示例"></a>4.常用示例</h2><h3 id="（1）ls命令按照修改日期递减排序"><a href="#（1）ls命令按照修改日期递减排序" class="headerlink" title="（1）ls命令按照修改日期递减排序"></a>（1）ls命令按照修改日期递减排序</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ls -t</span><br></pre></td></tr></table></figure><p>如果想按照修改日期递增的话使用<code>ls -rt</code> 就行了。</p><h3 id="（2）ls命令按照文件大小递减排序。"><a href="#（2）ls命令按照文件大小递减排序。" class="headerlink" title="（2）ls命令按照文件大小递减排序。"></a>（2）ls命令按照文件大小递减排序。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#递减排序</span><br><span class="line">ls -hS</span><br><span class="line"></span><br><span class="line">#递增排序</span><br><span class="line">ls -hrS</span><br></pre></td></tr></table></figure><h3 id="（3）显示隐藏文件，包括当前目录和父级目录。"><a href="#（3）显示隐藏文件，包括当前目录和父级目录。" class="headerlink" title="（3）显示隐藏文件，包括当前目录和父级目录。"></a>（3）显示隐藏文件，包括当前目录和父级目录。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[dablelv@<span class="title class_">TENCENT64</span> ~]$ ll -a</span><br><span class="line">total <span class="number">148</span></span><br><span class="line">drwxr-x---  <span class="number">8</span> dablelv dablelv  <span class="number">4096</span> <span class="title class_">Nov</span> <span class="number">23</span> <span class="number">23</span>:<span class="number">56</span> .</span><br><span class="line">drwxr-xr-x <span class="number">22</span> root    root     <span class="number">4096</span> <span class="title class_">Jun</span>  <span class="number">7</span> <span class="number">15</span>:<span class="number">15</span> ..</span><br><span class="line">-rw-------  <span class="number">1</span> dablelv dablelv <span class="number">71812</span> <span class="title class_">Nov</span> <span class="number">24</span> <span class="number">00</span>:<span class="number">38</span> .<span class="property">bash_history</span></span><br><span class="line">-rw-r--r--  <span class="number">1</span> dablelv dablelv  <span class="number">2153</span> <span class="title class_">May</span>  <span class="number">2</span>  <span class="number">2017</span> .<span class="property">bash_profile</span></span><br><span class="line">-rw-------  <span class="number">1</span> dablelv dablelv   <span class="number">595</span> <span class="title class_">Nov</span> <span class="number">24</span> <span class="number">16</span>:<span class="number">57</span> .<span class="property">lesshst</span></span><br><span class="line">drwx------  <span class="number">2</span> dablelv dablelv  <span class="number">4096</span> <span class="title class_">Jul</span> <span class="number">23</span> <span class="number">20</span>:<span class="number">42</span> .<span class="property">ssh</span></span><br></pre></td></tr></table></figure><p>ll实际是<code>ls -l</code>的别成，使用alias命令可以查看相关命令。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[dablelv@<span class="title class_">TENCENT64</span> ~]$ alias</span><br><span class="line">alias l.=<span class="string">&#x27;ls -d .* --color=auto&#x27;</span></span><br><span class="line">alias ll=<span class="string">&#x27;ls -l --color=auto&#x27;</span></span><br><span class="line">alias ls=<span class="string">&#x27;ls --color=auto&#x27;</span></span><br><span class="line">alias vi=<span class="string">&#x27;vim&#x27;</span></span><br><span class="line">alias which=<span class="string">&#x27;alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="（4）以指定的文件大小类型展示。"><a href="#（4）以指定的文件大小类型展示。" class="headerlink" title="（4）以指定的文件大小类型展示。"></a>（4）以指定的文件大小类型展示。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[dablelv@<span class="title class_">TENCENT64</span> ~]$ ll --block-size=K</span><br><span class="line">total 24K</span><br><span class="line">drwxrwxr-x <span class="number">10</span> dablelv dablelv 4K <span class="title class_">Nov</span> <span class="number">21</span> <span class="number">15</span>:<span class="number">08</span> code_root</span><br><span class="line">-rwxrwxr-x  <span class="number">1</span> dablelv dablelv 1K <span class="title class_">Nov</span> <span class="number">21</span> <span class="number">00</span>:<span class="number">18</span> dable.<span class="property">php</span></span><br><span class="line">-rw-rw-r--  <span class="number">1</span> dablelv dablelv 1K <span class="title class_">Nov</span> <span class="number">21</span> <span class="number">00</span>:<span class="number">18</span> dablelala.<span class="property">php</span></span><br><span class="line">-rw-rw-r--  <span class="number">1</span> dablelv dablelv 0K <span class="title class_">Nov</span> <span class="number">23</span> <span class="number">23</span>:<span class="number">56</span> dablelv~</span><br><span class="line">-rw-rw-r--  <span class="number">1</span> dablelv dablelv 1K <span class="title class_">Nov</span> <span class="number">21</span> <span class="number">00</span>:<span class="number">40</span> dablenewnew</span><br><span class="line">drwxrwxrwx  <span class="number">2</span> dablelv dablelv 4K <span class="title class_">Nov</span> <span class="number">21</span> <span class="number">00</span>:<span class="number">29</span> <span class="keyword">new</span></span><br><span class="line">drwxrwxr-x  <span class="number">6</span> dablelv dablelv 4K <span class="title class_">Nov</span> <span class="number">21</span> <span class="number">00</span>:<span class="number">24</span> test</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令——lsof命令</title>
      <link href="/FRank675.github.io/posts/4d9fc314d761/"/>
      <url>/FRank675.github.io/posts/4d9fc314d761/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="Linux命令——lsof命令"><a href="#Linux命令——lsof命令" class="headerlink" title="Linux命令——lsof命令"></a>Linux命令——lsof命令</h1><h2 id="1-命令简介"><a href="#1-命令简介" class="headerlink" title="1.命令简介"></a>1.命令简介</h2><p>​lsof（list open files）用于查看进程打开的文件，是十分方便的系统监测工具。</p><p>​因为 lsof 命令需要访问核心内存和各种系统文件，所以需要 root 权限才可执行。</p><p>在 Linux 系统中，一切皆文件。</p><p>​通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。所以 lsof 不仅可以查看进程打开的普通文件、目录，还可以查看进程监听的端口等 socket 相关的信息。</p><p>​进程打开的每一个文件，系统在后台都会为之分配一个文件描述符，无论这个文件的本质如何，该文件描述符为应用程序与基础操作系统之间的交互提供了通用接口。</p><p>​因为应用程序打开文件的描述符列表提供了大量关于这个应用程序本身的信息，因此通过 lsof 工具能够查看这个列表，对系统监测以及排错很有帮助。</p><p>lsof 查看的打开文件可以是：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">普通文件</span><br><span class="line">目录</span><br><span class="line">字符或块设备文件</span><br><span class="line">共享库</span><br><span class="line">管道、命名管道</span><br><span class="line">符号链接</span><br><span class="line">网络文件（如 <span class="variable constant_">NFS</span> file、网络 socket，<span class="title class_">Unix</span> 域名 socket）</span><br><span class="line">其它类型的文件，等等</span><br></pre></td></tr></table></figure><h2 id="2-命令格式"><a href="#2-命令格式" class="headerlink" title="2.命令格式"></a>2.命令格式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lsof [<span class="variable constant_">OPTIONS</span>] [--] [<span class="variable constant_">NAMES</span>]</span><br></pre></td></tr></table></figure><p>​在没有任何选项的情况下，lsof 列出所有属于活动进程的打开文件。</p><h2 id="3-选项说明"><a href="#3-选项说明" class="headerlink" title="3.选项说明"></a>3.选项说明</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">-?, -h </span><br><span class="line">显示帮助信息</span><br><span class="line">-a</span><br><span class="line">参数被视为逻辑与 <span class="variable constant_">AND</span>，会影响全部的参数</span><br><span class="line">-A A</span><br><span class="line">在配置了 <span class="variable constant_">AFS</span> 分布式网络文件系统的系统上可用，其 <span class="variable constant_">AFS</span> 内核代码是通过动态模块实现的。通过 A 指定备用名称列表文件，在该文件中可以找到动态模块的内核地址</span><br><span class="line">-b</span><br><span class="line">避免 lsof 因调用可能阻塞的内核函数而产生阻塞，比如 <span class="title function_">lstat</span>(<span class="number">2</span>)、<span class="title function_">readlink</span>(<span class="number">2</span>) 和 <span class="title function_">stat</span>(<span class="number">2</span>) 等内核函数</span><br><span class="line">-c C</span><br><span class="line">显示出以字符或字符串 C 开头的命令程序开启的文件，如 lsof -c init。如果 C 以斜杠 / 开头和结尾，则斜杠之间的字符被解释为正则表达式。该选项可多次指定</span><br><span class="line">+c W</span><br><span class="line">指定 <span class="variable constant_">COMMAND</span> 列的宽度，单位字符。默认为 <span class="number">9</span></span><br><span class="line">-C</span><br><span class="line">禁用从内核的名称缓存中报告任何路径名</span><br><span class="line">-D D</span><br><span class="line">指导 lsof 使用设备缓存文件。该选项的使用有时受到限制。-D 必须后面跟着一个函数字母，函数字母后面可以有一个路径名称。lsof 识别以下功能字母：</span><br><span class="line">?报告设备缓存文件路径</span><br><span class="line">b构建设备缓存文件</span><br><span class="line">i忽略设备缓存文件</span><br><span class="line">r读取设备缓存文件</span><br><span class="line">u读取并更新设备缓存文件</span><br><span class="line">+D D</span><br><span class="line">递归搜索目录 D。如显示在 /usr/local 及其子目录下被程序开启的文件：lsof +D /usr/local</span><br><span class="line">+d D</span><br><span class="line"> 非递归搜索目录 D。如显示在 /usr/local 下被程序开启的文件：lsof +d /usr/local</span><br><span class="line">-d <span class="variable constant_">FD</span></span><br><span class="line">指定文件描述符列表，可以采用逗号分隔，也可以指定范围。比如 <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> 或 <span class="number">1</span>-<span class="number">3</span>。如果前面包含尖号，表示排除。如显示 <span class="variable constant_">FD</span> 为 <span class="number">4</span> 的进程：lsof -d <span class="number">4</span></span><br><span class="line">+|-e S</span><br><span class="line">豁免（exempt）路径名称为 S 的文件系统不受可能阻塞的内核函数调用的影响。+e 选项豁免 <span class="title function_">stat</span>(<span class="number">2</span>)、<span class="title function_">lstat</span>(<span class="number">2</span>) 和大多数 <span class="title function_">readlink</span>(<span class="number">2</span>) 内核函数调用。-e 选项只能豁免 <span class="title function_">stat</span>(<span class="number">2</span>) 和 <span class="title function_">lstat</span>(<span class="number">2</span>) 内核函数调用</span><br><span class="line">+|-E</span><br><span class="line">+E 指定使用端点信息显示 <span class="title class_">Linux</span> 管道、<span class="title class_">Linux</span> <span class="variable constant_">UNIX</span> 套接字和 <span class="title class_">Linux</span> 伪终端文件，并显示端点的文件。-E 则不显示端点的文件</span><br><span class="line">-F <span class="variable constant_">LIST</span></span><br><span class="line">指定字符列表 <span class="variable constant_">LIST</span>，选择输出给另一程序处理的字段，各字段对应的字符见下文</span><br><span class="line">+|-f [cfgGn]</span><br><span class="line">f 本身澄清了路径名参数的解释方式。当后面跟着 c、f、g、G 或 n 时，它指定要启用（+）或抑制（-）内核文件结构信息。</span><br><span class="line">c 文件结构使用计数（not <span class="title class_">Linux</span>）</span><br><span class="line">f 文件结构地址（not <span class="title class_">Linux</span>）</span><br><span class="line">g 文件标志缩写（<span class="title class_">Linux</span> <span class="number">2.6</span><span class="number">.22</span> 及更高版本）</span><br><span class="line">G 十六进制文件标志（<span class="title class_">Linux</span> <span class="number">2.6</span><span class="number">.22</span> 及更高版本）</span><br><span class="line">n 文件结构节点地址（not <span class="title class_">Linux</span>）</span><br><span class="line">-g [<span class="variable constant_">PGID</span>]</span><br><span class="line">选择或排除属于指定进程组的进程打开的文件。 进程组 <span class="variable constant_">ID</span> 使用逗号分隔，如果 <span class="variable constant_">PGID</span> 前面包含尖号，表示排除。若没有指定 <span class="variable constant_">PGID</span>，则显示全部。如显示 <span class="variable constant_">PGID</span> 为 <span class="number">6</span> 和 <span class="number">7</span> 的进程：lsof -g6,<span class="number">7</span></span><br><span class="line">-i [I]</span><br><span class="line">选择其 <span class="title class_">Internet</span> 地址与 -i 中指定的地址匹配的文件，若没有相关地址被指定，则监听全部。</span><br><span class="line">用法： lsof -i [<span class="number">46</span>][protocol][@hostname|hostaddr][:serivce|port]</span><br><span class="line">说明：<span class="number">4</span> <span class="number">6</span> 分别表示 <span class="title class_">IPv4</span> 和 <span class="title class_">IPv6</span>   </span><br><span class="line">    protocol： <span class="variable constant_">TCP</span> or <span class="variable constant_">UDP</span>   </span><br><span class="line">    hostname：主机名</span><br><span class="line">    hostaddr：<span class="title class_">IPv4</span> 或 <span class="title class_">IPv6</span> 地址</span><br><span class="line">    service：主机提供的服务的名称，即 /etc/services 中的 service name</span><br><span class="line">    port：端口号</span><br><span class="line">-K</span><br><span class="line">在支持任务（线程）报告方式的系统上输出进程的任务（线程）列表</span><br><span class="line">-k K</span><br><span class="line">指定内核名称列表文件，代替 /vmunix、/mach 等</span><br><span class="line">-l</span><br><span class="line">禁止将 user <span class="variable constant_">ID</span> 转换为登录的名称，默认是登录名称</span><br><span class="line">+|-L [L]</span><br><span class="line">+ 或 - 表示开启或关闭显示文件连接数，如果只有单纯的 +L，后面没有任何数字，则表示显示全部，如果后面有数字，只有文件连接数少于该数字的会被列出</span><br><span class="line">+|-m M</span><br><span class="line">-m 指定一个内核内存文件 M ，代替 /dev/kmem 或 /dev/mem。+m 将装载补充文件写入标准输出文件</span><br><span class="line">+|-M</span><br><span class="line">启用或禁用报告本地 <span class="variable constant_">TCP</span>、<span class="variable constant_">UDP</span> 和 <span class="variable constant_">UDPLITE</span> 端口的端口映射器注册</span><br><span class="line">-n</span><br><span class="line">不将 <span class="variable constant_">IP</span> 地址转换为主机名</span><br><span class="line">-N</span><br><span class="line">显示 <span class="variable constant_">NFS</span> 文件</span><br><span class="line">-o</span><br><span class="line">始终显示文件偏移量。它导致 <span class="variable constant_">SIZE</span>/<span class="variable constant_">OFF</span> 输出列标题更改为 <span class="variable constant_">OFFSET</span></span><br><span class="line">-o O</span><br><span class="line">指定在文件偏移量的 0t 之后要打印的小数位数</span><br><span class="line">-O</span><br><span class="line">指示 lsof 避免被某些内核操作阻塞。即在分叉的子进程中执行它们。虽然使用此选项将减少 lsof 启动开销，但也可能导致 lsof 在内核不响应函数时挂起。谨慎使用此选项</span><br><span class="line">-P</span><br><span class="line">禁止将网络文件的端口号转换为端口名</span><br><span class="line">-p S</span><br><span class="line">排除或选择进程的文件列表，进程 <span class="variable constant_">ID</span> 列表使用逗号分隔，如 <span class="number">123</span> 或 <span class="number">123</span>,^<span class="number">456</span>。尖号表示排除指定 <span class="variable constant_">PID</span></span><br><span class="line">-R</span><br><span class="line">使用列 <span class="variable constant_">PPID</span> 列出父进程的 <span class="variable constant_">PID</span></span><br><span class="line">+|-r [T[mFMT]]</span><br><span class="line"> 控制 lsof 不断重复执行，间隔 T 秒，默认为 15s。-r 永远不断地执行，直到收到中断讯号（ctrl+ c），+r 一直执行，直到没有文件被显示。可选的 mFMT 参数指定标记线的格式，格式 <span class="variable constant_">FMT</span> 遵循 C 语言标准库函数 <span class="title function_">strftime</span>(<span class="number">3</span>) 的规范</span><br><span class="line">-S [T]</span><br><span class="line">指定内核函数 <span class="title function_">lstat</span>(<span class="number">2</span>)、<span class="title function_">readlink</span>(<span class="number">2</span>) 和 <span class="title function_">stat</span>(<span class="number">2</span>) 的可选超时秒值，否则可能会死锁。t 的最小值是 <span class="number">2</span>；默认值是 <span class="number">15</span></span><br><span class="line">-s [<span class="attr">P</span>:S]</span><br><span class="line">列出文件的大小，若该文件没有大小，则留下空白。它导致 <span class="variable constant_">SIZE</span>/<span class="variable constant_">OFF</span> 输出列标题更改为 <span class="variable constant_">SIZE</span>。P 表示协议名称 <span class="variable constant_">TCP</span>  or  <span class="variable constant_">UDP</span>，S 表示逗号分隔的协议状态</span><br><span class="line">-T [T]</span><br><span class="line">-T 没有参数则禁用 <span class="variable constant_">TCP</span>/<span class="variable constant_">TPI</span> 信息报告。跟如下参数，则显示指定 <span class="variable constant_">TCP</span>/<span class="variable constant_">TPI</span> 信息：</span><br><span class="line">f 选择报告套接字选项，状态和值，以及 <span class="variable constant_">TCP</span>标志和值</span><br><span class="line">q 选择队列长度</span><br><span class="line">s 选择连接状态</span><br><span class="line">w 选择窗口大小</span><br><span class="line">-t</span><br><span class="line">生成只有进程标识符而没有标题的简洁输出，这样输出可以通过管道传递给 <span class="title function_">kill</span>(<span class="number">1</span>) 杀死</span><br><span class="line">-U</span><br><span class="line">选择 <span class="variable constant_">UNIX</span> 域套接字文件的列表</span><br><span class="line">-u <span class="variable constant_">USERS</span></span><br><span class="line">选择登录名或用户 <span class="variable constant_">ID</span> 位于逗号分隔集 <span class="variable constant_">USERS</span> 中的用户的文件列表。如 root 或 <span class="number">548</span>,root”，如果用户名或用户 <span class="variable constant_">ID</span> 前有尖号 ^，表示排除</span><br><span class="line">-V</span><br><span class="line">指示被要求列出但找不到的项</span><br><span class="line">-v</span><br><span class="line">    显示版本信息</span><br><span class="line">+|-w</span><br><span class="line">   启用（＋）或禁用（－）警告消息</span><br><span class="line">-X</span><br><span class="line"><span class="title class_">Linux</span> 下跳过所有打开的 <span class="variable constant_">TCP</span>、<span class="variable constant_">UDP</span> 和 <span class="variable constant_">UDPLITE</span> <span class="title class_">IPv4</span> 和 <span class="title class_">IPv6</span> 文件的信息报告</span><br><span class="line">-x [fl]</span><br><span class="line">一般与选项 +d 和 +D 选项，指示搜索时是否跨文件系统和符号链接。-x 不跟任何参数时，表示跨文件系统和符号链接</span><br><span class="line">-Z [Z]</span><br><span class="line">指定如何处理 <span class="title class_">SELinux</span> 安全上下文。当在运行的 <span class="title class_">Linux</span> 内核中禁用<span class="title class_">SELinux</span>时，Z 字段将被抑制输出。-Z 选项不跟参数，如 -Z -，安全上下文将列在 <span class="variable constant_">SECURITY</span>-<span class="variable constant_">CONTEXT</span> 列中输出</span><br><span class="line">--</span><br><span class="line">双减号表示选项结束</span><br><span class="line"><span class="variable constant_">NAMES</span></span><br><span class="line">列出指定文件，符号链接在使用前将被解析</span><br></pre></td></tr></table></figure><h2 id="4-输出字段说明"><a href="#4-输出字段说明" class="headerlink" title="4.输出字段说明"></a>4.输出字段说明</h2><p>​当指定了 -F 选项时，lsof 将生成适合由另一个程序（如 awk 或 Perl 脚本或 C 程序）处理的输出。</p><p>​下面是 lsof 可输出的字段。单个字符表示字段标识符。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a文件访问模式</span><br><span class="line">c进程命令名</span><br><span class="line">C文件结构共享计数</span><br><span class="line">d文件的设备字符码</span><br><span class="line">D文件的主要/次要设备号</span><br><span class="line">F文件结构地址</span><br><span class="line">f文件描述符</span><br><span class="line">G文件标志</span><br><span class="line">g进程组 <span class="variable constant_">ID</span></span><br><span class="line">i文件 inode 编号</span><br><span class="line">K任务 <span class="variable constant_">ID</span></span><br><span class="line">k链接计数</span><br><span class="line">L进程登录名</span><br><span class="line">m重复输出之间的标记</span><br><span class="line">N节点标识符</span><br><span class="line">n文件名、注释、<span class="title class_">Internet</span> 地址</span><br><span class="line">o文件偏移量（十进制）</span><br><span class="line">P协议名称</span><br><span class="line">p进程 <span class="variable constant_">ID</span></span><br><span class="line">R父进程 <span class="variable constant_">ID</span></span><br><span class="line">r原始设备号</span><br><span class="line">S文件的流标识</span><br><span class="line">s文件大小（十进制）</span><br><span class="line">T<span class="variable constant_">TCP</span>/<span class="variable constant_">TPI</span> 信息</span><br><span class="line">t文件类型</span><br><span class="line">u进程用户 <span class="variable constant_">ID</span></span><br><span class="line">Z<span class="title class_">SELinux</span> 安全上下文（禁用 <span class="title class_">SELinux</span> 时禁用）</span><br><span class="line">z<span class="title class_">Solaris</span> <span class="number">10</span> 及更高版本的区域名</span><br><span class="line"><span class="number">0</span>使用<span class="variable constant_">NUL</span>字段结束符字符代替<span class="variable constant_">NL</span></span><br><span class="line"><span class="number">1</span>-<span class="number">9</span>系统特定的字段标识符</span><br></pre></td></tr></table></figure><p>​可以使用命令 <code>lsof -F?</code> 查看上面字段的说明信息。</p><h2 id="5-常用示例"><a href="#5-常用示例" class="headerlink" title="5.常用示例"></a>5.常用示例</h2><h3 id="（1）无任何参数，列出所有属于活动进程的打开文件。"><a href="#（1）无任何参数，列出所有属于活动进程的打开文件。" class="headerlink" title="（1）无任何参数，列出所有属于活动进程的打开文件。"></a>（1）无任何参数，列出所有属于活动进程的打开文件。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lsof | head</span><br><span class="line"><span class="variable constant_">COMMAND</span>     <span class="variable constant_">PID</span>   <span class="variable constant_">TID</span> <span class="variable constant_">USER</span>   <span class="variable constant_">FD</span>      <span class="variable constant_">TYPE</span>             <span class="variable constant_">DEVICE</span> <span class="variable constant_">SIZE</span>/<span class="variable constant_">OFF</span>       <span class="variable constant_">NODE</span> <span class="variable constant_">NAME</span></span><br><span class="line">systemd       <span class="number">1</span>       root  cwd       <span class="variable constant_">DIR</span>              <span class="number">252</span>,<span class="number">1</span>     <span class="number">4096</span>          <span class="number">2</span> /</span><br><span class="line">systemd       <span class="number">1</span>       root  rtd       <span class="variable constant_">DIR</span>              <span class="number">252</span>,<span class="number">1</span>     <span class="number">4096</span>          <span class="number">2</span> /</span><br><span class="line">systemd       <span class="number">1</span>       root  txt       <span class="variable constant_">REG</span>              <span class="number">252</span>,<span class="number">1</span>  <span class="number">1616248</span>      <span class="number">47908</span> /usr/lib/systemd/systemd</span><br><span class="line">systemd       <span class="number">1</span>       root  mem       <span class="variable constant_">REG</span>              <span class="number">252</span>,<span class="number">1</span>    <span class="number">20032</span>      <span class="number">25897</span> /usr/lib64/libuuid.<span class="property">so</span><span class="number">.1</span><span class="number">.3</span><span class="number">.0</span></span><br><span class="line">systemd       <span class="number">1</span>       root  mem       <span class="variable constant_">REG</span>              <span class="number">252</span>,<span class="number">1</span>   <span class="number">252704</span>      <span class="number">25043</span> /usr/lib64/libblkid.<span class="property">so</span><span class="number">.1</span><span class="number">.1</span><span class="number">.0</span></span><br><span class="line">systemd       <span class="number">1</span>       root  mem       <span class="variable constant_">REG</span>              <span class="number">252</span>,<span class="number">1</span>    <span class="number">90632</span>      <span class="number">25988</span> /usr/lib64/libz.<span class="property">so</span><span class="number">.1</span><span class="number">.2</span><span class="number">.7</span></span><br><span class="line">systemd       <span class="number">1</span>       root  mem       <span class="variable constant_">REG</span>              <span class="number">252</span>,<span class="number">1</span>   <span class="number">153192</span>      <span class="number">25496</span> /usr/lib64/liblzma.<span class="property">so</span><span class="number">.5</span><span class="number">.0</span><span class="number">.99</span></span><br><span class="line">systemd       <span class="number">1</span>       root  mem       <span class="variable constant_">REG</span>              <span class="number">252</span>,<span class="number">1</span>    <span class="number">23968</span>      <span class="number">25065</span> /usr/lib64/libcap-ng.<span class="property">so</span><span class="number">.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">systemd       <span class="number">1</span>       root  mem       <span class="variable constant_">REG</span>              <span class="number">252</span>,<span class="number">1</span>    <span class="number">19888</span>      <span class="number">25018</span> /usr/lib64/libattr.<span class="property">so</span><span class="number">.1</span><span class="number">.1</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><p>​lsof 输出各列信息的意义如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">COMMAND</span>：进程的名称</span><br><span class="line"><span class="variable constant_">PID</span>：进程标识符</span><br><span class="line"><span class="variable constant_">TID</span>：任务 <span class="variable constant_">ID</span>。<span class="title class_">Linux</span> 下 <span class="variable constant_">TID</span> 为空表示该行为进程</span><br><span class="line"><span class="variable constant_">USER</span>：进程所有者</span><br><span class="line"><span class="variable constant_">FD</span>：文件描述符。主要有：</span><br><span class="line">cwd：应用程序当前工作目录，这是该应用程序启动的目录，除非它本身对这个目录进行更改</span><br><span class="line">txt：该类型的文件是程序代码，如应用程序二进制文件本身或共享库，如上列表中显示的 /sbin/init 程序</span><br><span class="line">lnn：库引用（<span class="variable constant_">AIX</span>）</span><br><span class="line">err：<span class="variable constant_">FD</span> 信息错误</span><br><span class="line">jld：监狱目录（<span class="title class_">FreeBSD</span>）</span><br><span class="line">ltx：共享库文本（代码和数据）</span><br><span class="line">mxx：十六进制内存映射类型号 xx</span><br><span class="line">m86：<span class="variable constant_">DOS</span>合并映射文件</span><br><span class="line">mem：内存映射文件</span><br><span class="line">mmap：内存映射设备</span><br><span class="line">pd：父目录</span><br><span class="line">rtd：根目录</span><br><span class="line">tr：内核跟踪文件（<span class="title class_">OpenBSD</span>）</span><br><span class="line">v86：<span class="variable constant_">VP</span>/ix 映射文件</span><br><span class="line"><span class="number">0</span>：标准输出</span><br><span class="line"><span class="number">1</span>：标准输入</span><br><span class="line"><span class="number">2</span>：标准错误</span><br><span class="line"></span><br><span class="line">文件描述符后一般还跟着文件状态模式：</span><br><span class="line">r：只读模式</span><br><span class="line">w：写入模式</span><br><span class="line">u：读写模式</span><br><span class="line">空格：文件的状态模式为 unknow，且没有锁定</span><br><span class="line">-：文件的状态模式为 unknow，且被锁定</span><br><span class="line"></span><br><span class="line">同时在文件状态模式后面，还跟着相关的锁：</span><br><span class="line">N：对于未知类型的 <span class="title class_">Solaris</span> <span class="variable constant_">NFS</span> 锁</span><br><span class="line">r：文件部分的读锁</span><br><span class="line">R：整个文件的读锁</span><br><span class="line">w：文件的部分写锁</span><br><span class="line">W：整个文件的写锁</span><br><span class="line">u：任何长度的读写锁</span><br><span class="line">U：用于未知类型的锁</span><br><span class="line">x：用于部分文件上的 <span class="variable constant_">SCO</span> <span class="title class_">OpenServer</span> <span class="title class_">Xenix</span> 锁</span><br><span class="line">X：用于整个文件上的 <span class="variable constant_">SCO</span> <span class="title class_">OpenServer</span> <span class="title class_">Xenix</span> 锁</span><br><span class="line">space：无锁</span><br><span class="line"></span><br><span class="line"><span class="variable constant_">TYPE</span>：文件类型。常见的文件类型有：</span><br><span class="line"><span class="variable constant_">REG</span>：普通文件</span><br><span class="line"><span class="variable constant_">DIR</span>：表示目录</span><br><span class="line"><span class="variable constant_">CHR</span>：表示字符类型</span><br><span class="line"><span class="variable constant_">BLK</span>：块设备类型</span><br><span class="line"><span class="variable constant_">UNIX</span>：<span class="variable constant_">UNIX</span> 域套接字</span><br><span class="line"><span class="variable constant_">FIFO</span>：先进先出队列</span><br><span class="line"><span class="title class_">IPv4</span>：<span class="title class_">IPv4</span> 套接字</span><br><span class="line"><span class="variable constant_">DEVICE</span>：磁盘名称</span><br><span class="line"><span class="variable constant_">SIZE</span>：文件的大小或文件偏移量（以字节为单位）</span><br><span class="line"><span class="variable constant_">NODE</span>：索引节点</span><br><span class="line"><span class="variable constant_">NAME</span>：打开文件的确切名称</span><br></pre></td></tr></table></figure><h3 id="（2）查看谁正在使用某个文件，也就是说查找某个文件相关的进程。"><a href="#（2）查看谁正在使用某个文件，也就是说查找某个文件相关的进程。" class="headerlink" title="（2）查看谁正在使用某个文件，也就是说查找某个文件相关的进程。"></a>（2）查看谁正在使用某个文件，也就是说查找某个文件相关的进程。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lsof /bin/bash</span><br><span class="line"><span class="variable constant_">COMMAND</span>     <span class="variable constant_">PID</span> <span class="variable constant_">USER</span>  <span class="variable constant_">FD</span>   <span class="variable constant_">TYPE</span> <span class="variable constant_">DEVICE</span> <span class="variable constant_">SIZE</span>/<span class="variable constant_">OFF</span>  <span class="variable constant_">NODE</span> <span class="variable constant_">NAME</span></span><br><span class="line">watchdog.  <span class="number">7639</span> root txt    <span class="variable constant_">REG</span>  <span class="number">252</span>,<span class="number">1</span>   <span class="number">922760</span> <span class="number">45210</span> /usr/bin/bash</span><br><span class="line">bash       <span class="number">8591</span> root txt    <span class="variable constant_">REG</span>  <span class="number">252</span>,<span class="number">1</span>   <span class="number">922760</span> <span class="number">45210</span> /usr/bin/bash</span><br><span class="line">bash       <span class="number">9694</span> root txt    <span class="variable constant_">REG</span>  <span class="number">252</span>,<span class="number">1</span>   <span class="number">922760</span> <span class="number">45210</span> /usr/bin/bash</span><br><span class="line">bash      <span class="number">20151</span> root txt    <span class="variable constant_">REG</span>  <span class="number">252</span>,<span class="number">1</span>   <span class="number">922760</span> <span class="number">45210</span> /usr/bin/bash</span><br></pre></td></tr></table></figure><h3 id="（3）递归查看某个目录下所有被打开的文件信息。"><a href="#（3）递归查看某个目录下所有被打开的文件信息。" class="headerlink" title="（3）递归查看某个目录下所有被打开的文件信息。"></a>（3）递归查看某个目录下所有被打开的文件信息。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lsof +D ./test</span><br><span class="line"><span class="variable constant_">COMMAND</span>  <span class="variable constant_">PID</span> <span class="variable constant_">USER</span>   <span class="variable constant_">FD</span>   <span class="variable constant_">TYPE</span> <span class="variable constant_">DEVICE</span> <span class="variable constant_">SIZE</span>/<span class="variable constant_">OFF</span>   <span class="variable constant_">NODE</span> <span class="variable constant_">NAME</span></span><br><span class="line">bash    <span class="number">8518</span> root  cwd    <span class="variable constant_">DIR</span>  <span class="number">252</span>,<span class="number">1</span>     <span class="number">4096</span> <span class="number">799036</span> ./test/shell</span><br></pre></td></tr></table></figure><h3 id="（4）列出某个用户打开的文件信息。"><a href="#（4）列出某个用户打开的文件信息。" class="headerlink" title="（4）列出某个用户打开的文件信息。"></a>（4）列出某个用户打开的文件信息。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lsof -u root</span><br></pre></td></tr></table></figure><h3 id="（5）列出某个进程所打开的文件信息。"><a href="#（5）列出某个进程所打开的文件信息。" class="headerlink" title="（5）列出某个进程所打开的文件信息。"></a>（5）列出某个进程所打开的文件信息。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lsof -c sshd</span><br></pre></td></tr></table></figure><p>-c 选项将会列出所有以 sshd 开头的进程所打开的文件。其实也可以通过命令<code>lsof | grep sshd</code>来查看，但是第一种方法更加简洁。</p><h3 id="（6）列出多个进程打开的文件信息。"><a href="#（6）列出多个进程打开的文件信息。" class="headerlink" title="（6）列出多个进程打开的文件信息。"></a>（6）列出多个进程打开的文件信息。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lsof -c mysql -c apache</span><br></pre></td></tr></table></figure><h3 id="（7）列出某个用户以及某个进程所打开的文件信息。"><a href="#（7）列出某个用户以及某个进程所打开的文件信息。" class="headerlink" title="（7）列出某个用户以及某个进程所打开的文件信息。"></a>（7）列出某个用户以及某个进程所打开的文件信息。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lsof -u test -c mysql </span><br></pre></td></tr></table></figure><p>注意，-u 与 -c 选项之间是或的关系。可以使用 -</p><h3 id="（8）列出除了某个用户外的所有被打开的文件信息。"><a href="#（8）列出除了某个用户外的所有被打开的文件信息。" class="headerlink" title="（8）列出除了某个用户外的所有被打开的文件信息。"></a>（8）列出除了某个用户外的所有被打开的文件信息。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lsof -u ^root</span><br></pre></td></tr></table></figure><p>尖号 ^ 在用户名之前，表示排除在外，即不显示 root 用户所打开的文件信息。</p><h3 id="（9）通过某个进程号显示该进程打开的文件。"><a href="#（9）通过某个进程号显示该进程打开的文件。" class="headerlink" title="（9）通过某个进程号显示该进程打开的文件。"></a>（9）通过某个进程号显示该进程打开的文件。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lsof -p <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="（10）列出多个进程号对应的文件信息。"><a href="#（10）列出多个进程号对应的文件信息。" class="headerlink" title="（10）列出多个进程号对应的文件信息。"></a>（10）列出多个进程号对应的文件信息。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lsof -p <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="（11）列出除了某个进程号，其他进程号所打开的文件信息。"><a href="#（11）列出除了某个进程号，其他进程号所打开的文件信息。" class="headerlink" title="（11）列出除了某个进程号，其他进程号所打开的文件信息。"></a>（11）列出除了某个进程号，其他进程号所打开的文件信息。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lsof -p ^<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="（12）列出所有的网络连接。"><a href="#（12）列出所有的网络连接。" class="headerlink" title="（12）列出所有的网络连接。"></a>（12）列出所有的网络连接。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lsof -i</span><br></pre></td></tr></table></figure><h3 id="（13）列出所有的-TCP-网络连接信息。"><a href="#（13）列出所有的-TCP-网络连接信息。" class="headerlink" title="（13）列出所有的 TCP 网络连接信息。"></a>（13）列出所有的 TCP 网络连接信息。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lsof -i tcp</span><br></pre></td></tr></table></figure><h3 id="（14）列出所有-UDP-网络连接信息。"><a href="#（14）列出所有-UDP-网络连接信息。" class="headerlink" title="（14）列出所有 UDP 网络连接信息。"></a>（14）列出所有 UDP 网络连接信息。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lsof -i udp</span><br></pre></td></tr></table></figure><h3 id="（15）列出谁在使用某个端口。"><a href="#（15）列出谁在使用某个端口。" class="headerlink" title="（15）列出谁在使用某个端口。"></a>（15）列出谁在使用某个端口。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lsof -i :<span class="number">3306</span></span><br></pre></td></tr></table></figure><h3 id="（16）列出谁在使用某个特定的-UDP-或-TCP-端口。"><a href="#（16）列出谁在使用某个特定的-UDP-或-TCP-端口。" class="headerlink" title="（16）列出谁在使用某个特定的 UDP 或 TCP 端口。"></a>（16）列出谁在使用某个特定的 UDP 或 TCP 端口。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lsof -i <span class="attr">udp</span>:<span class="number">55</span></span><br><span class="line">lsof -i <span class="attr">tcp</span>:<span class="number">80</span></span><br></pre></td></tr></table></figure><h3 id="（17）列出某个用户的所有活跃的网络端口。"><a href="#（17）列出某个用户的所有活跃的网络端口。" class="headerlink" title="（17）列出某个用户的所有活跃的网络端口。"></a>（17）列出某个用户的所有活跃的网络端口。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lsof -a -u test -i</span><br></pre></td></tr></table></figure><h3 id="（18）列出所有网络文件系统。"><a href="#（18）列出所有网络文件系统。" class="headerlink" title="（18）列出所有网络文件系统。"></a>（18）列出所有网络文件系统。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lsof -N</span><br></pre></td></tr></table></figure><h3 id="（19）选择-UNIX-域套接字文件的列表。"><a href="#（19）选择-UNIX-域套接字文件的列表。" class="headerlink" title="（19）选择 UNIX 域套接字文件的列表。"></a>（19）选择 UNIX 域套接字文件的列表。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lsof -U</span><br></pre></td></tr></table></figure><h3 id="（20）查看某个用户组所打开的文件信息。"><a href="#（20）查看某个用户组所打开的文件信息。" class="headerlink" title="（20）查看某个用户组所打开的文件信息。"></a>（20）查看某个用户组所打开的文件信息。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lsof -g <span class="number">5555</span></span><br></pre></td></tr></table></figure><h3 id="（21）根据指定文件描述符的文件信息。"><a href="#（21）根据指定文件描述符的文件信息。" class="headerlink" title="（21）根据指定文件描述符的文件信息。"></a>（21）根据指定文件描述符的文件信息。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lsof -d txt</span><br><span class="line">lsof -d <span class="number">1</span></span><br><span class="line">lsof -d <span class="number">2</span></span><br></pre></td></tr></table></figure><p>0 表示标准输入，1 表示标准输出，2 表示标准错误，从而可知：所以大多数应用程序所打开的文件的 FD 都是从 3 开始。</p><h3 id="（22）查看指定文件描述符范围的文件信息。"><a href="#（22）查看指定文件描述符范围的文件信息。" class="headerlink" title="（22）查看指定文件描述符范围的文件信息。"></a>（22）查看指定文件描述符范围的文件信息。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lsof -d <span class="number">2</span>-<span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="（23列出-COMMAND-列中包含字符串-sshd-且文件描符的类型为-txt-的文件信息。"><a href="#（23列出-COMMAND-列中包含字符串-sshd-且文件描符的类型为-txt-的文件信息。" class="headerlink" title="（23列出 COMMAND 列中包含字符串 sshd 且文件描符的类型为 txt 的文件信息。"></a>（23列出 COMMAND 列中包含字符串 sshd 且文件描符的类型为 txt 的文件信息。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lsof -c sshd -a -d txt</span><br><span class="line"><span class="variable constant_">COMMAND</span>   <span class="variable constant_">PID</span> <span class="variable constant_">USER</span>  <span class="variable constant_">FD</span>   <span class="variable constant_">TYPE</span> <span class="variable constant_">DEVICE</span> <span class="variable constant_">SIZE</span>/<span class="variable constant_">OFF</span>  <span class="variable constant_">NODE</span> <span class="variable constant_">NAME</span></span><br><span class="line">sshd     <span class="number">8254</span> root txt    <span class="variable constant_">REG</span>  <span class="number">252</span>,<span class="number">1</span>   <span class="number">819608</span> <span class="number">27632</span> /usr/sbin/sshd</span><br><span class="line">sshd    <span class="number">20149</span> root txt    <span class="variable constant_">REG</span>  <span class="number">252</span>,<span class="number">1</span>   <span class="number">819608</span> <span class="number">27632</span> /usr/sbin/sshd</span><br></pre></td></tr></table></figure><h3 id="（24）列出被进程号为-1234-的进程所打开的所有-IPV4-网络文件。"><a href="#（24）列出被进程号为-1234-的进程所打开的所有-IPV4-网络文件。" class="headerlink" title="（24）列出被进程号为 1234 的进程所打开的所有 IPV4 网络文件。"></a>（24）列出被进程号为 1234 的进程所打开的所有 IPV4 网络文件。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lsof -p <span class="number">1234</span> -a -i <span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="（25）列出目前连接主机-peida-linux-上端口为：20，21，22，25-相关的所有文件信息，且每隔-3-秒不断地执行-lsof-指令。"><a href="#（25）列出目前连接主机-peida-linux-上端口为：20，21，22，25-相关的所有文件信息，且每隔-3-秒不断地执行-lsof-指令。" class="headerlink" title="（25）列出目前连接主机 peida.linux 上端口为：20，21，22，25 相关的所有文件信息，且每隔 3 秒不断地执行 lsof 指令。"></a>（25）列出目前连接主机 peida.linux 上端口为：20，21，22，25 相关的所有文件信息，且每隔 3 秒不断地执行 lsof 指令。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lsof -i @peida.<span class="property">linux</span>:<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">25</span> -r <span class="number">3</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令——ifconfig命令</title>
      <link href="/FRank675.github.io/posts/39c694be31b5/"/>
      <url>/FRank675.github.io/posts/39c694be31b5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="Linux命令——ifconfig命令"><a href="#Linux命令——ifconfig命令" class="headerlink" title="Linux命令——ifconfig命令"></a>Linux命令——ifconfig命令</h1><h2 id="1-命令简介"><a href="#1-命令简介" class="headerlink" title="1.命令简介"></a>1.命令简介</h2><p>ifconfig（configure a network interface）命令是系统管理员命令，用于查看和配置网络接口。</p><h2 id="2-命令格式"><a href="#2-命令格式" class="headerlink" title="2.命令格式"></a>2.命令格式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ifconfig [-v] [-a] [-s] [<span class="variable constant_">INTERFACE</span>]</span><br><span class="line">ifconfig [-v] <span class="variable constant_">INTERFACE</span> [aftype] <span class="variable constant_">OPTIONS</span> | <span class="variable constant_">ADDRESS</span> ...</span><br></pre></td></tr></table></figure><p>不跟任何选项和参数单独执行 ifconfig 命令将显示当前活动接口的状态。</p><p>如果给定一个接口参数，则它仅显示给定接口的状态。</p><p>如果只给一个选项 -a，它将显示所有接口的状态，包括那些关闭的接口。其他情况，用于配置一个接口。</p><h2 id="3-选项说明"><a href="#3-选项说明" class="headerlink" title="3.选项说明"></a>3.选项说明</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">-a</span><br><span class="line">显示所有接口的状态，包括那些关闭的接口</span><br><span class="line">-s</span><br><span class="line">显示接口简短状态列表，类似于 netstat -i</span><br><span class="line">-v</span><br><span class="line">冗余模式，遇到错误将报告错误信息</span><br><span class="line"><span class="variable constant_">INTERFACE</span></span><br><span class="line">接口的名称。这通常是一个驱动程序名，后面跟着一个单元号，例如用于第一个以太网接口的 eth0</span><br><span class="line">up</span><br><span class="line">此标志将导致激活接口。如果将地址分配给接口，则会隐式激活接口</span><br><span class="line">down</span><br><span class="line">此标志用于关闭接口的驱动程序</span><br><span class="line">[-]arp</span><br><span class="line">启用或关闭接口使用 <span class="variable constant_">ARP</span> 协议</span><br><span class="line">[-]promisc</span><br><span class="line">启用或禁用接口的混杂模式。如果选中，网络上的所有数据包都将由接口接收</span><br><span class="line">[-]allmulti</span><br><span class="line">启用或禁用所有多播模式。如果选中，则接口将接收网络上的所有多播数据包</span><br><span class="line">mtu N</span><br><span class="line">设置接口的最大传输单元</span><br><span class="line">dstaddr <span class="variable constant_">ADDR</span></span><br><span class="line">为点对点链路（如 <span class="variable constant_">PPP</span>）设置远程 <span class="variable constant_">IP</span> 地址。关键字 dstaddr 现在已经过时了，使用 pointopoint 关键字代替</span><br><span class="line">netmask <span class="variable constant_">ADDR</span></span><br><span class="line">设置接口的 <span class="variable constant_">IP</span> 网络掩码。此值默认为通常的 A、B 或 C 类网络掩码（从接口 <span class="variable constant_">IP</span> 地址派生），但可以设置为任何值</span><br><span class="line">add <span class="variable constant_">ADDR</span>/<span class="variable constant_">PREFIX_LEN</span></span><br><span class="line">向接口添加 <span class="title class_">IPv6</span> 地址</span><br><span class="line">del <span class="variable constant_">ADDR</span>/<span class="variable constant_">PREFIX_LEN</span></span><br><span class="line">从接口中删除 <span class="title class_">IPv6</span> 地址</span><br><span class="line">tunnel ::aa.<span class="property">bb</span>.<span class="property">cc</span>.<span class="property">dd</span></span><br><span class="line">创建一个新的<span class="title function_">SIT</span>(<span class="title class_">IPv6</span>-<span class="keyword">in</span>-<span class="title class_">IPv4</span>)设备，通过隧道到达给定的目的地</span><br><span class="line">irq <span class="variable constant_">ADDR</span></span><br><span class="line">设置此设备使用的中断行。并非所有设备都可以动态更改其 <span class="variable constant_">IRQ</span> 设置</span><br><span class="line">io_addr <span class="variable constant_">ADDR</span></span><br><span class="line">为该设备设置 I/O 空间中的起始地址</span><br><span class="line">mem_start <span class="variable constant_">ADDR</span></span><br><span class="line">设置此设备使用的共享内存的起始地址。只有少数几个设备需要这个</span><br><span class="line">media <span class="variable constant_">TYPE</span></span><br><span class="line">设置设备要使用的物理端口或介质类型。典型的类型值有10base2（细以太网）、10baseT（双绞线 10Mbps 以太网）、<span class="variable constant_">AUI</span>（外部收发器）等。特殊的媒体类型可以使用 auto 来告诉驱动程序进行自动感知。注意，并非所有设备都可以更改此设置</span><br><span class="line">[-]broadcast [<span class="variable constant_">ADDR</span>]</span><br><span class="line">如果给定地址参数，则为该接口设置协议广播地址。否则设置（或清除）接口的 <span class="variable constant_">IFF_BROADCAST</span>标志</span><br><span class="line">[-]pointopoint [<span class="variable constant_">ADDR</span>]</span><br><span class="line">这个关键字启用了接口的点对点模式，这意味着它是两台机器之间的直接连接，没有其他人监听它。如果给了地址参数，就像过时的 dstaddr 关键字一样，设置另一端的协议地址。否则设置或清除接口的 <span class="variable constant_">IFF_POINTOPOINT</span> 标志</span><br><span class="line">hw <span class="variable constant_">CLASS</span> <span class="variable constant_">ADDR</span></span><br><span class="line">如果设备驱动程序支持此操作，则设置此接口的物理地址。<span class="variable constant_">CLASS</span> 为硬件类型名称，<span class="variable constant_">ADDR</span> 为物理地址。目前支持的硬件类包括 ether (<span class="title class_">Ethernet</span>)、ax25 (<span class="variable constant_">AMPR</span> <span class="variable constant_">AX</span><span class="number">.25</span>)、<span class="title class_">ARCnet</span> 和 netrom (<span class="variable constant_">AMPR</span> <span class="variable constant_">NET</span>/<span class="variable constant_">ROM</span>)</span><br><span class="line">multicast</span><br><span class="line">在接口上设置多播标志。一般不需要显示设置，因为驱动程序本身会设置正确的标志</span><br><span class="line"><span class="variable constant_">ADDRESS</span></span><br><span class="line">接口的 <span class="variable constant_">IP</span> 地址</span><br><span class="line">txqueuelen <span class="variable constant_">LENGTH</span></span><br><span class="line">设置设备的传输队列的长度。对于具有高延迟（调制解调器链路，<span class="variable constant_">ISDN</span>）的较慢设备，将其设置为小值是有用的，以防止快速批量传输过多地干扰诸如 telnet 之类的交互通信</span><br></pre></td></tr></table></figure><h2 id="4-常用示例"><a href="#4-常用示例" class="headerlink" title="4.常用示例"></a>4.常用示例</h2><h3 id="（1）查看处于激活状态的网络接口信息。"><a href="#（1）查看处于激活状态的网络接口信息。" class="headerlink" title="（1）查看处于激活状态的网络接口信息。"></a>（1）查看处于激活状态的网络接口信息。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ifconfig</span><br><span class="line">eth0      <span class="title class_">Link</span> <span class="attr">encap</span>:<span class="title class_">Ethernet</span>  <span class="title class_">HWaddr</span> <span class="number">00</span>:<span class="number">16</span>:3<span class="attr">E</span>:<span class="number">00</span>:1<span class="attr">E</span>:<span class="number">51</span>  </span><br><span class="line">          inet <span class="attr">addr</span>:<span class="number">10.160</span><span class="number">.7</span><span class="number">.81</span>  <span class="title class_">Bcast</span>:<span class="number">10.160</span><span class="number">.15</span><span class="number">.255</span>  <span class="title class_">Mask</span>:<span class="number">255.255</span><span class="number">.240</span><span class="number">.0</span></span><br><span class="line">          <span class="variable constant_">UP</span> <span class="variable constant_">BROADCAST</span> <span class="variable constant_">RUNNING</span> <span class="variable constant_">MULTICAST</span>  <span class="attr">MTU</span>:<span class="number">1500</span>  <span class="title class_">Metric</span>:<span class="number">1</span></span><br><span class="line">          <span class="variable constant_">RX</span> <span class="attr">packets</span>:<span class="number">61430830</span> <span class="attr">errors</span>:<span class="number">0</span> <span class="attr">dropped</span>:<span class="number">0</span> <span class="attr">overruns</span>:<span class="number">0</span> <span class="attr">frame</span>:<span class="number">0</span></span><br><span class="line">          <span class="variable constant_">TX</span> <span class="attr">packets</span>:<span class="number">88534</span> <span class="attr">errors</span>:<span class="number">0</span> <span class="attr">dropped</span>:<span class="number">0</span> <span class="attr">overruns</span>:<span class="number">0</span> <span class="attr">carrier</span>:<span class="number">0</span></span><br><span class="line">          <span class="attr">collisions</span>:<span class="number">0</span> <span class="attr">txqueuelen</span>:<span class="number">1000</span></span><br><span class="line">          <span class="variable constant_">RX</span> <span class="attr">bytes</span>:<span class="number">3607197869</span> (<span class="number">3.3</span> <span class="title class_">GiB</span>)  <span class="variable constant_">TX</span> <span class="attr">bytes</span>:<span class="number">6115042</span> (<span class="number">5.8</span> <span class="title class_">MiB</span>)</span><br><span class="line"></span><br><span class="line">lo        <span class="title class_">Link</span> <span class="attr">encap</span>:<span class="title class_">Local</span> <span class="title class_">Loopback</span>  </span><br><span class="line">          inet <span class="attr">addr</span>:<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>  <span class="title class_">Mask</span>:<span class="number">255.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">          <span class="variable constant_">UP</span> <span class="variable constant_">LOOPBACK</span> <span class="variable constant_">RUNNING</span>  <span class="attr">MTU</span>:<span class="number">16436</span>  <span class="title class_">Metric</span>:<span class="number">1</span></span><br><span class="line">          <span class="variable constant_">RX</span> <span class="attr">packets</span>:<span class="number">56103</span> <span class="attr">errors</span>:<span class="number">0</span> <span class="attr">dropped</span>:<span class="number">0</span> <span class="attr">overruns</span>:<span class="number">0</span> <span class="attr">frame</span>:<span class="number">0</span></span><br><span class="line">          <span class="variable constant_">TX</span> <span class="attr">packets</span>:<span class="number">56103</span> <span class="attr">errors</span>:<span class="number">0</span> <span class="attr">dropped</span>:<span class="number">0</span> <span class="attr">overruns</span>:<span class="number">0</span> <span class="attr">carrier</span>:<span class="number">0</span></span><br><span class="line">          <span class="attr">collisions</span>:<span class="number">0</span> <span class="attr">txqueuelen</span>:<span class="number">0</span></span><br><span class="line">          <span class="variable constant_">RX</span> <span class="attr">bytes</span>:<span class="number">5079451</span> (<span class="number">4.8</span> <span class="title class_">MiB</span>)  <span class="variable constant_">TX</span> <span class="attr">bytes</span>:<span class="number">5079451</span> (<span class="number">4.8</span> <span class="title class_">MiB</span>)</span><br></pre></td></tr></table></figure><p>eth0 表示第一块网卡。</p><p>第一行 Link encap:Ethernet 表示连接类型为以太网，HWaddr 00:16:3E:00:1E:51 为网卡的物理地址；</p><p>第二行 inet addr:10.160.7.81 为网卡的 IPv4 地址，Bcast:10.160.15.255 为广播地址，Mask:255.255.240.0 为子网掩码； </p><p>第三行 UP（代表网卡开启状态），BROADCAST（支持广播），RUNNING（代表网卡的网线被接上），MULTICAST（支持组播），MTU:1500（最大传输单元 1500 字节），Metric:1 表示网卡路由数据包优先级，数值越低，优先级越高； </p><p>第四、五行：接收、发送数据包情况统计； </p><p>第七行：接收、发送数据字节数统计信息。</p><p>lo 是表示主机的回环地址，这个一般是用来测试一个网络程序，只能在本机上访问，局域网或外网的主机无法访问该地址。</p><h3 id="（2）查看所有网络接口信息，不论其是否激活。"><a href="#（2）查看所有网络接口信息，不论其是否激活。" class="headerlink" title="（2）查看所有网络接口信息，不论其是否激活。"></a>（2）查看所有网络接口信息，不论其是否激活。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ifconfig -a</span><br></pre></td></tr></table></figure><h3 id="（3）查看指定网络接口信息。"><a href="#（3）查看指定网络接口信息。" class="headerlink" title="（3）查看指定网络接口信息。"></a>（3）查看指定网络接口信息。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ifconfig eth0</span><br></pre></td></tr></table></figure><h3 id="（4）启动和关闭指定网卡。"><a href="#（4）启动和关闭指定网卡。" class="headerlink" title="（4）启动和关闭指定网卡。"></a>（4）启动和关闭指定网卡。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 启动网卡</span><br><span class="line">ifconfig eth0 up</span><br><span class="line"># 关闭网卡</span><br><span class="line">ifconfig eth0 down</span><br></pre></td></tr></table></figure><h3 id="（5）修改-MAC-地址。"><a href="#（5）修改-MAC-地址。" class="headerlink" title="（5）修改 MAC 地址。"></a>（5）修改 MAC 地址。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ifconfig eth0 down</span><br><span class="line">ifconfig eth0 hw ether <span class="number">00</span>:<span class="attr">AA</span>:<span class="attr">BB</span>:<span class="attr">CC</span>:<span class="attr">DD</span>:<span class="variable constant_">EE</span></span><br><span class="line">ifconfig eth0 up</span><br></pre></td></tr></table></figure><h3 id="（6）配置-IP-地址。"><a href="#（6）配置-IP-地址。" class="headerlink" title="（6）配置 IP 地址。"></a>（6）配置 IP 地址。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 给 eth0 网卡配置 <span class="variable constant_">IP</span> 地址</span><br><span class="line">ifconfig eth0 <span class="number">192.168</span><span class="number">.1</span><span class="number">.56</span></span><br><span class="line"></span><br><span class="line"># 给 eth0 网卡配置 <span class="variable constant_">IP</span> 地址并加上子网掩码</span><br><span class="line">ifconfig eth0 <span class="number">192.168</span><span class="number">.1</span><span class="number">.56</span> netmask <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span> </span><br><span class="line"></span><br><span class="line"># 给 eth0 网卡配置 <span class="variable constant_">IP</span> 地址，加上子网掩码，加上广播地址</span><br><span class="line">ifconfig eth0 <span class="number">192.168</span><span class="number">.1</span><span class="number">.56</span> netmask <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span> broadcast <span class="number">192.168</span><span class="number">.1</span><span class="number">.255</span></span><br></pre></td></tr></table></figure><h3 id="（7）启用和关闭-ARP-协议。"><a href="#（7）启用和关闭-ARP-协议。" class="headerlink" title="（7）启用和关闭 ARP 协议。"></a>（7）启用和关闭 ARP 协议。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 开启网卡 eth0 的 arp 协议</span><br><span class="line">ifconfig eth0 arp</span><br><span class="line"># 关闭网卡 eth0 的 arp 协议</span><br><span class="line">ifconfig eth0 -arp</span><br></pre></td></tr></table></figure><h3 id="（8）设置最大传输单元。"><a href="#（8）设置最大传输单元。" class="headerlink" title="（8）设置最大传输单元。"></a>（8）设置最大传输单元。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 设置能通过的最大数据包大小为 <span class="number">1500</span> bytes</span><br><span class="line">ifconfig eth0 mtu <span class="number">1500</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令——df命令</title>
      <link href="/FRank675.github.io/posts/210b0729d496/"/>
      <url>/FRank675.github.io/posts/210b0729d496/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="Linux命令——df命令"><a href="#Linux命令——df命令" class="headerlink" title="Linux命令——df命令"></a>Linux命令——df命令</h1><h2 id="1-功能"><a href="#1-功能" class="headerlink" title="1.功能"></a>1.功能</h2><p>用于查看Linux文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，以及剩余空间等信息。</p><h2 id="2-格式"><a href="#2-格式" class="headerlink" title="2.格式"></a>2.格式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">df [选项] [参数]</span><br></pre></td></tr></table></figure><h2 id="3-选项说明"><a href="#3-选项说明" class="headerlink" title="3.选项说明"></a>3.选项说明</h2><table><thead><tr><th align="left">选项</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">-a,–all</td><td align="left">显示所有的虚拟文件系统</td></tr><tr><td align="left">-B,–block-size&#x3D;SIZE</td><td align="left">使用指定的块大小</td></tr><tr><td align="left">-h,–human-readable</td><td align="left">以易读的方式显示磁盘空间已用与未用的大小</td></tr><tr><td align="left">–direct</td><td align="left">显示文件的统计信息，而不是挂载点</td></tr><tr><td align="left">–total</td><td align="left">显示所有文件系统总的使用情况</td></tr><tr><td align="left">-H,–si</td><td align="left">使用1000而非1024作为换算单位</td></tr><tr><td align="left">-i,–inodes</td><td align="left">显示索引节点inode信息，而非磁盘块的使用情况</td></tr><tr><td align="left">-k,–local</td><td align="left">同–block-size&#x3D;1K，即将块大小设置为1KB</td></tr><tr><td align="left">-t &lt;文件系统类型&gt;,–type&#x3D;TYPE</td><td align="left">显示指定的文件系统</td></tr><tr><td align="left">-T,–print-type</td><td align="left">显示文件系统类型</td></tr><tr><td align="left">-x &lt;文件系统类型&gt;,–exclude-type&#x3D;TYPE</td><td align="left">显示指定的文件系统之外的文件系统</td></tr><tr><td align="left">–no-sync</td><td align="left">不进行磁盘同步，默认选项</td></tr><tr><td align="left">-P</td><td align="left">输出格式为POSIX</td></tr><tr><td align="left">–help</td><td align="left">显示帮助信息</td></tr><tr><td align="left">–version</td><td align="left">显示版本信息</td></tr></tbody></table><h2 id="4-参数说明"><a href="#4-参数说明" class="headerlink" title="4.参数说明"></a>4.参数说明</h2><table><thead><tr><th align="left">参数</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">文件名称</td><td align="left">指定对应的磁盘分区或者外围设备</td></tr></tbody></table><h2 id="5-示例"><a href="#5-示例" class="headerlink" title="5.示例"></a>5.示例</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">df -hT</span><br><span class="line"><span class="title class_">Filesystem</span>    <span class="title class_">Type</span>    <span class="title class_">Size</span>  <span class="title class_">Used</span> <span class="title class_">Avail</span> <span class="title class_">Use</span>% <span class="title class_">Mounted</span> on</span><br><span class="line">/dev/mapper/vg_mic-lv_root</span><br><span class="line">              ext4     50G   16G   32G  <span class="number">33</span>% /</span><br><span class="line">tmpfs        tmpfs     16G     <span class="number">0</span>   16G   <span class="number">0</span>% <span class="regexp">/dev/</span>shm</span><br><span class="line">/dev/sda1     ext4    485M   38M  422M   <span class="number">9</span>% /boot</span><br><span class="line">/dev/mapper/vg_mic-lv_home</span><br><span class="line">              ext4    210G  197G  <span class="number">2.</span>7G  <span class="number">99</span>% /home</span><br></pre></td></tr></table></figure><p>上面的示例输出信息表示的意思分别是：  </p><p><strong>第一列</strong>：filesystem代表文件系统在哪个分区，所以列出设备名称。其中<code>/dev/mapper/vg_mic-lv_root</code>这行的意思是，你有一个VG (volume group，卷组)叫作vg_mic, vg_mic里面有一个LV(logical volume，逻辑卷)叫作lv_root。其实这个<code>/dev/mapper/vg_mic-lv_root</code>是一个连接文件，连接到&#x2F;dev&#x2F;dm-0的，可以用<code>ll /dev/mapper/vg_mic-lv_root</code>查看。实际上，可以将<code>vg_mic-lv_root</code>看作一个分区来对待就可以了。如果想查看实际的物理分区，可以使用命令pvdisplay[1,2]^{[1,2]}。</p><p><strong>第二列</strong>：Type代表文件系统类型。比如第三行的tmpfs是一种基于内存的文件系统，类似于ramdisk。tmpfs可以使用RAM，也可以使用swap分区来存储文件，提高文件的读写读写速度。再如第三行的&#x2F;dev&#x2F;sda1分区的文件系统是ext4。</p><p><strong>第三列</strong>：Size 代表分区的大小。</p><p><strong>第四列</strong>：Used表示已经使用的大小。</p><p><strong>第五列</strong>：Avail表示可用的大小。</p><p><strong>第六列</strong>：Use%表示以百分比显示已经使用的比例。</p><p><strong>第七列</strong>：Mounted on表示磁盘分区挂载的目录，即挂载点。</p><p>这里列一下Linux系统中磁盘与其它外设的命名规则，以及磁盘分区的命名规则。</p><p>常见的设备与其在Linux中的文件名如下表：</p><table><thead><tr><th align="left">设备</th><th align="left">文件名</th></tr></thead><tbody><tr><td align="left">IDE硬盘</td><td align="left">&#x2F;dev&#x2F;hd[a-d]</td></tr><tr><td align="left">SCSI&#x2F;SATA&#x2F;USB硬盘与U盘</td><td align="left">&#x2F;dev&#x2F;sd[a-p]</td></tr><tr><td align="left">软驱</td><td align="left">&#x2F;dev&#x2F;fd[0-1]</td></tr><tr><td align="left">打印机</td><td align="left">25针：&#x2F;dev&#x2F;lp[]0-2USB:&#x2F;dev&#x2F;usb&#x2F;lp[0-15]</td></tr><tr><td align="left">鼠标</td><td align="left">USB：&#x2F;dev&#x2F;usb&#x2F;mouse[0-15]ps2:&#x2F;dev&#x2F;psaux</td></tr><tr><td align="left">当前CD ROM&#x2F;DVD ROM</td><td align="left">cdrom</td></tr><tr><td align="left">当前鼠标</td><td align="left">&#x2F;dev&#x2F;mouse</td></tr><tr><td align="left">磁带机</td><td align="left">IDE：&#x2F;dev&#x2F;ht0SCSI:&#x2F;dev&#x2F;st0</td></tr></tbody></table><p>需要注意的是，每个磁盘驱动器的磁盘分区（partition）不同时，磁盘文件名还会改变。此外，磁带机的文件名，在某些不同的linux发行版本中可能不一样。</p><p>IDE磁盘，一般可以接4个，磁盘名称分别是hda，hdb，hdc和hdd。以hda为例，如果分为四个分区，则四个分区的名称分别为hda1，hda2，hda3和hda4，其他三个磁盘的分区名称以此类推。</p><p>一个IDE磁盘、SATA磁盘和SCSI 磁盘主分区与扩展分区加在一起最多4个，扩展分区最多只有一个，扩展分区中再开辟逻辑分区。</p><p>IDE磁盘最多可以分63个分区，59个逻辑分区。  SATA硬盘最多15个分区，11个逻辑分区。  SCSI硬盘最多16个分区，12个逻辑分区。</p><p>SATA硬盘的分区名称与IDE磁盘的分区名称类似，以第一块SATA磁盘sda为例，那么各个分区的名称分别是sda1，sda2，sda3…，以此类推。可见，IDE磁盘与SATA磁盘的分区号均是从1开始的[3]^{[3]}。</p><p>SCSI硬盘的分区名称与SATA硬盘分区名称相同。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令——crontab命令</title>
      <link href="/FRank675.github.io/posts/f77050876da6/"/>
      <url>/FRank675.github.io/posts/f77050876da6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="Linux命令——crontab命令"><a href="#Linux命令——crontab命令" class="headerlink" title="Linux命令——crontab命令"></a>Linux命令——crontab命令</h1><h2 id="1-命令简介"><a href="#1-命令简介" class="headerlink" title="1.命令简介"></a>1.命令简介</h2><p>contab（cron table） 命令被用管理用户的需要周期性执行的任务，与 Windows 下的计划任务类似，当安装完操作系统后，默认会安装此服务工具，并且会自动启动 crond 进程，crond 进程每分钟会检查是否有要执行的任务，如果有则执行该任务。</p><p>Linux 下的任务调度分为两类，系统任务调度和用户任务调度。</p><p><strong>系统任务调度</strong>：系统周期性所要执行的工作，比如写缓存数据到硬盘、日志清理等。&#x2F;etc&#x2F;crontab 文件是系统任务调度的配置文件。</p><p><strong>用户任务调度</strong>：用户定期要执行的工作，比如用户<a href="https://cloud.tencent.com/solution/backup?from=10680">数据备份</a>、定时邮件提醒等。用户可以使用 crontab 工具来定制自己的计划任务。所有用户定义的 crontab 文件都被保存在 &#x2F;var&#x2F;spool&#x2F;cron 目录中，其文件名与用户名一致。</p><p>系统管理员可以通过&#x2F;etc&#x2F;cron.deny 和 &#x2F;etc&#x2F;cron.allow 这两个文件来禁止或允许用户拥有自己的 crontab 文件。</p><h2 id="2-命令格式"><a href="#2-命令格式" class="headerlink" title="2.命令格式"></a>2.命令格式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">crontab [-u <span class="variable constant_">USER</span>] <span class="variable constant_">FILE</span></span><br><span class="line">crontab [-u <span class="variable constant_">USER</span>] [-l | -r | -e] [-i] [-s]</span><br><span class="line">crontab -n [ <span class="variable constant_">HOSTNAME</span> ]</span><br><span class="line">crontab -c</span><br></pre></td></tr></table></figure><h2 id="3-选项说明"><a href="#3-选项说明" class="headerlink" title="3.选项说明"></a>3.选项说明</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">-u</span><br><span class="line">指定要设置定时任务的用户名</span><br><span class="line">-l</span><br><span class="line">列出当前的定时任务</span><br><span class="line">-r</span><br><span class="line">删除定时任务</span><br><span class="line">-e</span><br><span class="line">编辑用户的定时任务。任务保存在 /<span class="keyword">var</span>/spool/cron 目录下与用户名同名的文件中</span><br><span class="line">-i</span><br><span class="line">在删除定时任务前询问用户是否确定删除</span><br><span class="line">-s</span><br><span class="line">在进行编辑/替换之前，将当前的 <span class="title class_">SELinux</span> 安全上下文字符串作为 <span class="variable constant_">MLS_LEVEL</span> 附加到 crontab 文件</span><br><span class="line">-n [<span class="variable constant_">HOSTNAME</span>]</span><br><span class="line">此选项只有当 <span class="title function_">cron</span>(<span class="number">8</span>) 使用 -c 选项启动以支持集群环境时才使用，用于指定集群中哪个主机执行定时 crontab 文件中的定时任务。如果省略了主机名，则使用 <span class="title function_">gethostname</span>(<span class="number">2</span>) 返回的本地主机名</span><br><span class="line">-c</span><br><span class="line">此选项只有当 <span class="title function_">cron</span>(<span class="number">8</span>) 使用 -c 选项启动以支持集群环境时才使用，用于查询集群中当前哪个主机执行定时 crontab 文件中的定时任务</span><br></pre></td></tr></table></figure><h2 id="4-用户配置文件"><a href="#4-用户配置文件" class="headerlink" title="4.用户配置文件"></a>4.用户配置文件</h2><p>crontab 文件保存了用户的定时任务，以特定格式保存在 &#x2F;var&#x2F;spool&#x2F;cron 目录下与用户名同名的文件中。</p><p>例如如果是 root 用户，那么添加任务时，会在该路径下有一个 root 文件。</p><p>Linux 的 cron 服务会每隔一分钟去读取一次 &#x2F;var&#x2F;spool&#x2F;cron 目录下面所有的内容。</p><p>crontab 文件每一行代表一项任务，每项任务分为六个字段，前五个字段是时间字段，第六个字段是要执行的命令，格式如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">minute hour day month week command</span><br></pre></td></tr></table></figure><p>minute 分钟，取值范围 0 到 59； </p><p>hour 小时，取值范围 0 到 23； </p><p>day 日期，取值范围 1 到 31； </p><p>month 月份，取值范围 1 到 12，或 jan,feb,mar,apr…； </p><p>week 星期，取值范围 0 到 7，或 sun,mon,tue,wed,thu,fri,sat。</p><p>注意 0 和 7 均代表星期日； </p><p>command 要执行的命令，可以是系统命令，也可以是自己编写的脚本文件；</p><p>在以上各个时间字段中，还可以使用以下特殊字符：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">* 表示所有可能的值，例如 minute 是 *，表示每分钟都执行命令</span><br><span class="line">, 可以用逗号隔开的值指定一个列表，例如，<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span></span><br><span class="line">- 可以用整数之间的横杠表示一个范围，例如 <span class="number">2</span>-<span class="number">6</span> 表示 <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> </span><br><span class="line">/ 可以用斜杠指定时间的间隔频率，例如 minute 为 */<span class="number">2</span> 表示每两分钟执行一次命令</span><br></pre></td></tr></table></figure><p>注意，crontab 文件注释符号为 #。</p><h2 id="5-系统配置文件"><a href="#5-系统配置文件" class="headerlink" title="5.系统配置文件"></a>5.系统配置文件</h2><p>除了用户的 crontab 文件，与定时任务相关的系统配置文件有：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/etc/crontab系统定时任务配置文件</span><br><span class="line">/etc/cron.<span class="property">d</span>自动定期需要做的任务</span><br><span class="line">/etc/cron.<span class="property">hourly</span>每小时执行一次的任务</span><br><span class="line">/etc/cron.<span class="property">daily</span>每天执行一次的任务</span><br><span class="line">/etc/cron.<span class="property">weekly</span>每周执行一次的任务</span><br><span class="line">/etc/cron.<span class="property">monthly</span>每月执行一次的任务</span><br><span class="line">/etc/cron.<span class="property">allow</span>    该文件中所列用户允许执行定时任务</span><br><span class="line">/etc/cron.<span class="property">deny</span>    该文件中所列用户不允许执行定时任务</span><br><span class="line">/<span class="keyword">var</span>/log/croncrontab 的日志文件</span><br></pre></td></tr></table></figure><p>Linux 的 cron 服务会每隔一分钟去读取一次 &#x2F;etc&#x2F;crontab 文件和 &#x2F;etc&#x2F;cron.d 目录下面所有的内容。</p><p>&#x2F;etc&#x2F;cron.hourly、&#x2F;etc&#x2F;cron.daily、&#x2F;etc&#x2F;cron.weekly 和 &#x2F;etc&#x2F;cron.monthly 下的任务也会间接按照相应的周期被调用。</p><h2 id="6-常用示例"><a href="#6-常用示例" class="headerlink" title="6.常用示例"></a>6.常用示例</h2><h3 id="（1）添加定时任务。"><a href="#（1）添加定时任务。" class="headerlink" title="（1）添加定时任务。"></a>（1）添加定时任务。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br><span class="line">* * * * * command# 每分钟执行一次 command</span><br><span class="line"><span class="number">3</span>,<span class="number">15</span> * * * * command# 每小时的第 <span class="number">3</span> 和第 <span class="number">15</span> 分钟执行</span><br><span class="line"><span class="number">3</span>,<span class="number">15</span> <span class="number">8</span>-<span class="number">11</span> * * * command# 上午 <span class="number">8</span> 点到 <span class="number">11</span>点每小时第 <span class="number">3</span> 和第 <span class="number">15</span> 分钟执行</span><br><span class="line"><span class="number">3</span>,<span class="number">15</span> <span class="number">8</span>-<span class="number">11</span> * * <span class="number">1</span> command# 每个星期一的上午 <span class="number">8</span> 点到 <span class="number">11</span> 点的第 <span class="number">3</span> 和第 <span class="number">15</span> 分钟执行</span><br><span class="line"><span class="number">3</span>,<span class="number">15</span> <span class="number">8</span>-<span class="number">11</span> <span class="number">1</span> * * command# 每个月一号上午 <span class="number">8</span> 点到 <span class="number">11</span> 点的第 <span class="number">3</span> 和第 <span class="number">15</span> 分钟执行</span><br><span class="line"><span class="number">3</span>,<span class="number">15</span> <span class="number">8</span>-<span class="number">11</span> <span class="number">1</span> <span class="number">1</span> * command# 每年一月一号上午 <span class="number">8</span> 点到 <span class="number">11</span> 点的第 <span class="number">3</span> 和第 <span class="number">15</span> 分钟执行</span><br><span class="line"><span class="number">0</span> *<span class="regexp">/2 * * * /</span>sbin/service httpd restart# 每隔两个小时在第 <span class="number">0</span> 分时候重启一次 httpd</span><br></pre></td></tr></table></figure><h3 id="（2）查看定时任务。"><a href="#（2）查看定时任务。" class="headerlink" title="（2）查看定时任务。"></a>（2）查看定时任务。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">crontab -l</span><br></pre></td></tr></table></figure><h3 id="（3）删除定时任务"><a href="#（3）删除定时任务" class="headerlink" title="（3）删除定时任务"></a>（3）删除定时任务</h3><p>即清除 &#x2F;var&#x2F;spool&#x2F;cron 目录下 crontab 文件。危险动作，请注意备份。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">crontab -r</span><br></pre></td></tr></table></figure><h3 id="（4）将指定的-crontab-文件还原到-x2F-var-x2F-spool-x2F-cron-目录下。"><a href="#（4）将指定的-crontab-文件还原到-x2F-var-x2F-spool-x2F-cron-目录下。" class="headerlink" title="（4）将指定的 crontab 文件还原到 &#x2F;var&#x2F;spool&#x2F;cron 目录下。"></a>（4）将指定的 crontab 文件还原到 &#x2F;var&#x2F;spool&#x2F;cron 目录下。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">crontab <span class="variable constant_">FILE</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令——cd命令</title>
      <link href="/FRank675.github.io/posts/337d2d2224c8/"/>
      <url>/FRank675.github.io/posts/337d2d2224c8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="Linux命令——cd命令"><a href="#Linux命令——cd命令" class="headerlink" title="Linux命令——cd命令"></a>Linux命令——cd命令</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>cd命令是shell的内建命令（bash builtin），用来切换工作目录至指定的目录dirname。</p><p> 其中dirname可以是绝对路径或相对路径。</p><p>若目录名称省略，则变换至使用者的home directory（也就是刚login时所在的目录）。</p><p>另外，~也表示为home directory的意思，.则是表示目前所在的目录，..则表示目前目录位置的上一层目录。</p><h2 id="2-命令格式"><a href="#2-命令格式" class="headerlink" title="2.命令格式"></a>2.命令格式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cd [-L|-P] [dir]</span><br></pre></td></tr></table></figure><h2 id="3-命令选项"><a href="#3-命令选项" class="headerlink" title="3.命令选项"></a>3.命令选项</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">-p：如果要切换到的目标目录是一个符号连接，直接切换到符号连接指向的目标目录。</span><br><span class="line">-L：如果要切换的目标目录是一个符号的连接，直接切换到字符连接名代表的目录，而非符号连接所指向的目标目录。</span><br><span class="line">-：当仅使用一个横杠 - 时，当前工作目录将被切换到环境变量<span class="string">&quot;OLDPWD&quot;</span>所表示的目录。</span><br></pre></td></tr></table></figure><h2 id="4-常用示例"><a href="#4-常用示例" class="headerlink" title="4.常用示例"></a>4.常用示例</h2><h3 id="（1）回到上一层目录："><a href="#（1）回到上一层目录：" class="headerlink" title="（1）回到上一层目录："></a>（1）回到上一层目录：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cd ..</span><br></pre></td></tr></table></figure><h3 id="（2）回到根目录："><a href="#（2）回到根目录：" class="headerlink" title="（2）回到根目录："></a>（2）回到根目录：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cd /</span><br></pre></td></tr></table></figure><h3 id="（3）回到上次使用的目录："><a href="#（3）回到上次使用的目录：" class="headerlink" title="（3）回到上次使用的目录："></a>（3）回到上次使用的目录：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cd –</span><br></pre></td></tr></table></figure><h3 id="（4）回到用户家目录："><a href="#（4）回到用户家目录：" class="headerlink" title="（4）回到用户家目录："></a>（4）回到用户家目录：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cd ~</span><br><span class="line">#或</span><br><span class="line">cd -- </span><br></pre></td></tr></table></figure><p><strong>注意：</strong>  </p><p>（1）登录Linux主机后，命令行最左侧<code>[lvlv@echidna ~/code]$</code>中，~表示在当前用户的家目录，$表示是普通用户权限，#则表示超级用户权限。echidna表示当前主机的名称，lvlv则表示当前登录的用户名称。查看当前主机名称用hostname命令。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令——cat命令</title>
      <link href="/FRank675.github.io/posts/44cb01cbd9f6/"/>
      <url>/FRank675.github.io/posts/44cb01cbd9f6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="Linux命令——cat命令"><a href="#Linux命令——cat命令" class="headerlink" title="Linux命令——cat命令"></a>Linux命令——cat命令</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>cat 命令用于连接文件或者标准输入的内容，并打印到标准输出设备上。</p><h2 id="2-命令格式"><a href="#2-命令格式" class="headerlink" title="2.命令格式"></a>2.命令格式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cat [<span class="variable constant_">OPTION</span>]... [<span class="variable constant_">FILE</span>]...</span><br></pre></td></tr></table></figure><h2 id="3-选项说明"><a href="#3-选项说明" class="headerlink" title="3.选项说明"></a>3.选项说明</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">-：从标准输入获取内容。</span><br><span class="line">-A, --show-all：等价于-vET，显示文件内所有不可打印的字符。</span><br><span class="line">-b, --number-nonblank：和 -n 相似，只不过对于空白行不编号。</span><br><span class="line">-e : 等价于 -vE。</span><br><span class="line">-E, --show-ends：在每行结束处显示 $。</span><br><span class="line">-n, --number：由 <span class="number">1</span> 开始对所有输出的行数编号。</span><br><span class="line">-s, --squeeze-blank：当遇到有连续两行以上的空白行，就代换为一行的空白行。</span><br><span class="line">-t：等价于<span class="string">&quot;-vT&quot;</span>选项。</span><br><span class="line">-T, --show-tabs： 将 <span class="variable constant_">TAB</span> 字符显示为 ^I。</span><br><span class="line">-v, --show-nonprinting：使用 ^ 和 M- 符号，除了 <span class="variable constant_">LFD</span> 和 <span class="variable constant_">TAB</span> 之外。</span><br><span class="line">--help：显示帮助信息。</span><br><span class="line">--version：显示版本信息。</span><br></pre></td></tr></table></figure><h2 id="4-常用示例"><a href="#4-常用示例" class="headerlink" title="4.常用示例"></a>4.常用示例</h2><h3 id="（1）将几个文件合并为一个文件。"><a href="#（1）将几个文件合并为一个文件。" class="headerlink" title="（1）将几个文件合并为一个文件。"></a>（1）将几个文件合并为一个文件。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$ cat file1 file2 &gt; file</span><br></pre></td></tr></table></figure><h3 id="（2）查看文件。"><a href="#（2）查看文件。" class="headerlink" title="（2）查看文件。"></a>（2）查看文件。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$ cat  file</span><br></pre></td></tr></table></figure><h3 id="（3）从键盘创建一个文件。"><a href="#（3）从键盘创建一个文件。" class="headerlink" title="（3）从键盘创建一个文件。"></a>（3）从键盘创建一个文件。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$ cat &gt; filename<span class="string">`</span></span><br></pre></td></tr></table></figure><h3 id="（4）把-textfile1-的文档内容加上行号后输入-textfile2-这个文档里。"><a href="#（4）把-textfile1-的文档内容加上行号后输入-textfile2-这个文档里。" class="headerlink" title="（4）把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里。"></a>（4）把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$ cat -n textfile1 &gt; textfile2</span><br></pre></td></tr></table></figure><h3 id="（5）将文件file1和标准输入内容，纵向连接后重定向至文件file2。"><a href="#（5）将文件file1和标准输入内容，纵向连接后重定向至文件file2。" class="headerlink" title="（5）将文件file1和标准输入内容，纵向连接后重定向至文件file2。"></a>（5）将文件file1和标准输入内容，纵向连接后重定向至文件file2。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$ cat file1 - &gt; file2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令——awk命令</title>
      <link href="/FRank675.github.io/posts/658af63f600d/"/>
      <url>/FRank675.github.io/posts/658af63f600d/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="Linux命令——awk命令"><a href="#Linux命令——awk命令" class="headerlink" title="Linux命令——awk命令"></a>Linux命令——awk命令</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>AWK是一个优良的文本处理工具，Linux及Unix环境中现有的功能最强大的数据处理引擎之一。</p><p>数据可以来自标准输入(stdin)、一个或多个文件，或其它命令的输出。</p><p>它支持用户自定义函数和动态正则表达式等先进功能，是linux&#x2F;unix下的一个强大编程工具。</p><p>它在命令行中使用，但更多是作为脚本来使用。</p><p>awk有很多内建的功能，比如数组、函数等，这是它和C语言的相同之处，灵活性是awk最大的优势。</p><p>简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。</p><p>awk有3个不同版本: awk、nawk和gawk，未作特别说明，一般指gawk，gawk 是 AWK 的 GNU 版本。</p><p>awk其名称得自于它的创始人 Alfred Aho 、Peter Weinberger 和 Brian Kernighan 姓氏的首个字母。</p><p>实际上AWK的确拥有自己的语言： AWK程序设计语言 ， 三位创建者已将它正式定义为“样式扫描和处理语言”。</p><p>它允许您创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成<a href="https://cloud.tencent.com/product/bi?from=10680">报表</a>，还有无数其他的功能。</p><h2 id="2-命令格式"><a href="#2-命令格式" class="headerlink" title="2.命令格式"></a>2.命令格式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">awk [options] <span class="string">&#x27;pattern + &#123;action&#125;&#x27;</span> [filenames...]</span><br></pre></td></tr></table></figure><p>尽管操作可能会很复杂，但语法总是这样。awk通常用来格式化文本文件中的信息，是以文件的一行为处理单位，每接收文件的一行，然后执行相应的命令，来处理文本。其中pattern表示AWK在数据中查找的内容，而action是在找到匹配内容时所执行的一系列命令。花括号{}不需要在程序中始终出现，但它们用于根据特定的模式对一系列指令进行分组。pattern表示的正则表达式，用斜杠括起来，action 对匹配的行进行处理。</p><p><strong>注意：</strong>  </p><p>（1）pattern缺省为1，action缺省为{print}。  </p><p>（2）pattern + {action}可以同时存在多个，每个pattern之间的关系是或，只要当前行匹配pattern，则执行pattern后大括号中的commands。</p><h2 id="3-常用命令选项"><a href="#3-常用命令选项" class="headerlink" title="3.常用命令选项"></a>3.常用命令选项</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">-F fs,--field-separator fs：使用字符串fs作为域分隔符。可以同时指定多个域分隔符，此时需要使用一对中括号括起来。例如使用-和|可写作 -F <span class="string">&#x27;[-|]&#x27;</span>。如果用[]作为分隔符，可写作-F <span class="string">&#x27;[][]&#x27;</span>。不指定分隔符，默认为空格和<span class="title class_">Tab</span>。需要注意，awk命令使用-F<span class="string">&#x27; &#x27;</span>显示指定空格时，tab也会被作为分隔符。</span><br><span class="line">-v [<span class="keyword">var</span>]=[val],--assign [<span class="keyword">var</span>]=[val]：定义一个awk变量并赋值，可以将外部变量传递给awk；</span><br><span class="line">-f [program-file],--file [program-file]：从指定的awk脚本文件program-file读取awk指令；</span><br><span class="line">-m[f/r] <span class="attr">val</span>:对val值设置内在限制，-mf选项限制分配给val的最大块数目；-mr选项限制记录的最大数目。这两个功能是<span class="title class_">Bell</span>实验室版awk的扩展功能，在标准awk中不适用;</span><br><span class="line">-O,--optimize：在程序的内部表示上启用优化。目前，这只包括简单的常量折叠。gawk的维护者系统随着时间推移，增加额外的优化；</span><br><span class="line">-W compat,-W traditional,--compat,--traditional：是awk运行在兼容模式下，gawk的任何扩展都不会被识别；</span><br><span class="line">-W copyleft,--copyleft,-W copyright,--copyright：打印简短的版权信息；</span><br><span class="line">-W dump-variables[=file],--dump-variables[=file]：将awk的全局变量排序后打印到指定的文件file中，如果没有指定file，则在当前目录默认生成一个awkvars.<span class="property">out</span>；</span><br><span class="line">-W exec [file],--exec [file]:功能类似于命令选项-f，但脚本文件需要以#!开头；另外命令行的变量将不再生效；</span><br><span class="line">-W gen-po,--gen-<span class="attr">po</span>:解析awk程序，产生.<span class="property">po</span>格式的文件到标准输出，来标明程序中每一个可本地化的字符串位置（自己翻译的可能不准确）；</span><br><span class="line">-W help,-W usage,--help,--<span class="attr">usage</span>:打印全部awk选项和每个选项的简短说明;</span><br><span class="line">-W lint[=value],--lint[=value]:打印有关在其它版本awk中，出现可疑的或不可移植结构的警告。该选项提供了一个可选的参数fatal，即将警告视为致命的错误；</span><br><span class="line">-W lint-old,--lint-<span class="attr">old</span>:打印关于不能向传统unix平台移植的结构的警告；</span><br><span class="line">-W non-decimal-data,--non-decimal-data：识别输入数据中的八进制和十六进制数；</span><br><span class="line">-W posix,--posix：打开兼容模式，会出现以下限制：</span><br><span class="line">    不识别\x;</span><br><span class="line">    当域分隔fs是一个空格时，只有空格和tab能作为域分隔符，换行符将不能作为一个域分隔符；</span><br><span class="line">    在?和:之后，不能继续当前行；</span><br><span class="line">    函数关键字func将不能被识别；</span><br><span class="line">    操作符**和**=不能代替^和^=；</span><br><span class="line">    fflush函数无效。</span><br><span class="line">-W profile[=prof_file],--profile[=prof_file]：输出性能分析报告至指定的文件prof_file,如果prof_file缺省，默认输出到awkprof.<span class="property">out</span>；</span><br><span class="line">-W re-interval,--re-interval：允许间隔正则表达式的使用，参考(grep中的<span class="title class_">Posix</span>字符类)，如括号表达式[[:<span class="attr">alpha</span>:]]；</span><br><span class="line">-W source program-text,--source program-<span class="attr">text</span>:使用program-text作为源代码，可与-f命令混用；</span><br><span class="line">-W use-lc-numeric,--use-lc-<span class="attr">numeric</span>:是awk使用本地小数点解析输入的数据（自己翻译的可能不准确）；</span><br><span class="line">-W version,--<span class="attr">version</span>:打印awk版本信息；</span><br><span class="line">--:标识命令选项结束。（自己翻译的可能不准确）</span><br></pre></td></tr></table></figure><h2 id="4-调用awk方式"><a href="#4-调用awk方式" class="headerlink" title="4.调用awk方式"></a>4.调用awk方式</h2><p>有三种方式调用awk。</p><h3 id="（1）命令行方式。"><a href="#（1）命令行方式。" class="headerlink" title="（1）命令行方式。"></a>（1）命令行方式。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">awk [-F  field-separator]  <span class="string">&#x27;pattern + &#123;action&#125;&#x27;</span>  input-<span class="title function_">file</span>(s)</span><br></pre></td></tr></table></figure><p>其中，commands 是真正awk命令，[-F域分隔符]是可选的。 input-file(s) 是待处理的文件。  在awk中，文件的每一行中，由域分隔符分开的每一项称为一个域。通常，在不指名-F域分隔符的情况下，默认的域分隔符是空格。</p><h3 id="（2）shell脚本方式。"><a href="#（2）shell脚本方式。" class="headerlink" title="（2）shell脚本方式。"></a>（2）shell脚本方式。</h3><p>  将所有的awk命令插入一个文件，脚本中在首行注明使用awk命令来解析执行，相当于将shell脚本首行的：<code>#!/bin/sh</code>换成：<code>#!/bin/awk</code>，最后通过键入脚本名称来调用。</p><h3 id="（3）将所有的awk命令插入到一个单独文件，然后使用-f选项调用。"><a href="#（3）将所有的awk命令插入到一个单独文件，然后使用-f选项调用。" class="headerlink" title="（3）将所有的awk命令插入到一个单独文件，然后使用-f选项调用。"></a>（3）将所有的awk命令插入到一个单独文件，然后使用-f选项调用。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">awk -f awk-script-file input-<span class="title function_">file</span>(s)</span><br></pre></td></tr></table></figure><p>其中，-f选项加载awk-script-file中的awk脚本，input-file(s)跟上面的是一样的。</p><h2 id="5-awk内置变量"><a href="#5-awk内置变量" class="headerlink" title="5.awk内置变量"></a>5.awk内置变量</h2><p>awk有许多内置变量用来设置环境信息，这些变量可以被改变，下面给出常见的内置变量说明。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$n             当前记录的第n个字段，n从<span class="number">1</span>开始，字段间由<span class="variable constant_">FS</span>分隔</span><br><span class="line">$<span class="number">0</span>             当前完成的记录（当前处理行）</span><br><span class="line"><span class="variable constant_">ARGC</span>            命令行参数个数</span><br><span class="line"><span class="variable constant_">ARGIND</span>          命令行中当前处理文件的位置(从<span class="number">0</span>开始算)</span><br><span class="line"><span class="variable constant_">ARGV</span>            命令行参数数组</span><br><span class="line"><span class="variable constant_">CONVFMT</span>         数字转换格式，默认值为%.6g</span><br><span class="line"><span class="variable constant_">ENVIRON</span>         支持队列中系统环境变量的使用</span><br><span class="line"><span class="variable constant_">ERRNO</span>           最后一个系统错误的描述</span><br><span class="line"><span class="variable constant_">FIELDWIDTHS</span>     字段宽度列表(用空格键分隔)</span><br><span class="line"><span class="variable constant_">FILENAME</span>        awk浏览的文件名</span><br><span class="line"><span class="variable constant_">FNR</span>             当前被处理文件的记录数</span><br><span class="line"><span class="variable constant_">FS</span>              设置输入域分隔符，等价于命令行-F选项</span><br><span class="line"><span class="variable constant_">IGNORECASE</span>      如果为真，则进行忽略大小写的匹配</span><br><span class="line"><span class="variable constant_">LINT</span>            动态控制--lint选项是否生效，为<span class="literal">false</span>不生效，为<span class="literal">true</span>则生效；</span><br><span class="line"><span class="variable constant_">NF</span>              浏览记录的域的个数</span><br><span class="line"><span class="variable constant_">NR</span>              已读的记录数</span><br><span class="line"><span class="variable constant_">OFMT</span>            数字的输出格式，默认值是%.6g</span><br><span class="line"><span class="variable constant_">OFS</span>             输出域分隔符</span><br><span class="line"><span class="variable constant_">ORS</span>             输出记录分隔符             </span><br><span class="line"><span class="variable constant_">RS</span>              <span class="title class_">The</span> input record separator，输入记录的分隔符，默认为换行符</span><br><span class="line"><span class="variable constant_">RT</span>              <span class="title class_">The</span> record terminator，输入记录的结束符      </span><br><span class="line"><span class="variable constant_">RSTART</span>          由match函数所匹配的字符串的第一个位置</span><br><span class="line"><span class="variable constant_">RLENGTH</span>         由match函数所匹配的字符串的长度</span><br><span class="line"><span class="variable constant_">SUBSEP</span>          数组下标分隔符(默认值是\<span class="number">034</span>)</span><br><span class="line"><span class="variable constant_">TEXTDOMAIN</span>      awk程序所使用的文本所处的地域</span><br></pre></td></tr></table></figure><h2 id="6-awk编程示例"><a href="#6-awk编程示例" class="headerlink" title="6.awk编程示例"></a>6.awk编程示例</h2><h3 id="6-1基础打印输出"><a href="#6-1基础打印输出" class="headerlink" title="6.1基础打印输出"></a>6.1基础打印输出</h3><p>（1）假设last -n 5的输出如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[root@www ~]# last -n <span class="number">5</span> &lt;==仅取出前五行</span><br><span class="line">root     pts/<span class="number">1</span>   <span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span>  <span class="title class_">Tue</span> <span class="title class_">Feb</span> <span class="number">10</span> <span class="number">11</span>:<span class="number">21</span>   still logged <span class="keyword">in</span></span><br><span class="line">root     pts/<span class="number">1</span>   <span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span>  <span class="title class_">Tue</span> <span class="title class_">Feb</span> <span class="number">10</span> <span class="number">00</span>:<span class="number">46</span> - <span class="number">02</span>:<span class="number">28</span>  (<span class="number">01</span>:<span class="number">41</span>)</span><br><span class="line">root     pts/<span class="number">1</span>   <span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span>  <span class="title class_">Mon</span> <span class="title class_">Feb</span>  <span class="number">9</span> <span class="number">11</span>:<span class="number">41</span> - <span class="number">18</span>:<span class="number">30</span>  (<span class="number">06</span>:<span class="number">48</span>)</span><br><span class="line">dmtsai   pts/<span class="number">1</span>   <span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span>  <span class="title class_">Mon</span> <span class="title class_">Feb</span>  <span class="number">9</span> <span class="number">11</span>:<span class="number">41</span> - <span class="number">11</span>:<span class="number">41</span>  (<span class="number">00</span>:<span class="number">00</span>)</span><br><span class="line">root     tty1                   <span class="title class_">Fri</span> <span class="title class_">Sep</span>  <span class="number">5</span> <span class="number">14</span>:<span class="number">09</span> - <span class="number">14</span>:<span class="number">10</span>  (<span class="number">00</span>:<span class="number">01</span>)</span><br></pre></td></tr></table></figure><p>如果只是显示最近登录的5个帐号:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#last -n <span class="number">5</span> | awk  <span class="string">&#x27;&#123;print $1&#125;&#x27;</span></span><br><span class="line">root</span><br><span class="line">root</span><br><span class="line">root</span><br><span class="line">dmtsai</span><br><span class="line">root</span><br></pre></td></tr></table></figure><p>awk工作流程是这样的：</p><p>读入有’\n’换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域，0则表示所有域,0则表示所有域,0则表示所有域,1表示第一个域,n表示第n个域。</p><p>默认域分隔符是”空白键”或”[tab]键”,所以n表示第n个域。默认域分隔符是”空白键”或”[tab]键”,所以n表示第n个域。</p><p>默认域分隔符是”空白键” 或 “[tab]键”,所以1表示登录用户，$3表示登录用户ip,以此类推。</p><p>（2）如果想显示&#x2F;etc&#x2F;passwd配置文件中的账户以及账户对应的shell,而账户与shell之间以tab键分割。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#cat /etc/passwd |awk  -F <span class="string">&#x27;:&#x27;</span>  <span class="string">&#x27;&#123;print $1&quot;\t&quot;$7&#125;&#x27;</span></span><br><span class="line">root    /bin/bash</span><br><span class="line">daemon  /bin/sh</span><br><span class="line">bin     /bin/sh</span><br><span class="line">sys     /bin/sh</span><br></pre></td></tr></table></figure><p>注意，这里使用了-F指定域分隔符为’:’。</p><p>（3）如果只是显示&#x2F;etc&#x2F;passwd的账户和账户对应的shell,而账户与shell之间以逗号分割,而且在所有行添加列名name,shell,在最后一行添加”blue,&#x2F;bin&#x2F;nosh”。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cat /etc/passwd |awk  -F <span class="string">&#x27;:&#x27;</span>  <span class="string">&#x27;BEGIN &#123;print &quot;name,shell&quot;&#125;  &#123;print $1&quot;,&quot;$7&#125; END &#123;print &quot;blue,/bin/nosh&quot;&#125;&#x27;</span></span><br><span class="line">name,shell</span><br><span class="line">root,<span class="regexp">/bin/</span>bash</span><br><span class="line">daemon,<span class="regexp">/bin/</span>sh</span><br><span class="line">bin,<span class="regexp">/bin/</span>sh</span><br><span class="line">sys,<span class="regexp">/bin/</span>sh</span><br><span class="line">....</span><br><span class="line">blue,<span class="regexp">/bin/</span>nosh</span><br></pre></td></tr></table></figure><p>awk工作流程是这样的：先执行BEGING，然后读取文件，读入有&#x2F;n换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域，0则表示所有域,0则表示所有域,0则表示所有域,1表示第一个域,$n表示第n个域,随后开始执行模式所对应的动作action。接着开始读入第二条记录······直到所有的记录都读完，最后执行END操作。</p><p>（4）搜索&#x2F;etc&#x2F;passwd有root关键字的所有行。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#awk -<span class="attr">F</span>: <span class="string">&#x27;/root/&#x27;</span> /etc/passwd</span><br><span class="line"><span class="attr">root</span>:<span class="attr">x</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="attr">root</span>:<span class="regexp">/root:/</span>bin/bash</span><br></pre></td></tr></table></figure><p>上面三种是awk的action的使用示例，而这种是pattern的使用示例，匹配了pattern(这里是root)的行才会执行action(没有指定action，默认输出每行的内容)。</p><p>搜索支持正则表达式，例如找root开头的。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">awk -<span class="attr">F</span>: <span class="string">&#x27;/^root/&#x27;</span> /etc/passwd</span><br></pre></td></tr></table></figure><p>（5）搜索&#x2F;etc&#x2F;passwd有root关键字的所有行，并显示对应的shell。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># awk -<span class="attr">F</span>: <span class="string">&#x27;/root/&#123;print $7&#125;&#x27;</span> /etc/passwd             </span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure><p>这里是awk的pattern+action示例用法，同时指明了action是{print $7}。</p><p>（6）打印&#x2F;etc&#x2F;passwd第三行的第一列和第二列。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">awk -<span class="attr">F</span>: <span class="string">&#x27;NR==3&#123;print $1,$2;&#125;&#x27;</span> /etc/passwd</span><br><span class="line"></span><br><span class="line">#输出结果：</span><br><span class="line">daemon x</span><br></pre></td></tr></table></figure><h3 id="6-2-awk在每一列后添加字符串后输出"><a href="#6-2-awk在每一列后添加字符串后输出" class="headerlink" title="6.2.awk在每一列后添加字符串后输出"></a>6.2.awk在每一列后添加字符串后输出</h3><p>设定变量内容：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a=<span class="string">&quot;/test.html /dir1 /abc.txt&quot;</span></span><br></pre></td></tr></table></figure><p>希望得到</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">echo $a</span><br><span class="line">--exclude=<span class="regexp">/test.html --exclude=/</span>dir1 --exclude=/abc.<span class="property">txt</span></span><br></pre></td></tr></table></figure><p>如何用awk实现。</p><p>解决办法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">echo $a|awk <span class="string">&#x27;&#123;for(i=1;i&lt;=NF-1;++i)&#123;printf &quot;-execute=%s &quot;,$i&#125;&#125;&#123;print &quot;--exclude=&quot;$NF&quot;&quot;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">#或者</span><br><span class="line">echo $a|awk <span class="string">&#x27;&#123;for(i=1;i&lt;=NF;i++)&#123;printf &quot;--exclude=&quot;$i&quot; &quot;&#125;&#123;print &quot;&quot;&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>后者是网友给出的答案，和我上面的写法是差不多的，只是对printf在使用形式上有所差别而已。第二种方法print “”是用于换行，print每次输出后默认进行换行。</p><h3 id="6-3shell编程使用awk浮点运算保留两位小数"><a href="#6-3shell编程使用awk浮点运算保留两位小数" class="headerlink" title="6.3shell编程使用awk浮点运算保留两位小数"></a>6.3shell编程使用awk浮点运算保留两位小数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a=<span class="number">3</span></span><br><span class="line">b=<span class="number">10</span></span><br><span class="line">c=$(awk <span class="string">&#x27;BEGIN&#123;printf &quot;%.2f&quot;,&#x27;</span>$a<span class="string">&#x27;*100/&#x27;</span>$b<span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">echo <span class="attr">c</span>:$c%</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">c=$(awk -v n=$a -v m=$b <span class="string">&#x27;BEGIN&#123;printf &quot;%.2f&quot;,n*100/m&#125;&#x27;</span>)</span><br><span class="line">echo <span class="attr">c</span>:$c%</span><br></pre></td></tr></table></figure><p>-v表示定义awk的变量！v是variable的首字母。输出：c：30.00%。</p><h3 id="6-4awk访问shell变量"><a href="#6-4awk访问shell变量" class="headerlink" title="6.4awk访问shell变量"></a>6.4awk访问shell变量</h3><p>awk默认是无法访问shell变量的，我所知道的有三种方法。  方法一：awk -v 选项让awk 里使用shell变量。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">var0=dablelv0</span><br><span class="line">var1=dablelv1</span><br><span class="line">awk -v tmpVar0=$var0 -v tmpVar1=$var1 <span class="string">&#x27;BEGIN&#123;print tmpVar0&quot; &quot;tmpVar1&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>输出：</strong> dablelv0 dablelv1  <strong>注意：</strong> BEGIN必须大写，awk的{action}必须要使用单引号括起来。</p><p>方法二：<code>&#39;&quot;$var&quot;&#39;</code>  这种写法是老外常用的写法。如:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>=<span class="string">&quot;test&quot;</span> </span><br><span class="line">awk <span class="string">&#x27;BEGIN&#123;print &quot;&#x27;</span>$var<span class="string">&#x27;&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>这种写法其实际是双括号变为单括号的常量,传递给了awk。</p><p>如果var中含空格，为了shell不把空格作为分格符，应该如下使用：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>=<span class="string">&quot;this is a test&quot;</span> </span><br><span class="line">awk <span class="string">&#x27;BEGIN&#123;print &quot;&#x27;</span><span class="string">&quot;$var&quot;</span><span class="string">&#x27;&quot;&#125;&#x27;</span> </span><br></pre></td></tr></table></figure><p>方法三：export 变量，将变量设置为临时会话环境变量，仅在当前shell会话中有效。在awk中使用<code>ENVIRON[&quot;var&quot;]</code>形式访问变量。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>=<span class="string">&quot;this is a test&quot;</span></span><br><span class="line"><span class="keyword">export</span> $var #或者 <span class="keyword">export</span> <span class="keyword">var</span></span><br><span class="line"></span><br><span class="line">#或者</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span>=<span class="string">&quot;this is a test&quot;</span></span><br><span class="line"></span><br><span class="line">awk <span class="string">&#x27;BEGIN&#123;print ENVIRON[&quot;var&quot;]&#125;&#x27;</span> </span><br></pre></td></tr></table></figure><h3 id="6-5awk执行shell命令"><a href="#6-5awk执行shell命令" class="headerlink" title="6.5awk执行shell命令"></a>6.5awk执行shell命令</h3><p>awk执行shell命令有两种方法。  方法一：使用awk的system()函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">var</span>=dablelv</span><br><span class="line">awk <span class="string">&#x27;BEGIN&#123;system(&quot;echo $var&quot;)&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>输出：</strong>dablelv  </p><p><strong>注意：</strong>一定要使用export将变量设置为临时环境变量，因为awk的system()实际上是新建了一个shell进程来执行给定的shell命令，否则无法访问父进程的变量。</p><p>方法二：使用<code>使用print cmd | &quot;/bin/bash&quot;</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>=<span class="string">&quot;this is a test&quot;</span></span><br><span class="line">awk <span class="string">&#x27;BEGIN&#123;print &quot;echo &quot;&quot;&#x27;</span><span class="string">&quot;$var&quot;</span><span class="string">&#x27;&quot;|&quot;sh&quot;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">#或者</span><br><span class="line"><span class="keyword">var</span>=<span class="string">&quot;this is a test&quot;</span></span><br><span class="line">awk -v varTmp=<span class="string">&quot;$var&quot;</span> <span class="string">&#x27;BEGIN&#123;print &quot;echo &quot;varTmp|&quot;sh&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>输出：this is a test  </p><p><strong>注意：</strong>  </p><p>（1）指定bash的时候需要双引号括起来；  </p><p>（2）方法二与方法一的区别在于方法二是将变量在awk解析后再通过管道传给shell，所以无需将变量设置为临时环境变量，因为shell接收到的变量已经是变量的值。</p><h2 id="7-awk常见问题"><a href="#7-awk常见问题" class="headerlink" title="7.awk常见问题"></a>7.awk常见问题</h2><p>（1）awk以空格为分隔符Tab也被作为域分隔符。现在只以空格为分隔符，需要使用中括号的方式。不使用中括号，则仍然会将Tab作为分隔符。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#错误的写法</span><br><span class="line">awk -F<span class="string">&#x27; &#x27;</span> <span class="string">&#x27;&#123;print $1;&#125;&#x27;</span> test.<span class="property">txt</span></span><br><span class="line"></span><br><span class="line">#正确的写法</span><br><span class="line">awk -F<span class="string">&#x27;[ ]&#x27;</span> <span class="string">&#x27;&#123;print $1;&#125;&#x27;</span> test.<span class="property">txt</span> </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/FRank675.github.io/posts/a1f5c5e2a0f5/"/>
      <url>/FRank675.github.io/posts/a1f5c5e2a0f5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h1><p><strong>系统信息</strong><br>arch 显示机器的处理器架构<br>uname -m 显示机器的处理器架构<br><strong>uname -r 显示正在使用的内核版本</strong><br>dmidecode -q 显示硬件系统部件 - (SMBIOS &#x2F; DMI)<br>hdparm -i &#x2F;dev&#x2F;hda 罗列一个磁盘的架构特性<br>hdparm -tT &#x2F;dev&#x2F;sda 在磁盘上执行测试性读取操作<br><strong>cat &#x2F;proc&#x2F;cpuinfo 显示CPU info的信息</strong><br>cat &#x2F;proc&#x2F;interrupts 显示中断<br>cat &#x2F;proc&#x2F;meminfo 校验内存使用<br>cat &#x2F;proc&#x2F;swaps 显示哪些swap被使用<br>cat &#x2F;proc&#x2F;version 显示内核的版本<br>cat &#x2F;proc&#x2F;net&#x2F;dev 显示网络适配器及统计<br>cat &#x2F;proc&#x2F;mounts 显示已加载的文件系统<br>lspci -tv 罗列 PCI 设备<br>lsusb -tv 显示 USB 设备<br><strong>date 显示系统日期</strong><br>cal 2007 显示2007年的日历表<br>date 041217002007.00 设置日期和时间 - 月日时分年.秒<br>clock -w 将时间修改保存到 BIOS </p><p><strong>关机 (系统的关机、重启以及登出 )</strong><br>shutdown -h now 关闭系统<br>init 0 关闭系统<br>telinit 0 关闭系统<br>shutdown -h hours:minutes &amp; 按预定时间关闭系统<br>shutdown -c 取消按预定时间关闭系统<br>shutdown -r now 重启<br><strong>reboot 重启</strong><br>logout 注销 </p><p><strong>文件和目录</strong><br>cd &#x2F;home 进入 ‘&#x2F; home’ 目录’<br><strong>cd .. 返回上一级目录</strong><br><strong>cd ..&#x2F;.. 返回上两级目录</strong><br>cd 进入个人的主目录<br>cd ~user1 进入个人的主目录<br><strong>cd - 返回上次所在的目录</strong><br><strong>pwd 显示工作路径</strong><br><strong>ls 查看目录中的文件</strong><br>ls -F 查看目录中的文件<br>ls -l 显示文件和目录的详细资料<br><strong>ls -a 显示隐藏文件</strong><br>ls <em>[0-9]</em> 显示包含数字的文件名和目录名<br>tree 显示文件和目录由根目录开始的树形结构<br>lstree 显示文件和目录由根目录开始的树形结构<br><strong>mkdir dir1 创建一个叫做 ‘dir1’ 的目录’</strong><br><strong>mkdir dir1 dir2 同时创建两个目录</strong><br><strong>mkdir -p &#x2F;tmp&#x2F;dir1&#x2F;dir2 创建一个目录树</strong><br><strong>rm -f file1 删除一个叫做 ‘file1’ 的文件’</strong><br>rmdir dir1 删除一个叫做 ‘dir1’ 的目录’<br><strong>rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容</strong><br>rm -rf dir1 dir2 同时删除两个目录及它们的内容<br><strong>mv dir1 new_dir 重命名&#x2F;移动 一个目录</strong><br><strong>cp file1 file2 复制一个文件</strong><br><em><em>cp dir&#x2F;</em> . 复制一个目录下的所有文件到当前工作目录</em>*<br>cp -a &#x2F;tmp&#x2F;dir1 . 复制一个目录到当前工作目录<br>cp -a dir1 dir2 复制一个目录 </p><p>cp -r dir1 dir2 复制一个目录及子目录<br>ln -s file1 lnk1 创建一个指向文件或目录的软链接<br>ln file1 lnk1 创建一个指向文件或目录的物理链接<br>touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm)<br>file file1 outputs the mime type of the file as text<br>iconv -l 列出已知的编码<br>iconv -f fromEncoding -t toEncoding inputFile &gt; outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding.<br>find . -maxdepth 1 -name *.jpg -print -exec convert “{}” -resize 80x60 “thumbs&#x2F;{}” ; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick) </p><p><strong>文件搜索</strong><br><strong><u>find &#x2F; -name file1 从 ‘&#x2F;‘ 开始进入根文件系统搜索文件和目录</strong></u><br>find &#x2F; -user user1 搜索属于用户 ‘user1’ 的文件和目录<br><strong>find &#x2F;home&#x2F;user1 -name *.bin 在目录 ‘&#x2F; home&#x2F;user1’ 中搜索带有’.bin’ 结尾的文件</strong><br>find &#x2F;usr&#x2F;bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件<br>find &#x2F;usr&#x2F;bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件<br>find &#x2F; -name *.rpm -exec chmod 755 ‘{}’ ; 搜索以 ‘.rpm’ 结尾的文件并定义其权限<br>find &#x2F; -xdev -name *.rpm 搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备<br>locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令<br>whereis halt 显示一个二进制文件、源码或man的位置<br><strong>which halt 显示一个二进制文件或可执行文件的完整路径</strong> </p><p><strong>挂载一个文件系统</strong><br>mount &#x2F;dev&#x2F;hda2 &#x2F;mnt&#x2F;hda2 挂载一个叫做hda2的盘 - 确定目录 ‘&#x2F; mnt&#x2F;hda2’ 已经存在<br>umount &#x2F;dev&#x2F;hda2 卸载一个叫做hda2的盘 - 先从挂载点 ‘&#x2F; mnt&#x2F;hda2’ 退出<br>fuser -km &#x2F;mnt&#x2F;hda2 当设备繁忙时强制卸载<br>umount -n &#x2F;mnt&#x2F;hda2 运行卸载操作而不写入 &#x2F;etc&#x2F;mtab 文件- 当文件为只读或当磁盘写满时非常有用<br>mount &#x2F;dev&#x2F;fd0 &#x2F;mnt&#x2F;floppy 挂载一个软盘<br>mount &#x2F;dev&#x2F;cdrom &#x2F;mnt&#x2F;cdrom 挂载一个cdrom或dvdrom<br>mount &#x2F;dev&#x2F;hdc &#x2F;mnt&#x2F;cdrecorder 挂载一个cdrw或dvdrom<br>mount &#x2F;dev&#x2F;hdb &#x2F;mnt&#x2F;cdrecorder 挂载一个cdrw或dvdrom<br>mount -o loop file.iso &#x2F;mnt&#x2F;cdrom 挂载一个文件或ISO镜像文件<br>mount -t vfat &#x2F;dev&#x2F;hda5 &#x2F;mnt&#x2F;hda5 挂载一个Windows FAT32文件系统<br>mount &#x2F;dev&#x2F;sda1 &#x2F;mnt&#x2F;usbdisk 挂载一个usb 捷盘或闪存设备<br>mount -t smbfs -o username&#x3D;user,password&#x3D;pass &#x2F;&#x2F;WinClient&#x2F;share &#x2F;mnt&#x2F;share 挂载一个windows网络共享 </p><p><strong>磁盘空间</strong><br><strong>df -h 显示已经挂载的分区列表</strong><br>ls -lSr |more 以尺寸大小排列文件和目录<br>du -sh dir1 估算目录 ‘dir1’ 已经使用的磁盘空间’<br>du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小<br>rpm -q -a –qf ‘%10{SIZE}t%{NAME}n’ | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)<br>dpkg-query -W -f&#x3D;’${Installed-Size;10}t${Package}n’ | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (<a href="https://so.csdn.net/so/search?q=ubuntu&spm=1001.2101.3001.7020">ubuntu</a>, debian类系统) </p><p><strong>用户和群组</strong><br>groupadd group_name 创建一个新用户组<br>groupdel group_name 删除一个用户组<br>groupmod -n new_group_name old_group_name 重命名一个用户组<br>useradd -c “Name Surname “ -g admin -d &#x2F;home&#x2F;user1 -s &#x2F;bin&#x2F;bash user1 创建一个属于 “admin” 用户组的用户<br>useradd user1 创建一个新用户<br>userdel -r user1 删除一个用户 ( ‘-r’ 排除主目录)<br>usermod -c “User FTP” -g system -d &#x2F;ftp&#x2F;user1 -s &#x2F;bin&#x2F;nologin user1 修改用户属性<br>passwd 修改口令<br>passwd user1 修改一个用户的口令 (只允许root执行)<br>chage -E 2005-12-31 user1 设置用户口令的失效期限<br>pwck 检查 ‘&#x2F;etc&#x2F;passwd’ 的文件格式和语法修正以及存在的用户<br>grpck 检查 ‘&#x2F;etc&#x2F;passwd’ 的文件格式和语法修正以及存在的群组<br>newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组 </p><p><strong>文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消</strong><br><strong>ls -lh 显示权限</strong><br>ls &#x2F;tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示<br>chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限<br>chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限<br>chown user1 file1 改变一个文件的所有人属性<br>chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性<br>chgrp group1 file1 改变文件的群组<br>chown user1:group1 file1 改变一个文件的所有人和群组属性<br>find &#x2F; -perm -u+s 罗列一个系统中所有使用了SUID控制的文件<br>chmod u+s &#x2F;bin&#x2F;file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限<br>chmod u-s &#x2F;bin&#x2F;file1 禁用一个二进制文件的 SUID位<br>chmod g+s &#x2F;home&#x2F;public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的<br>chmod g-s &#x2F;home&#x2F;public 禁用一个目录的 SGID 位<br>chmod o+t &#x2F;home&#x2F;public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件<br>chmod o-t &#x2F;home&#x2F;public 禁用一个目录的 STIKY 位 </p><p><strong>文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消</strong><br>chattr +a file1 只允许以追加方式读写文件<br>chattr +c file1 允许这个文件能被内核自动压缩&#x2F;解压<br>chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件<br>chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接<br>chattr +s file1 允许一个文件被安全地删除<br>chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘<br>chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件<br>lsattr 显示特殊的属性 </p><p><strong>打包和压缩文件</strong><br>bunzip2 file1.bz2 解压一个叫做 ‘file1.bz2’的文件<br>bzip2 file1 压缩一个叫做 ‘file1’ 的文件<br>gunzip file1.gz 解压一个叫做 ‘file1.gz’的文件<br>gzip file1 压缩一个叫做 ‘file1’的文件<br>gzip -9 file1 最大程度压缩<br>rar a file1.rar test_file 创建一个叫做 ‘file1.rar’ 的包<br>rar a file1.rar file1 file2 dir1 同时压缩 ‘file1’, ‘file2’ 以及目录 ‘dir1’<br>rar x file1.rar 解压rar包<br>unrar x file1.rar 解压rar包<br>tar -cvf archive.tar file1 创建一个非压缩的 tarball<br>tar -cvf archive.tar file1 file2 dir1 创建一个包含了 ‘file1’, ‘file2’ 以及 ‘dir1’的档案文件<br>tar -tf archive.tar 显示一个包中的内容<br>tar -xvf archive.tar 释放一个包<br><strong>tar -xvf archive.tar -C &#x2F;tmp 将压缩包释放到 &#x2F;tmp目录下</strong><br>tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包<br>tar -jxvf archive.tar.bz2 解压一个bzip2格式的压缩包<br>tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包<br>tar -zxvf archive.tar.gz 解压一个gzip格式的压缩包<br>zip file1.zip file1 创建一个zip格式的压缩包<br>zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包<br>unzip file1.zip 解压一个zip格式压缩包 </p><p><strong>RPM 包 - （Fedora, Redhat及类似系统）</strong><br>rpm -ivh package.rpm 安装一个rpm包<br>rpm -ivh –nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告<br>rpm -U package.rpm 更新一个rpm包但不改变其配置文件<br>rpm -F package.rpm 更新一个确定已经安装的rpm包<br>rpm -e package_name.rpm 删除一个rpm包<br>rpm -qa 显示系统中所有已经安装的rpm包<br>rpm -qa | grep httpd 显示所有名称中包含 “httpd” 字样的rpm包<br>rpm -qi package_name 获取一个已安装包的特殊信息<br>rpm -qg “System Environment&#x2F;Daemons” 显示一个组件的rpm包<br>rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表<br>rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表<br>rpm -q package_name –whatrequires 显示与一个rpm包存在依赖关系的列表<br>rpm -q package_name –whatprovides 显示一个rpm包所占的体积<br>rpm -q package_name –scripts 显示在安装&#x2F;删除期间所执行的脚本l<br>rpm -q package_name –changelog 显示一个rpm包的修改历史<br>rpm -qf &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf 确认所给的文件由哪个rpm包所提供<br>rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表<br>rpm –import &#x2F;media&#x2F;cdrom&#x2F;RPM-GPG-KEY 导入公钥数字证书<br>rpm –checksig package.rpm 确认一个rpm包的完整性<br>rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性<br>rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间<br>rpm -Va 检查系统中所有已安装的rpm包- 小心使用<br>rpm -Vp package.rpm 确认一个rpm包还未安装<br>rpm2cpio package.rpm | cpio –extract –make-directories <em>bin</em> 从一个rpm包运行可执行文件<br>rpm -ivh &#x2F;usr&#x2F;src&#x2F;redhat&#x2F;RPMS&#x2F;<code>arch</code>&#x2F;package.rpm 从一个rpm源码安装一个构建好的包<br>rpmbuild –rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包 </p><p><strong>YUM 软件包升级器 - （Fedora, RedHat及类似系统）</strong><br>yum install package_name 下载并安装一个rpm包<br>yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系<br>yum update package_name.rpm 更新当前系统中所有安装的rpm包<br>yum update package_name 更新一个rpm包<br>yum remove package_name 删除一个rpm包<br>yum list 列出当前系统中安装的所有包<br>yum search package_name 在rpm仓库中搜寻软件包<br>yum clean packages 清理rpm缓存删除下载的包<br>yum clean headers 删除所有头文件<br>yum clean all 删除所有缓存的包和头文件 </p><p><strong>DEB 包 (Debian, Ubuntu 以及类似系统)</strong><br>dpkg -i package.deb 安装&#x2F;更新一个 deb 包<br>dpkg -r package_name 从系统删除一个 deb 包<br>dpkg -l 显示系统中所有已经安装的 deb 包<br>dpkg -l | grep httpd 显示所有名称中包含 “httpd” 字样的deb包<br>dpkg -s package_name 获得已经安装在系统中一个特殊包的信息<br>dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表<br>dpkg –contents package.deb 显示尚未安装的一个包所提供的文件列表<br>dpkg -S &#x2F;bin&#x2F;ping 确认所给的文件由哪个deb包提供 </p><p><strong>APT 软件工具 (Debian, Ubuntu 以及类似系统)</strong><br>apt-get install package_name 安装&#x2F;更新一个 deb 包<br>apt-cdrom install package_name 从光盘安装&#x2F;更新一个 deb 包<br>apt-get update 升级列表中的软件包<br>apt-get upgrade 升级所有已安装的软件<br>apt-get remove package_name 从系统删除一个deb包<br>apt-get check 确认依赖的软件仓库正确<br>apt-get clean 从下载的软件包中清理缓存<br>apt-cache search searched-package 返回包含所要搜索字符串的软件包名称 </p><p><strong>查看文件内容</strong><br><strong>cat file1 从第一个字节开始正向查看文件的内容</strong><br>tac file1 从最后一行开始反向查看一个文件的内容<br>more file1 查看一个长文件的内容<br>less file1 类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作<br>head -2 file1 查看一个文件的前两行<br>tail -2 file1 查看一个文件的最后两行<br>tail -f &#x2F;var&#x2F;log&#x2F;messages 实时查看被添加到一个文件中的内容 </p><p><strong>文本处理</strong><br>cat file1 file2 … | command &lt;&gt; file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUT<br>cat file1 | command( sed, grep, awk, grep, etc…) &gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中<br>cat file1 | command( sed, grep, awk, grep, etc…) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中<br>grep Aug &#x2F;var&#x2F;log&#x2F;messages 在文件 ‘&#x2F;var&#x2F;log&#x2F;messages’中查找关键词”Aug”<br>grep ^Aug &#x2F;var&#x2F;log&#x2F;messages 在文件 ‘&#x2F;var&#x2F;log&#x2F;messages’中查找以”Aug”开始的词汇<br>grep [0-9] &#x2F;var&#x2F;log&#x2F;messages 选择 ‘&#x2F;var&#x2F;log&#x2F;messages’ 文件中所有包含数字的行<br>grep Aug -R &#x2F;var&#x2F;log&#x2F;* 在目录 ‘&#x2F;var&#x2F;log’ 及随后的目录中搜索字符串”Aug”<br>sed ‘s&#x2F;stringa1&#x2F;stringa2&#x2F;g’ example.txt 将example.txt文件中的 “string1” 替换成 “string2”<br>sed ‘&#x2F;^$&#x2F;d’ example.txt 从example.txt文件中删除所有空白行<br>sed ‘&#x2F; *#&#x2F;d; &#x2F;^$&#x2F;d’ example.txt 从example.txt文件中删除所有注释和空白行<br>echo ‘esempio’ | tr ‘[:lower:]’ ‘[:upper:]’ 合并上下单元格内容<br>sed -e ‘1d’ result.txt 从文件example.txt 中排除第一行<br>sed -n ‘&#x2F;stringa1&#x2F;p’ 查看只包含词汇 “string1”的行<br>sed -e ‘s&#x2F; <em>$&#x2F;&#x2F;‘ example.txt 删除每一行最后的空白字符<br>sed -e ‘s&#x2F;stringa1&#x2F;&#x2F;g’ example.txt 从文档中只删除词汇 “string1” 并保留剩余全部<br>sed -n ‘1,5p;5q’ example.txt 查看从第一行到第5行内容<br>sed -n ‘5p;5q’ example.txt 查看第5行<br>sed -e ‘s&#x2F;00</em>&#x2F;0&#x2F;g’ example.txt 用单个零替换多个零<br>cat -n file1 标示文件的行数<br>cat example.txt | awk ‘NR%2&#x3D;&#x3D;1’ 删除example.txt文件中的所有偶数行<br>echo a b c | awk ‘{print $1}’ 查看一行第一栏<br>echo a b c | awk ‘{print $1,$3}’ 查看一行的第一和第三栏<br>paste file1 file2 合并两个文件或两栏的内容<br>paste -d ‘+’ file1 file2 合并两个文件或两栏的内容，中间用”+”区分<br>sort file1 file2 排序两个文件的内容<br>sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份)<br>sort file1 file2 | uniq -u 删除交集，留下其他的行<br>sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件)<br>comm -1 file1 file2 比较两个文件的内容只删除 ‘file1’ 所包含的内容<br>comm -2 file1 file2 比较两个文件的内容只删除 ‘file2’ 所包含的内容<br>comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分 </p><p><strong>字符设置和文件格式转换</strong><br>dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIX<br>unix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOS<br>recode ..HTML &lt; page.txt &gt; page.html 将一个文本文件转换成html<br>recode -l | more 显示所有允许的转换格式 </p><p><strong>文件系统分析</strong><br>badblocks -v &#x2F;dev&#x2F;hda1 检查磁盘hda1上的坏磁块<br>fsck &#x2F;dev&#x2F;hda1 修复&#x2F;检查hda1磁盘上linux文件系统的完整性<br>fsck.ext2 &#x2F;dev&#x2F;hda1 修复&#x2F;检查hda1磁盘上ext2文件系统的完整性<br>e2fsck &#x2F;dev&#x2F;hda1 修复&#x2F;检查hda1磁盘上ext2文件系统的完整性<br>e2fsck -j &#x2F;dev&#x2F;hda1 修复&#x2F;检查hda1磁盘上ext3文件系统的完整性<br>fsck.ext3 &#x2F;dev&#x2F;hda1 修复&#x2F;检查hda1磁盘上ext3文件系统的完整性<br>fsck.vfat &#x2F;dev&#x2F;hda1 修复&#x2F;检查hda1磁盘上fat文件系统的完整性<br>fsck.msdos &#x2F;dev&#x2F;hda1 修复&#x2F;检查hda1磁盘上dos文件系统的完整性<br>dosfsck &#x2F;dev&#x2F;hda1 修复&#x2F;检查hda1磁盘上dos文件系统的完整性 </p><p><strong>初始化一个文件系统</strong><br>mkfs &#x2F;dev&#x2F;hda1 在hda1分区创建一个文件系统<br>mke2fs &#x2F;dev&#x2F;hda1 在hda1分区创建一个linux ext2的文件系统<br>mke2fs -j &#x2F;dev&#x2F;hda1 在hda1分区创建一个linux ext3(日志型)的文件系统<br>mkfs -t vfat 32 -F &#x2F;dev&#x2F;hda1 创建一个 FAT32 文件系统<br>fdformat -n &#x2F;dev&#x2F;fd0 格式化一个软盘<br>mkswap &#x2F;dev&#x2F;hda3 创建一个swap文件系统 </p><p><strong>SWAP文件系统</strong><br>mkswap &#x2F;dev&#x2F;hda3 创建一个swap文件系统<br>swapon &#x2F;dev&#x2F;hda3 启用一个新的swap文件系统<br>swapon &#x2F;dev&#x2F;hda2 &#x2F;dev&#x2F;hdb3 启用两个swap分区 </p><p><strong>备份</strong><br>dump -0aj -f &#x2F;tmp&#x2F;home0.bak &#x2F;home 制作一个 ‘&#x2F;home’ 目录的完整备份<br>dump -1aj -f &#x2F;tmp&#x2F;home0.bak &#x2F;home 制作一个 ‘&#x2F;home’ 目录的交互式备份<br>restore -if &#x2F;tmp&#x2F;home0.bak 还原一个交互式备份<br>rsync -rogpav –delete &#x2F;home &#x2F;tmp 同步两边的目录<br>rsync -rogpav -e ssh –delete &#x2F;home ip_address:&#x2F;tmp 通过SSH通道rsync<br>rsync -az -e ssh –delete ip_addr:&#x2F;home&#x2F;public &#x2F;home&#x2F;local 通过ssh和压缩将一个远程目录同步到本地目录<br>rsync -az -e ssh –delete &#x2F;home&#x2F;local ip_addr:&#x2F;home&#x2F;public 通过ssh和压缩将本地目录同步到远程目录<br>dd bs&#x3D;1M if&#x3D;&#x2F;dev&#x2F;hda | gzip | ssh user@ip_addr ‘dd of&#x3D;hda.gz’ 通过ssh在远程主机上执行一次备份本地磁盘的操作<br>dd if&#x3D;&#x2F;dev&#x2F;sda of&#x3D;&#x2F;tmp&#x2F;file1 备份磁盘内容到一个文件<br>tar -Puf backup.tar &#x2F;home&#x2F;user 执行一次对 ‘&#x2F;home&#x2F;user’ 目录的交互式备份操作<br>( cd &#x2F;tmp&#x2F;local&#x2F; &amp;&amp; tar c . ) | ssh -C user@ip_addr ‘cd &#x2F;home&#x2F;share&#x2F; &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个目录内容<br>( tar c &#x2F;home ) | ssh -C user@ip_addr ‘cd &#x2F;home&#x2F;backup-home &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个本地目录<br>tar cf - . | (cd &#x2F;tmp&#x2F;backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接<br>find &#x2F;home&#x2F;user1 -name ‘<em>.txt’ | xargs cp -av –target-directory&#x3D;&#x2F;home&#x2F;backup&#x2F; –parents 从一个目录查找并复制所有以 ‘.txt’ 结尾的文件到另一个目录<br>find &#x2F;var&#x2F;log -name ‘</em>.log’ | tar cv –files-from&#x3D;- | bzip2 &gt; log.tar.bz2 查找所有以 ‘.log’ 结尾的文件并做成一个bzip包<br>dd if&#x3D;&#x2F;dev&#x2F;hda of&#x3D;&#x2F;dev&#x2F;fd0 bs&#x3D;512 count&#x3D;1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作<br>dd if&#x3D;&#x2F;dev&#x2F;fd0 of&#x3D;&#x2F;dev&#x2F;hda bs&#x3D;512 count&#x3D;1 从已经保存到软盘的备份中恢复MBR内容 </p><p><strong>光盘</strong><br>cdrecord -v gracetime&#x3D;2 dev&#x3D;&#x2F;dev&#x2F;cdrom -eject blank&#x3D;fast -force 清空一个可复写的光盘内容<br>mkisofs &#x2F;dev&#x2F;cdrom &gt; cd.iso 在磁盘上创建一个光盘的iso镜像文件<br>mkisofs &#x2F;dev&#x2F;cdrom | gzip &gt; cd_iso.gz 在磁盘上创建一个压缩了的光盘iso镜像文件<br>mkisofs -J -allow-leading-dots -R -V “Label CD” -iso-level 4 -o .&#x2F;cd.iso data_cd 创建一个目录的iso镜像文件<br>cdrecord -v dev&#x3D;&#x2F;dev&#x2F;cdrom cd.iso 刻录一个ISO镜像文件<br>gzip -dc cd_iso.gz | cdrecord dev&#x3D;&#x2F;dev&#x2F;cdrom - 刻录一个压缩了的ISO镜像文件<br>mount -o loop cd.iso &#x2F;mnt&#x2F;iso 挂载一个ISO镜像文件<br>cd-paranoia -B 从一个CD光盘转录音轨到 wav 文件中<br>cd-paranoia – “-3” 从一个CD光盘转录音轨到 wav 文件中（参数-3）<br>cdrecord –scanbus 扫描总线以识别scsi通道<br>dd if&#x3D;&#x2F;dev&#x2F;hdc | md5sum 校验一个设备的md5sum编码，例如一张 CD </p><p><strong>网络 - （以太网和WIFI无线</strong>）<br>ifconfig eth0 显示一个以太网卡的配置<br>ifup eth0 启用一个 ‘eth0’ 网络设备<br>ifdown eth0 禁用一个 ‘eth0’ 网络设备<br>ifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址<br>ifconfig eth0 promisc 设置 ‘eth0’ 成混杂模式以嗅探数据包 (sniffing)<br>dhclient eth0 以dhcp模式启用 ‘eth0’<br>route -n show routing table<br>route add -net 0&#x2F;0 gw IP_Gateway configura default gateway<br>route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 configure static route to reach network ‘192.168.0.0&#x2F;16’<br>route del 0&#x2F;0 gw IP_gateway remove static route<br>echo “1” &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward activate ip routing<br>hostname show hostname of system<br>host <a href="http://www.example.com/">www.example.com</a> lookup hostname to resolve name to ip address and viceversa<br>nslookup <a href="http://www.example.com/">www.example.com</a> lookup hostname to resolve name to ip address and viceversa<br>ip link show show link status of all interfaces<br>mii-tool eth0 show link status of ‘eth0’<br>ethtool eth0 show statistics of network card ‘eth0’<br>netstat -tup show all active network connections and their PID<br>netstat -tupl show all network services listening on the system and their PID<br>tcpdump tcp port 80 show all HTTP traffic<br>iwlist scan show wireless networks<br>iwconfig eth1 show configuration of a wireless network card<br>hostname show hostname<br>host <a href="http://www.example.com/">www.example.com</a> lookup hostname to resolve name to ip address and viceversa<br>nslookup <a href="http://www.example.com/">www.example.com</a> lookup hostname to resolve name to ip address and viceversa<br>whois <a href="http://www.example.com/">www.example.com</a> lookup on Whois database </p><p><strong>JPS工具</strong></p><p>jps(Java Virtual Machine Process Status Tool)是JDK 1.5提供的一个显示当前所有java进程pid的命令，简单实用，非常适合在linux&#x2F;unix平台上简单察看当前java进程的一些简单情况。</p><p>  我想很多人都是用过unix系统里的ps命令，这个命令主要是用来显示当前系统的进程情况，有哪些进程，及其 id。 jps 也是一样，它的作用是显示当前系统的java进程情况，及其id号。我们可以通过它来查看我们到底启动了几个java进程（因为每一个java程序都会独占一个java虚拟机实例），和他们的进程号（为下面几个程序做准备），并可通过opt来查看这些进程的详细启动参数。</p><p>   <strong>使用方法：在当前命令行下打 jps(需要JAVA_HOME，没有的话，到改程序的目录下打) 。</strong></p><p><strong>jps存放在JAVA_HOME&#x2F;bin&#x2F;jps，使用时为了方便请将JAVA_HOME&#x2F;bin&#x2F;加入到Path.</strong></p><p>$&gt; <strong>jps</strong><br>23991 Jps<br>23789 BossMain<br>23651 Resin</p><p>比较常用的参数：</p><p><strong>-q 只显示pid，不显示class名称,jar文件名和传递给main 方法的参数</strong><br>$&gt; <strong>jps -q</strong><br>28680<br>23789<br>23651</p><p><strong>-m 输出传递给main 方法的参数，在嵌入式jvm上可能是null</strong></p><p>$&gt; <strong>jps -m</strong><br>28715 Jps -m<br>23789 BossMain<br>23651 Resin -socketwait 32768 -stdout &#x2F;data&#x2F;aoxj&#x2F;resin&#x2F;log&#x2F;stdout.log -stderr &#x2F;data&#x2F;aoxj&#x2F;resin&#x2F;log&#x2F;stderr.log</p><p><strong>-l 输出应用程序main class的完整package名 或者 应用程序的jar文件完整路径名</strong></p><p>$&gt; <strong>jps -l</strong><br>28729 sun.tools.jps.Jps<br>23789 com.asiainfo.aimc.bossbi.BossMain<br>23651 com.caucho.server.resin.Resin</p><p><strong>-v 输出传递给JVM的参数</strong></p><p>$&gt; <strong>jps -v</strong><br>23789 BossMain<br>28802 Jps -Denv.class.path&#x3D;&#x2F;data&#x2F;aoxj&#x2F;bossbi&#x2F;twsecurity&#x2F;java&#x2F;trustwork140.jar:&#x2F;data&#x2F;aoxj&#x2F;bossbi&#x2F;twsecurity&#x2F;java&#x2F;:&#x2F;data&#x2F;aoxj&#x2F;bossbi&#x2F;twsecurity&#x2F;java&#x2F;twcmcc.jar:&#x2F;data&#x2F;aoxj&#x2F;jdk15&#x2F;lib&#x2F;rt.jar:&#x2F;data&#x2F;aoxj&#x2F;jd</p><p>k15&#x2F;lib&#x2F;tools.jar -Dapplication.home&#x3D;&#x2F;data&#x2F;aoxj&#x2F;jdk15 -Xms8m<br>23651 Resin -Xss1m -Dresin.home&#x3D;&#x2F;data&#x2F;aoxj&#x2F;resin -Dserver.root&#x3D;&#x2F;data&#x2F;aoxj&#x2F;resin -Djava.util.logging.manager&#x3D;com.caucho.log.LogManagerImpl -</p><p>Djavax.management.builder.initial&#x3D;com.caucho.jmx.MBeanServerBuilderImpl</p><p><strong>sudo jps看到的进程数量最全</strong></p><p><strong>jps 192.168.0.77</strong></p><p><strong>列出远程服务器192.168.0.77机器所有的jvm实例，采用rmi协议，默认连接端口为1099</strong></p><p><strong>（前提是远程服务器提供jstatd服务）</strong></p><p><strong>注：jps命令有个地方很不好，似乎只能显示当前用户的java进程，要显示其他用户的还是只能用unix&#x2F;linux的ps命令。</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python常用操作</title>
      <link href="/FRank675.github.io/posts/40889dd62d68/"/>
      <url>/FRank675.github.io/posts/40889dd62d68/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="Python-总结"><a href="#Python-总结" class="headerlink" title="Python 总结"></a>Python 总结</h1><p>[TOC]</p><h2 id="将两个list转换为dictionary"><a href="#将两个list转换为dictionary" class="headerlink" title="将两个list转换为dictionary"></a>将两个list转换为dictionary</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将两个list转换为dictionary</span></span><br><span class="line">list_1 = [<span class="string">&#x27;karl&#x27;</span>, <span class="string">&#x27;lay&#x27;</span>, <span class="string">&#x27;martin&#x27;</span>]</span><br><span class="line">list_2 = [<span class="number">111</span>, <span class="number">222</span>, <span class="number">333</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 1 ： zip()</span></span><br><span class="line">dict_1 = <span class="built_in">dict</span>(<span class="built_in">zip</span>(list_1, list_2))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 2 : dictionary comprehension</span></span><br><span class="line">dict_2 = &#123;key: value <span class="keyword">for</span> key, value <span class="keyword">in</span> <span class="built_in">zip</span>(list_1, list_2)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 3 : Using a For loop (Not Recommended)</span></span><br><span class="line">tuples = <span class="built_in">zip</span>(list_1, list_2)</span><br><span class="line">dict_3 = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> tuples:</span><br><span class="line">    <span class="keyword">if</span> key <span class="keyword">in</span> dict_3:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        dict_3[key] = value</span><br><span class="line"><span class="built_in">print</span>(dict_1, dict_2, dict_3, sep= <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; Output</span></span><br><span class="line"><span class="string">&#123;&#x27;karl&#x27;: 111, &#x27;lay&#x27;: 222, &#x27;martin&#x27;: 333&#125;</span></span><br><span class="line"><span class="string">&#123;&#x27;karl&#x27;: 111, &#x27;lay&#x27;: 222, &#x27;martin&#x27;: 333&#125;</span></span><br><span class="line"><span class="string">&#123;&#x27;karl&#x27;: 111, &#x27;lay&#x27;: 222, &#x27;martin&#x27;: 333&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="对字符串列表进行排序"><a href="#对字符串列表进行排序" class="headerlink" title="对字符串列表进行排序"></a>对字符串列表进行排序</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对字符串列表进行排序</span></span><br><span class="line">list1 = [<span class="string">&quot;Karl&quot;</span>,<span class="string">&quot;Larry&quot;</span>,<span class="string">&quot;Ana&quot;</span>,<span class="string">&quot;Zack&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># sort是在原位重新排列列表，而sorted ()是产生一个新的列表。 </span></span><br><span class="line"><span class="comment"># sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 1: sort()</span></span><br><span class="line">list1.sort()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 2: sorted()</span></span><br><span class="line">sorted_list = <span class="built_in">sorted</span>(list1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 3: Brute Force Method</span></span><br><span class="line">size = <span class="built_in">len</span>(list1)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">    <span class="keyword">if</span> list1[i] &lt; list1[j]:</span><br><span class="line">       temp = list1[i]</span><br><span class="line">       list1[i] = list1[j]</span><br><span class="line">       list1[j] = temp</span><br><span class="line">       </span><br><span class="line"><span class="built_in">print</span>(list1)</span><br><span class="line"><span class="string">&quot;&quot;&quot; Output</span></span><br><span class="line"><span class="string">[&#x27;Ana&#x27;, &#x27;Karl&#x27;, &#x27;Larry&#x27;, &#x27;Zack&#x27;]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="List-Comprehension-with-if-and-else"><a href="#List-Comprehension-with-if-and-else" class="headerlink" title="List Comprehension with if and else"></a>List Comprehension with if and else</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## List Comprehension with if and else</span></span><br><span class="line"></span><br><span class="line">list_1 = [<span class="string">&quot;Divided By 5&quot;</span> <span class="keyword">if</span> i%<span class="number">5</span> == <span class="number">0</span> <span class="keyword">else</span> i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">20</span>)]</span><br><span class="line">list_2 = [<span class="string">&quot;FizzBuzz&quot;</span> <span class="keyword">if</span> i%<span class="number">3</span> == <span class="number">0</span> <span class="keyword">and</span> i%<span class="number">5</span> == <span class="number">0</span> <span class="keyword">else</span> <span class="string">&#x27;Fuzz&#x27;</span> <span class="keyword">if</span> i%<span class="number">3</span> == <span class="number">0</span> <span class="keyword">else</span> <span class="string">&#x27;Buzz&#x27;</span> <span class="keyword">if</span> i%<span class="number">5</span> == <span class="number">0</span> <span class="keyword">else</span> i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">20</span>)]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(list_1, list_2, sep=<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot; Output</span></span><br><span class="line"><span class="string">[1, 2, 3, 4, &#x27;Divided By 5&#x27;, 6, 7, 8, 9, &#x27;Divided By 5&#x27;, 11, 12, 13, 14, &#x27;Divided By 5&#x27;, 16, 17, 18, 19]</span></span><br><span class="line"><span class="string">[1, 2, &#x27;Fuzz&#x27;, 4, &#x27;Buzz&#x27;, &#x27;Fuzz&#x27;, 7, 8, &#x27;Fuzz&#x27;, &#x27;Buzz&#x27;, 11, &#x27;Fuzz&#x27;, 13, 14, &#x27;FizzBuzz&#x27;, 16, 17, &#x27;Fuzz&#x27;, 19]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="添加来自两个列表的元素"><a href="#添加来自两个列表的元素" class="headerlink" title="添加来自两个列表的元素"></a>添加来自两个列表的元素</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加来自两个列表的元素</span></span><br><span class="line"></span><br><span class="line">maths = [<span class="number">59</span>, <span class="number">64</span>, <span class="number">75</span>, <span class="number">86</span>]</span><br><span class="line">physics = [<span class="number">78</span>, <span class="number">98</span>, <span class="number">56</span>, <span class="number">56</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Brute Force Method</span></span><br><span class="line">list1 = [</span><br><span class="line">  maths[<span class="number">0</span>]+physics[<span class="number">0</span>],</span><br><span class="line">  maths[<span class="number">1</span>]+physics[<span class="number">1</span>],</span><br><span class="line">  maths[<span class="number">2</span>]+physics[<span class="number">2</span>],</span><br><span class="line">  maths[<span class="number">3</span>]+physics[<span class="number">3</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># List Comprehension</span></span><br><span class="line">list1 = [x + y <span class="keyword">for</span> x,y <span class="keyword">in</span> <span class="built_in">zip</span>(maths,physics)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Using Maps</span></span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line">all_devices = <span class="built_in">list</span>(<span class="built_in">map</span>(operator.add, maths, physics))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Using Numpy Library</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">list1 = np.add(maths,physics)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(list1)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;Output</span></span><br><span class="line"><span class="string">[137 162 131 142]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="对dictionary列表进行排序"><a href="#对dictionary列表进行排序" class="headerlink" title="对dictionary列表进行排序"></a>对dictionary列表进行排序</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = [</span><br><span class="line">    &#123;<span class="string">&quot;Name&quot;</span>:<span class="string">&quot;Karl&quot;</span>,</span><br><span class="line">     <span class="string">&quot;Age&quot;</span>:<span class="number">25</span>&#125;,</span><br><span class="line">     &#123;<span class="string">&quot;Name&quot;</span>:<span class="string">&quot;Lary&quot;</span>,</span><br><span class="line">     <span class="string">&quot;Age&quot;</span>:<span class="number">39</span>&#125;,</span><br><span class="line">     &#123;<span class="string">&quot;Name&quot;</span>:<span class="string">&quot;Nina&quot;</span>,</span><br><span class="line">     <span class="string">&quot;Age&quot;</span>:<span class="number">35</span>&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">## Using sort()</span></span><br><span class="line">dict1.sort(key=<span class="keyword">lambda</span> item: item.get(<span class="string">&quot;Age&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># List sorting using itemgetter</span></span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line">f = itemgetter(<span class="string">&#x27;Name&#x27;</span>)</span><br><span class="line">dict1.sort(key=f)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Iterable sorted function</span></span><br><span class="line">dict1 = <span class="built_in">sorted</span>(dict1, key=<span class="keyword">lambda</span> item: item.get(<span class="string">&quot;Age&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dict1)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;Output</span></span><br><span class="line"><span class="string">[&#123;&#x27;Age&#x27;: 25, &#x27;Name&#x27;: &#x27;Karl&#x27;&#125;,</span></span><br><span class="line"><span class="string"> &#123;&#x27;Age&#x27;: 35, &#x27;Name&#x27;: &#x27;Nina&#x27;&#125;,</span></span><br><span class="line"><span class="string"> &#123;&#x27;Age&#x27;: 39, &#x27;Name&#x27;: &#x27;Lary&#x27;&#125;]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="检查字符串中的子字符串"><a href="#检查字符串中的子字符串" class="headerlink" title="检查字符串中的子字符串"></a>检查字符串中的子字符串</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">addresses = [</span><br><span class="line">  <span class="string">&quot;12/45 Elm street&quot;</span>,</span><br><span class="line">  <span class="string">&#x27;34/56 Clark street&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;56,77 maple street&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;17/45 Elm street&#x27;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">street = <span class="string">&#x27;Elm street&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> addresses:</span><br><span class="line">  <span class="keyword">if</span> street <span class="keyword">in</span> i:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;output</span></span><br><span class="line"><span class="string">12/45 Elm street</span></span><br><span class="line"><span class="string">17/45 Elm street</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="字符串格式"><a href="#字符串格式" class="headerlink" title="字符串格式"></a>字符串格式</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;Abhay&quot;</span></span><br><span class="line">age = <span class="number">21</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># METHOD 1: Concatenation</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My name is &quot;</span> + name + <span class="string">&quot;, and I am &quot;</span> + <span class="built_in">str</span>(age) + <span class="string">&quot; years old.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># METHOD 2: F-strings (Python 3+)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;My name is <span class="subst">&#123;name&#125;</span>, and I am <span class="subst">&#123;age&#125;</span> years old&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># METHOD 3: Join</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join([<span class="string">&quot;My name is &quot;</span>, name, <span class="string">&quot;, and I am &quot;</span>, <span class="built_in">str</span>(age), <span class="string">&quot; years old&quot;</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># METHOD 4: modulus operator</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My name is %s, and I am %d years old.&quot;</span> % (name, age))</span><br><span class="line"></span><br><span class="line"><span class="comment"># METHOD 5: format(Python 2 and 3)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My name is &#123;&#125;, and I am &#123;&#125; years old&quot;</span>.<span class="built_in">format</span>(name, age))</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; Output</span></span><br><span class="line"><span class="string">My name is Abhay, and I am 21 years old.</span></span><br><span class="line"><span class="string">My name is Abhay, and I am 21 years old</span></span><br><span class="line"><span class="string">My name is Abhay, and I am 21 years old</span></span><br><span class="line"><span class="string">My name is Abhay, and I am 21 years old.</span></span><br><span class="line"><span class="string">My name is Abhay, and I am 21 years old</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="列表中最常见的元素"><a href="#列表中最常见的元素" class="headerlink" title="列表中最常见的元素"></a>列表中最常见的元素</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列表中最常见的元素</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">most_frequent</span>(<span class="params">nums</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">set</span>(nums), key = nums.count)</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">most_frequent_num = most_frequent(<span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(most_frequent_num)</span><br><span class="line"><span class="string">&quot;&quot;&quot; Output</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="在没有if-else情况下计算"><a href="#在没有if-else情况下计算" class="headerlink" title="在没有if-else情况下计算"></a>在没有if-else情况下计算</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import operator</span><br><span class="line">action = &#123;</span><br><span class="line">  &quot;+&quot; : operator.add,</span><br><span class="line">  &quot;-&quot; : operator.sub,</span><br><span class="line">  &quot;/&quot; : operator.truediv,</span><br><span class="line">  &quot;*&quot; : operator.mul,</span><br><span class="line">  &quot;**&quot; : pow</span><br><span class="line">&#125;</span><br><span class="line">print(action[&#x27;*&#x27;](5, 5))    # 25</span><br></pre></td></tr></table></figure><h2 id="Chained-Function调用"><a href="#Chained-Function调用" class="headerlink" title="Chained Function调用"></a>Chained Function调用</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在python中，你可以在同一行代码调用多个函数。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a,b</span>):</span><br><span class="line">  <span class="keyword">return</span> a+b</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub</span>(<span class="params">a,b</span>):</span><br><span class="line">  <span class="keyword">return</span> a-b</span><br><span class="line"></span><br><span class="line">a,b = <span class="number">9</span>,<span class="number">6</span></span><br><span class="line"><span class="built_in">print</span>((sub <span class="keyword">if</span> a &gt; b <span class="keyword">else</span> add)(a, b))</span><br></pre></td></tr></table></figure><h2 id="交换数值"><a href="#交换数值" class="headerlink" title="交换数值"></a>交换数值</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a,b = <span class="number">5</span>,<span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 1</span></span><br><span class="line">b,a = a,b</span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">swap</span>(<span class="params">a,b</span>):</span><br><span class="line">  <span class="keyword">return</span> b,a</span><br><span class="line"></span><br><span class="line">swap(a,b)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a,b)</span><br><span class="line"><span class="string">&quot;&quot;&quot; Output</span></span><br><span class="line"><span class="string">7 5</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="查找重复项"><a href="#查找重复项" class="headerlink" title="查找重复项"></a>查找重复项</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">has_duplicates</span>(<span class="params">lst</span>):</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">not</span> <span class="built_in">len</span>(lst) == <span class="built_in">len</span>(<span class="built_in">set</span>(lst))</span><br><span class="line"></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">y = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(has_duplicates(x))    <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(has_duplicates(y))    <span class="comment"># True</span></span><br></pre></td></tr></table></figure><h2 id="在给定范围内，算所有数的平方"><a href="#在给定范围内，算所有数的平方" class="headerlink" title="在给定范围内，算所有数的平方"></a>在给定范围内，算所有数的平方</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># METHOD 1</span></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> repeat</span><br><span class="line">n = <span class="number">5</span></span><br><span class="line">squares = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">pow</span>, <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>), repeat(<span class="number">2</span>)))</span><br><span class="line"><span class="built_in">print</span>(squares)</span><br><span class="line"></span><br><span class="line"><span class="comment"># METHOD 2</span></span><br><span class="line">n = <span class="number">6</span></span><br><span class="line">squares = [i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>)]</span><br><span class="line"><span class="built_in">print</span>(squares)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;Output</span></span><br><span class="line"><span class="string">  [1, 4, 9, 16, 25]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="合并两个字典"><a href="#合并两个字典" class="headerlink" title="合并两个字典"></a>合并两个字典</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">basic_information = &#123;<span class="string">&quot;name&quot;</span>:[<span class="string">&#x27;karl&#x27;</span>,<span class="string">&#x27;Lary&#x27;</span>],<span class="string">&quot;mobile&quot;</span>:[<span class="string">&quot;0134567894&quot;</span>,<span class="string">&quot;0123456789&quot;</span>]&#125;</span><br><span class="line">academic_information = &#123;<span class="string">&quot;grade&quot;</span>:[<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>]&#125;</span><br><span class="line"></span><br><span class="line">details = <span class="built_in">dict</span>() <span class="comment">## Combines Dict</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Dictionary Comprehension Method</span></span><br><span class="line">details = &#123;key: value <span class="keyword">for</span> data <span class="keyword">in</span> (basic_information, academic_information) <span class="keyword">for</span> key,value <span class="keyword">in</span> data.items()&#125;</span><br><span class="line"><span class="built_in">print</span>(details)</span><br><span class="line"></span><br><span class="line"><span class="comment">## Dictionary unpacking</span></span><br><span class="line">details = &#123;**basic_information ,**academic_information&#125;</span><br><span class="line"><span class="built_in">print</span>(details)</span><br><span class="line"></span><br><span class="line"><span class="comment">## Copy and Update Method</span></span><br><span class="line">details = basic_information.copy()</span><br><span class="line">details.update(academic_information)</span><br><span class="line"><span class="built_in">print</span>(details)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动化测试-Selenium</title>
      <link href="/FRank675.github.io/posts/2674f79a35bd/"/>
      <url>/FRank675.github.io/posts/2674f79a35bd/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script>]]></content>
      
      
      <categories>
          
          <category> 测试,技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试，selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/FRank675.github.io/posts/72b1ae2f9336/"/>
      <url>/FRank675.github.io/posts/72b1ae2f9336/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="1、TCP"><a href="#1、TCP" class="headerlink" title="1、TCP"></a>1、TCP</h2><h3 id="（1）介绍一下OSI七层模型和TCP五层模型？"><a href="#（1）介绍一下OSI七层模型和TCP五层模型？" class="headerlink" title="（1）介绍一下OSI七层模型和TCP五层模型？"></a>（1）介绍一下OSI七层模型和TCP五层模型？</h3><p>OSI七层模型从上到下依次为：</p><p>应用层：为应用程序提供网络服务；</p><p>表示层：数据格式转换、数据压缩和数据加密；</p><p>会话层：建立、断开和维护通信链接；</p><p>传输层：为上层协议提供端到端的可靠传输；</p><p>网络层：寻址和路由；</p><p>数据链路层：定义通过通信媒介互连的设备之间传输的规范；</p><p>物理层：利用物理传输介质为数据链路层提供物理连接。</p><p>TCP五层模型相比OSI七层模型，将OSI的应用层、表示层和会话层合为一层：应用层，其他不变。</p><h3 id="（2）什么是面向有连接型和面向无连接型？"><a href="#（2）什么是面向有连接型和面向无连接型？" class="headerlink" title="（2）什么是面向有连接型和面向无连接型？"></a>（2）什么是面向有连接型和面向无连接型？</h3><ul><li>面向有连接型传输包括会话建立、传输数据和会话断开，此外还包括保证传输可靠性的各种措施，比如超时重传、流量控制等，常见的面向有连接传输有TCP；</li><li>面向无连接型传输仅提供基本的传输数据的功能，即使接收端不存在，发送端也能发送数据包，常见的面向无连接传输有UDP、IP。</li></ul><h3 id="（3）什么是UDP和TCP？UDP和TCP的区别是什么？"><a href="#（3）什么是UDP和TCP？UDP和TCP的区别是什么？" class="headerlink" title="（3）什么是UDP和TCP？UDP和TCP的区别是什么？"></a>（3）什么是UDP和TCP？UDP和TCP的区别是什么？</h3><p>UDP和TCP都是传输层的协议，用来建立可靠的通信传输链接的。</p><p>UDP仅提供了最基本的数据传输功能，至于传输时连接的建立和断开、传输可靠性的保证这些UDP统统不关心，而是把这些问题抛给了UDP上层的应用层程序去处理，自己仅提供传输层协议的最基本功能。</p><p>TCP作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，会在传输开始前建立连接，传输结束后断开连接，此外，TCP还采取了多种措施保障传输的可靠性。</p><p><strong>TCP和UDP的区别如下：</strong></p><ul><li>TCP是面向有连接型，UDP是面向无连接型；</li><li>TCP是一对一传输，UDP支持一对一、一对多、多对一和多对多的交互通信；</li><li>TCP是面向字节流的，即把应用层传来的报文看成字节流，将字节流拆分成大小不等的数据块，并添加TCP首部；UDP是面向报文的，对应用层传下来的报文不拆分也不合并，仅添加UDP首部；</li><li>TCP支持传输可靠性的多种措施，包括保证包的传输顺序、重发机制、流量控制和拥塞控制；UDP仅提供最基本的数据传输能力。</li></ul><h3 id="（4）TCP对应的应用层协议有哪些？UDP对应的应用层协议有哪些？"><a href="#（4）TCP对应的应用层协议有哪些？UDP对应的应用层协议有哪些？" class="headerlink" title="（4）TCP对应的应用层协议有哪些？UDP对应的应用层协议有哪些？"></a>（4）TCP对应的应用层协议有哪些？UDP对应的应用层协议有哪些？</h3><p>TCP对应的典型的应用层协议：</p><ul><li>FTP：文件传输协议；</li><li>SSH：远程登录协议；</li><li>HTTP：web服务器传输超文本到本地浏览器的超文本传输协议。</li></ul><p>UDP对应的典型的应用层协议：</p><ul><li>DNS：域名解析协议；</li><li>TFTP：简单文件传输协议；</li><li>SNMP：简单网络管理协议。</li></ul><h3 id="（5）介绍一下TCP三次握手？为什么不是两次？为什么不是四次？"><a href="#（5）介绍一下TCP三次握手？为什么不是两次？为什么不是四次？" class="headerlink" title="（5）介绍一下TCP三次握手？为什么不是两次？为什么不是四次？"></a>（5）介绍一下TCP三次握手？为什么不是两次？为什么不是四次？</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>物理层、数据链路层在物理层面上架设好了通信链路，网络层确定了通信双方的地址，那下一步就是传输层建立逻辑层面上的通信连接，将从应用层获得的报文数据从源端发送给接受端。TCP的三次握手就是在发送数据前通过“三次握手”的方式建立起这个通信连接，<strong>建立这个连接的目的是让源端和目的端确认一下双方的发送报文能力和接收报文能力是正常的，实际上就是通过三次握手这个操作将下面的表填完整：</strong></p><p><img src="https://pic1.zhimg.com/80/v2-3a6613efd413f9e5ae1c5e124e0a0fa8_720w.webp" alt="img"></p><p>图1.1 三次握手要填充的表格</p><p>下面具体介绍三次握手的过程，并在每次握手时填充这个表格，当表格填满后，意味着源端和目的端已确认完毕双方的发送报文能力和接收报文能力是正常的，三次握手结束，通信双方的连接已成功建立。</p><h5 id="TCP报文首部"><a href="#TCP报文首部" class="headerlink" title="TCP报文首部"></a>TCP报文首部</h5><p>在介绍三次握手前先介绍一下TCP报文的首部，报文首部可以理解为报文的元数据，里面存放着与这次报文相关的其他信息，图我就不摆了，介绍一下跟三次握手相关的报文首部字段。</p><p>（1）序号seq</p><p>对字节流的编号。例如第一个字节的序号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。注意第一份报文段的序号是随机生成的，后面的报文段序号是根据上一个报文段序号及报文长度生成的。</p><p>（2）确认号ack</p><p>期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</p><p>（3）SYN</p><p>控制位的一种，用于建立连接，该位设为 1，表示希望建立连接，并对第一份报文的序号进行随机初始化。</p><p>（4）ACK</p><p>控制位的一种，确认应答的字段有效，TCP规定除了最初建立连接时的 SYN 包以外该位必须设为 1。</p><p>（5）FIN</p><p>控制位的一种，当FIN&#x3D;1，表明此报文的发送方的数据已经发送完毕，要求关闭连接。</p><h5 id="三次握手具体过程"><a href="#三次握手具体过程" class="headerlink" title="三次握手具体过程"></a>三次握手具体过程</h5><p>TCP三次握手的过程如图所示</p><p><img src="https://pic3.zhimg.com/80/v2-770e5584cb5752e0295432be789b86d2_720w.webp" alt="img"></p><p>TCP三次握手过程</p><p>（1）第一次握手</p><p>Client端将SYN置为1，表示希望与Server端建立连接；序号seq初始化为J，并将该数据包发送给Server端，Client进入SYN_SENT状态，等待Server确认。</p><p>（2）第二次握手</p><p>Server端检查报文发现SYN为1，知道了Client端想建立连接；Server端将SYN置为1，表示Server端也希望与Clinet端建立连接；Server端将ACK置为1，表示收到了Client端建立连接的请求；Server端将seq初始化为K；Server端将ack置为J+1，这里ack&#x3D;seq + 1，还有疑问（如果控制位占1字节，为什么第三次握手时有ACK&#x3D;1、SYN&#x3D;1，ack为什么不是+2？如果+1只是告诉服务端收到了消息，那ACK控制位就已经达到目的了，为什么还要多次一举再加一个ack?）。第二次握手包括服务端确认客户端发来的报文和服务端向客户端发送报文两个过程。</p><p>第二次握手时表格填充结果如下：</p><p><img src="https://pic1.zhimg.com/80/v2-e697bf5e5130739686f11ddf5d43a5dc_720w.webp" alt="img"></p><p>第二次握手表格填充</p><p>（3）第三次握手</p><p>Client收到报文后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack&#x3D;K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。第三次握手包括客户端确认服务端发来的报文，客户端向服务端发送报文和服务端确认客户端发来的报文三个过程。</p><p>第三次握手客户端确认信息后填充表格如下:</p><p><img src="https://pic3.zhimg.com/80/v2-fb9327440993a84efc06eb827b25ebe2_720w.webp" alt="img"></p><p>第三次握手客户端确认信息表格填充</p><p>第三次握手服务端确认信息后填充表格如下：</p><p><img src="https://pic1.zhimg.com/80/v2-d868aad5715376de187ea48ec781b520_720w.webp" alt="img"></p><p>​                                                              第三次握手服务端确认信息表格填充</p><p>至此，表格填充完毕，三次握手也结束，连接成功建立。有些面试官会问为什么不是2次握手？</p><p><strong>因为2次握手表格填充不完，源端和目的端无法确认双方的收发能力；为什么不是4次握手？3次握手表格就填充完毕了，不需要再多一次握手了。</strong></p><h3 id="（6）介绍一下TCP四次挥手？为什么不是三次？为什么不是五次？"><a href="#（6）介绍一下TCP四次挥手？为什么不是三次？为什么不是五次？" class="headerlink" title="（6）介绍一下TCP四次挥手？为什么不是三次？为什么不是五次？"></a>（6）介绍一下TCP四次挥手？为什么不是三次？为什么不是五次？</h3><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>三次握手是建立TCP连接，四次挥手是断开TCP连接，即客户端和服务端总共要收发4个包才能确定断开连接。</p><h4 id="四次挥手的具体过程"><a href="#四次挥手的具体过程" class="headerlink" title="四次挥手的具体过程"></a>四次挥手的具体过程</h4><p>四次挥手的过程如图所示：</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/v2-439585f9ae8c89bfb5a96f100fb99ed5_720w.webp" alt="img"></p><p>TCP四次挥手过程图</p><p>（1）第一次挥手</p><p>假设客户端主动发起断开请求，客户端向服务端发送报文，报文首部包括FIN&#x3D;1，这个控制位代表客户端想要断开连接；序列号seq&#x3D;u，这时客户端进入FIN-WAIT-1（终止等待1）状态，停止发送数据，并等待服务端的确认。</p><p>（2）第二次挥手</p><p>服务端收到客户端的报文后发出确认报文，控制位ACK&#x3D;1；确认号ack&#x3D;u+1；序列号seq&#x3D;v；然后服务端就进入CLOSE-WAIT（关闭等待）状态。TCP服务端会告知上层的应用进程来自客户端的连接即将关闭，让应用程序做好相应的准备。此时客户端已经没有数据向服务端发送了，但服务端向客户端发送数据，客户端依然能接收。</p><p>（3）第三次挥手</p><p>客户端收到服务器确认报文后，进入FIN-WAIT-2状态。此时服务器再次发送报文，报文首部控制位FIN&#x3D;1，表示服务端向客户端发送断开连接请求；确认标志ACK&#x3D;1；确认序号ack&#x3D;u+1；序号seq&#x3D;w，然后服务器进入LAST-ACK（最后确认态），等待客户端确认。</p><p>（4）第四次挥手</p><p>客户端收到了服务端的断开连接的报文后，必须发出确认报文，标志位ACK&#x3D;1；确认号ack&#x3D;w+1;序号seq&#x3D;u+1；之后客户端就进入了TIME-WAIT（时间等待）状态。注意此时客户端的TCP连接还没有释放，必须经过2*MSL（最长报文段寿命）的时间后，客户端才进入CLOSED状态关闭连接。而服务端只要收到了客户端发送的确认报文后就会进入CLOSED状态关闭服务端连接。当客户端和服务端都进入了CLOSED状态后，客户端和服务端之间的连接才完全断开。</p><h3 id="2-2-为什么会有TIME-WAIT状态？"><a href="#2-2-为什么会有TIME-WAIT状态？" class="headerlink" title="2.2 为什么会有TIME_WAIT状态？"></a>2.2 为什么会有TIME_WAIT状态？</h3><p>上面介绍第四次挥手的过程中，客户端在发送完给服务端的回执报文后没有立刻进入CLOSED状态，而是进入TIME-WAIT状态，然后等待2*MSL（最长报文段寿命）的时间后才进入CLOSED状态，这是为什么？原因有以下两点：</p><ul><li>客户端发送给服务端回执后，有可能这个回执报文在传输途中丢失等原因，服务端并没有收到，此时服务端会再次向客户端发送FIN&#x3D;1的断开请求报文，如果客户端没有等待2*MSL时间而直接进入了CLOSED状态，客户端就会收不到服务端再次发送的断开连接的请求报文，导致服务端无法进入CLOSED状态；</li><li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li></ul><p>注：MSL是Maximum Segment Lifetime英文的缩写，中文可以译为“报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p><h3 id="2-3-为什么是四次挥手而不是三次或者五次？"><a href="#2-3-为什么是四次挥手而不是三次或者五次？" class="headerlink" title="2.3 为什么是四次挥手而不是三次或者五次？"></a>2.3 为什么是四次挥手而不是三次或者五次？</h3><p>第二次挥手和第三次挥手都是服务端向客户端发送报文，第二次挥手是服务端收到了客户端的断开请求，通知客户端俺收到了，此时客户端没有数据向服务端发送了，但不代表服务端也没有数据向客户端发送，因为服务端要把剩余还没有发送的报文发送完毕再断开连接；第三次挥手是服务端数据全部发送完毕，向客户端发送断开请求报文（FIN&#x3D;1）。</p><p>如果是三次挥手，即把服务端向客户端发送报文的第二次挥手和第三次挥手合为一次，会造成服务端发送了回执后立刻又发送断开请求，造成服务端有数据没有全部发送至客户端，因此必须将第二次挥手和第三次挥手分开；五次挥手则完全没必要，多此一举。</p><h3 id="（7）在四次挥手中，为什么客户端进入TIME-WAIT状态等待2-MSL时间，而不是直接进入CLOSED状态？"><a href="#（7）在四次挥手中，为什么客户端进入TIME-WAIT状态等待2-MSL时间，而不是直接进入CLOSED状态？" class="headerlink" title="（7）在四次挥手中，为什么客户端进入TIME_WAIT状态等待2*MSL时间，而不是直接进入CLOSED状态？"></a>（7）在四次挥手中，为什么客户端进入TIME_WAIT状态等待2*MSL时间，而不是直接进入CLOSED状态？</h3><p>客户端在发送完给服务端的回执报文后没有立刻进入CLOSED状态，而是进入TIME-WAIT状态，然后等待2*MSL（最长报文段寿命）的时间后才进入CLOSED状态，这是为什么？原因有以下两点：</p><ul><li>客户端发送给服务端回执后，有可能这个回执报文在传输途中丢失等原因，服务端并没有收到，此时服务端会再次向客户端发送FIN&#x3D;1的断开请求报文，如果客户端没有等待2*MSL时间而直接进入了CLOSED状态，客户端就会收不到服务端再次发送的断开连接的请求报文，导致服务端无法进入CLOSED状态；</li><li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li></ul><p>注：MSL是Maximum Segment Lifetime英文的缩写，中文可以译为“报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p><h3 id="（8）说一下ARQ协议？"><a href="#（8）说一下ARQ协议？" class="headerlink" title="（8）说一下ARQ协议？"></a>（8）说一下ARQ协议？</h3><p>ARQ协议，即自动重传请求（Automatic Repeat-reQuest），意思是如果发送方在发送后一段时间之内没有收到确认回执，它通常会重新发送。ARQ协议包括停止等待ARQ协议和连续ARQ协议。</p><p>（1）停止等待ARQ协议</p><p>停止等待ARQ协议是指，在停止等待中如果接收端没有收到发送端发来的分组，接收端就不会给发送端发送确认回执，此时发送端会重新发送之前的报文分组。发送端会维护一个超时计时器，超时时间会设置的比数据在传输往返过程的时间要长一些。</p><p>（2）连续ARQ协议</p><p>连续ARQ协议是指，发送端维护一个“窗口”，“窗口”内可以有多个分组，窗口的大小就是窗口中分组的个数，凡是位于“窗口”内的分组可以连续发送出去而不必等待接收端返回的确认回执，对按序到达的最后一个分组，接收端会向发送端发送确认回执，如果有分组没有正确到达，会返回最后一个正确达到的分组序号，该序号后面的分组会重新发送给接收端。</p><p>举个例子，窗口大小为4，发送时第1、2、4号分组均成功发送，3号分组发送失败，接收端会给发送端发送2号分组的确认回执，然后发送端会把2号分组之后的数据（3号分组和4号分组）重新再发送一遍，即使4号分组是发送成功的。</p><p>在连续ARQ协议中，发送端会维护一块发送端的数据缓存，“窗口”里的分组都会在这个缓存中，当需要重新发送“窗口”中的分组报文时，便会从缓存里读取分组并发送。</p><p>连续 ARQ 协议可提高信道利用率。</p><h3 id="（9）说一下TCP的流量控制？"><a href="#（9）说一下TCP的流量控制？" class="headerlink" title="（9）说一下TCP的流量控制？"></a>（9）说一下TCP的流量控制？</h3><p>流量控制是为了控制发送端发送数据的速率，保证接收端能将本应接收的所有报文分组接收成功，否则会触发自动重传机制造成网络流量的浪费。</p><p>流量控制的具体操作是：接收端会通知发送端自己能接收的数据大小，于是发送端会发送不超过这个数据量的数据，这个大小被称为“窗口”的大小，在TCP首部中专门有一个字段表示“窗口”的大小，该值越大代表网络的吞吐量越高。</p><h3 id="（10）说一下TCP的拥塞控制？"><a href="#（10）说一下TCP的拥塞控制？" class="headerlink" title="（10）说一下TCP的拥塞控制？"></a>（10）说一下TCP的拥塞控制？</h3><p>计算机网络都处在一个共享的环境，在通信开始时如果立即把大量数据注入到网络，可能会引起网络阻塞，甚至带来网络瘫痪。TCP为了防止该问题的出现，采用了拥塞控制的策略，常见的拥塞控制策略有慢启动、拥塞避免、快重传与快恢复，这里以慢启动为例做简单介绍。</p><p>在通信开始时，定义一个“拥塞窗口”，窗口大小为1，意思是开始时只发送一个分组，之后每收到一个确认回执（ACK），拥塞窗口的大小就加1（即逐渐增大窗口大小），发送端在发送数据时，将拥塞窗口的大小与接收端流量控制窗口的大小作比较，取二者中较小的值，然后实际发送的数据量比这个最小值还要小。</p><h3 id="（11）什么是TCP粘包？"><a href="#（11）什么是TCP粘包？" class="headerlink" title="（11）什么是TCP粘包？"></a>（11）什么是TCP粘包？</h3><p>如果客户端连续不断的向服务端发送数据包时，服务端接收的数据会出现两个数据包粘在一起的情况。</p><p>\1. TCP 是基于字节流的，虽然应用层和 TCP 传输层之间的数据交互是大小不等的数据块，但是 TCP 把这些数据块仅仅看成一连串无结构的字节流，没有边界；</p><p>\2. 从 TCP 的帧结构也可以看出，在 TCP 的首部没有表示数据长度的字段。</p><p>基于上面两点，在使用 TCP 传输数据时，才有粘包或者拆包现象发生的可能。一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。</p><h3 id="（12）粘包是如何产生的？"><a href="#（12）粘包是如何产生的？" class="headerlink" title="（12）粘包是如何产生的？"></a>（12）粘包是如何产生的？</h3><p>（1）发送方产生粘包</p><p>采用 TCP 协议传输数据的客户端与服务器经常是保持一个长连接的状态（一次连接发一次数据不存在粘包），双方在连接不断开的情况下，可以一直传输数据。但当发送的数据包过于的小时，那么 TCP 协议默认的会启用 Nagle 算法，将这些较小的数据包进行合并发送（缓冲区数据发送是一个堆压的过程）；这个合并过程就是在发送缓冲区中进行的，也就是说数据发送出来它已经是粘包的状态了。</p><p>一句话：要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包。</p><p>（2）接收方产生粘包</p><p>接收方采用 TCP 协议接收数据时的过程是这样的：数据到接收方，从网络模型的下方传递至传输层，传输层的 TCP 协议处理是将其放置接收缓冲区，然后由应用层来主动获取（C 语言用 recv、read 等函数）；这时会出现一个问题，就是我们在程序中调用的读取数据函数不能及时的把缓冲区中的数据拿出来，而下一个数据又到来并有一部分放入的缓冲区末尾，等我们读取数据时就是一个粘包。（放数据的速度 &gt; 应用层拿数据速度）。</p><p>一句话：接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。</p><h3 id="（13）如何避免粘包？"><a href="#（13）如何避免粘包？" class="headerlink" title="（13）如何避免粘包？"></a>（13）如何避免粘包？</h3><p>有以下两个措施：</p><ul><li>在每个包的末尾加上特殊字符，用以区分连续的两个包；</li><li>在报文首部添加包的长度。</li></ul><h1 id="2、http"><a href="#2、http" class="headerlink" title="2、http"></a>2、http</h1><h3 id="（1）什么是http协议？http和https的区别？"><a href="#（1）什么是http协议？http和https的区别？" class="headerlink" title="（1）什么是http协议？http和https的区别？"></a>（1）什么是http协议？http和https的区别？</h3><p>http协议是应用层的协议，中文名称是超文本传输协议，是客户端和服务端相互通信时将信息以http报文的形式传输。</p><p>https可以简单的理解为：https &#x3D; http + 加密 + 认证 + 完整性保护。</p><p>http协议的缺点:</p><ol><li>通信使用明文，内容可能被窃听。</li><li>通信双方的身份无法得到认证，身份可能遭遇伪装。</li><li>无法验证报文的完整性。</li></ol><p>针对以上问题，https的改进措施:</p><ol><li>加密。https协议通过SSL或者TLS协议将报文内容进行加密，client端进行加密，server端进行解密。</li><li>认证。通过值得信赖的第三方机构颁布证书，即可确认通信双方的身份。客户端持有证书即可完成客户端身份的确认，客户端通信前会查看服务端的证书。</li><li>完整性保护。可以通过MD5等散列码进行通信内容的校验。</li></ol><h3 id="（2）为什么说http协议是无状态协议？怎么解决Http协议无状态协议"><a href="#（2）为什么说http协议是无状态协议？怎么解决Http协议无状态协议" class="headerlink" title="（2）为什么说http协议是无状态协议？怎么解决Http协议无状态协议?"></a>（2）为什么说http协议是无状态协议？怎么解决Http协议无状态协议?</h3><p>http协议是一种无状态协议，协议自身不对请求和响应之间的通信状态进行保存，即对发送过来的请求和响应都不做持久化处理，把http协议设计的如此简单是为了更快地处理大量事务。</p><p>为了解决http协议不能保存通信状态的问题，引入了Cookie状态管理。Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。Cookie会根据从服务端发送的响应报文的一个叫Set-Cookie的首部字段，通知客户端保存Cookie。当下次客户端再往该服务端发送请求时，客户端会自动在请求报文中加入Cookie值发送出去，服务端发现客户端发来的Cookie后，会检查是哪一个客户端发来的连接请求，对比服务器上的记录，最后得到之前的状态信息。</p><h3 id="（3）URI和URL的区别"><a href="#（3）URI和URL的区别" class="headerlink" title="（3）URI和URL的区别?"></a>（3）URI和URL的区别?</h3><p>URI: Uniform Resource Identifier，统一资源标识符，用来唯一标识互联网中的一份资源。</p><p>URL: Uniform Resource Locator，统一资源定位符，我们访问网站的网址就是URL。</p><p>URL是URI的子集。</p><p>URI的目的就是唯一标识互联网中的一份资源，具体可以用资源名称、资源地址等，但是资源地址是目前使用最广泛的，因此URL就容易和URI混淆。URI相当于抽象类，URL就是这个抽象类的具体实现类。</p><h3 id="（4）常见的http动词有哪些？"><a href="#（4）常见的http动词有哪些？" class="headerlink" title="（4）常见的http动词有哪些？"></a>（4）常见的http动词有哪些？</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">GET: 从服务器获取资源</span><br><span class="line">POST: 在服务器新建资源</span><br><span class="line">PUT: 在服务器更新资源</span><br><span class="line">DELETE: 在服务器删除资源</span><br><span class="line">HEAD: 获取资源的元数据</span><br><span class="line">OPTIONAL: 查询对指定的资源支持的方法</span><br></pre></td></tr></table></figure><h3 id="（5）put和post的区别？"><a href="#（5）put和post的区别？" class="headerlink" title="（5）put和post的区别？"></a>（5）put和post的区别？</h3><p>put是幂等的，post不是。</p><p>幂等是数学的一个用语，对于单个输入或者无输入的运算方法，如果每次都是同样的结果，则称其是幂等的。也就是说，如果一个网络重复执行多次，产生的效果是一样的，那就是幂等（idempotent）。</p><p>post在发请求的时候，服务器会每次都创建一个文件，而put发请求的时候，是更新文件而不是创建文件，因此put是幂等的。</p><h3 id="（6）http请求报文和响应报文的组成？"><a href="#（6）http请求报文和响应报文的组成？" class="headerlink" title="（6）http请求报文和响应报文的组成？"></a>（6）http请求报文和响应报文的组成？</h3><p>http协议全称是HyperTest Transfer Protocol，超文本传输协议。</p><p>http报文说白了就是client和server通信时依据http协议，将传输的信息以文本的形式呈现，这个文本就是http报文。http报文分为请求报文和消息报文，这两类报文有着相同的结构组成，如图：</p><p><img src="https://pic2.zhimg.com/80/v2-c33de43cb8ec51af31ba034ec2b05d91_720w.webp" alt="img"></p><p>http报文组成</p><p>网上有很多如何在浏览器上查看http报文的，我这里举个例子，方便理解。</p><p><strong>http请求报文：</strong></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/v2-5363573a7ecc660173ae165251709346_720w.webp" alt="img"></p><p>http请求报文</p><p><strong>http响应报文：</strong></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/v2-236226d376885574b63151bb072bccdd_720w.webp" alt="img"></p><p>http响应报文</p><p>图中没有显示空行和报文主体。</p><p>下面大致讲一下这四部分：</p><p><strong>请求行&#x2F;响应行</strong></p><p>请求行由http动词，请求uri和http版本组成，主要是反应这次请求要对什么资源做什么操作</p><p>响应行由http返回码，原因短语和http版本组成，呈现的服务端对这次请求的处理结果，我们通过响应行的信息能知道这次请求是否成功，bug出在client端还是server端，原因是什么。</p><p><strong>首部字段</strong></p><p>首部字段又叫头域（header），相当于http报文的元数据，记录了这次http报文的具体描述信息，比如时间、服务端域名等。</p><p><strong>空行</strong></p><p>用来区分首部字段和报文主体。</p><p><strong>报文主体</strong></p><p>报文主体并不是每个报文都有的，要看具体的报文是要做什么，比如列举桶的返回报文里，报文主体会把桶列表以xml格式返回，但是列举桶的请求报文主体什么都不包含。报文主体返回的格式一般是xml或者json格式。</p><h3 id="（7）常见的http返回码有哪些？"><a href="#（7）常见的http返回码有哪些？" class="headerlink" title="（7）常见的http返回码有哪些？"></a>（7）常见的http返回码有哪些？</h3><ul><li>200：请求被正常处理</li><li>204：请求被受理但没有资源可以返回</li><li>206：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。</li><li>301：永久性重定向</li><li>302：临时重定向</li><li>303：与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上</li><li>304：发送附带条件的请求时，条件不满足时返回，与重定向无关</li><li>307：临时重定向，与302类似，只是强制要求使用POST方法</li><li>400：请求报文语法有误，服务器无法识别</li><li>401：请求需要认证</li><li>403：请求的对应资源禁止被访问</li><li>404：服务器无法找到对应资源</li><li>500：服务器内部错误</li><li>503：服务器正忙</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕设-知识图谱</title>
      <link href="/FRank675.github.io/posts/3d9e214a9050/"/>
      <url>/FRank675.github.io/posts/3d9e214a9050/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p> <img src="/%E6%AF%95%E8%AE%BE-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1.assets/adee1c68c8051e0b802b0d24e96df45a.png" alt="img"> </p>]]></content>
      
      
      <categories>
          
          <category> 知识图谱 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 毕设,知识图谱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日常小确幸记录</title>
      <link href="/FRank675.github.io/posts/1e3575b0dcca/"/>
      <url>/FRank675.github.io/posts/1e3575b0dcca/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="2023-1-23"><a href="#2023-1-23" class="headerlink" title="2023.1.23"></a>2023.1.23</h2><p>今天刷题看到了一些有趣的评论^_^</p><p><img src="/%E6%97%A5%E5%B8%B8%E7%82%B9%E6%BB%B4.assets/1674463375977.png" alt="1674463375977"></p><p><img src="/%E6%97%A5%E5%B8%B8%E7%82%B9%E6%BB%B4.assets/1674463442949.png" alt="1674463442949"></p><p>然后一年后有人评论</p><p><img src="/%E6%97%A5%E5%B8%B8%E7%82%B9%E6%BB%B4.assets/1674463413620.png" alt="1674463413620"></p><p>然后我好像得研究一下网站的图床咋搞</p>]]></content>
      
      
      <categories>
          
          <category> 小确幸 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题记录</title>
      <link href="/FRank675.github.io/posts/8cc09a6c47db/"/>
      <url>/FRank675.github.io/posts/8cc09a6c47db/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="主要记录LEETCODE刷题的感想和总结"><a href="#主要记录LEETCODE刷题的感想和总结" class="headerlink" title="主要记录LEETCODE刷题的感想和总结~"></a>主要记录LEETCODE刷题的感想和总结~</h1><h2 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a><a href="https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">剑指 Offer 09. 用两个栈实现队列</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -<span class="number">1</span> )</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line">输入：</span><br><span class="line">[<span class="string">&quot;CQueue&quot;</span>,<span class="string">&quot;appendTail&quot;</span>,<span class="string">&quot;deleteHead&quot;</span>,<span class="string">&quot;deleteHead&quot;</span>,<span class="string">&quot;deleteHead&quot;</span>]</span><br><span class="line">[[],[<span class="number">3</span>],[],[],[]]</span><br><span class="line">输出：[null,null,<span class="number">3</span>,-<span class="number">1</span>,-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[<span class="string">&quot;CQueue&quot;</span>,<span class="string">&quot;deleteHead&quot;</span>,<span class="string">&quot;appendTail&quot;</span>,<span class="string">&quot;appendTail&quot;</span>,<span class="string">&quot;deleteHead&quot;</span>,<span class="string">&quot;deleteHead&quot;</span>]</span><br><span class="line">[[],[],[<span class="number">5</span>],[<span class="number">2</span>],[],[]]</span><br><span class="line">输出：[null,-<span class="number">1</span>,null,null,<span class="number">5</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">###思路分析：使用双栈实现队列，队列要求先进先出，所以一个栈用于进，另一个栈倒置用于出，在python中可以使用append()方法添加元素，使用pop()弹出元素</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CQueue</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment">#初始化双栈</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.stack1 = []</span><br><span class="line">        self.stack2 = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#添加元素，在第一个栈中添加元素</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">appendTail</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type value: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.stack1.append(value)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除最先进去的元素</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteHead</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment">#当第二个栈不为空，则可以直接弹出</span></span><br><span class="line">        <span class="comment">#否则需要将第一个栈中的元素弹入第二个栈</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.stack2) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(self.stack1) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            <span class="comment">#将第一个栈中的元素全部弹出装入第二个栈中</span></span><br><span class="line">            <span class="comment">#达到的效果就是第一个栈最先进去的元素在第二个栈的顶部</span></span><br><span class="line">            <span class="keyword">while</span> self.stack1:</span><br><span class="line">                self.stack2.append(self.stack1.pop())</span><br><span class="line">        <span class="comment">#第二个栈顶端的元素就是队列删除的最先进去的元素</span></span><br><span class="line">        <span class="keyword">return</span> self.stack2.pop()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = CQueue()</span></span><br><span class="line"><span class="comment"># obj.appendTail(value)</span></span><br><span class="line"><span class="comment"># param_2 = obj.deleteHead()</span></span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-30-包含min函数的栈"><a href="#剑指-Offer-30-包含min函数的栈" class="headerlink" title="剑指 Offer 30. 包含min函数的栈"></a><a href="https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/">剑指 Offer 30. 包含min函数的栈</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 <span class="built_in">min</span> 函数在该栈中，调用 <span class="built_in">min</span>、push 及 pop 的时间复杂度都是 O(<span class="number">1</span>)。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-<span class="number">2</span>);</span><br><span class="line">minStack.push(<span class="number">0</span>);</span><br><span class="line">minStack.push(-<span class="number">3</span>);</span><br><span class="line">minStack.<span class="built_in">min</span>();   --&gt; 返回 -<span class="number">3.</span></span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 <span class="number">0.</span></span><br><span class="line">minStack.<span class="built_in">min</span>();   --&gt; 返回 -<span class="number">2.</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">各函数的调用总次数不超过 <span class="number">20000</span> 次</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment">#初始化两个栈，一个栈正常存储，另一个栈存储最小值</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.minStack = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x</span>):<span class="number">2</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment">#第一个栈正常存储</span></span><br><span class="line">        self.stack.append(x)</span><br><span class="line">        <span class="comment">#第二个栈比较是否出现更小的值，如果出现，添加到最小栈</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.minStack <span class="keyword">or</span> x &lt;= self.minStack[-<span class="number">1</span>]:</span><br><span class="line">            self.minStack.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment">#第一个栈正常弹出，第二个栈比较是否弹出最小值，如果是，第二个栈也弹出</span></span><br><span class="line">        <span class="keyword">if</span> self.stack.pop() == self.minStack[-<span class="number">1</span>]:</span><br><span class="line">            self.minStack.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">min</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment">#最小值即最小栈最后一个值</span></span><br><span class="line">        <span class="keyword">return</span> self.minStack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MinStack()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.min()</span></span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-06-从尾到头打印链表"><a href="#剑指-Offer-06-从尾到头打印链表" class="headerlink" title="剑指 Offer 06. 从尾到头打印链表"></a><a href="https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">剑指 Offer 06. 从尾到头打印链表</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line">输入：head = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line"> </span><br><span class="line">限制：</span><br><span class="line"><span class="number">0</span> &lt;= 链表长度 &lt;= <span class="number">10000</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 递归法</span></span><br><span class="line"><span class="comment"># [1,2,3,4,5]</span></span><br><span class="line"><span class="comment"># [2,3,4,5]</span></span><br><span class="line"><span class="comment"># [3,4,5]</span></span><br><span class="line"><span class="comment"># [4,5]</span></span><br><span class="line"><span class="comment"># [5]</span></span><br><span class="line"><span class="comment"># []</span></span><br><span class="line"><span class="comment"># [5,4,3,2,1]</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reversePrint</span>(<span class="params">self, head</span>):</span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> self.reversePrint(head.<span class="built_in">next</span>) + [head.val]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 普通做法</span></span><br><span class="line"><span class="comment"># 遍历链表使用一个list存储链表</span></span><br><span class="line"><span class="comment"># 反转链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reversePrint</span>(<span class="params">self, head</span>):</span><br><span class="line">        resList = []</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            resList.append(head.val)</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> resList[::-<span class="number">1</span>]</span><br><span class="line"><span class="comment"># list的[]中有三个参数，用冒号分割</span></span><br><span class="line"><span class="comment"># list[param1:param2:param3]</span></span><br><span class="line"><span class="comment"># param1，相当于start_index，可以为空，默认是0</span></span><br><span class="line"><span class="comment"># param2，相当于end_index，可以为空，默认是list.size</span></span><br><span class="line"><span class="comment"># param3，步长，默认为1。步长为-1时，返回倒序原序列</span></span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-24-反转链表"><a href="#剑指-Offer-24-反转链表" class="headerlink" title="剑指 Offer 24. 反转链表"></a><a href="https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/">剑指 Offer 24. 反转链表</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL</span><br><span class="line">输出: <span class="number">5</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;NULL</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line"><span class="number">0</span> &lt;= 节点个数 &lt;= <span class="number">5000</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义指针 pre，cur 分别指向 null 和头节点。</span></span><br><span class="line"><span class="comment">#遍历链表，将 cur.next 临时保存到 t 中，然后改变指针 cur 指向的节点的指向，将其指向 pre 指针指向的节点，即 cur.next = pre。然后 pre 指针指向 cur，cur 指针往前走。</span></span><br><span class="line"><span class="comment">#当遍历结束后，返回 pre 指针即可。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        pre, cur = <span class="literal">None</span>, head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            t = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = t</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">请实现一个函数，把字符串 s 中的每个空格替换成<span class="string">&quot;%20&quot;</span>。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line">输入：s = <span class="string">&quot;We are happy.&quot;</span></span><br><span class="line">输出：<span class="string">&quot;We%20are%20happy.&quot;</span></span><br><span class="line"> </span><br><span class="line">限制：</span><br><span class="line"><span class="number">0</span> &lt;= s 的长度 &lt;= <span class="number">10000</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">replaceSpace</span>(<span class="params">self, s</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> s.replace(<span class="string">&quot; &quot;</span>,<span class="string">&quot;%20&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python replace()方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 描述</span></span><br><span class="line"><span class="comment"># Python replace() 方法把字符串中的 old（旧字符串） 替换成 new(新字符串)，如果指定第三个参数max，则替换不超过 max 次。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># replace()方法语法：</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span>.replace(old, new[, <span class="built_in">max</span>])</span><br><span class="line"><span class="comment"># 参数</span></span><br><span class="line"><span class="comment"># old -- 将被替换的子字符串。</span></span><br><span class="line"><span class="comment"># new -- 新字符串，用于替换old子字符串。</span></span><br><span class="line"><span class="comment"># max -- 可选字符串, 替换不超过 max 次</span></span><br><span class="line"><span class="comment"># 返回值</span></span><br><span class="line"><span class="comment"># 返回字符串中的 old（旧字符串） 替换成 new(新字符串)后生成的新字符串，如果指定第三个参数max，则替换不超过 max 次。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例</span></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;this is string example....wow!!! this is really string&quot;</span>;</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span>.replace(<span class="string">&quot;is&quot;</span>, <span class="string">&quot;was&quot;</span>);</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span>.replace(<span class="string">&quot;is&quot;</span>, <span class="string">&quot;was&quot;</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment"># 以上实例输出结果如下：</span></span><br><span class="line">thwas was string example....wow!!! thwas was really string</span><br><span class="line">thwas was string example....wow!!! thwas <span class="keyword">is</span> really string</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-58-II-左旋转字符串"><a href="#剑指-Offer-58-II-左旋转字符串" class="headerlink" title="剑指 Offer 58 - II. 左旋转字符串"></a><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">剑指 Offer 58 - II. 左旋转字符串</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串<span class="string">&quot;abcdefg&quot;</span>和数字<span class="number">2</span>，该函数将返回左旋转两位得到的结果<span class="string">&quot;cdefgab&quot;</span>。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line">输入: s = <span class="string">&quot;abcdefg&quot;</span>, k = <span class="number">2</span></span><br><span class="line">输出: <span class="string">&quot;cdefgab&quot;</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line">输入: s = <span class="string">&quot;lrloseumgh&quot;</span>, k = <span class="number">6</span></span><br><span class="line">输出: <span class="string">&quot;umghlrlose&quot;</span></span><br><span class="line"> </span><br><span class="line">限制：</span><br><span class="line"><span class="number">1</span> &lt;= k &lt; s.length &lt;= <span class="number">10000</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseLeftWords</span>(<span class="params">self, s, n</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> s[n:]+s[<span class="number">0</span>:n]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Python字符串运算符</span></span><br><span class="line"></span><br><span class="line">下表实例变量 a 值为字符串 <span class="string">&quot;Hello&quot;</span>，b 变量值为 <span class="string">&quot;Python&quot;</span>：</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">操作符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">+</td><td align="left">字符串连接</td><td align="left">&gt;&gt;&gt;a + b ‘HelloPython’</td></tr><tr><td align="left">*</td><td align="left">重复输出字符串</td><td align="left">&gt;&gt;&gt;a * 2 ‘HelloHello’</td></tr><tr><td align="left">[]</td><td align="left">通过索引获取字符串中字符</td><td align="left">&gt;&gt;&gt;a[1] ‘e’</td></tr><tr><td align="left">[ : ]</td><td align="left">截取字符串中的一部分</td><td align="left">&gt;&gt;&gt;a[1:4] ‘ell’</td></tr><tr><td align="left">in</td><td align="left">成员运算符 - 如果字符串中包含给定的字符返回 True</td><td align="left">&gt;&gt;&gt;”H” in a True</td></tr><tr><td align="left">not in</td><td align="left">成员运算符 - 如果字符串中不包含给定的字符返回 True</td><td align="left">&gt;&gt;&gt;”M” not in a True</td></tr><tr><td align="left">r&#x2F;R</td><td align="left">原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母”r”（可以大小写）以外，与普通字符串有着几乎完全相同的语法。</td><td align="left">&gt;&gt;&gt;print r’\n’ \n &gt;&gt;&gt; print R’\n’ \n</td></tr><tr><td align="left">%</td><td align="left">格式字符串</td><td align="left"></td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Python 的字符串内建函数</span></span><br><span class="line"></span><br><span class="line">字符串方法是从 Python1<span class="number">.6</span> 到 <span class="number">2.0</span> 慢慢加进来的 —— 它们也被加到了Jython 中。</span><br><span class="line"></span><br><span class="line">这些方法实现了 string 模块的大部分方法，如下表所示列出了目前字符串内建支持的方法，所有的方法都包含了对 Unicode 的支持，有一些甚至是专门用于 Unicode 的。</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">方法</th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left">string.capitalize()</td><td align="left">把字符串的第一个字符大写</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-center.html">string.center(width)</a></td><td align="left">返回一个原字符串居中,并使用空格填充至长度 width 的新字符串</td></tr><tr><td align="left">string.count(str, beg&#x3D;0, end&#x3D;len(string))</td><td align="left">返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-decode.html">string.decode(encoding&#x3D;’UTF-8’, errors&#x3D;’strict’)</a></td><td align="left">以 encoding 指定的编码格式解码 string，如果出错默认报一个 ValueError 的 异 常 ， 除非 errors 指 定 的 是 ‘ignore’ 或 者’replace’</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-encode.html">string.encode(encoding&#x3D;’UTF-8’, errors&#x3D;’strict’)</a></td><td align="left">以 encoding 指定的编码格式编码 string，如果出错默认报一个ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’</td></tr><tr><td align="left"><strong><a href="https://www.runoob.com/python/att-string-endswith.html">string.endswith(obj, beg&#x3D;0, end&#x3D;len(string))</a></strong></td><td align="left">检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False.</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-expandtabs.html">string.expandtabs(tabsize&#x3D;8)</a></td><td align="left">把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8。</td></tr><tr><td align="left"><strong><a href="https://www.runoob.com/python/att-string-find.html">string.find(str, beg&#x3D;0, end&#x3D;len(string))</a></strong></td><td align="left">检测 str 是否包含在 string 中，如果 beg 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回-1</td></tr><tr><td align="left"><strong><a href="https://www.runoob.com/python/att-string-format.html">string.format()</a></strong></td><td align="left">格式化字符串</td></tr><tr><td align="left"><strong><a href="https://www.runoob.com/python/att-string-index.html">string.index(str, beg&#x3D;0, end&#x3D;len(string))</a></strong></td><td align="left">跟find()方法一样，只不过如果str不在 string中会报一个异常.</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-isalnum.html">string.isalnum()</a></td><td align="left">如果 string 至少有一个字符并且所有字符都是字母或数字则返回 True,否则返回 False</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-isalpha.html">string.isalpha()</a></td><td align="left">如果 string 至少有一个字符并且所有字符都是字母则返回 True,否则返回 False</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-isdecimal.html">string.isdecimal()</a></td><td align="left">如果 string 只包含十进制数字则返回 True 否则返回 False.</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-isdigit.html">string.isdigit()</a></td><td align="left">如果 string 只包含数字则返回 True 否则返回 False.</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-islower.html">string.islower()</a></td><td align="left">如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-isnumeric.html">string.isnumeric()</a></td><td align="left">如果 string 中只包含数字字符，则返回 True，否则返回 False</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-isspace.html">string.isspace()</a></td><td align="left">如果 string 中只包含空格，则返回 True，否则返回 False.</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-istitle.html">string.istitle()</a></td><td align="left">如果 string 是标题化的(见 title())则返回 True，否则返回 False</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-isupper.html">string.isupper()</a></td><td align="left">如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False</td></tr><tr><td align="left"><strong><a href="https://www.runoob.com/python/att-string-join.html">string.join(seq)</a></strong></td><td align="left">以 string 作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-ljust.html">string.ljust(width)</a></td><td align="left">返回一个原字符串左对齐,并使用空格填充至长度 width 的新字符串</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-lower.html">string.lower()</a></td><td align="left">转换 string 中所有大写字符为小写.</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-lstrip.html">string.lstrip()</a></td><td align="left">截掉 string 左边的空格</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-maketrans.html">string.maketrans(intab, outtab)</a></td><td align="left">maketrans() 方法用于创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-max.html">max(str)</a></td><td align="left">返回字符串 <em>str</em> 中最大的字母。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-min.html">min(str)</a></td><td align="left">返回字符串 <em>str</em> 中最小的字母。</td></tr><tr><td align="left"><strong><a href="https://www.runoob.com/python/att-string-partition.html">string.partition(str)</a></strong></td><td align="left">有点像 find()和 split()的结合体,从 str 出现的第一个位置起,把 字 符 串 string 分 成 一 个 3 元 素 的 元 组 (string_pre_str,str,string_post_str),如果 string 中不包含str 则 string_pre_str &#x3D;&#x3D; string.</td></tr><tr><td align="left"><strong><a href="https://www.runoob.com/python/att-string-replace.html">string.replace(str1, str2, num&#x3D;string.count(str1))</a></strong></td><td align="left">把 string 中的 str1 替换成 str2,如果 num 指定，则替换不超过 num 次.</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-rfind.html">string.rfind(str, beg&#x3D;0,end&#x3D;len(string) )</a></td><td align="left">类似于 find() 函数，返回字符串最后一次出现的位置，如果没有匹配项则返回 -1。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-rindex.html">string.rindex( str, beg&#x3D;0,end&#x3D;len(string))</a></td><td align="left">类似于 index()，不过是返回最后一个匹配到的子字符串的索引号。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-rjust.html">string.rjust(width)</a></td><td align="left">返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-rpartition.html">string.rpartition(str)</a></td><td align="left">类似于 partition()函数,不过是从右边开始查找</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-rstrip.html">string.rstrip()</a></td><td align="left">删除 string 字符串末尾的空格.</td></tr><tr><td align="left"><strong><a href="https://www.runoob.com/python/att-string-split.html">string.split(str&#x3D;””, num&#x3D;string.count(str))</a></strong></td><td align="left">以 str 为分隔符切片 string，如果 num 有指定值，则仅分隔 <strong>num+1</strong> 个子字符串</td></tr><tr><td align="left">[string.splitlines(<a href="https://www.runoob.com/python/att-string-splitlines.html">keepends])</a></td><td align="left">按照行(‘\r’, ‘\r\n’, ‘\n’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-startswith.html">string.startswith(obj, beg&#x3D;0,end&#x3D;len(string))</a></td><td align="left">检查字符串是否是以 obj 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查.</td></tr><tr><td align="left">[string.strip(obj])</td><td align="left">在 string 上执行 lstrip()和 rstrip()</td></tr><tr><td align="left">string.swapcase()</td><td align="left">翻转 string 中的大小写</td></tr><tr><td align="left">string.title()</td><td align="left">返回”标题化”的 string,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle())</td></tr><tr><td align="left"><strong><a href="https://www.runoob.com/python/att-string-translate.html">string.translate(str, del&#x3D;””)</a></strong></td><td align="left">根据 str 给出的表(包含 256 个字符)转换 string 的字符,要过滤掉的字符放到 del 参数中</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-upper.html">string.upper()</a></td><td align="left">转换 string 中的小写字母为大写</td></tr><tr><td align="left">string.zfill(width)</td><td align="left">返回长度为 width 的字符串，原字符串 string 右对齐，前面填充0</td></tr></tbody></table><h2 id="剑指-Offer-03-数组中重复的数字"><a href="#剑指-Offer-03-数组中重复的数字" class="headerlink" title="剑指 Offer 03. 数组中重复的数字"></a><a href="https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">剑指 Offer 03. 数组中重复的数字</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">找出数组中重复的数字。</span><br><span class="line"></span><br><span class="line">在一个长度为 n 的数组 nums 里的所有数字都在 <span class="number">0</span>～n-<span class="number">1</span> 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line">输入：</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>]</span><br><span class="line">输出：<span class="number">2</span> 或 <span class="number">3</span> </span><br><span class="line"> </span><br><span class="line">限制：</span><br><span class="line"><span class="number">2</span> &lt;= n &lt;= <span class="number">100000</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 排序</span></span><br><span class="line"><span class="comment"># 先排序，将相同的数字聚集到一起。</span></span><br><span class="line"><span class="comment"># 再遍历，当位于 i 与 i + 1 的数字相等时，返回该数字。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findRepeatNumber</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        sorted_nums = <span class="built_in">sorted</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> sorted_nums[i] == sorted_nums[i+<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> sorted_nums[i]   </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 哈希表</span></span><br><span class="line"><span class="comment"># 记录数字在数组中的数量，当数量为 2 时，返回即可。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findRepeatNumber</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        sorted_nums = <span class="built_in">sorted</span>(nums)</span><br><span class="line">        hash_map = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> i, number <span class="keyword">in</span> <span class="built_in">enumerate</span>(sorted_nums):</span><br><span class="line">            <span class="keyword">if</span> number <span class="keyword">in</span> hash_map:</span><br><span class="line">                <span class="keyword">return</span> number</span><br><span class="line">            hash_map[number] = i</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Python <span class="built_in">enumerate</span>() 函数</span><br><span class="line"></span><br><span class="line">描述</span><br><span class="line"><span class="built_in">enumerate</span>() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 <span class="keyword">for</span> 循环当中。</span><br><span class="line"></span><br><span class="line">语法</span><br><span class="line">以下是 <span class="built_in">enumerate</span>() 方法的语法:</span><br><span class="line"></span><br><span class="line"><span class="built_in">enumerate</span>(sequence, [start=<span class="number">0</span>])</span><br><span class="line">参数</span><br><span class="line">sequence -- 一个序列、迭代器或其他支持迭代对象。</span><br><span class="line">start -- 下标起始位置的值。</span><br><span class="line">返回值</span><br><span class="line">返回 <span class="built_in">enumerate</span>(枚举) 对象。</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line">以下展示了使用 <span class="built_in">enumerate</span>() 方法的实例：</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>seasons = [<span class="string">&#x27;Spring&#x27;</span>, <span class="string">&#x27;Summer&#x27;</span>, <span class="string">&#x27;Fall&#x27;</span>, <span class="string">&#x27;Winter&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">enumerate</span>(seasons))</span><br><span class="line">[(<span class="number">0</span>, <span class="string">&#x27;Spring&#x27;</span>), (<span class="number">1</span>, <span class="string">&#x27;Summer&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;Fall&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;Winter&#x27;</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">enumerate</span>(seasons, start=<span class="number">1</span>))       <span class="comment"># 下标从 1 开始</span></span><br><span class="line">[(<span class="number">1</span>, <span class="string">&#x27;Spring&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;Summer&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;Fall&#x27;</span>), (<span class="number">4</span>, <span class="string">&#x27;Winter&#x27;</span>)]</span><br><span class="line"></span><br><span class="line">普通的 <span class="keyword">for</span> 循环</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>i = <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>seq = [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> element <span class="keyword">in</span> seq:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span> i, seq[i]</span><br><span class="line"><span class="meta">... </span>    i += <span class="number">1</span></span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> one</span><br><span class="line"><span class="number">1</span> two</span><br><span class="line"><span class="number">2</span> three</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> 循环使用 <span class="built_in">enumerate</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>seq = [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, element <span class="keyword">in</span> <span class="built_in">enumerate</span>(seq):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span> i, element</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> one</span><br><span class="line"><span class="number">1</span> two</span><br><span class="line"><span class="number">2</span> three</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Python <span class="built_in">sorted</span>() 函数</span><br><span class="line"></span><br><span class="line">描述</span><br><span class="line"><span class="built_in">sorted</span>() 函数对所有可迭代的对象进行排序操作。</span><br><span class="line"></span><br><span class="line">sort 与 <span class="built_in">sorted</span> 区别：</span><br><span class="line">sort 是应用在 <span class="built_in">list</span> 上的方法，<span class="built_in">sorted</span> 可以对所有可迭代的对象进行排序操作。</span><br><span class="line"><span class="built_in">list</span> 的 sort 方法返回的是对已经存在的列表进行操作，无返回值，而内建函数 <span class="built_in">sorted</span> 方法返回的是一个新的 <span class="built_in">list</span>，而不是在原来的基础上进行的操作，原列表不发生变化。</span><br><span class="line"></span><br><span class="line"><span class="built_in">sorted</span> 语法：</span><br><span class="line"><span class="built_in">sorted</span>(iterable, cmp=<span class="literal">None</span>, key=<span class="literal">None</span>, reverse=<span class="literal">False</span>)</span><br><span class="line">参数说明：</span><br><span class="line"></span><br><span class="line">iterable -- 可迭代对象。</span><br><span class="line">cmp -- 比较的函数，这个具有两个参数，参数的值都是从可迭代对象中取出，此函数必须遵守的规则为，大于则返回<span class="number">1</span>，小于则返回-<span class="number">1</span>，等于则返回<span class="number">0</span>。</span><br><span class="line">key -- 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。</span><br><span class="line">reverse -- 排序规则，reverse = <span class="literal">True</span> 降序 ， reverse = <span class="literal">False</span> 升序（默认）。</span><br><span class="line"></span><br><span class="line">返回值</span><br><span class="line">返回重新排序的列表。</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-53-I-在排序数组中查找数字-I"><a href="#剑指-Offer-53-I-在排序数组中查找数字-I" class="headerlink" title="剑指 Offer 53 - I. 在排序数组中查找数字 I"></a><a href="https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">剑指 Offer 53 - I. 在排序数组中查找数字 I</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">统计一个数字在排序数组中出现的次数。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: nums = [<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">10</span>], target = <span class="number">8</span></span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: nums = [<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">10</span>], target = <span class="number">6</span></span><br><span class="line">输出: <span class="number">0</span></span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line"><span class="number">0</span> &lt;= nums.length &lt;= <span class="number">105</span></span><br><span class="line">-<span class="number">109</span> &lt;= nums[i] &lt;= <span class="number">109</span></span><br><span class="line">nums 是一个非递减数组</span><br><span class="line">-<span class="number">109</span> &lt;= target &lt;= <span class="number">109</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-53-II-0～n-1中缺失的数字"><a href="#剑指-Offer-53-II-0～n-1中缺失的数字" class="headerlink" title="剑指 Offer 53 - II. 0～n-1中缺失的数字"></a><a href="https://leetcode.cn/problems/que-shi-de-shu-zi-lcof/">剑指 Offer 53 - II. 0～n-1中缺失的数字</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">一个长度为n-<span class="number">1</span>的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围<span class="number">0</span>～n-<span class="number">1</span>之内。在范围<span class="number">0</span>～n-<span class="number">1</span>内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line">输出: <span class="number">8</span></span><br><span class="line"> </span><br><span class="line">限制：</span><br><span class="line"><span class="number">1</span> &lt;= 数组长度 &lt;= <span class="number">10000</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python</title>
      <link href="/FRank675.github.io/posts/290bdd6d9133/"/>
      <url>/FRank675.github.io/posts/290bdd6d9133/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><p>变量是存储在内存中的值，这就意味着在创建变量时会在内存中开辟一个空间。</p><p>基于变量的数据类型，解释器会分配指定内存，并决定什么数据可以被存储在内存中。</p><p>因此，变量可以指定不同的数据类型，这些变量可以存储整数，小数或字符。</p><h3 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h3><p>Python 中的变量赋值不需要类型声明。</p><p>每个变量在内存中创建，都包括变量的标识，名称和数据这些信息。</p><p>每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。</p><p>等号 <strong>&#x3D;</strong> 用来给变量赋值。</p><p>等号 <strong>&#x3D;</strong> 运算符左边是一个变量名，等号 <strong>&#x3D;</strong> 运算符右边是存储在变量中的值。例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line">counter = <span class="number">100</span> <span class="comment"># 赋值整型变量</span></span><br><span class="line">miles = <span class="number">1000.0</span> <span class="comment"># 浮点型</span></span><br><span class="line">name = <span class="string">&quot;John&quot;</span> <span class="comment"># 字符串</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> counter</span><br><span class="line"><span class="built_in">print</span> miles</span><br><span class="line"><span class="built_in">print</span> name</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100</span><br><span class="line">1000.0</span><br><span class="line">John</span><br></pre></td></tr></table></figure><h3 id="多个变量赋值"><a href="#多个变量赋值" class="headerlink" title="多个变量赋值"></a>多个变量赋值</h3><p>Python允许你同时为多个变量赋值。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = b = c = 1</span><br></pre></td></tr></table></figure><p>以上实例，创建一个整型对象，值为1，三个变量被分配到相同的内存空间上。</p><p>您也可以为多个对象指定多个变量。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a, b, c = 1, 2, &quot;john&quot;</span><br></pre></td></tr></table></figure><p>以上实例，两个整型对象 1 和 2 分别分配给变量 a 和 b，字符串对象 “john” 分配给变量 c。</p><h3 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h3><p>Python 定义了一些标准类型，用于存储各种类型的数据。</p><p>Python有五个标准的数据类型：</p><ul><li>Numbers（数字）</li><li>String（字符串）</li><li>List（列表）</li><li>Tuple（元组）</li><li>Dictionary（字典）</li></ul><h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><p>数字数据类型用于存储数值。</p><p>他们是不可改变的数据类型，这意味着改变数字数据类型会分配一个新的对象。</p><p>当你指定一个值时，Number 对象就会被创建：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var1 = 1</span><br><span class="line">var2 = 10</span><br></pre></td></tr></table></figure><p>您也可以使用del语句删除一些对象的引用。</p><p>del语句的语法是：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">del var1[,var2[,var3[....,varN]]]</span><br></pre></td></tr></table></figure><p>您可以通过使用del语句删除单个或多个对象的引用。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">del var</span><br><span class="line">del var_a, var_b</span><br></pre></td></tr></table></figure><p>Python支持四种不同的数字类型：</p><ul><li>int（有符号整型）</li><li>long（长整型，也可以代表八进制和十六进制）</li><li>float（浮点型）</li><li>complex（复数）</li></ul><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串或串(String)是由数字、字母、下划线组成的一串字符。</p><p>一般记为 :</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s = &quot;a1a2···an&quot;   # n&gt;=0</span><br></pre></td></tr></table></figure><p>它是编程语言中表示文本的数据类型。</p><p>python的字串列表有2种取值顺序:</p><ul><li>从左到右索引默认0开始的，最大范围是字符串长度少1</li><li>从右到左索引默认-1开始的，最大范围是字符串开头</li></ul><p><img src="/Python.assets/python-string-slice.png" alt="img"></p><p>如果你要实现从字符串中获取一段子字符串的话，可以使用 <strong>[头下标:尾下标]</strong> 来截取相应的字符串，其中下标是从 0 开始算起，可以是正数或负数，下标可以为空表示取到头或尾。</p><p><strong>[头下标:尾下标]</strong> 获取的子字符串包含头下标的字符，但不包含尾下标的字符。</p><p>比如:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; s = &#x27;abcdef&#x27;</span><br><span class="line">&gt;&gt;&gt; s[1:5]</span><br><span class="line">&#x27;bcde&#x27;</span><br></pre></td></tr></table></figure><p>当使用以冒号分隔的字符串，python 返回一个新的对象，结果包含了以这对偏移标识的连续的内容，左边的开始是包含了下边界。</p><p>上面的结果包含了 <strong>s[1]</strong> 的值 b，而取到的最大范围不包括<strong>尾下标</strong>，就是 <strong>s[5]</strong> 的值 f。</p><p><img src="https://www.runoob.com/wp-content/uploads/2013/11/o99aU.png" alt="img"></p><p>加号（+）是字符串连接运算符，星号（*）是重复操作。如下实例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span>           <span class="comment"># 输出完整字符串</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span>[<span class="number">0</span>]        <span class="comment"># 输出字符串中的第一个字符</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span>[<span class="number">2</span>:<span class="number">5</span>]      <span class="comment"># 输出字符串中第三个至第六个之间的字符串</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span>[<span class="number">2</span>:]       <span class="comment"># 输出从第三个字符开始的字符串</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span> * <span class="number">2</span>       <span class="comment"># 输出字符串两次</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span> + <span class="string">&quot;TEST&quot;</span>  <span class="comment"># 输出连接的字符串</span></span><br></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello World!</span><br><span class="line">H</span><br><span class="line">llo</span><br><span class="line">llo World!</span><br><span class="line">Hello World!Hello World!</span><br><span class="line">Hello World!TEST</span><br></pre></td></tr></table></figure><p>Python 列表截取可以接收第三个参数，参数作用是截取的步长，以下实例在索引 1 到索引 4 的位置并设置为步长为 2（间隔一个位置）来截取字符串：</p><p><img src="/Python.assets/python_list_slice_2.png" alt="img"></p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>List（列表） 是 Python 中使用最频繁的数据类型。</p><p>列表可以完成大多数集合类的数据结构实现。它支持字符，数字，字符串甚至可以包含列表（即嵌套）。</p><p>列表用 <strong>[ ]</strong> 标识，是 python 最通用的复合数据类型。</p><p>列表中值的切割也可以用到变量 <strong>[头下标:尾下标]</strong> ，就可以截取相应的列表，从左到右索引默认 0 开始，从右到左索引默认 -1 开始，下标可以为空表示取到头或尾。</p><p><img src="/Python.assets/list_slicing1_new1.png" alt="img"></p><p>加号 <strong>+</strong> 是列表连接运算符，星号 ***** 是重复操作。如下实例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">list</span> = [ <span class="string">&#x27;runoob&#x27;</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">&#x27;john&#x27;</span>, <span class="number">70.2</span> ]</span><br><span class="line">tinylist = [<span class="number">123</span>, <span class="string">&#x27;john&#x27;</span>]</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> <span class="built_in">list</span>               <span class="comment"># 输出完整列表</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">list</span>[<span class="number">0</span>]            <span class="comment"># 输出列表的第一个元素</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">list</span>[<span class="number">1</span>:<span class="number">3</span>]          <span class="comment"># 输出第二个至第三个元素 </span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">list</span>[<span class="number">2</span>:]           <span class="comment"># 输出从第三个开始至列表末尾的所有元素</span></span><br><span class="line"><span class="built_in">print</span> tinylist * <span class="number">2</span>       <span class="comment"># 输出列表两次</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">list</span> + tinylist    <span class="comment"># 打印组合的列表</span></span><br></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;runoob&#x27;, 786, 2.23, &#x27;john&#x27;, 70.2]</span><br><span class="line">runoob</span><br><span class="line">[786, 2.23]</span><br><span class="line">[2.23, &#x27;john&#x27;, 70.2]</span><br><span class="line">[123, &#x27;john&#x27;, 123, &#x27;john&#x27;]</span><br><span class="line">[&#x27;runoob&#x27;, 786, 2.23, &#x27;john&#x27;, 70.2, 123, &#x27;john&#x27;]</span><br></pre></td></tr></table></figure><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>元组是另一个数据类型，类似于 List（列表）。</p><p>元组用 <strong>()</strong> 标识。内部元素用逗号隔开。但是元组不能二次赋值，相当于只读列表。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">tuple</span> = ( <span class="string">&#x27;runoob&#x27;</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">&#x27;john&#x27;</span>, <span class="number">70.2</span> )</span><br><span class="line">tinytuple = (<span class="number">123</span>, <span class="string">&#x27;john&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> <span class="built_in">tuple</span>               <span class="comment"># 输出完整元组</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">tuple</span>[<span class="number">0</span>]            <span class="comment"># 输出元组的第一个元素</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">tuple</span>[<span class="number">1</span>:<span class="number">3</span>]          <span class="comment"># 输出第二个至第四个（不包含）的元素 </span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">tuple</span>[<span class="number">2</span>:]           <span class="comment"># 输出从第三个开始至列表末尾的所有元素</span></span><br><span class="line"><span class="built_in">print</span> tinytuple * <span class="number">2</span>       <span class="comment"># 输出元组两次</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">tuple</span> + tinytuple   <span class="comment"># 打印组合的元组</span></span><br></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(&#x27;runoob&#x27;, 786, 2.23, &#x27;john&#x27;, 70.2)</span><br><span class="line">runoob</span><br><span class="line">(786, 2.23)</span><br><span class="line">(2.23, &#x27;john&#x27;, 70.2)</span><br><span class="line">(123, &#x27;john&#x27;, 123, &#x27;john&#x27;)</span><br><span class="line">(&#x27;runoob&#x27;, 786, 2.23, &#x27;john&#x27;, 70.2, 123, &#x27;john&#x27;)</span><br></pre></td></tr></table></figure><p>以下对元组的操作是无效的，因为元组不允许更新，而列表是允许更新的：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">tuple</span> = ( <span class="string">&#x27;runoob&#x27;</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">&#x27;john&#x27;</span>, <span class="number">70.2</span> )</span><br><span class="line"><span class="built_in">list</span> = [ <span class="string">&#x27;runoob&#x27;</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">&#x27;john&#x27;</span>, <span class="number">70.2</span> ]</span><br><span class="line"><span class="built_in">tuple</span>[<span class="number">2</span>] = <span class="number">1000</span>    <span class="comment"># 元组中是非法应用</span></span><br><span class="line"><span class="built_in">list</span>[<span class="number">2</span>] = <span class="number">1000</span>     <span class="comment"># 列表中是合法应用</span></span><br></pre></td></tr></table></figure><p>元组是不允许更新的，所以以上代码执行错误，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;test.py&quot;, line 6, in &lt;module&gt;</span><br><span class="line">    tuple[2] = 1000    # 元组中是非法应用</span><br><span class="line">TypeError: &#x27;tuple&#x27; object does not support item assignment</span><br></pre></td></tr></table></figure><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>字典(dictionary)是除列表以外python之中最灵活的内置数据结构类型。列表是有序的对象集合，字典是无序的对象集合。</p><p>两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。</p><p>字典用”{ }”标识。字典由索引(key)和它对应的值value组成。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">dict</span> = &#123;&#125;</span><br><span class="line"><span class="built_in">dict</span>[<span class="string">&#x27;one&#x27;</span>] = <span class="string">&quot;This is one&quot;</span></span><br><span class="line"><span class="built_in">dict</span>[<span class="number">2</span>] = <span class="string">&quot;This is two&quot;</span></span><br><span class="line"> </span><br><span class="line">tinydict = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;runoob&#x27;</span>,<span class="string">&#x27;code&#x27;</span>:<span class="number">6734</span>, <span class="string">&#x27;dept&#x27;</span>: <span class="string">&#x27;sales&#x27;</span>&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> <span class="built_in">dict</span>[<span class="string">&#x27;one&#x27;</span>]          <span class="comment"># 输出键为&#x27;one&#x27; 的值</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">dict</span>[<span class="number">2</span>]              <span class="comment"># 输出键为 2 的值</span></span><br><span class="line"><span class="built_in">print</span> tinydict             <span class="comment"># 输出完整的字典</span></span><br><span class="line"><span class="built_in">print</span> tinydict.keys()      <span class="comment"># 输出所有键</span></span><br><span class="line"><span class="built_in">print</span> tinydict.values()    <span class="comment"># 输出所有值</span></span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This is one</span><br><span class="line">This is two</span><br><span class="line">&#123;&#x27;dept&#x27;: &#x27;sales&#x27;, &#x27;code&#x27;: 6734, &#x27;name&#x27;: &#x27;runoob&#x27;&#125;</span><br><span class="line">[&#x27;dept&#x27;, &#x27;code&#x27;, &#x27;name&#x27;]</span><br><span class="line">[&#x27;sales&#x27;, 6734, &#x27;runoob&#x27;]</span><br></pre></td></tr></table></figure><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><p>有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。</p><p>以下几个内置的函数可以执行数据类型之间的转换。这些函数返回一个新的对象，表示转换的值。</p><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">[int(x [,base])</td><td align="left">将x转换为一个整数</td></tr><tr><td align="left">[long(x [,base] )</td><td align="left">将x转换为一个长整数</td></tr><tr><td align="left">[float(x)]</td><td align="left">将x转换到一个浮点数</td></tr><tr><td align="left">[complex(real [,imag])]</td><td align="left">创建一个复数</td></tr><tr><td align="left">[str(x)]</td><td align="left">将对象 x 转换为字符串</td></tr><tr><td align="left">[repr(x)]</td><td align="left">将对象 x 转换为表达式字符串</td></tr><tr><td align="left">[eval(str)]</td><td align="left">用来计算在字符串中的有效Python表达式,并返回一个对象</td></tr><tr><td align="left">[tuple(s)]</td><td align="left">将序列 s 转换为一个元组</td></tr><tr><td align="left">[list(s)]</td><td align="left">将序列 s 转换为一个列表</td></tr><tr><td align="left">[set(s)]</td><td align="left">转换为可变集合</td></tr><tr><td align="left">[dict(d)]</td><td align="left">创建一个字典。d 必须是一个序列 (key,value)元组。</td></tr><tr><td align="left">[frozenset(s)]</td><td align="left">转换为不可变集合</td></tr><tr><td align="left">[chr(x)]</td><td align="left">将一个整数转换为一个字符</td></tr><tr><td align="left">[unichr(x)]</td><td align="left">将一个整数转换为Unicode字符</td></tr><tr><td align="left">[ord(x)]</td><td align="left">将一个字符转换为它的整数值</td></tr><tr><td align="left">[hex(x)]</td><td align="left">将一个整数转换为一个十六进制字符串</td></tr><tr><td align="left">[oct(x)]</td><td align="left">将一个整数转换为一个八进制字符串</td></tr></tbody></table><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">&#x3D;</td><td align="left">简单的赋值运算符</td><td align="left">c &#x3D; a + b 将 a + b 的运算结果赋值为 c</td></tr><tr><td align="left">+&#x3D;</td><td align="left">加法赋值运算符</td><td align="left">c +&#x3D; a 等效于 c &#x3D; c + a</td></tr><tr><td align="left">-&#x3D;</td><td align="left">减法赋值运算符</td><td align="left">c -&#x3D; a 等效于 c &#x3D; c - a</td></tr><tr><td align="left">*&#x3D;</td><td align="left">乘法赋值运算符</td><td align="left">c *&#x3D; a 等效于 c &#x3D; c * a</td></tr><tr><td align="left">&#x2F;&#x3D;</td><td align="left">除法赋值运算符</td><td align="left">c &#x2F;&#x3D; a 等效于 c &#x3D; c &#x2F; a</td></tr><tr><td align="left">%&#x3D;</td><td align="left">取模赋值运算符</td><td align="left">c %&#x3D; a 等效于 c &#x3D; c % a</td></tr><tr><td align="left">**&#x3D;</td><td align="left">幂赋值运算符</td><td align="left">c **&#x3D; a 等效于 c &#x3D; c ** a</td></tr><tr><td align="left">&#x2F;&#x2F;&#x3D;</td><td align="left">取整除赋值运算符</td><td align="left">c &#x2F;&#x2F;&#x3D; a 等效于 c &#x3D; c &#x2F;&#x2F; a</td></tr></tbody></table><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20:</p><table><thead><tr><th align="left">运算符</th><th align="left">逻辑表达式</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">and</td><td align="left">x and y</td><td align="left">布尔”与” - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。</td><td align="left">(a and b) 返回 20。</td></tr><tr><td align="left">or</td><td align="left">x or y</td><td align="left">布尔”或” - 如果 x 是非 0，它返回 x 的计算值，否则它返回 y 的计算值。</td><td align="left">(a or b) 返回 10。</td></tr><tr><td align="left">not</td><td align="left">not x</td><td align="left">布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。</td><td align="left">not(a and b) 返回 False</td></tr></tbody></table><h3 id="成员运算符"><a href="#成员运算符" class="headerlink" title="成员运算符"></a>成员运算符</h3><p>除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">in</td><td align="left">如果在指定的序列中找到值返回 True，否则返回 False。</td><td align="left">x 在 y 序列中 , 如果 x 在 y 序列中返回 True。</td></tr><tr><td align="left">not in</td><td align="left">如果在指定的序列中没有找到值返回 True，否则返回 False。</td><td align="left">x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。</td></tr></tbody></table><p>以下实例演示了Python所有成员运算符的操作：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">20</span></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ( a <span class="keyword">in</span> <span class="built_in">list</span> ):</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;1 - 变量 a 在给定的列表中 list 中&quot;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;1 - 变量 a 不在给定的列表中 list 中&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ( b <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">list</span> ):</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;2 - 变量 b 不在给定的列表中 list 中&quot;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;2 - 变量 b 在给定的列表中 list 中&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 修改变量 a 的值</span></span><br><span class="line">a = <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> ( a <span class="keyword">in</span> <span class="built_in">list</span> ):</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;3 - 变量 a 在给定的列表中 list 中&quot;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;3 - 变量 a 不在给定的列表中 list 中&quot;</span></span><br></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 - 变量 a 不在给定的列表中 list 中</span><br><span class="line">2 - 变量 b 不在给定的列表中 list 中</span><br><span class="line">3 - 变量 a 在给定的列表中 list 中</span><br></pre></td></tr></table></figure><h3 id="身份运算符"><a href="#身份运算符" class="headerlink" title="身份运算符"></a>身份运算符</h3><p>身份运算符用于比较两个对象的存储单元</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">is</td><td align="left">is 是判断两个标识符是不是引用自一个对象</td><td align="left"><strong>x is y</strong>, 类似 <strong>id(x) &#x3D;&#x3D; id(y)</strong> , 如果引用的是同一个对象则返回 True，否则返回 False</td></tr><tr><td align="left">is not</td><td align="left">is not 是判断两个标识符是不是引用自不同对象</td><td align="left"><strong>x is not y</strong> ， 类似 **id(a) !&#x3D; id(b)**。如果引用的不是同一个对象则返回结果 True，否则返回 False。</td></tr></tbody></table><p><strong>注：</strong> id()函数用于获取对象内存地址。</p><p>以下实例演示了Python所有身份运算符的操作：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line">a = <span class="number">20</span></span><br><span class="line">b = <span class="number">20</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ( a <span class="keyword">is</span> b ):</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;1 - a 和 b 有相同的标识&quot;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;1 - a 和 b 没有相同的标识&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ( a <span class="keyword">is</span> <span class="keyword">not</span> b ):</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;2 - a 和 b 没有相同的标识&quot;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;2 - a 和 b 有相同的标识&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 修改变量 b 的值</span></span><br><span class="line">b = <span class="number">30</span></span><br><span class="line"><span class="keyword">if</span> ( a <span class="keyword">is</span> b ):</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;3 - a 和 b 有相同的标识&quot;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;3 - a 和 b 没有相同的标识&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ( a <span class="keyword">is</span> <span class="keyword">not</span> b ):</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;4 - a 和 b 没有相同的标识&quot;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;4 - a 和 b 有相同的标识&quot;</span></span><br></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 - a 和 b 有相同的标识</span><br><span class="line">2 - a 和 b 有相同的标识</span><br><span class="line">3 - a 和 b 没有相同的标识</span><br><span class="line">4 - a 和 b 没有相同的标识</span><br></pre></td></tr></table></figure><blockquote><p>is 与 &#x3D;&#x3D; 区别：</p><p>is 用于判断两个变量引用对象是否为同一个(同一块内存空间)， &#x3D;&#x3D; 用于判断引用变量的值是否相等。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b <span class="keyword">is</span> a </span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b == a</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a[:]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b <span class="keyword">is</span> a</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b == a</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure></blockquote><hr><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><p>以下表格列出了从最高到最低优先级的所有运算符：</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">**</td><td align="left">指数 (最高优先级)</td></tr><tr><td align="left">~ + -</td><td align="left">按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)</td></tr><tr><td align="left">* &#x2F; % &#x2F;&#x2F;</td><td align="left">乘，除，取模和取整除</td></tr><tr><td align="left">+ -</td><td align="left">加法减法</td></tr><tr><td align="left">&gt;&gt; &lt;&lt;</td><td align="left">右移，左移运算符</td></tr><tr><td align="left">&amp;</td><td align="left">位 ‘AND’</td></tr><tr><td align="left">^ |</td><td align="left">位运算符</td></tr><tr><td align="left">&lt;&#x3D; &lt; &gt; &gt;&#x3D;</td><td align="left">比较运算符</td></tr><tr><td align="left">&lt;&gt; &#x3D;&#x3D; !&#x3D;</td><td align="left">等于运算符</td></tr><tr><td align="left">&#x3D; %&#x3D; &#x2F;&#x3D; &#x2F;&#x2F;&#x3D; -&#x3D; +&#x3D; *&#x3D; **&#x3D;</td><td align="left">赋值运算符</td></tr><tr><td align="left">is is not</td><td align="left">身份运算符</td></tr><tr><td align="left">in not in</td><td align="left">成员运算符</td></tr><tr><td align="left">not and or</td><td align="left">逻辑运算符</td></tr></tbody></table><p>以下实例演示了Python所有运算符优先级的操作：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line">a = <span class="number">20</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line">c = <span class="number">15</span></span><br><span class="line">d = <span class="number">5</span></span><br><span class="line">e = <span class="number">0</span></span><br><span class="line"> </span><br><span class="line">e = (a + b) * c / d       <span class="comment">#( 30 * 15 ) / 5</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;(a + b) * c / d 运算结果为：&quot;</span>,  e</span><br><span class="line"> </span><br><span class="line">e = ((a + b) * c) / d     <span class="comment"># (30 * 15 ) / 5</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;((a + b) * c) / d 运算结果为：&quot;</span>,  e</span><br><span class="line"> </span><br><span class="line">e = (a + b) * (c / d);    <span class="comment"># (30) * (15/5)</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;(a + b) * (c / d) 运算结果为：&quot;</span>,  e</span><br><span class="line"> </span><br><span class="line">e = a + (b * c) / d;      <span class="comment">#  20 + (150/5)</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;a + (b * c) / d 运算结果为：&quot;</span>,  e</span><br></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(a + b) * c / d 运算结果为： 90</span><br><span class="line">((a + b) * c) / d 运算结果为： 90</span><br><span class="line">(a + b) * (c / d) 运算结果为： 90</span><br><span class="line">a + (b * c) / d 运算结果为： 50</span><br></pre></td></tr></table></figure><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p>Python条件语句是通过一条或多条语句的执行结果（True或者False）来决定执行的代码块。</p><p>Python程序语言指定任何非0和非空（null）值为true，0 或者 null为false。</p><p>Python 编程中 if 语句用于控制程序的执行，基本形式为：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 判断条件：</span><br><span class="line">    执行语句……</span><br><span class="line"><span class="keyword">else</span>：</span><br><span class="line">    执行语句……</span><br></pre></td></tr></table></figure><p>其中”判断条件”成立时（非零），则执行后面的语句，而执行内容可以多行，以缩进来区分表示同一范围。</p><p>else 为可选语句，当需要在条件不成立时执行内容则可以执行相关语句。</p><p>if 语句的判断条件可以用&gt;（大于）、&lt;(小于)、&#x3D;&#x3D;（等于）、&gt;&#x3D;（大于等于）、&lt;&#x3D;（小于等于）来表示其关系。</p><p>当判断条件为多个值时，可以使用以下形式：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 判断条件<span class="number">1</span>:</span><br><span class="line">    执行语句<span class="number">1</span>……</span><br><span class="line"><span class="keyword">elif</span> 判断条件<span class="number">2</span>:</span><br><span class="line">    执行语句<span class="number">2</span>……</span><br><span class="line"><span class="keyword">elif</span> 判断条件<span class="number">3</span>:</span><br><span class="line">    执行语句<span class="number">3</span>……</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    执行语句<span class="number">4</span>……</span><br></pre></td></tr></table></figure><p>由于 python 并不支持 switch 语句，所以多个条件判断，只能用 elif 来实现，如果判断需要多个条件需同时判断时，可以使用 or （或），表示两个条件有一个成立时判断条件成功；使用 and （与）时，表示只有两个条件同时成立的情况下，判断条件才成功。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 例3：if语句多个条件</span></span><br><span class="line"> </span><br><span class="line">num = <span class="number">9</span></span><br><span class="line"><span class="keyword">if</span> num &gt;= <span class="number">0</span> <span class="keyword">and</span> num &lt;= <span class="number">10</span>:    <span class="comment"># 判断值是否在0~10之间</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="comment"># 输出结果: hello</span></span><br><span class="line"> </span><br><span class="line">num = <span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> num &lt; <span class="number">0</span> <span class="keyword">or</span> num &gt; <span class="number">10</span>:    <span class="comment"># 判断值是否在小于0或大于10</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;undefine&#x27;</span></span><br><span class="line"><span class="comment"># 输出结果: undefine</span></span><br><span class="line"> </span><br><span class="line">num = <span class="number">8</span></span><br><span class="line"><span class="comment"># 判断值是否在0~5或者10~15之间</span></span><br><span class="line"><span class="keyword">if</span> (num &gt;= <span class="number">0</span> <span class="keyword">and</span> num &lt;= <span class="number">5</span>) <span class="keyword">or</span> (num &gt;= <span class="number">10</span> <span class="keyword">and</span> num &lt;= <span class="number">15</span>):    </span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;undefine&#x27;</span></span><br><span class="line"><span class="comment"># 输出结果: undefine</span></span><br></pre></td></tr></table></figure><p>当if有多个条件时可使用括号来区分判断的先后顺序，括号中的判断优先执行，此外 and 和 or 的优先级低于&gt;（大于）、&lt;（小于）等判断符号，即大于和小于在没有括号的情况下会比与或要优先判断。</p><hr><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>Python 提供了 for 循环和 while 循环（在 Python 中没有 do..while 循环）:</p><table><thead><tr><th align="left">循环类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">while 循环</td><td align="left">在给定的判断条件为 true 时执行循环体，否则退出循环体。</td></tr><tr><td align="left">for 循环</td><td align="left">重复执行语句</td></tr><tr><td align="left">嵌套循环</td><td align="left">你可以在while循环体中嵌套for循环</td></tr></tbody></table><h3 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h3><p>循环控制语句可以更改语句执行的顺序。Python支持以下循环控制语句：</p><table><thead><tr><th align="left">控制语句</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">break 语句</td><td align="left">在语句块执行过程中终止循环，并且跳出整个循环</td></tr><tr><td align="left">continue 语句</td><td align="left">在语句块执行过程中终止当前循环，跳出该次循环，执行下一次循环。</td></tr><tr><td align="left">pass 语句</td><td align="left">pass是空语句，是为了保持程序结构的完整性。</td></tr></tbody></table><hr><h2 id="While循环语句"><a href="#While循环语句" class="headerlink" title="While循环语句"></a>While循环语句</h2><p>Python 编程中 while 语句用于循环执行程序，即在某条件下，循环执行某段程序，以处理需要重复处理的相同任务。其基本形式为：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 判断条件(condition)：</span><br><span class="line">    执行语句(statements)……</span><br></pre></td></tr></table></figure><p>执行语句可以是单个语句或语句块。判断条件可以是任何表达式，任何非零、或非空（null）的值均为true。</p><p>当判断条件假 false 时，循环结束。</p><p>while 语句时还有另外两个重要的命令 continue，break 来跳过循环，continue 用于跳过该次循环，break 则是用于退出循环，此外”判断条件”还可以是个常值，表示循环必定成立，具体用法如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># continue 和 break 用法</span></span><br><span class="line"> </span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">10</span>:   </span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> i%<span class="number">2</span> &gt; <span class="number">0</span>:     <span class="comment"># 非双数时跳过输出</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="built_in">print</span> i         <span class="comment"># 输出双数2、4、6、8、10</span></span><br><span class="line"> </span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:            <span class="comment"># 循环条件为1必定成立</span></span><br><span class="line">    <span class="built_in">print</span> i         <span class="comment"># 输出1~10</span></span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">10</span>:     <span class="comment"># 当i大于10时跳出循环</span></span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h2 id="循环使用-else-语句"><a href="#循环使用-else-语句" class="headerlink" title="循环使用 else 语句"></a>循环使用 else 语句</h2><p>在 python 中，while … else 在循环条件为 false 时执行 else 语句块：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"> </span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> count &lt; <span class="number">5</span>:</span><br><span class="line">   <span class="built_in">print</span> count, <span class="string">&quot; is  less than 5&quot;</span></span><br><span class="line">   count = count + <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> count, <span class="string">&quot; is not less than 5&quot;</span></span><br></pre></td></tr></table></figure><p>以上实例输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 is less than 5</span><br><span class="line">1 is less than 5</span><br><span class="line">2 is less than 5</span><br><span class="line">3 is less than 5</span><br><span class="line">4 is less than 5</span><br><span class="line">5 is not less than 5</span><br></pre></td></tr></table></figure><hr><h2 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h2><p>如果条件判断语句永远为 true，循环将会无限的执行下去</p><hr><h2 id="for循环语句"><a href="#for循环语句" class="headerlink" title="for循环语句"></a>for循环语句</h2><hr><h2 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a>循环嵌套</h2><hr><h2 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h2><hr><h2 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h2><hr><h2 id="pass语句"><a href="#pass语句" class="headerlink" title="pass语句"></a>pass语句</h2><hr><h2 id="Number（数字）"><a href="#Number（数字）" class="headerlink" title="Number（数字）"></a>Number（数字）</h2><hr><h2 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串"></a>字符串</h2><hr><h2 id="列表（List）"><a href="#列表（List）" class="headerlink" title="列表（List）"></a>列表（List）</h2><hr><h2 id="元组-1"><a href="#元组-1" class="headerlink" title="元组"></a>元组</h2><h2 id="字典（Dictionary）"><a href="#字典（Dictionary）" class="headerlink" title="字典（Dictionary）"></a>字典（Dictionary）</h2><h2 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h2><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><h2 id="文件I-x2F-O"><a href="#文件I-x2F-O" class="headerlink" title="文件I&#x2F;O"></a>文件I&#x2F;O</h2><h2 id="File方法"><a href="#File方法" class="headerlink" title="File方法"></a>File方法</h2><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h2 id="OS文件-x2F-目录方法"><a href="#OS文件-x2F-目录方法" class="headerlink" title="OS文件&#x2F;目录方法"></a>OS文件&#x2F;目录方法</h2><h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>舜桀的2023</title>
      <link href="/FRank675.github.io/posts/491f272d9433/"/>
      <url>/FRank675.github.io/posts/491f272d9433/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="舜桀的2023"><a href="#舜桀的2023" class="headerlink" title="舜桀的2023"></a>舜桀的2023</h1><h2 id="1月1日"><a href="#1月1日" class="headerlink" title="1月1日"></a>1月1日</h2>]]></content>
      
      
      <categories>
          
          <category> 复盘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复盘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git相关</title>
      <link href="/FRank675.github.io/posts/b87a3cdd6d0d/"/>
      <url>/FRank675.github.io/posts/b87a3cdd6d0d/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="Git取得项目的仓库"><a href="#Git取得项目的仓库" class="headerlink" title="Git取得项目的仓库"></a>Git取得项目的仓库</h2><h3 id="在工作目录中初始化新仓库"><a href="#在工作目录中初始化新仓库" class="headerlink" title="在工作目录中初始化新仓库"></a>在工作目录中初始化新仓库</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*在项目所在目录进行初始化，初始化后会得到一个名为.git的目录，存放所有Git需要的数据和资源*/</span></span><br><span class="line"></span><br><span class="line">$ git init</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交：*/</span></span><br><span class="line"></span><br><span class="line">$ git add *.c</span><br><span class="line"></span><br><span class="line">$ git add README</span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">&#x27;initial project version&#x27;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*这样我们就得到了一个实际维护着若干文件的Git仓库*/</span>    </span><br></pre></td></tr></table></figure><h3 id="从现有仓库克隆"><a href="#从现有仓库克隆" class="headerlink" title="从现有仓库克隆"></a>从现有仓库克隆</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*如果想对某个开源项目出一份力，可以先把该项目的 Git 仓库复制一份出来，这就需要用到git clone 命令。*/</span></span><br><span class="line"><span class="comment">/*克隆仓库的命令格式为 git clone [url]。*/</span></span><br><span class="line"><span class="comment">/*比如，要克隆 Ruby 语言的 Git 代码仓库 Grit，可以用下面的命令：*/</span></span><br><span class="line"></span><br><span class="line">$ git clone git:<span class="comment">//github.com/schacon/grit.git</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*这会在当前目录下创建一个名为grit的目录，其中包含一个 .git 的目录，用于保存下载下来的所有版本记录，然后从中取出最新版本的文件拷贝。*/</span></span><br><span class="line"><span class="comment">/*如果进入这个新建的 grit 目录，你会看到项目中的所有文件已经在里边了，准备好后续的开发和使用。*/</span></span><br><span class="line"><span class="comment">/*如果希望在克隆的时候，自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：*/</span></span><br><span class="line"></span><br><span class="line">$ git clone git:<span class="comment">//github.com/schacon/grit.git mygrit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*唯一的差别就是，现在新建的目录成了mygrit，其他的都和上边的一样。*/</span></span><br></pre></td></tr></table></figure><h2 id="Git记录每次更新到仓库"><a href="#Git记录每次更新到仓库" class="headerlink" title="Git记录每次更新到仓库"></a>Git记录每次更新到仓库</h2><p>有了一个真实项目的 Git 仓库，并从这个仓库中取出了所有文件的工作拷贝。接下来，对这些文件作些修改，在完成了一个阶段的目标之后，提交本次更新到仓库。</p><p>工作目录下面的所有文件有这两种状态：已跟踪或未跟踪。</p><p>已跟踪的文件是指本来就被纳入版本控制管理的文件，在上次快照中有它们的记录，工作一段时间后，它们的状态可能是未更新，已修改或者已放入暂存区。</p><p>而所有其他文件都属于未跟踪文件。它们既没有上次更新时的快照，也不在当前的暂存区域。初次克隆某个仓库时，工作目录中的所有文件都属于已跟踪文件，且状态为未修改。</p><p>在编辑过某些文件之后，Git 将这些文件标为已修改。我们逐步把这些修改过的文件放到暂存区域，直到最后一次性提交所有这些暂存起来的文件，如此重复。</p><h2 id="Git查看提交历史"><a href="#Git查看提交历史" class="headerlink" title="Git查看提交历史"></a>Git查看提交历史</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*在提交了若干更新之后，又或者克隆了某个项目，想回顾下提交历史，可以使用 `git log` 命令查看。*/</span></span><br><span class="line"></span><br><span class="line">$ git log</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*默认不用任何参数的话，git log 会按提交时间列出所有的更新，最近的更新排在最上面。*/</span></span><br><span class="line"><span class="comment">/*每次更新都有一个 SHA-1 校验和、作者的名字和电子邮件地址、提交时间，最后缩进一个段落显示提交说明。*/</span></span><br><span class="line"><span class="comment">/*常用 -p 选项展开显示每次提交的内容差异，用 -2 则仅显示最近的两次更新：*/</span></span><br><span class="line">    </span><br><span class="line">$ git log -p -<span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下表还列出了一些其他常用的选项及其释义。</p><table><thead><tr><th align="left">选项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-p</td><td align="left">按补丁格式显示每个更新之间的差异。</td></tr><tr><td align="left">–word-diff</td><td align="left">按 word diff 格式显示差异。</td></tr><tr><td align="left">–stat</td><td align="left">显示每次更新的文件修改统计信息。</td></tr><tr><td align="left">–shortstat</td><td align="left">只显示 –stat 中最后的行数修改添加移除统计。</td></tr><tr><td align="left">–name-only</td><td align="left">仅在提交信息后显示已修改的文件清单。</td></tr><tr><td align="left">–name-status</td><td align="left">显示新增、修改、删除的文件清单。</td></tr><tr><td align="left">–abbrev-commit</td><td align="left">仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。</td></tr><tr><td align="left">–relative-date</td><td align="left">使用较短的相对时间显示（比如，“2 weeks ago”）。</td></tr><tr><td align="left">–graph</td><td align="left">显示 ASCII 图形表示的分支合并历史。</td></tr><tr><td align="left">–pretty</td><td align="left">使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。</td></tr><tr><td align="left">–oneline</td><td align="left">–pretty&#x3D;oneline –abbrev-commit 的简化用法。</td></tr></tbody></table><p>限制输出长度</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*下面的命令列出所有最近两周内的提交：*/</span></span><br><span class="line"></span><br><span class="line">$ git log --since=<span class="number">2.</span>weeks</span><br><span class="line"></span><br><span class="line"><span class="comment">/*可以给出各种时间格式，比如说具体的某一天（“2008-01-15”），或者是多久以前（“2 years 1 day 3 minutes ago”）。*/</span></span><br><span class="line"><span class="comment">/*另一个真正实用的git log选项是路径(path)，如果只关心某些文件或者目录的历史提交，可以在 git log 选项的最后指定它们的路径。因为是放在最后位置上的选项，所以用两个短划线（--）隔开之前的选项和后面限定的路径名。*/</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">选项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-(n)</td><td align="left">仅显示最近的 n 条提交</td></tr><tr><td align="left">–since, –after</td><td align="left">仅显示指定时间之后的提交。</td></tr><tr><td align="left">–until, –before</td><td align="left">仅显示指定时间之前的提交。</td></tr><tr><td align="left">–author</td><td align="left">仅显示指定作者相关的提交。</td></tr><tr><td align="left">–committer</td><td align="left">仅显示指定提交者相关的提交。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*如果要查看 Git 仓库中，2008 年 10 月期间，Junio Hamano 提交的但未合并的测试脚本（位于项目的 t/ 目录下的文件），可以用下面的查询命令：*/</span></span><br><span class="line"></span><br><span class="line">$ git log --pretty=<span class="string">&quot;%h - %s&quot;</span> --author=gitster --since=<span class="string">&quot;2008-10-01&quot;</span> \ --before=<span class="string">&quot;2008-11-01&quot;</span> --no-merges -- t/</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Git撤销操作"><a href="#Git撤销操作" class="headerlink" title="Git撤销操作"></a>Git撤销操作</h2><h3 id="修改最后一次提交"><a href="#修改最后一次提交" class="headerlink" title="修改最后一次提交"></a>修改最后一次提交</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*提交完了才发现漏掉了几个文件没有加，或者提交信息写错了。想要撤消刚才的提交操作，可以使用 --amend 选项重新提交*/</span></span><br><span class="line"></span><br><span class="line">$ git commit --amend</span><br><span class="line"></span><br><span class="line"><span class="comment">/*此命令将使用当前的暂存区域快照提交。*/</span></span><br><span class="line"><span class="comment">/*如果刚才提交完没有作任何改动，直接运行此命令的话，相当于有机会重新编辑提交说明，但将要提交的文件快照和之前的一样。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*启动文本编辑器后，会看到上次提交时的说明，编辑它确认没问题后保存退出，就会使用新的提交说明覆盖刚才失误的提交。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果刚才提交时忘了暂存某些修改，可以先补上暂存操作，然后再运行 --amend 提交：*/</span></span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">&#x27;initial commit&#x27;</span></span><br><span class="line">    </span><br><span class="line">$ git add forgotten_file</span><br><span class="line">    </span><br><span class="line">$ git commit --amend</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*上面的三条命令最终只是产生一个提交，第二个提交命令修正了第一个的提交内容。*/</span></span><br></pre></td></tr></table></figure><h3 id="取消已经暂存的文件"><a href="#取消已经暂存的文件" class="headerlink" title="取消已经暂存的文件"></a>取消已经暂存的文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*有两个修改过的文件，想要分开提交，但不小心用 git add . 全加到了暂存区域。该如何撤消暂存其中的一个文件呢？*/</span></span><br><span class="line"></span><br><span class="line">$ git reset HEAD benchmarks.rb</span><br><span class="line"></span><br><span class="line"><span class="comment">/*现在 benchmarks.rb 文件又回到了之前已修改未暂存的状态。*/</span></span><br></pre></td></tr></table></figure><h3 id="取消对文件的修改"><a href="#取消对文件的修改" class="headerlink" title="取消对文件的修改"></a>取消对文件的修改</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*该如何取消修改，回到之前的状态（也就是修改之前的版本）*/</span></span><br><span class="line"></span><br><span class="line">$ git checkout -- benchmarks.rb</span><br><span class="line"></span><br><span class="line"><span class="comment">/*在用这条命令前，请务必确定真的不再需要保留刚才的修改。*/</span></span><br></pre></td></tr></table></figure><h2 id="Git远程仓库的使用"><a href="#Git远程仓库的使用" class="headerlink" title="Git远程仓库的使用"></a>Git远程仓库的使用</h2><p>远程仓库是指托管在网络上的项目仓库，可能会有好多个，其中有些你只能读，另外有些可以写。</p><p>同他人协作开发某个项目时，需要管理这些远程仓库，以便推送或拉取数据，分享各自的工作进展。 </p><p>管理远程仓库的工作，包括添加远程库，移除废弃的远程库，管理各式远程库分支，定义是否跟踪这些分支，等等。 </p><h3 id="查看当前的远程库"><a href="#查看当前的远程库" class="headerlink" title="查看当前的远程库"></a>查看当前的远程库</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*要查看当前配置有哪些远程仓库，可以用 git remote 命令，它会列出每个远程库的简短名字。*/</span></span><br><span class="line"><span class="comment">/*在克隆完某个项目后，至少可以看到一个名为origin 的远程库，Git 默认使用这个名字来标识你所克隆的原始仓库：*/</span></span><br><span class="line"></span><br><span class="line">$ git clone git:<span class="comment">//github.com/schacon/ticgit.git</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*Cloning into &#x27;ticgit&#x27;...</span></span><br><span class="line"><span class="comment">remote: Reusing existing pack: 1857, done.</span></span><br><span class="line"><span class="comment">remote: Total 1857 (delta 0), reused 0 (delta 0)</span></span><br><span class="line"><span class="comment">Receiving objects: 100% (1857/1857), 374.35 KiB | 193.00 KiB/s, done.</span></span><br><span class="line"><span class="comment">Resolving deltas: 100% (772/772), done.</span></span><br><span class="line"><span class="comment">Checking connectivity... done.*/</span></span><br><span class="line"></span><br><span class="line">$ cd ticgit</span><br><span class="line">    </span><br><span class="line">$ git remote</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*origin*/</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*也可以加上 -v 选项（译注：此为 --verbose 的简写，取首字母），显示对应的克隆地址：*/</span></span><br><span class="line"></span><br><span class="line">$ git remote -v</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*origin  git://github.com/schacon/ticgit.git (fetch)</span></span><br><span class="line"><span class="comment">origin  git://github.com/schacon/ticgit.git (push)*/</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*如果有多个远程仓库，此命令将全部列出。比如在我的 Grit 项目中，可以看到：*/</span></span><br><span class="line"></span><br><span class="line">$ cd grit</span><br><span class="line">$ git remote -v</span><br><span class="line">bakkdoor  git:<span class="comment">//github.com/bakkdoor/grit.git</span></span><br><span class="line">cho45     git:<span class="comment">//github.com/cho45/grit.git</span></span><br><span class="line">defunkt   git:<span class="comment">//github.com/defunkt/grit.git</span></span><br><span class="line">koke      git:<span class="comment">//github.com/koke/grit.git</span></span><br><span class="line">origin    git<span class="meta">@github</span>.com:mojombo/grit.git</span><br><span class="line"><span class="comment">/*这样一来，我就可以非常轻松地从这些用户的仓库中，拉取他们的提交到本地。*/</span></span><br><span class="line"><span class="comment">/*需要注意，上面列出的地址只有 origin 用的是 SSH URL 链接，所以也只有这个仓库能推送数据上去。*/</span></span><br></pre></td></tr></table></figure><h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用，运行git remote add [shortname] [url]：*/</span></span><br><span class="line"></span><br><span class="line">$ git remote</span><br><span class="line">    </span><br><span class="line">origin</span><br><span class="line">    </span><br><span class="line">$ git remote add pb git:<span class="comment">//github.com/paulboone/ticgit.git</span></span><br><span class="line"></span><br><span class="line">$ git remote -v</span><br><span class="line">    </span><br><span class="line">origin  git:<span class="comment">//github.com/schacon/ticgit.git</span></span><br><span class="line">pb  git:<span class="comment">//github.com/paulboone/ticgit.git</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*现在可以用字符串 pb 指代对应的仓库地址了。比如说，要抓取所有 Paul 有的，但本地仓库没有的信息，可以运行 git fetch pb：*/</span></span><br><span class="line"></span><br><span class="line">$ git fetch pb</span><br><span class="line">    </span><br><span class="line">remote: Counting objects: <span class="number">58</span>, done.</span><br><span class="line">remote: Compressing objects: <span class="number">100</span>% (<span class="number">41</span>/<span class="number">41</span>), done.</span><br><span class="line">remote: Total <span class="number">44</span> (delta <span class="number">24</span>), reused <span class="number">1</span> (delta <span class="number">0</span>)</span><br><span class="line">Unpacking objects: <span class="number">100</span>% (<span class="number">44</span>/<span class="number">44</span>), done.</span><br><span class="line">From git:<span class="comment">//github.com/paulboone/ticgit</span></span><br><span class="line"> * [<span class="keyword">new</span> <span class="title class_">branch</span>]      master     -&gt; pb/master</span><br><span class="line"> * [<span class="keyword">new</span> <span class="title class_">branch</span>]      ticgit     -&gt; pb/ticgit</span><br><span class="line">     </span><br><span class="line"><span class="comment">/*现在，Paul 的主干分支（master）已经完全可以在本地访问了，对应的名字是 pb/master，你可以将它合并到自己的某个分支，或者切换到这个分支。*/</span></span><br></pre></td></tr></table></figure><h3 id="从远程仓库抓取数据"><a href="#从远程仓库抓取数据" class="headerlink" title="从远程仓库抓取数据"></a>从远程仓库抓取数据</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*可以用下面的命令从远程仓库抓取数据到本地：*/</span></span><br><span class="line"></span><br><span class="line">$ git fetch [remote-name]</span><br><span class="line"></span><br><span class="line"><span class="comment">/*此命令会到远程仓库中拉取所有你本地仓库中还没有的数据。运行完成后，你就可以在本地访问该远程仓库中的所有分支，将其中某个分支合并到本地，或者只是取出某个分支，一探究竟。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果是克隆了一个仓库，此命令会自动将远程仓库归于 origin 名下。*/</span></span><br><span class="line"><span class="comment">/*所以，git fetch origin 会抓取从你上次克隆以来别人上传到此远程仓库中的所有更新（或是上次 fetch 以来别人提交的更新）。*/</span></span><br><span class="line"><span class="comment">/*有一点很重要，需要记住，fetch 命令只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支，只有当你确实准备好了，才能手工合并。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果设置了某个分支用于跟踪某个远端仓库的分支，可以使用git pull命令自动抓取数据下来，然后将远端分支自动合并到本地仓库中当前分支。*/</span></span><br><span class="line"><span class="comment">/*在日常工作中我们经常这么用，既快且好。实际上，默认情况下 git clone 命令本质上就是自动创建了本地的 master 分支用于跟踪远程仓库中的 master 分支（假设远程仓库确实有 master 分支）。所以一般我们运行 git pull，目的都是要从原始克隆的远端仓库中抓取数据后，合并到工作目录中的当前分支。*/</span></span><br></pre></td></tr></table></figure><h3 id="推送数据到远程仓库"><a href="#推送数据到远程仓库" class="headerlink" title="推送数据到远程仓库"></a>推送数据到远程仓库</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*项目进行到一个阶段，要同别人分享目前的成果，可以将本地仓库中的数据推送到远程仓库。*/</span></span><br><span class="line"><span class="comment">/*实现这个任务的命令很简单： git push [remote-name] [branch-name]。*/</span></span><br><span class="line"><span class="comment">/*如果要把本地的 master 分支推送到 origin 服务器上（再次说明下，克隆操作会自动使用默认的 master 和 origin 名字），可以运行下面的命令：*/</span></span><br><span class="line"></span><br><span class="line">$ git push origin master</span><br><span class="line"></span><br><span class="line"><span class="comment">/*只有在所克隆的服务器上有写权限，或者同一时刻没有其他人在推数据，这条命令才会如期完成任务。*/</span></span><br><span class="line"><span class="comment">/*如果在你推数据前，已经有其他人推送了若干更新，那你的推送操作就会被驳回。你必须先把他们的更新抓取到本地，合并到自己的项目中，然后才可以再次推送。*/</span></span><br></pre></td></tr></table></figure><h3 id="查看远程仓库信息"><a href="#查看远程仓库信息" class="headerlink" title="查看远程仓库信息"></a>查看远程仓库信息</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*可以通过命令 git remote show [remote-name] 查看某个远程仓库的详细信息，比如要看所克隆的 origin 仓库，可以运行：*/</span></span><br><span class="line"></span><br><span class="line">$ git remote show origin</span><br><span class="line">    </span><br><span class="line">* remote origin</span><br><span class="line">  URL: git:<span class="comment">//github.com/schacon/ticgit.git</span></span><br><span class="line">  Remote branch merged with <span class="string">&#x27;git pull&#x27;</span> <span class="keyword">while</span> on branch master</span><br><span class="line">    master</span><br><span class="line">  Tracked remote branches</span><br><span class="line">    master</span><br><span class="line">    ticgit</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*除了对应的克隆地址外，它还给出了许多额外的信息。它友善地告诉你如果是在 master 分支，就可以用 git pull 命令抓取数据合并到本地。另外还列出了所有处于跟踪状态中的远端分支。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*随着使用 Git 的深入，git remote show 给出的信息可能会像这样：*/</span></span><br><span class="line"></span><br><span class="line">$ git remote show origin</span><br><span class="line">      </span><br><span class="line">* remote origin</span><br><span class="line">  URL: git<span class="meta">@github</span>.com:defunkt/github.git</span><br><span class="line">  Remote branch merged with <span class="string">&#x27;git pull&#x27;</span> <span class="keyword">while</span> on branch issues</span><br><span class="line">    issues</span><br><span class="line">  Remote branch merged with <span class="string">&#x27;git pull&#x27;</span> <span class="keyword">while</span> on branch master</span><br><span class="line">    master</span><br><span class="line">  New remote <span class="title function_">branches</span> <span class="params">(next fetch will store in remotes/origin)</span></span><br><span class="line">    caching</span><br><span class="line">  Stale tracking <span class="title function_">branches</span> <span class="params">(use <span class="string">&#x27;git remote prune&#x27;</span>)</span></span><br><span class="line">    libwalker</span><br><span class="line">    walker2</span><br><span class="line">  Tracked remote branches</span><br><span class="line">    acl</span><br><span class="line">    apiv2</span><br><span class="line">    dashboard2</span><br><span class="line">    issues</span><br><span class="line">    master</span><br><span class="line">    postgres</span><br><span class="line">  Local branch pushed with <span class="string">&#x27;git push&#x27;</span></span><br><span class="line">    master:master</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*它告诉我们，运行 git push 时缺省推送的分支是什么（译注：最后两行）。*/</span></span><br><span class="line"><span class="comment">/*它还显示了有哪些远端分支还没有同步到本地（译注：第六行的 caching 分支），哪些已同步到本地的远端分支在远端服务器上已被删除（译注：Stale tracking branches下面的两个分支），以及运行 git pull 时将自动合并哪些分支（译注：前四行中列出的 issues 和 master 分支）。*/</span></span><br></pre></td></tr></table></figure><h3 id="远程仓库的删除和重命名"><a href="#远程仓库的删除和重命名" class="headerlink" title="远程仓库的删除和重命名"></a>远程仓库的删除和重命名</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*可以用 git remote rename命令修改某个远程仓库在本地的简称，比如想把 pb 改成 paul，可以这么运行：*/</span></span><br><span class="line"></span><br><span class="line">$ git remote rename pb paul</span><br><span class="line">$ git remote</span><br><span class="line">    </span><br><span class="line">origin</span><br><span class="line">paul</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*注意，对远程仓库的重命名，也会使对应的分支名称发生变化，原来的 pb/master 分支现在成了 paul/master。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*碰到远端仓库服务器迁移，或者原来的克隆镜像不再使用，又或者某个参与者不再贡献代码，那么需要移除对应的远端仓库，可以运行 git remote rm 命令：*/</span></span><br><span class="line"></span><br><span class="line">$ git remote rm paul</span><br><span class="line">$ git remote</span><br><span class="line">    </span><br><span class="line">origin</span><br></pre></td></tr></table></figure><h2 id="Git打标签"><a href="#Git打标签" class="headerlink" title="Git打标签"></a>Git打标签</h2><h3 id="列出已有标签"><a href="#列出已有标签" class="headerlink" title="列出已有标签"></a>列出已有标签</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line">v0<span class="number">.1</span></span><br><span class="line">v1<span class="number">.3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*显示的标签按字母顺序排列，所以标签的先后并不表示重要程度的轻重。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*我们可以用特定的搜索模式列出符合条件的标签。*/</span></span><br><span class="line"><span class="comment">/*在 Git 自身项目仓库中，有着超过 240 个标签，如果你只对 1.4.2 系列的版本感兴趣，可以运行下面的命令：*/</span></span><br><span class="line"></span><br><span class="line">$ git tag -l <span class="string">&#x27;v1.4.2.*&#x27;</span></span><br><span class="line">    </span><br><span class="line">v1<span class="number">.4</span><span class="number">.2</span><span class="number">.1</span></span><br><span class="line">v1<span class="number">.4</span><span class="number">.2</span><span class="number">.2</span></span><br><span class="line">v1<span class="number">.4</span><span class="number">.2</span><span class="number">.3</span></span><br><span class="line">v1<span class="number">.4</span><span class="number">.2</span><span class="number">.4</span></span><br></pre></td></tr></table></figure><h3 id="新建标签"><a href="#新建标签" class="headerlink" title="新建标签"></a>新建标签</h3><p>Git 使用的标签有两种类型：轻量级的（lightweight）和含附注的（annotated）。</p><p>轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用。</p><p>而含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证。</p><p>一般我们都建议使用含附注型的标签，以便保留相关信息；当然，如果只是临时性加注标签，或者不需要旁注额外信息，用轻量级标签也没问题。 </p><h3 id="含附注的标签"><a href="#含附注的标签" class="headerlink" title="含附注的标签"></a>含附注的标签</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*创建一个含附注类型的标签非常简单，用 -a （译注：取 annotated 的首字母）指定标签名字即可：*/</span></span><br><span class="line"></span><br><span class="line">$ git tag -a v1<span class="number">.4</span> -m <span class="string">&#x27;my version 1.4&#x27;</span></span><br><span class="line">$ git tag</span><br><span class="line">    </span><br><span class="line">v0<span class="number">.1</span></span><br><span class="line">v1<span class="number">.3</span></span><br><span class="line">v1<span class="number">.4</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*而 -m 选项则指定了对应的标签说明，Git 会将此说明一同保存在标签对象中。如果没有给出该选项，Git 会启动文本编辑软件供你输入标签说明。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*可以使用 git show 命令查看相应标签的版本信息，并连同显示打标签时的提交对象。*/</span></span><br><span class="line"></span><br><span class="line">$ git show v1<span class="number">.4</span></span><br><span class="line">    </span><br><span class="line">tag v1<span class="number">.4</span></span><br><span class="line">Tagger: Scott Chacon &lt;schacon<span class="meta">@gee</span>-mail.com&gt;</span><br><span class="line">Date:   Mon Feb <span class="number">9</span> <span class="number">14</span>:<span class="number">45</span>:<span class="number">11</span> <span class="number">2009</span> -0800</span><br><span class="line"></span><br><span class="line">my version <span class="number">1.4</span></span><br><span class="line"></span><br><span class="line">commit 15027957951b64cf874c3557a0f3547bd83b3ff6</span><br><span class="line">Merge: 4a447f7... a6b4c97...</span><br><span class="line">Author: Scott Chacon &lt;schacon<span class="meta">@gee</span>-mail.com&gt;</span><br><span class="line">Date:   Sun Feb <span class="number">8</span> <span class="number">19</span>:<span class="number">02</span>:<span class="number">46</span> <span class="number">2009</span> -0800</span><br><span class="line"></span><br><span class="line">    Merge branch <span class="string">&#x27;experiment&#x27;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*可以看到在提交对象信息上面，列出了此标签的提交者和提交时间，以及相应的标签说明。*/</span></span><br></pre></td></tr></table></figure><h3 id="签署标签"><a href="#签署标签" class="headerlink" title="签署标签"></a>签署标签</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*如果你有自己的私钥，还可以用 GPG 来签署标签，只需要把之前的 -a 改为 -s（译注： 取 signed 的首字母）即可：*/</span></span><br><span class="line"></span><br><span class="line">$ git tag -s v1<span class="number">.5</span> -m <span class="string">&#x27;my signed 1.5 tag&#x27;</span></span><br><span class="line"></span><br><span class="line">You need a passphrase to unlock the secret key <span class="keyword">for</span></span><br><span class="line">user: <span class="string">&quot;Scott Chacon &lt;schacon@gee-mail.com&gt;&quot;</span></span><br><span class="line"><span class="number">1024</span>-bit DSA key, ID F721C45A, created <span class="number">2009</span>-<span class="number">02</span>-09</span><br><span class="line"></span><br><span class="line"><span class="comment">/*现在再运行 git show 会看到对应的 GPG 签名也附在其内：*/</span></span><br><span class="line"></span><br><span class="line">$ git show v1<span class="number">.5</span></span><br><span class="line"></span><br><span class="line">tag v1<span class="number">.5</span></span><br><span class="line">Tagger: Scott Chacon &lt;schacon<span class="meta">@gee</span>-mail.com&gt;</span><br><span class="line">Date:   Mon Feb <span class="number">9</span> <span class="number">15</span>:<span class="number">22</span>:<span class="number">20</span> <span class="number">2009</span> -0800</span><br><span class="line"></span><br><span class="line">my signed <span class="number">1.5</span> tag</span><br><span class="line">-----BEGIN PGP SIGNATURE-----</span><br><span class="line">Version: GnuPG v1<span class="number">.4</span><span class="number">.8</span> (Darwin)</span><br><span class="line"></span><br><span class="line">iEYEABECAAYFAkmQurIACgkQON3DxfchxFr5cACeIMN+ZxLKggJQf0QYiQBwgySN</span><br><span class="line">Ki0An2JeAVUCAiJ7Ox6ZEtK+NvZAj82/</span><br><span class="line">=WryJ</span><br><span class="line">-----END PGP SIGNATURE-----</span><br><span class="line">commit 15027957951b64cf874c3557a0f3547bd83b3ff6</span><br><span class="line">Merge: 4a447f7... a6b4c97...</span><br><span class="line">Author: Scott Chacon &lt;schacon<span class="meta">@gee</span>-mail.com&gt;</span><br><span class="line">Date:   Sun Feb <span class="number">8</span> <span class="number">19</span>:<span class="number">02</span>:<span class="number">46</span> <span class="number">2009</span> -0800</span><br><span class="line"></span><br><span class="line">    Merge branch <span class="string">&#x27;experiment&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="轻量级标签"><a href="#轻量级标签" class="headerlink" title="轻量级标签"></a>轻量级标签</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*轻量级标签实际上就是一个保存着对应提交对象的校验和信息的文件。要创建这样的标签，一个 -a，-s 或 -m 选项都不用，直接给出标签名字即可：*/</span></span><br><span class="line"></span><br><span class="line">$ git tag v1<span class="number">.4</span>-lw</span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line">v0<span class="number">.1</span></span><br><span class="line">v1<span class="number">.3</span></span><br><span class="line">v1<span class="number">.4</span></span><br><span class="line">v1<span class="number">.4</span>-lw</span><br><span class="line">v1<span class="number">.5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*现在运行 git show 查看此标签信息，就只有相应的提交对象摘要：*/</span></span><br><span class="line"></span><br><span class="line">$ git show v1<span class="number">.4</span>-lw</span><br><span class="line"></span><br><span class="line">commit 15027957951b64cf874c3557a0f3547bd83b3ff6</span><br><span class="line">Merge: 4a447f7... a6b4c97...</span><br><span class="line">Author: Scott Chacon &lt;schacon<span class="meta">@gee</span>-mail.com&gt;</span><br><span class="line">Date:   Sun Feb <span class="number">8</span> <span class="number">19</span>:<span class="number">02</span>:<span class="number">46</span> <span class="number">2009</span> -0800</span><br><span class="line"></span><br><span class="line">    Merge branch <span class="string">&#x27;experiment&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="验证标签"><a href="#验证标签" class="headerlink" title="验证标签"></a>验证标签</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*可以使用 git tag -v [tag-name] （译注：取 verify 的首字母）的方式验证已经签署的标签。*/</span></span><br><span class="line"><span class="comment">/*此命令会调用 GPG 来验证签名，所以你需要有签署者的公钥，存放在 keyring 中，才能验证：*/</span></span><br><span class="line"></span><br><span class="line">$ git tag -v v1<span class="number">.4</span><span class="number">.2</span><span class="number">.1</span></span><br><span class="line"></span><br><span class="line">object 883653babd8ee7ea23e6a5c392bb739348b1eb61</span><br><span class="line">type commit</span><br><span class="line">tag v1<span class="number">.4</span><span class="number">.2</span><span class="number">.1</span></span><br><span class="line">tagger Junio C Hamano &lt;junkio<span class="meta">@cox</span>.net&gt; <span class="number">1158138501</span> -<span class="number">0700</span></span><br><span class="line"></span><br><span class="line">GIT <span class="number">1.4</span><span class="number">.2</span><span class="number">.1</span></span><br><span class="line"></span><br><span class="line">Minor fixes since <span class="number">1.4</span><span class="number">.2</span>, including git-mv and git-http with alternates.</span><br><span class="line">gpg: Signature made Wed Sep <span class="number">13</span> <span class="number">02</span>:08:<span class="number">25</span> <span class="number">2006</span> PDT using DSA key ID F3119B9A</span><br><span class="line">gpg: Good signature from <span class="string">&quot;Junio C Hamano &lt;junkio@cox.net&gt;&quot;</span></span><br><span class="line">gpg:                 aka <span class="string">&quot;[jpeg image of size 1513]&quot;</span></span><br><span class="line">Primary key fingerprint: <span class="number">3565</span> 2A26 <span class="number">2040</span> E066 C9A7  4A7D C0C6 D9A4 F311 9B9A</span><br><span class="line"></span><br><span class="line"><span class="comment">/*若是没有签署者的公钥，会报告类似下面这样的错误：*/</span></span><br><span class="line"></span><br><span class="line">gpg: Signature made Wed Sep <span class="number">13</span> <span class="number">02</span>:08:<span class="number">25</span> <span class="number">2006</span> PDT using DSA key ID F3119B9A</span><br><span class="line">gpg: Can<span class="string">&#x27;t check signature: public key not found</span></span><br><span class="line"><span class="string">error: could not verify the tag &#x27;</span>v1<span class="number">.4</span><span class="number">.2</span><span class="number">.1</span><span class="string">&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="后期加注标签"><a href="#后期加注标签" class="headerlink" title="后期加注标签"></a>后期加注标签</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*可以在后期对早先的某次提交加注标签。比如在下面展示的提交历史中：*/</span></span><br><span class="line"></span><br><span class="line">$ git log --pretty=oneline</span><br><span class="line"></span><br><span class="line">15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch <span class="string">&#x27;experiment&#x27;</span></span><br><span class="line">a6b4c97498bd301d84096da251c98a07c7723e65 beginning write support</span><br><span class="line">0d52aaab4479697da7686c15f77a3d64d9165190 one more thing</span><br><span class="line">6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch <span class="string">&#x27;experiment&#x27;</span></span><br><span class="line">0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function</span><br><span class="line">4682c3261057305bdd616e23b64b0857d832627b added a todo file</span><br><span class="line">166ae0c4d3f420721acbb115cc33848dfcc2121a started write support</span><br><span class="line">9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile</span><br><span class="line">964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo</span><br><span class="line">8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme</span><br><span class="line"></span><br><span class="line"><span class="comment">/*我们忘了在提交 “updated rakefile” 后为此项目打上版本号 v1.2，没关系，现在也能做。只要在打标签的时候跟上对应提交对象的校验和（或前几位字符）即可：*/</span></span><br><span class="line"></span><br><span class="line">$ git tag -a v1<span class="number">.2</span> 9fceb02</span><br><span class="line"></span><br><span class="line">可以看到我们已经补上了标签：</span><br><span class="line"></span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line">v0<span class="number">.1</span></span><br><span class="line">v1<span class="number">.2</span></span><br><span class="line">v1<span class="number">.3</span></span><br><span class="line">v1<span class="number">.4</span></span><br><span class="line">v1<span class="number">.4</span>-lw</span><br><span class="line">v1<span class="number">.5</span></span><br><span class="line"></span><br><span class="line">$ git show v1<span class="number">.2</span></span><br><span class="line"></span><br><span class="line">tag v1<span class="number">.2</span></span><br><span class="line">Tagger: Scott Chacon &lt;schacon<span class="meta">@gee</span>-mail.com&gt;</span><br><span class="line">Date:   Mon Feb <span class="number">9</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">16</span> <span class="number">2009</span> -0800</span><br><span class="line"></span><br><span class="line">version <span class="number">1.2</span></span><br><span class="line">commit 9fceb02d0ae598e95dc970b74767f19372d61af8</span><br><span class="line">Author: Magnus Chacon &lt;mchacon<span class="meta">@gee</span>-mail.com&gt;</span><br><span class="line">Date:   Sun Apr <span class="number">27</span> <span class="number">20</span>:<span class="number">43</span>:<span class="number">35</span> <span class="number">2008</span> -<span class="number">0700</span></span><br><span class="line"></span><br><span class="line">    updated rakefile</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="分享标签"><a href="#分享标签" class="headerlink" title="分享标签"></a>分享标签</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*默认情况下，git push 并不会把标签传送到远端服务器上，只有通过显式命令才能分享标签到远端仓库。*/</span></span><br><span class="line"><span class="comment">/*其命令格式如同推送分支，运行git push origin [tagname]即可：*/</span></span><br><span class="line"></span><br><span class="line">$ git push origin v1<span class="number">.5</span></span><br><span class="line">    </span><br><span class="line">Counting objects: <span class="number">50</span>, done.</span><br><span class="line">Compressing objects: <span class="number">100</span>% (<span class="number">38</span>/<span class="number">38</span>), done.</span><br><span class="line">Writing objects: <span class="number">100</span>% (<span class="number">44</span>/<span class="number">44</span>), <span class="number">4.56</span> KiB, done.</span><br><span class="line">Total <span class="number">44</span> (delta <span class="number">18</span>), reused <span class="number">8</span> (delta <span class="number">1</span>)</span><br><span class="line">To git<span class="meta">@github</span>.com:schacon/simplegit.git</span><br><span class="line">* [<span class="keyword">new</span> <span class="title class_">tag</span>]         v1<span class="number">.5</span> -&gt; v1<span class="number">.5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果要一次推送所有本地新增的标签上去，可以使用 --tags 选项：*/</span></span><br><span class="line"></span><br><span class="line">$ git push origin --tags</span><br><span class="line">    </span><br><span class="line">Counting objects: <span class="number">50</span>, done.</span><br><span class="line">Compressing objects: <span class="number">100</span>% (<span class="number">38</span>/<span class="number">38</span>), done.</span><br><span class="line">Writing objects: <span class="number">100</span>% (<span class="number">44</span>/<span class="number">44</span>), <span class="number">4.56</span> KiB, done.</span><br><span class="line">Total <span class="number">44</span> (delta <span class="number">18</span>), reused <span class="number">8</span> (delta <span class="number">1</span>)</span><br><span class="line">To git<span class="meta">@github</span>.com:schacon/simplegit.git</span><br><span class="line"> * [<span class="keyword">new</span> <span class="title class_">tag</span>]         v0<span class="number">.1</span> -&gt; v0<span class="number">.1</span></span><br><span class="line"> * [<span class="keyword">new</span> <span class="title class_">tag</span>]         v1<span class="number">.2</span> -&gt; v1<span class="number">.2</span></span><br><span class="line"> * [<span class="keyword">new</span> <span class="title class_">tag</span>]         v1<span class="number">.4</span> -&gt; v1<span class="number">.4</span></span><br><span class="line"> * [<span class="keyword">new</span> <span class="title class_">tag</span>]         v1<span class="number">.4</span>-lw -&gt; v1<span class="number">.4</span>-lw</span><br><span class="line"> * [<span class="keyword">new</span> <span class="title class_">tag</span>]         v1<span class="number">.5</span> -&gt; v1<span class="number">.5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*现在，其他人克隆共享仓库或拉取数据同步后，也会看到这些标签。*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>舜桀的单词表</title>
      <link href="/FRank675.github.io/posts/b0e37f2d3829/"/>
      <url>/FRank675.github.io/posts/b0e37f2d3829/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>这里主要记录我背过的一些单词和喜欢的句子~</p>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单词 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试面试干货</title>
      <link href="/FRank675.github.io/posts/ecf024466033/"/>
      <url>/FRank675.github.io/posts/ecf024466033/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>测试用例设计的能力</p><p>需求，代码结构</p><p>拆解需求的能力</p><p>经验</p><p>业务变革</p><p>LTC</p><p>12月底薪 + 绩效（0-4个月） +  </p><p>风险分析</p><p>测试用例执行不一致的风险</p><p>代码规范</p><p>自动化工具</p><p>初级提供一些帮助</p><p>工业协议</p><p>plc程序</p><p>协议转换-数据</p><p>西直门-13号线</p><p>三餐-一天300-</p><p>早餐9-930</p><p>晚7</p><p>中12 1：30休息时间</p><p>下午茶</p><p>生日会一个月一次</p><p>9：30-6：30</p><p>每周4-5，可以实习5个月</p><p>稳定性测试-压力测试</p><p>脚本开发-平台开发</p><p><strong>实习有机会接触项目（校招生没到）</strong></p><p>学信网认证</p><h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>尊敬的面试官您好，我是来自北京交通大学软件工程专业的杨顺杰，我想面试是测试工程师的实习，在大学期间我认真学习，在软件测试与质量保障、项目管理等相关课程取得了较好的成绩，在二手交易平台项目中曾使用自动化测试工具selseleenium对网页进行了简单的测试，了解了selenium元素的定位属性以及鼠标控制，同时作为负责人负责了一项大学生创新创业项目，统筹规划，并最终获评国家级项目，学习之余我也积极参与导师项目，选择测试优化的方向，设计了<strong>DiKlee:一种缺陷预测引导的测试用例生成方法</strong>并撰写了一篇论文目前处于在投状态。这些经历也让我对测试有了一些了解，并产生了很大的兴趣，目前我在安心网盾做测试开发实习生，主要负责压力测试、接口测试相关工作，使用的测试工具有metersphere和jemeter等，同时我是一个有耐心、热爱沟通、坚持学习的人，这也和测试这个岗位较为匹配。以上就是我的全部介绍，感谢面试官的聆听。</p><p>Dear interviewer, I am Yang Shunjie, a software engineering major from Beijing Jiaotong University. The position I want to interview is the internship of a test engineer. I studied hard during the university and achieved good results in software testing, quality assurance, project management and other relevant courses. In the second-hand trading platform project, I have used selenium, an automated testing tool, to conduct simple tests on web pages, and learned about the positioning properties of selenium elements and mouse control. At the same time, I took charge of an innovation and entrepreneurship project for college students as the person in charge, made overall planning, and was awarded the national project. In my spare time, I also actively participated in the tutor project. Choose the direction of test optimization, design **DiKlee: A defect Prediction-guided test case generation method ** and write a paper, which is currently in the process of submission. These experiences also give me some understanding of testing, and I have a great interest in it. Meanwhile, I am patient, love communication and insist on learning, which is a good match for the position of testing. That’s all for my introduction. Thank you for your listening.</p><h2 id="自我评价"><a href="#自我评价" class="headerlink" title="自我评价"></a>自我评价</h2><p>能够较为熟练运用python完成项目，对软件测试理论有较为全面的了解，对于自动化测试工具selseleenium有了解及简单的应用，同时较为有耐心、热爱沟通、坚持学习，热爱测试这一岗位。</p><p><img src="/%E6%B5%8B%E8%AF%95%E9%9D%A2%E8%AF%95%E5%B9%B2%E8%B4%A7.assets/1673839050294.png" alt="1673839050294"></p><h2 id="一、-测试流程"><a href="#一、-测试流程" class="headerlink" title="一、 测试流程"></a><strong>一、 测试流程</strong></h2><h3 id="1-软件测试的基本流程有哪些？"><a href="#1-软件测试的基本流程有哪些？" class="headerlink" title="1.软件测试的基本流程有哪些？"></a><strong>1.软件测试的基本流程有哪些？</strong></h3><p>需求分析、编写测试用例、评审测试用例、搭建环境、等待程序开发包、部署程序开发包、冒烟测试、执行具体的测试用例细节、Bug 跟踪处理回归测试、N 轮之后满足需求，测试结束</p><h3 id="2-测试结束的标准是什么？"><a href="#2-测试结束的标准是什么？" class="headerlink" title="2.测试结束的标准是什么？"></a><strong>2.测试结束的标准是什么？</strong></h3><p>第一类标准：测试超过了预定时间，则停止测试。</p><p>第二类标准：执行了所有的测试用例，但并没有发现故障，则停止测试。</p><p>第三类标准：使用特定的测试用例设计方案作为判断测试停止的基础</p><p>第四类标准：正面指出停止测试的具体要求，即停止测试的标准可定义为查出某一预订数目的故障。</p><p>第五类标准：根据单位时间内查出故障的数量决定是否停止测试</p><h3 id="3-软件测试的原则是什么？"><a href="#3-软件测试的原则是什么？" class="headerlink" title="3.软件测试的原则是什么？"></a><strong>3.软件测试的原则是什么？</strong></h3><ol><li><p>应当把“尽早地和不断地进行软件测试”作为软件开发者的座右铭。</p></li><li><p>测试用例应由测试输入数据和对应的预期输出结果这两部分组成。</p></li><li><p>程序员应避免检查自己的程序。</p></li><li><p>在设计测试用例时，应包括合理的输入条件和不合理的输入条件。</p></li><li><p>软件测试的原则</p></li></ol><p>sum &#x3D; 0</p><p>for i in range(1,101):</p><p>​sum &#x3D; sum + i</p><p>print(sum)</p><ol start="6"><li><p>充分注意测试中的群集现象。 经验表明，测试后程序中残存的错误数目与该程序中已发现的错误数目成正比。</p></li><li><p>严格执行测试计划，排除测试的随意性。</p></li><li><p>应当对每一个测试结果做全面检查。</p></li><li><p>妥善保存测试计划，测试用例，出错统计和最终分析报告，为维护提供方便。</p></li></ol><h2 id="二、-用例设计"><a href="#二、-用例设计" class="headerlink" title="二、 用例设计"></a><strong>二、 用例设计</strong></h2><h3 id="1-什么是测试用例，测试用例的基本要素？"><a href="#1-什么是测试用例，测试用例的基本要素？" class="headerlink" title="1.什么是测试用例，测试用例的基本要素？"></a><strong>1.什么是测试用例，测试用例的基本要素？</strong></h3><p>测试用例是为某个特殊目标而编制的一组测试输入、执行条件以及预期结果，以便测试某个程序路径或核实是否满足某个特定需求。</p><p>测试用例的基本元素： 测试索引，测试环境，测试输入，测试操作，预期结果，评价标准。</p><h3 id="2-描述测试用例设计的完整过程？"><a href="#2-描述测试用例设计的完整过程？" class="headerlink" title="2.描述测试用例设计的完整过程？"></a><strong>2.描述测试用例设计的完整过程？</strong></h3><p>首先根据需求文档、概要设计、测试计划、测试方案细分出各功能模块的测试项</p><p>再根据各测试项，按照概要设计、详细设计以及测试方案中测试的覆盖率细分出测试子项</p><p>最后按照测试子项、根据测试用例的设计方法（因果图、边界值、等价类等的设计方法）书写测试用例。</p><p><strong>注意</strong></p><ul><li>选用适合的用例管理工具（如 word，excel）</li><li>用例一定要及时更新（补充新的想法，删除过时的需求）</li><li>做好用例分级</li><li>做好用例评审，写用例之前可以征询相关人员的意见，如果评审通过可以参考其执行测试，如果未通过， 需要继续修改直到通过为止。</li><li>可以考虑结对编写，这个是不错的主意</li><li>要全面，包括功能、性能、兼容性、安全性、易用性、容错性等等</li><li>注意把握适当的颗粒度</li></ul><h3 id="3-好的测试用例有哪些特点？"><a href="#3-好的测试用例有哪些特点？" class="headerlink" title="3.好的测试用例有哪些特点？"></a><strong>3.好的测试用例有哪些特点？</strong></h3><p>质量属性：</p><ul><li>正确性：确保测试标题描述部分的内容正确性。</li><li>经济性：只为确定需要的目的设计相应的测试步骤。</li><li>可重复性：自我一致性，即不管谁执行此用例，结果一样。</li><li>适应性：既能适应短期需要，又能考虑长远需要。</li><li>可追踪性：用例能追踪到一个具体的需求。</li><li>自我清理性：单个用例不会影响整个测试环境，即用例执行完了可以恢复原有的测试环境。</li></ul><p><strong>结构化和可测试性</strong></p><ul><li>含有规范的测试标题和编号。</li><li>含有一个确定的测试某一个特定需求的目的。</li><li>含有关于测试方法的描述。</li><li>指定条件信息-环境、数据、预置的条件测试、安全入口等。</li><li>含有操作步骤和预期结果。</li><li>陈述任何辅助证据，例如截图报告并确保这些东西妥善保存。</li><li>确保测试环境的干净（即用例不会影响整个环境）。</li><li>描述时使用主动语气结构。</li><li>操作步骤不要超过 15 步。</li><li>确保单个用例测试执行时用时不超过 20 分钟。</li><li>自动化脚本用例添加必要的注释，比如目的、输入和期望结果。</li><li>如果可能，建议提供可选择性的预置条件测试。</li><li>用例之间的先后顺序是否跟业务流程一致，即用例在业务流程中的彼此顺序关系是否合理。</li></ul><p><strong>配置管理：</strong></p><ul><li>采用命名和编号规范归档。</li><li>保存为特定的格式，文件类型。</li><li>用例版本是否与当前被测试软件版本一致（对应）。</li><li>包含用例需要的相应测试对象，如特定数据库。</li><li>存档阅读。</li><li>存档时按角色控制访问方式</li><li>当网络备份时存档。</li><li>离线归档</li></ul><h3 id="4-写测试用例时要注意什么问题"><a href="#4-写测试用例时要注意什么问题" class="headerlink" title="4.写测试用例时要注意什么问题"></a><strong>4.写测试用例时要注意什么问题</strong></h3><p>1、复用率：如果随着产品不停得升级，需要设计的详细些，追求一劳永逸；仅使用一两次，则没有必要设计的过于详细；</p><p>2、项目进展：项目时间如果允许可以设计的详细些，反之则能执行即可；</p><p>3、使用对象：测试用例如果供多人使用，尤其让后参加测试的工程师来执行，则需要设计的详细些。</p><p>4、用例的冗余</p><p>5、操作步骤要细分简明，可执行</p><h3 id="5-如何在有限的情况下提高测试效率，保证产品的上线质量？"><a href="#5-如何在有限的情况下提高测试效率，保证产品的上线质量？" class="headerlink" title="5.如何在有限的情况下提高测试效率，保证产品的上线质量？"></a><strong>5.如何在有限的情况下提高测试效率，保证产品的上线质量？</strong></h3><p>1、一个详细合理的详细的测试计划</p><p>2、测试尽早的介入项目，连接项目的业务需求，做好测试的前期准备</p><p>3、对测试项目前景充满信心，调整最佳心态，保持愉悦的工作心情</p><p>4、提高测试接受的标准，减少测试版本的送测次数</p><h3 id="6-如何降低漏测率"><a href="#6-如何降低漏测率" class="headerlink" title="6.如何降低漏测率"></a><strong>6.如何降低漏测率</strong></h3><p>1、需求评审</p><p>2、梳理需求，尽早与开发人员、需求人员进行需求确认，统一不同角色对需求的认识</p><p>3、用例设计及评审</p><p>4、测试执行</p><p>5、bug 回归</p><p>6、发布前的功能回归</p><h3 id="7-测试用例的基本设计方法"><a href="#7-测试用例的基本设计方法" class="headerlink" title="7.测试用例的基本设计方法"></a><strong>7.测试用例的基本设计方法</strong></h3><p>1、等价类划分法</p><p>2、边界值分析法</p><p>3、错误推断法</p><p>4、因果图判定表法</p><p>5、正交实验法</p><p>6、流程法</p><p>7、场景法</p><h3 id="8-测试为什么要写测试用例"><a href="#8-测试为什么要写测试用例" class="headerlink" title="8.测试为什么要写测试用例"></a><strong>8.测试为什么要写测试用例</strong></h3><p>1、深入了解需求的过程</p><p>2、测试执行的指导</p><p>3、规划测试数据的准备</p><p>4、反应测试进度</p><p>5、举一反三发现隐藏缺陷</p><p>6、分析缺陷标准</p><h2 id="三、-缺陷-bug"><a href="#三、-缺陷-bug" class="headerlink" title="三、 缺陷 bug"></a><strong>三、 缺陷 bug</strong></h2><h3 id="1-什么是缺陷报告，缺陷报告的作用，缺陷报告的要点"><a href="#1-什么是缺陷报告，缺陷报告的作用，缺陷报告的要点" class="headerlink" title="1.什么是缺陷报告，缺陷报告的作用，缺陷报告的要点"></a><strong>1.什么是缺陷报告，缺陷报告的作用，缺陷报告的要点</strong></h3><p>(1)缺陷报告是描述软件缺陷现象和重现步骤的集合。<a href="https://www.zhihu.com/search?q=%E8%BD%AF%E4%BB%B6%E7%BC%BA%E9%99%B7%E6%8A%A5%E5%91%8A&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2528417467%7D">软件缺陷报告</a> Software Bug Report(SBR)或软件问题报告 software Problem Report(SPR)。</p><p>(2)缺陷报告是<a href="https://www.zhihu.com/search?q=%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%BA%BA%E5%91%98&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2528417467%7D">软件测试人员</a>的工作成果之一，体现软件测试的价值缺陷报告可以把软件存在的缺陷准确的描述</p><p>出来，便于开发人员修正缺陷报告可以反映项目&#x2F;产品当前的质量状态，便于项目整体进度和质量控制软件测试缺陷</p><p>报告是软件测试的输出成果之一，可以衡量测试人员的工作能力。</p><p>(3)标题(Title)简洁、准确、完整、反映缺陷本质、方便查询前缀+标题正文，标题正文采用结果和动作，或者现象和位置的方式表达；步骤(Steps)可复现、完整、简洁、准确按数字编号；实际结果(Actual results)准确、详细描述软件的现象和特征；期望结果(Expected results)准确、丰富、有理有据；平台(Platforms)准确；截图 (Sereenshots)准确反映缺陷特征；注释(Notes)关于缺陷的辅助说明</p><h3 id="2-软件测试缺陷报告的-5C-原则"><a href="#2-软件测试缺陷报告的-5C-原则" class="headerlink" title="2.软件测试缺陷报告的 5C 原则"></a><strong>2.软件测试缺陷报告的 5C 原则</strong></h3><p>Correct（准确）：每个组成部分的描述准确，不会引起误解；</p><p>Clear（清晰）：每个组成部分的描述清晰，易于理解；</p><p>Concise（简洁）：只包含必不可少的信息，不包括任何多余的内容；</p><p>Complete（完整）：包含复现该缺陷的完整步骤和其他本质信息；</p><p>Consistent（一致）：按照一致的格式书写全部缺陷报告。</p><h3 id="3-测试为什么要写测试用例"><a href="#3-测试为什么要写测试用例" class="headerlink" title="3.测试为什么要写测试用例"></a><strong>3.测试为什么要写测试用例</strong></h3><p>1、深入了解需求的过程</p><p>2、测试执行的指导</p><p>3、规划测试数据的准备</p><p>4、反应测试进度</p><p>5、举一反三发现隐藏缺陷</p><p>6、分析缺陷标准</p><h2 id="四、-缺陷-bug"><a href="#四、-缺陷-bug" class="headerlink" title="四、 缺陷 bug"></a><strong>四、 缺陷 bug</strong></h2><h3 id="1-什么是缺陷报告，缺陷报告的作用，缺陷报告的要点-1"><a href="#1-什么是缺陷报告，缺陷报告的作用，缺陷报告的要点-1" class="headerlink" title="1.什么是缺陷报告，缺陷报告的作用，缺陷报告的要点"></a><strong>1.什么是缺陷报告，缺陷报告的作用，缺陷报告的要点</strong></h3><p>(1)缺陷报告是描述软件缺陷现象和重现步骤的集合。软件缺陷报告 Software Bug Report(SBR)或软件问题报</p><p>告 software Problem Report(SPR)。</p><p>(2)缺陷报告是软件测试人员的工作成果之一，体现软件测试的价值缺陷报告可以把软件存在的缺陷准确的描述</p><p>出来，便于开发人员修正缺陷报告可以反映项目&#x2F;产品当前的质量状态，便于项目整体进度和质量控制软件测试缺陷</p><p>报告是软件测试的输出成果之一，可以衡量测试人员的工作能力。</p><p>(3)标题(Title)简洁、准确、完整、反映缺陷本质、方便查询前缀+标题正文，标题正文采用结果和动作，或者</p><p>现象和位置的方式表达；步骤(Steps)可复现、完整、简洁、准确按数字编号；实际结果(Actual results)准确、详</p><p>细描述软件的现象和特征；期望结果(Expected results)准确、丰富、有理有据；平台(Platforms)准确；截图</p><p>(Sereenshots)准确反映缺陷特征；注释(Notes)关于缺陷的辅助说明</p><h3 id="2-软件测试缺陷报告的-5C-原则-1"><a href="#2-软件测试缺陷报告的-5C-原则-1" class="headerlink" title="2.软件测试缺陷报告的 5C 原则"></a><strong>2.软件测试缺陷报告的 5C 原则</strong></h3><p>Correct（准确）：每个组成部分的描述准确，不会引起误解；</p><p>Clear（清晰）：每个组成部分的描述清晰，易于理解；</p><p>Concise（简洁）：只包含必不可少的信息，不包括任何多余的内容；</p><p>Complete（完整）：包含复现该缺陷的完整步骤和其他本质信息；</p><p>Consistent（一致）：按照一致的格式书写全部缺陷报告。</p><h3 id="3-软件缺陷的生命周期？"><a href="#3-软件缺陷的生命周期？" class="headerlink" title="3.软件缺陷的生命周期？"></a><strong>3.软件缺陷的生命周期？</strong></h3><p>![img](data:image&#x2F;svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='722' height='368'></svg>)</p><p>测试人员提交新的 Bug 入库，错误状态为 New。</p><p>高级测试人员验证错误，如果确认是错误，分配给相应的开发人员，设置状态为 Open。如果不是错误，则拒绝，设置为 Declined(拒绝)状态。</p><p>开发人员查询状态为 Open 的 Bug， 如果不是错误，则置状态为 Declined；如果是 Bug 则修复并置状态为 Fixed。不能解决的 Bug，要留下文字说明及保持 Bug 为 Open 状态。对于不能解决和延期解决的 Bug，不能由开发人员自己决定，一般要通过某种会议（评审会）通过才能认可。 测试人员查询状态为 Fixed 的 Bug，然后验证 Bug 是否已解决，如解决置 Bug 的状态为 Closed，如没有解决置状态为 Reopen。</p><h3 id="4-缺陷描述（报告单）中应该包括哪些内容？"><a href="#4-缺陷描述（报告单）中应该包括哪些内容？" class="headerlink" title="4.缺陷描述（报告单）中应该包括哪些内容？"></a><strong>4.缺陷描述（报告单）中应该包括哪些内容？</strong></h3><p>缺陷的标题，简要描述。缺陷的类型。缺陷的详细步骤描述。缺陷的实际结果。期望结果。有的缺陷需要上传</p><p>截图，日志信息。缺陷的等级。缺陷指派给开发同事。（开发主管）</p><h3 id="5-如何提高缺陷的记录质量？"><a href="#5-如何提高缺陷的记录质量？" class="headerlink" title="5.如何提高缺陷的记录质量？"></a><strong>5.如何提高缺陷的记录质量？</strong></h3><p>通用 UI 要统一、准确；尽量使用业界惯用的表达术语和表达方法；使用业界惯用的表达术语和表达方法，保证表达准确，体现专业化；每条缺陷报告只包括一个缺陷；不可重现的缺陷也要报告；明确指明缺陷类型；明确指明缺陷严重等级和优先等级；描述 (Description) ，简洁、准确，完整，揭示缺陷实质，记录缺陷或缺陷出现的位置；</p><p>短行之间使用自动数字序号，使用相同的字体、字号、行间距； 每一个步骤尽量只记录一个操作；确认步骤完整，准确，简短；根据缺陷，可选择是否进行图象捕捉； 检查拼写和语法缺陷；尽量使用短语和短句，避免复杂句型句式；缺陷描述内容。</p><h3 id="6-如果一个缺陷被提交后，开发人员认为不是问题，怎么处理？"><a href="#6-如果一个缺陷被提交后，开发人员认为不是问题，怎么处理？" class="headerlink" title="6.如果一个缺陷被提交后，开发人员认为不是问题，怎么处理？"></a><strong>6.如果一个缺陷被提交后，开发人员认为不是问题，怎么处理？</strong></h3><p>a)首先，将问题提交到缺陷管理库里面进行备案。</p><p>b)然后，要获取判断的依据和标准：</p><ul><li>v.根据需求说明书、产品说明、设计文档等，确认实际结果是否与计划有不一致的地方，提供缺陷是否确认的直接依据；</li><li>vi.如果没有文档依据，可以根据类似软件的一般特性来说明是否存在不一致的地方，来确认是否是缺陷；</li><li>vii.根据用户的一般使用习惯，来确认是否是缺陷；</li><li>viii.与设计人员、开发人员和客户代表等相关人员探讨，确认是否是缺陷；</li></ul><p>c)合理的论述，向测试经理说明自己的判断的理由，注意客观、严谨，不掺杂个人情绪。</p><p>d)等待测试经理做出最终决定，如果仍然存在争议，可以通过公司政策所提供的渠道，向上级反映，并有上级 做出决定。</p><h3 id="7-缺陷的优先级划分和描述"><a href="#7-缺陷的优先级划分和描述" class="headerlink" title="7.缺陷的优先级划分和描述"></a><strong>7.缺陷的优先级划分和描述</strong></h3><p>一般来说按照下面的来分，具体的是由每个公司而定。</p><p>软件缺陷有四种级别，分别为：致命的(Fatal)，严重的(Critical)，一般的(Major)，微小的(Minor)。</p><p>A 类—致命的软件缺陷(Fatal):造成系统或应用程序崩溃、死机、系统挂起，或造成数据丢失，主要功能完全丧失，导致本模块以及相关模块异常等问题。如代码错误，死循环，数据库发生死锁、与数据库连接错误或数据通讯错误， 未考虑异常操作，功能错误等</p><p>B 类—严重错误的软件缺陷（critical）：系统的主要功能部分丧失、数据不能保存，系统的次要功能完全丧失。</p><p>问题局限在本模块，导致模块功能失效或异常退出。如致命的错误声明，程序接口错误，数据库的表、业务规则、 缺省值未加完整性等约束条件</p><p>C 类—一般错误的软件缺陷（major）：次要功能没有完全实现但不影响使用。如提示信息不太准确，或用户界面差，操作时间长，模块功能部分失效等，打印内容、格式错误，删除操作未给出提示，数据库表中有过多的空字段等</p><p>D 类—较小错误的软件缺陷（Minor）</p><p>:使操作者不方便或遇到麻烦，但它不影响功能过的操作和执行，如错别字、 界面不规范（字体大小不统一，文字排列不整齐，可输入区域和只读区域没有明显的区分标志），辅助说明描述不清楚</p><p>E 类- 建议问题的软件缺陷（Enhancemental）：由问题提出人对测试对象的改进意见或测试人员提出的建议、质 疑。</p><h2 id="五、-测试实例"><a href="#五、-测试实例" class="headerlink" title="五、 测试实例"></a><strong>五、 测试实例</strong></h2><p><strong>1.一个有广告的纸杯子，请设计测试用例？</strong></p><p>测试项目：杯子</p><p>需求测试：查看杯子使用说明书</p><p>界面测试：查看杯子外观</p><p>功能度：用水杯装水看漏不漏；水能不能被喝到</p><p>安全性：杯子有没有毒或细菌</p><p>可靠性：杯子从不同高度落下的损坏程度</p><p>可移植性：杯子在不同的地方、温度等环境下是否都可以正常使用</p><p>兼容性：杯子是否能够容纳果汁、白水、酒精、汽油等</p><p>易用性：杯子是否烫手、是否有防滑措施、是否方便饮用</p><p>用户文档：使用手册是否对杯子的用法、限制、使用条件等有详细描述</p><p>疲劳测试：将杯子盛上水（案例一）放 24 小时检查泄漏时间和情况；盛上汽油（案例二）放 24 小时检查泄漏时间和情况等</p><p>压力测试：用根针并在针上面不断加重量，看压强多大时会穿透</p><p>跌落测试: 杯子加包装(有填充物),在多高的情况摔下不破损</p><p>震动测试: 杯子加包装(有填充物),六面震动,检查产品是否能应对恶劣的铁路\公路\航空运输</p><p>基本功能测试（逻辑功能测试）。</p><p>（1）硬度：是否达到设计标准。</p><p>装载能力：在杯子内分别装入少量的、半杯的、满杯的，看其装载量是否达到设计标准。</p><p>装载种类：开水（是否产生异味）、温水、冷水、冰水、咖啡…</p><p>（2）界面测试（UI 测试）。</p><p>看其形状、大小设计是否适合人方便拿起。</p><p>外观是否吸引人（广告嘛），赏心悦目。</p><p>带广告的图案沾水受是否掉色、模糊。</p><p>（3）<a href="https://www.zhihu.com/search?q=%E6%98%93%E7%94%A8%E6%80%A7%E6%B5%8B%E8%AF%95&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2528417467%7D">易用性测试</a>。</p><p>看其形状、大小设计是否适合人方便拿起。</p><p>残疾人士用此杯去喝水的容程度。</p><p>杯子设计是否上大下小，在运输过程中可以套在一起有效利用空间，在使用时也容易拿开。</p><p>（4）稳定性测试（24 X 7 测试）。装入液体后记录其多少以后漏水。</p><p>（5）安全性测试。杯子所用的材料（包括纸基、涂层和广告颜料）是否符合食品卫生标准，在内外温度等环境</p><p>因素下是否会与所盛各种饮料相反应，而产生对人体有害的物质。</p><p>（6）本地化测试。为国际化和本地化的需要，广告图案和文字是否在政治、宗教和文化方面具有广泛的适用性。</p><p>（7）对设计的改进建议。“如果是一次性杯子，能否标示已使用（比如变色）”和“杯子是否有使用者标贴（多 人使用时防止混淆）”。</p><h3 id="3-一个身份证号码输入框，怎么设计用例？"><a href="#3-一个身份证号码输入框，怎么设计用例？" class="headerlink" title="3.一个身份证号码输入框，怎么设计用例？"></a><strong>3.一个身份证号码输入框，怎么设计用例？</strong></h3><p>校验身份证号规则的有效性（包括地址码、生日期码、顺序码和校验码</p><p>校验 15 位身份证号和 18 位身份正好都是可用的</p><p>校验末位是 X 的情况</p><p>校验不足 15 位、16-17 位和大于 18 位的情况</p><p>如果是必输项，校验不输入的时候会不会有正确的提示</p><p>如果不是必输项，则要校验不输入的时候流程能否正常进行</p><p>校验输入非数字的情况，是否会有正确提示信息（包括大小写字母、汉字、特殊字符和标点符号）</p><p>校验输入全角的数字的时候，系统是否会识别（这个得根据需求确定是否可以使用全角的数字）</p><h3 id="3-登录功能怎么设计测试用例？"><a href="#3-登录功能怎么设计测试用例？" class="headerlink" title="3.登录功能怎么设计测试用例？"></a><strong>3.登录功能怎么设计测试用例？</strong></h3><p><strong>具体需求：</strong></p><p>有一个登录页面，有一个账号和一个密码输入框, 一个提交按钮。</p><p><strong>此题的考察目的：</strong></p><p>1、了解需求（测什么都是从了解需求开始）；</p><p>2、是否有设计 Test Case 的能力</p><p>3、是否熟悉各种测试方法；</p><p>4、是否有丰富的 Web 测试经验；</p><p>5、是否了解 Web 开发；</p><p>A B</p><p><strong>了解需求：</strong></p><p>1、登录界面应该是弹出窗口式的，还是直接在网页里面；</p><p>2、账号长度和密码的强度（比如需要多少位、大小写敏感、特殊字符混搭等）；</p><p>3、界面美观是否有特殊要求？（即是否要进行 UI 测试）；</p><p>4、····</p><p><strong>用例设计：</strong></p><p>测试需求分析完成后，开始用例设计，主要可以从以下几个方面考虑：</p><p><strong>功能测试(Function Test)</strong></p><p>1、输入正确的账号和密码，点击提交按钮，验证是否能正确登录。（正常输入）</p><p>2、输入错误的账号或者密码, 验证登录会失败，并且提示相应的错误信息。（错误校验）</p><p>3、登录成功后能否跳转到正确的页面（低）</p><p>4、账号和密码，如果太短或者太长，应该怎么处理（安全性，密码太短时是否有提示）</p><p>5、账号和密码，中有特殊字符（比如空格），和其他非英文的情况（是否做了过滤）</p><p>6、记住账号的功能</p><p>7、登录失败后，不能记录密码的功能</p><p>8、账号和密码前后有空格的处理</p><p>9、密码是否加密显示（星号圆点等）</p><p>10、牵扯到验证码的，还要考虑文字是否扭曲过度导致辨认难度大，考虑颜色（色盲使用者），刷新或换一个按 钮是否好用</p><p>11、登录页面中的注册、忘记密码，登出用另一帐号登录等链接是否正确</p><p>12、输入密码的时候，大写键盘开启的时候要有提示信息。</p><p>13、什么都不输入，点击提交按钮，看提示信息。（非空检查）</p><p><strong>界面测试(UI Test)</strong></p><p>1、布局是否合理，2 个 Testbox 和一个按钮是否对齐</p><p>2、Testbox 和按钮的长度，高度是否符合要求</p><p>3、界面的设计风格是否与 UI 的设计风格统一</p><p>4、界面中的文字简洁易懂，没有错别字。</p><p><strong>性能测试(Performance Test)</strong></p><p>1、打开登录页面，需要几秒</p><p>2 、输入正确的账号和密码后，登录成功跳转到新页面，不超过 5 秒</p><p><strong>安全性测试(Security Test)</strong></p><p>1、登录成功后生成的 Cookie 是否有 HttpOnly(降低脚本盗取风险)</p><p>2、账号和密码是否通过加密的方式，发送给 Web 服务器</p><p>3、账号和密码的验证，应该是用服务器端验证，而不能单单是在客户端用 javaScript 验证</p><p>4、账号和密码的输入框，应该屏蔽 SQL 注入攻击</p><p>5、账号和密码的输入框，应该禁止输入脚本（防止 XSS 攻击）</p><p>6、错误登录的次数限制（防止暴力破解）</p><p>7、考虑是否支持多用户在同一机器上登录；</p><p>8、考虑一用户在多台机器上登录</p><p><strong>可用性测试(Usability Test)</strong></p><p>1、是否可以全用键盘操作，是否有快捷键</p><p>2、输入账号，密码后按回车，是否可以登录</p><p>3、输入框是否可以以 Tab 键切换</p><p><strong>兼容性测试（Compatibility Test）</strong></p><p>1、主流的浏览器下能否显示正常已经功能正常（IE6~11, FireFox, Chrome, Safari 等 ）</p><p>2、不同的平台是否能正常工作，比如 Windows, Mac</p><p>3、移动设备上是否正常工作，比如 iPhone, Android</p><p>4、不同的分辨率</p><p><strong>本地化测试 （Localization Test）</strong></p><p>1、不同语言环境下，页面的显示是否正确。</p><p>软件辅助性测试 （Accessibility Test）</p><p>软件辅助功能测试是指测试软件是否向残疾用户提供足够的辅助功能</p><p>1、高对比度下能否显示正常（视力不好的人使用）</p><h3 id="4-移动端和-web-端测试有什么区别"><a href="#4-移动端和-web-端测试有什么区别" class="headerlink" title="4.移动端和 web 端测试有什么区别"></a><strong>4.移动端和 web 端测试有什么区别</strong></h3><p>单纯从功能测试的层面上来讲的话，APP 测试、web 测试 在流程和功能测试上是没有区别的。</p><p>根据两者载体不一样，则区别如下：</p><p>系统结构方面</p><p>web 项目，b&#x2F;s 架构，基于浏览器的；web 测试只要更新了服务器端，客户端就会同步会更新。</p><p>app 项目，c&#x2F;s 结构的，必须要有客户端；app 修改了服务端，则客户端用户所有核心版本都需要进行回归</p><p>测试一遍。</p><p>性能方面</p><p>web 项目</p><p>需监测 响应时间、CPU、Memory</p><p>app 项目</p><p>除了监测 响应时间、CPU、Memory 外，还需监测 流量、电量等</p><p>兼容方面</p><p>（1）web 项目：</p><p>\1. 浏览器（火狐、谷歌、IE 等）</p><p>\2. 操作系统（Windows7、Windows10、Linux 等）</p><p>（2）app 项目：</p><p>\1. 设备系统:iOS（ipad、iphone）、Android（三星、华为、联想等） 、Windows（Win7、Win8）、 OSX（Mac）</p><p>\2. 手机设备可根据 手机型号、分辨率不同</p><p>相对于 Wed 项目，APP 有专项测试</p><p>\1. 干扰测试：中断，来电，短信，关机，重启等</p><p>\2. 弱<a href="https://www.zhihu.com/search?q=%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2528417467%7D">网络测试</a>（模拟 2g、3g、4g，wifi 网络状态以及丢包情况）；网络切换测试（网络断开后重连、3g 切换到 4g&#x2F;wifi 等）</p><p>\3. 安装、更新、卸载</p><p>安装：需考虑安装时的中断、弱网、安装后删除安装文件等情况</p><p>卸载：需考虑 卸载后是否删除 app 相关的文件</p><p>更新：分强制更新、非强制更新、增量包更新、断点续传、弱网状态下更新<br>\4. 界面操作：关于手机端测试，需注意手势，横竖屏切换，多点触控，前后台切换</p><p>\5. 安全测试：安装包是否可反编译代码、安装包是否签名、权限设置，例如访问通讯录等</p><p>\6. 边界测试：可用存储空间少、没有 SD 卡&#x2F;双 SD 卡、飞行模式、系统时间有误、第三方依赖（QQ、微信 登录）等</p><p>\7. 权限测试：设置某个 App 是否可以获取该权限，例如是否可访问通讯录、相册、照相机等</p><p>测试工具方面</p><p>自动化工具：APP 一般使用 Appium; Web 一般使用 Selenium</p><p>性能测试工具：APP 一般使用 JMeter; Web 一般使用 LR、JMeter</p><h3 id="5-测试一个-C-x2F-S-客户端时，需要考虑的因素"><a href="#5-测试一个-C-x2F-S-客户端时，需要考虑的因素" class="headerlink" title="5.测试一个 C&#x2F;S 客户端时，需要考虑的因素"></a><strong>5.测试一个 C&#x2F;S 客户端时，需要考虑的因素</strong></h3><p>客户端安装测试</p><p>客户端升级测试</p><p>客户端可维护性测试</p><p>（1）个体的<a href="https://www.zhihu.com/search?q=%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BA%94%E7%94%A8&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2528417467%7D">客户端应用</a>以“分离的”模式被测试——不考虑服务器和底层网络的运行；</p><p>（2）客户端软件和关联的服务器端应用被一起测试，但网络运行不被明显的考虑；</p><p>（3）完整的 C&#x2F;S 体系结构，包括网络运行和性能被测试。</p><p>应用功能测试——客户端应用被独立地执行，以揭示在其运行中的错误。</p><p>服务器测试——测试服务器的协调和数据管理功能，也考虑服务器性能（整体反映时间和数据吞吐量）。</p><p><a href="https://www.zhihu.com/search?q=%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B5%8B%E8%AF%95&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2528417467%7D">数据库测试</a>——测试服务器存储的数据的精确性和完整性，检查客户端应用提交的事务，以保证数据被正确地 存储、更新和检索。</p><p>事务测试——创建一系列的测试以保证每类事务被按照需求处理。测试着重于处理的正确性，也关注性能问题。</p><p>网络通信测试——这些测试验证网络节点间的通信正常地发生，并且消息传递、事务和相关的网络交通无错的 发生</p><h3 id="6-测试电梯，请详细描述"><a href="#6-测试电梯，请详细描述" class="headerlink" title="6.测试电梯，请详细描述"></a><strong>6.测试电梯，请详细描述</strong></h3><p><strong>如果给你一台电梯，请问你如何测试它，分析如下：</strong></p><p>1.功能：上升、下降、停止、开门、关门、梯内电话、灯光、指示灯等；</p><p>2.性能：速度、反应时间、关门时间等；</p><p>3.压力：超载、尖锐物碰撞电梯壁等；</p><p>4.安全：停电、报警装置、轿箱停靠位置、有人扒门时的情况等；</p><p>5.可用性：按键高度、操作是否方便、舒适程度等；</p><p>6.UI：美观程度、光滑程度、形状、质感等；</p><p>7.稳定性：长时间运行情况等；</p><p>8.兼容性：不同电压是否可工作、不同类型电话是否可安装等。其实在简单分析的过程中，发现许多东西根本</p><p>测试不全，比如电话、灯光、材质、调度程序、可维修性等，当发现在一个用例中无法说清楚时，这些应该拆分开</p><p>来分别测试。可以告诉主考官，你需要模块化地测试电话、灯光等。再有在一起的组装测试。</p><p><strong>下面是详细的测试点：</strong></p><p>需求测试：查看电梯使用说明书、安全说明书等</p><p>界面测试：查看电梯外观</p><p>功能测试：1.测试电梯能否实现正常的上升和下降功能。</p><p>2.电梯的按钮是否都可以使用。</p><p>3.电梯门的打开，关闭是否正常。</p><p>4.报警装置是否可用。</p><p>5.与其他电梯之间是否协作良好。</p><p>6.通风状况如何。</p><p>7.突然停电时的情况。</p><p>8.上升途中的响应。<br>1）电梯本来在 1 楼，如果有人按 18 楼，那么电梯在上升到 5 楼的时候，有人按了 10 楼， 这时候是否会在 10 楼先停下来</p><p>2）电梯下降到 10 层时显示满员，此时若 8 层有人等待电梯，是否在 8 层停。</p><p>9.是否有手机信号</p><p>可靠性测试：</p><p>1.门关上的一刹那出现障碍物。</p><p>2.同时按关门和开门按钮。</p><p>3.点击当前楼层号码</p><p>4.多次点击同一楼层号码</p><p>5.同时按上键和下键</p><p>易用性：电梯的按钮的设计符合一般人的习惯吗</p><p>用户文档：使用手册是否对电梯的用法、限制、使用条件等有详细的描述</p><p>压力测试：1.看电梯的最大承重量，在负载过重时报警装置是否有提醒</p><p>稳定性测试：看垫底在最大负载下平行运行的最长时间</p><h3 id="7-对一只圆珠笔进行测试"><a href="#7-对一只圆珠笔进行测试" class="headerlink" title="7.对一只圆珠笔进行测试"></a><strong>7.对一只圆珠笔进行测试</strong></h3><p>1.界面测试，无论我们做那类软件（嵌入式别提），只要给用户有看到的东西，从测试的角度，就要考虑界面测试，这个呢，现在针对微软的产品，某公司开发了一套界面检查表，我这里有一份，想要可以找我</p><p>界面测试测什么，怎么测呢？针对这个问题我是这样回答的，印刷在产品上的图片，文字，这可能涉及不同的 东西，有圆珠笔厂家的信息，也有针对不同用户的信息（譬如小孩子喜欢颜色搭配多一点的，而成人用稳重的产品 等），可能涉及的还有人的审美观，你圆珠笔色彩搭配之类的</p><p>2.功能测试，这是我们测试的重点，也是客户针对某家公司产品给出满意度的参考点，圆珠笔功能主要是书写， 这里面涉及一个功用方面的焦点——书写的快慢程度，也就是流利不流利的问题（这涉及笔芯的材质问题） 针对这方面的测试，个人认为应从以下几点</p><p>a.材质问题，这涉及程序员和用户之间的关系，两者利益均有，程序员考虑成本问题，用户考虑污染问题，也 就是说制作圆珠笔的材料与环境的问题，厂商考虑价格因素，用户考虑环境因素以及安全性因素 这就把安全性测试给说出来了，大的方面因为笔油材质的问题，和使用者之间的健康问题有联系， 要测小的方面，笔油的速率，以及书写后是否马上可以涂抹，可否修改，这都涉及安全性的问题</p><p>b.性能问题，温度，湿度，气压对笔芯产生不同的影响</p><p>3.安全性问题</p><p>测试不同的高度，笔身做自由落体损坏程度</p><p>4.兼容性问题</p><p>不同的笔筒和笔芯之间的互相兼容</p><p>5.强度测试</p><p>弹簧在不同的压力之下，承受变形的程度</p><p>6.在金山面试时候，考官特意问我针对笔芯那个米珠如何测试</p><p>或者</p><p>1、界面测试</p><p>界面测试也就是对其外表先进行判断。</p><p>尺寸是否适合用户使用？用户需要的是什么样的尺寸，小孩和成年人使用的尺寸是有区别的；</p><p>色彩搭配是否合理？形状是否美观？</p><p>是否方便携带和存放？</p><p>笔芯颜色是否与客户要求一致？</p><p>笔身印的 logo 或者文字是否这么正确</p><p>2、功能测试</p><p>笔筒开合；</p><p>笔芯替换；</p><p>出墨快慢；</p><p>笔头出墨粗细；</p><p>是不是可操作性签字笔；</p><p>3、性能测试</p><p>笔芯的寿命；</p><p>笔墨的气味；</p><p>写过的字用纸水浸透后，笔墨是否会晕开</p><p>压力测试：笔尖在多大压力范围内可以正常写字，不能正常出墨，太重损坏笔尖或纸张；</p><p>笔壳能在多大压力范围内正常使用？成人用力太重掰断笔壳，掉到地上易摔，能在纸上写出清晰的字</p><p>4、性能测试</p><p>握笔的地方纹路是否会硌手或太滑；</p><p>书写的流畅度；</p><p>写出的墨水多久能干；</p><p>高温和低温环境对笔芯出墨和笔壳的影响；</p><p>长时间不盖笔套，或笔盖盖多长时间不用，会不会对笔下次写字有影响</p><p>5、安全测试</p><p>笔墨是否有易燃性；</p><p>笔墨是否对皮肤有害；</p><p>笔杆折断，材质是否容易刮伤手；</p><p>误食笔芯是否会引起中毒（有小孩或者有人喜欢咬笔头）</p><p>6、兼容性测试</p><p>笔壳和笔芯是否能够很好的适应主流签字笔尺寸；</p><p>这个笔芯的笔尖如果损坏，换上其他的笔芯的笔尖是否能用；</p><p>这个笔芯的笔墨如果用完，换上其他笔芯的笔墨是否可以使用；</p><p>笔的笔墨如果在其他笔的笔墨上写字是否可以成功覆盖</p><p>7、其他测试</p><p>（1）比较测试</p><p>与其他品牌签字笔比较，优劣在哪些地方？</p><p>（2）场景测试</p><p>笔从高处摔到地上，笔尖是否会摔坏；</p><p>倒着写，是否可以写出很多字来；</p><p>扔到水里，笔墨会不会一直晕开；</p><p>笔在粗糙的纸上是否能写出字…</p><h3 id="8-请以微信点赞，功能点进行测试"><a href="#8-请以微信点赞，功能点进行测试" class="headerlink" title="8.请以微信点赞，功能点进行测试"></a><strong>8.请以微信点赞，功能点进行测试</strong></h3><p>\1. 功能测试</p><p>考虑功能是否符合预期</p><p>\2. 接口</p><p>考虑各内部和外部的接口，比如朋友圈客户端和服务端的交互接口的功能。朋友圈点赞功能和消息提示功能的</p><p>接口（点了赞之后对应的朋友收到提示信息）</p><p>\3. 平台</p><p>手机版 pad 版 web 版</p><p>\4. 用户操作场景</p><p>测试用户常用场景，比如：用户打开微信看到十条消息提示，点击后进入朋友圈界面显示了“谁谁谁点了赞”</p><p>\5. 速度、延迟</p><p>\6. 性能测试</p><p>模拟一些多用户并发操作的场景</p><p>\7. 安全</p><p>功能 易用 效率 可靠性 可维护性</p><h2 id="六、-Linux-基础"><a href="#六、-Linux-基础" class="headerlink" title="六、 Linux 基础"></a>六、 <strong>Linux 基础</strong></h2><h3 id="1-查看占用-CPU-使用率最高的进程？"><a href="#1-查看占用-CPU-使用率最高的进程？" class="headerlink" title="1.查看占用 CPU 使用率最高的进程？"></a><strong>1.查看占用 CPU 使用率最高的进程？</strong></h3><p>ps -aux | sort -k3nr | head -K</p><h3 id="2-如何查看一个文件的末尾-50-行？"><a href="#2-如何查看一个文件的末尾-50-行？" class="headerlink" title="2.如何查看一个文件的末尾 50 行？"></a><strong>2.如何查看一个文件的末尾 50 行？</strong></h3><p>查看&#x2F;etc&#x2F;profile 的前 10 行内容，应该是：</p><p># head -n 10 &#x2F;etc&#x2F;profile</p><p>查看&#x2F;etc&#x2F;profile 的最后 50 行内容，应该是：</p><p># tail -n 50 &#x2F;etc&#x2F;profile</p><h3 id="3-如何过滤文件内容中包含”ERROR“的行？"><a href="#3-如何过滤文件内容中包含”ERROR“的行？" class="headerlink" title="3.如何过滤文件内容中包含”ERROR“的行？"></a><strong>3.如何过滤文件内容中包含”ERROR“的行？</strong></h3><p>grep “ERROR” file_name</p><p>cat file_name | grep “ERROR”</p><h3 id="4-查看某端口号？"><a href="#4-查看某端口号？" class="headerlink" title="4.查看某端口号？"></a><strong>4.查看某端口号？</strong></h3><p>netstat -anp | grep port_number</p><h3 id="5-查看某进程号？"><a href="#5-查看某进程号？" class="headerlink" title="5.查看某进程号？"></a><strong>5.查看某进程号？</strong></h3><p>ps -ef | grep ps_name</p><p>ps -ef | grep ps_number</p><h3 id="3-rep-和-find-的区别？grep-都有哪些用法？"><a href="#3-rep-和-find-的区别？grep-都有哪些用法？" class="headerlink" title="3.rep 和 find 的区别？grep 都有哪些用法？"></a><strong>3.rep 和 find 的区别？grep 都有哪些用法？</strong></h3><h3 id="4-查看-IP-地址？"><a href="#4-查看-IP-地址？" class="headerlink" title="4.查看 IP 地址？"></a><strong>4.查看 IP 地址？</strong></h3><p>ifconfig</p><h3 id="5-创建和删除一个多级目录？"><a href="#5-创建和删除一个多级目录？" class="headerlink" title="5.创建和删除一个多级目录？"></a><strong>5.创建和删除一个多级目录？</strong></h3><p>mkdir -p .&#x2F;a&#x2F;b</p><p>rm -rf .&#x2F;a</p><h3 id="6-在当前用户家目录中查找-haha-txt-文件？"><a href="#6-在当前用户家目录中查找-haha-txt-文件？" class="headerlink" title="6.在当前用户家目录中查找 haha.txt 文件？"></a><strong>6.在当前用户家目录中查找 haha.txt 文件？</strong></h3><p>find ~&#x2F; -name haha.txt</p><h3 id="7-如何查询出-tomcat-的进程并杀掉这个进程，写出-linux-命令？"><a href="#7-如何查询出-tomcat-的进程并杀掉这个进程，写出-linux-命令？" class="headerlink" title="7.如何查询出 tomcat 的进程并杀掉这个进程，写出 linux 命令？"></a><strong>7.如何查询出 tomcat 的进程并杀掉这个进程，写出 linux 命令？</strong></h3><p>ps -ef | grep tomcat</p><p>kill -9 tomcat_port</p><h3 id="8-动态查看日志文件？"><a href="#8-动态查看日志文件？" class="headerlink" title="8.动态查看日志文件？"></a><strong>8.动态查看日志文件？</strong></h3><p>tail -f log_file</p><h3 id="9-查看系统硬盘空间的命令？"><a href="#9-查看系统硬盘空间的命令？" class="headerlink" title="9.查看系统硬盘空间的命令？"></a><strong>9.查看系统硬盘空间的命令？</strong></h3><p>df -aTh</p><h3 id="10-查看当前机器-listen-的所有端口？"><a href="#10-查看当前机器-listen-的所有端口？" class="headerlink" title="10.查看当前机器 listen 的所有端口？"></a><strong>10.查看当前机器 listen 的所有端口？</strong></h3><p>netstat -tlnp</p><h3 id="11-把一个文件夹打包压缩成-tar-gz-的命令，以及解压拆包-tar-gz-的命令？"><a href="#11-把一个文件夹打包压缩成-tar-gz-的命令，以及解压拆包-tar-gz-的命令？" class="headerlink" title="11.把一个文件夹打包压缩成.tar.gz 的命令，以及解压拆包.tar.gz 的命令？"></a><strong>11.把一个文件夹打包压缩成.tar.gz 的命令，以及解压拆包.tar.gz 的命令？</strong></h3><p>tar zcvf xxx.tar.gz file tar zxvf xxx.tar.gz</p><h3 id="12-Xshell-工具如果想要实现从服务器上传或者下载文件的话-可以在服务器上安装什么包？"><a href="#12-Xshell-工具如果想要实现从服务器上传或者下载文件的话-可以在服务器上安装什么包？" class="headerlink" title="12.Xshell 工具如果想要实现从服务器上传或者下载文件的话,可以在服务器上安装什么包？"></a><strong>12.Xshell 工具如果想要实现从服务器上传或者下载文件的话,可以在服务器上安装什么包？</strong></h3><p>lrzsz</p><h3 id="13-以-x2F-etc-x2F-passwd-的前五行内容为例，提取用户名？"><a href="#13-以-x2F-etc-x2F-passwd-的前五行内容为例，提取用户名？" class="headerlink" title="13.以&#x2F;etc&#x2F;passwd 的前五行内容为例，提取用户名？"></a><strong>13.以&#x2F;etc&#x2F;passwd 的前五行内容为例，提取用户名？</strong></h3><p>cat &#x2F;etc&#x2F;passwd | head -n 5 | cut -d : -f 1</p><h3 id="14-在-linux-中-find-和-grep-的区别？"><a href="#14-在-linux-中-find-和-grep-的区别？" class="headerlink" title="14.在 linux 中 find 和 grep 的区别？"></a><strong>14.在 linux 中 find 和 grep 的区别？</strong></h3><p>Linux 系统中 grep 命令是一种强大的<a href="https://www.zhihu.com/search?q=%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2%E5%B7%A5%E5%85%B7&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2528417467%7D">文本搜索工具</a>，它能使用正则表达式搜索文本，并把匹配的行打印出来。</p><p>grep 全称是 Global Regular Expression Print，表示全局正则表达式版本，它的使用权限是所有用户。</p><p>linux 下的 find：</p><p>功能：在目录结构中搜索文件，并执行指定的操作。此命令提供了相当多的查找条件，功能很强大。</p><p>语法：find 起始目录寻找条件操作说明：find 命令从指定的起始目录开始，递归地搜索其各个子目录，查找满 足寻找条件的文件并对之采取相关的操作。</p><p>简单点说说，grep 是查找匹配条件的行，find 是搜索匹配条件的文件。</p><h2 id="七、-Mysql-基础"><a href="#七、-Mysql-基础" class="headerlink" title="七、 Mysql 基础"></a>七、 <strong>Mysql 基础</strong></h2><p><strong>一、 基础知识</strong></p><h3 id="1-什么是数据库？"><a href="#1-什么是数据库？" class="headerlink" title="1. 什么是数据库？"></a><strong>1. 什么是数据库？</strong></h3><p>数据库(Database)是按照数据结构来组织、存储和管理数据的仓库</p><h3 id="2-什么是关系型数据库，主键，外键，索引分别是什么？"><a href="#2-什么是关系型数据库，主键，外键，索引分别是什么？" class="headerlink" title="2. 什么是关系型数据库，主键，外键，索引分别是什么？"></a><strong>2. 什么是关系型数据库，主键，外键，索引分别是什么？</strong></h3><p>关系型数据库是由多张能互相联接的二维行列表格组成的数据库</p><p>主关键字(primary key)是表中的一个或多个字段，它的值用于唯一地标识表中的某一条记录外键表示了两个关系之间的相关联系。以另一个关系的外键作主关键字的表被称为主表，具有此外键的表被称 为主表的从表。外键又称作外关键字</p><p>在关系数据库中，索引是一种单独的、物理的对数据库表中一列或多列的值进行排序的一种存储结构，它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单</p><h3 id="3-表的连接查询方式有哪些，有什么区别？"><a href="#3-表的连接查询方式有哪些，有什么区别？" class="headerlink" title="3. 表的连接查询方式有哪些，有什么区别？"></a><strong>3. 表的<a href="https://www.zhihu.com/search?q=%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2528417467%7D">连接查询</a>方式有哪些，有什么区别？</strong></h3><p>交叉连接即笛卡儿乘积，是指两个关系中所有元组的任意组合使用内连接时，如果两个表的相关字段满足连接条件，就从这两个表中提取数据并组合成新的记录 自连接是一种特殊的内连接，它是指相互连接的表在物理上为同一张表，但可以在逻辑上分为两张表 外连接是只限制一张表中的数据必须满足连接条件，而另一张表中的数据可以不满足连接条件的连接方式</p><h3 id="4-SQL-的-select-语句完整的执行顺序？"><a href="#4-SQL-的-select-语句完整的执行顺序？" class="headerlink" title="4. SQL 的 select 语句完整的执行顺序？"></a><strong>4. SQL 的 select 语句完整的执行顺序？</strong></h3><p>1、from 子句组装来自不同数据源的数据；</p><p>2、where 子句基于指定的条件对记录行进行筛选；</p><p>3、group by 子句将数据划分为多个分组；</p><p>4、使用聚集函数进行计算；</p><p>5、使用 having 子句筛选分组；</p><p>6、计算所有的表达式；</p><p>7、select 的字段；</p><p>8、使用 order by 对结果集进行排序。</p><h3 id="5-说一下-Mysql-数据库存储的原理？"><a href="#5-说一下-Mysql-数据库存储的原理？" class="headerlink" title="5. 说一下 Mysql 数据库存储的原理？"></a><strong>5. 说一下 Mysql 数据库存储的原理？</strong></h3><p>储存过程是一个可编程的函数，它在数据库中创建并保存。它可以有 SQL 语句和一些特殊的控制结构组成。当 希望在不同的应用程序或平台上执行相同的函数，或者封装特定功能时，存储过程是非常有用的。数据库中的存储 过程可以看做是对编程中面向对象方法的模拟。它允许控制数据的访问方式。存储过程通常有以下优点：</p><p>1、存储过程能实现较快的执行速度</p><p>2、存储过程允许标准组件是编程。</p><p>3、存储过程可以用流程控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。</p><p>4、存储过程可被作为一种安全机制来充分利用。</p><p>5、存储过程能够减少网络流量</p><h3 id="6-事务的特性？"><a href="#6-事务的特性？" class="headerlink" title="6. 事务的特性？"></a><strong>6. 事务的特性？</strong></h3><p>1、原子性(Atomicity)：事务中的全部操作在数据库中是不可分割的，要么全部完成，要么均不执行。</p><p>2、一致性(Consistency)：几个并行执行的事务，其执行结果必须与按某一顺序串行执行的结果相一致。</p><p>3、隔离性(Isolation)：事务的执行不受其他事务的干扰，事务执行的中间结果对其他事务必须是透明的。</p><p>4、持久性(Durability)：对于任意已提交事务，系统必须保证该事务对数据库的改变不被丢失，即使数据库出现故障</p><p><strong>7. 数据库索引？</strong></p><p>数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用 B_TREE。B_TREE 索引加速了数据访问，因为存储引擎不会再去扫描整张表得到需要的数据；相反，它从根节点开始，根节点保存了子节点的指针，存储引擎会根据指针快速寻找数据。</p><h3 id="8-数据库怎么优化查询效率？"><a href="#8-数据库怎么优化查询效率？" class="headerlink" title="8. 数据库怎么优化查询效率？"></a><strong>8. 数据库怎么优化查询效率？</strong></h3><p>1、储存引擎选择：如果数据表需要事务处理，应该考虑使用 InnoDB，因为它完全符合 ACID 特性。如果不需要事务处理，使用默认存储引擎 MyISAM 是比较明智的</p><p>2、分表分库，主从。</p><p>3、对查询进行优化，要尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引</p><p>4、应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描</p><p>5、应尽量避免在 where 子句中使用!&#x3D; 或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描</p><p>6、应尽量避免在 where 子句中使用 or 来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描</p><p>7、Update 语句，如果只更改 1、2 个字段，不要 Update 全部字段，否则频繁调用会引起明显的性能消耗，同时带来大量日志</p><p>8、对于多张大数据量（这里几百条就算大了）的表 JOIN，要先分页再 JOIN，否则逻辑读会很高，性能很差。</p><h3 id="9-你用的-Mysql-是哪个引擎，各引擎之间有什么区别？"><a href="#9-你用的-Mysql-是哪个引擎，各引擎之间有什么区别？" class="headerlink" title="9. 你用的 Mysql 是哪个引擎，各引擎之间有什么区别？"></a><strong>9. 你用的 Mysql 是哪个引擎，各引擎之间有什么区别？</strong></h3><p>主要 MyISAM 与 InnoDB 两个引擎，其主要区别如下：InnoDB 支持事务，MyISAM 不支持，这一点是非常之重要。事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而 MyISAM 就不可以了；</p><p>MyISAM 适合查询以及插入为主的应用，InnoDB 适合频繁修改以及涉及到安全性较高的应用；</p><p>InnoDB 支持外键，MyISAM 不支持；</p><p>MyISAM 是默认引擎，InnoDB 需要指定；</p><p>InnoDB 不支持 FULLTEXT 类型的索引；</p><p>InnoDB 中不保存表的行数，如 select count() from table 时，InnoDB；需要扫描一遍整个表来计算有多少行，但</p><p>是 MyISAM 只要简单的读出保存好的行数即可。注意的是，当 count()语句包含 where 条件时 MyISAM 也需要扫描整个表；</p><p>对于自增长的字段，InnoDB 中必须包含只有该字段的索引，但是在 MyISAM 表中可以和其他字</p><p>段一起建立联合索引；清空整个表时，InnoDB 是一行一行的删除，效率非常慢。MyISAM 则会重建表；</p><p>InnoDB 支持行锁（某些情况下还是锁整表，如 update table set a&#x3D;1 where user like ‘%lee%’</p><h3 id="10-如何对查询命令进行优化？"><a href="#10-如何对查询命令进行优化？" class="headerlink" title="10.如何对查询命令进行优化？"></a><strong>10.如何对查询命令进行优化？</strong></h3><p>a. 应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索。</p><p>b. 应尽量避免在 where 子句中对字段进行 null 值判断，避免使用!&#x3D;或&lt;&gt;操作符，避免使用 or</p><p>连接条件，或在 where 子句中使用参数、对字段进行表达式或函数操作，否则会导致权标扫描</p><p>c. 不要在 where 子句中的“&#x3D;”左边进行函数、算术运算或其他表达式运算，否则系统将可能无</p><p>法正确使用索引。</p><p>d. 使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为</p><p>条件时才能保证系统使用该索引，否则该索引将不会被使用。</p><p>e. 很多时候可考虑用 exists 代替 in。</p><p>f. 尽量使用数字型字段。</p><p>g. 尽可能的使用 varchar&#x2F;nvarchar 代替 char&#x2F;nchar。</p><p>h. 任何地方都不要使用 select from t ，用具体的字段列表代替“”，不要返回用不到的任何字段。</p><p>i. 尽量使用表变量来代替临时表。</p><p>j. 避免频繁创建和删除临时表，以减少系统表资源的消耗。</p><p>k. 尽量避免使用游标，因为游标的效率较差</p><p>l. 在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SETNOCOUNT OFF。</p><p>m. 尽量避免大事务操作，提高系统并发能力。</p><p>n. 尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。</p><h3 id="11-数据库的优化？"><a href="#11-数据库的优化？" class="headerlink" title="11.数据库的优化？"></a><strong>11.数据库的优化？</strong></h3><p>1.优化索引、SQL 语句、分析慢查询；</p><p>2.设计表的时候严格根据数据库的设计范式来设计数据库；</p><p>3.使用缓存，把经常访问到的数据而且不需要经常变化的数据放在缓存中，能节约磁盘 IO</p><p>4.优化硬件；采用 SSD，使用磁盘队列技术(RAID0,RAID1,RDID5)等</p><p>5.采用 MySQL 内部自带的表分区技术，把数据分层不同的文件，能够提高磁盘的读取效率；</p><p>6.垂直分表；把一些不经常读的数据放在一张表里，节约磁盘 I&#x2F;O；</p><p>7.主从分离读写；采用主从复制把数据库的读操作和写入操作分离开来；</p><p>8.分库分表分机器（数据量特别大），主要的原理就是数据路由；</p><p>9.选择合适的表引擎，参数上的优化</p><p>10.进行架构级别的缓存，静态化和分布式；</p><p>11.不采用全文索引；</p><p>12.采用更快的存储方式，例如 NoSQL 存储经常访问的数据。</p><h3 id="12-Sql-注入是如何产生的，如何防止？"><a href="#12-Sql-注入是如何产生的，如何防止？" class="headerlink" title="12.Sql 注入是如何产生的，如何防止？"></a><strong>12.Sql 注入是如何产生的，如何防止？</strong></h3><p>程序开发过程中不注意规范书写 sql 语句和对特殊字符进行过滤，导致客户端可以通过全局变量 POST 和 GET</p><p>提交一些 sql 语句正常执行。产生 Sql 注入。下面是防止办法：</p><p>a. 过滤掉一些常见的数据库操作关键字，或者通过系统函数来进行过滤。</p><p>b. 在 PHP 配置文件中将 Register_globals&#x3D;off;设置为关闭状态</p><p>c. SQL 语句书写的时候尽量不要省略小引号(tab 键上面那个)和单引号</p><p>d. 提高数据库命名技巧，对于一些重要的字段根据程序的特点命名，取不易被猜到的</p><p>e. 对于常用的方法加以封装，避免直接暴漏 SQL 语句</p><p>f. 开启 PHP 安全模式：Safe_mode&#x3D;on;</p><p>g. 打开 magic_quotes_gpc 来防止 SQL 注入</p><p>h. 控制错误信息：关闭错误提示信息，将错误信息写到<a href="https://www.zhihu.com/search?q=%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%BF%97&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2528417467%7D">系统日志</a>。</p><p>i. 使用 mysqli 或 pdo 预处理。</p><h3 id="13-NoSQL-和关系数据库的区别？"><a href="#13-NoSQL-和关系数据库的区别？" class="headerlink" title="13.NoSQL 和关系数据库的区别？"></a><strong>13.NoSQL 和关系数据库的区别？</strong></h3><p>a. SQL 数据存在特定结构的表中；而 NoSQL 则更加灵活和可扩展，存储方式可以省是 JSON 文档、哈希表或其他方式。</p><p>b. 在 SQL 中，必须定义好表和字段结构后才能添加数据，例如定义表的主键(primary key)，索引(index),触发器</p><p>(trigger),存储过程(stored procedure)等。表结构可以在被定义之后更新，但是如果有比较大的结构变更的话就会变得比较复杂。在 NoSQL 中，数据可以在任何时候任何地方添加，不需要先定义表。</p><p>c. SQL 中如果需要增加外部关联数据的话，规范化做法是在原表中增加一个外键，关联外部数据表。而在 NoSQL 中除了这种规范化的外部数据表做法以外，我们还能用如下的非规范化方式把外部数据直接放到原数据集中，以提高查询效率。缺点也比较明显，更新审核人数据的时候将会比较麻烦。</p><p>d. SQL 中可以使用 JOIN 表链接方式将多个关系数据表中的数据用一条简单的查询语句查询出来。</p><p>NoSQL 暂未提供类似 JOIN 的查询方式对多个数据集中的数据做查询。所以大部分 NoSQL 使用非规范化的数据存储方式存储数据。</p><p>e. SQL 中不允许删除已经被使用的外部数据，而 NoSQL 中则没有这种强耦合的概念，可以随时删除任何数据。</p><p>f. SQL 中如果多张表数据需要同批次被更新，即如果其中一张表更新失败的话其他表也不能更新成</p><p>功。这种场景可以通过事务来控制，可以在所有命令完成后再统一提交事务。而 NoSQL 中没有事务这个概念，每一个数据集的操作都是原子级的。</p><p>g. 在相同水平的系统设计的前提下，因为 NoSQL 中省略了 JOIN 查询的消耗，故理论上性能上是优于 SQL 的。</p><h3 id="14-MySQL-与-MongoDB-本质之间最基本的差别是什么"><a href="#14-MySQL-与-MongoDB-本质之间最基本的差别是什么" class="headerlink" title="14.MySQL 与 MongoDB 本质之间最基本的差别是什么"></a><strong>14.MySQL 与 MongoDB 本质之间最基本的差别是什么</strong></h3><p>差别在多方面，例如：数据的表示、查询、关系、事务、模式的设计和定义、速度和性能。MongoDB 是由 C++ 语言编写的，是一个基于分布式文件存储的开源数据库系统。在高负载的情况下，添加更多的节点，可以保证服务器性能。</p><p>MongoDB 旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。</p><p>MongoDB 将数据存储为一个文档，数据结构由键值(key&#x3D;&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。</p><p>MongoDB 是一个面向文档的数据库，目前由 10gen 开发并维护，它的功能丰富齐全，所以完全可以替代 MySQL。</p><p>与 MySQL 等关系型数据库相比，MongoDB 的优点如下：</p><p>①弱一致性，更能保证用户的访问速度。</p><p>②文档结构的存储方式，能够更便捷的获取数据。</p><p>③内置 GridFS，支持大容量的存储。</p><p>④内置 Sharding。</p><p>⑤第三方支持丰富。(这是与其他的 NoSQL 相比，MongoDB 也具有的优势)</p><p>⑥性能优越：</p><p>MongoDB 本身它还算比较年轻的一个产品，所以它的问题，就是成熟度肯定没有传统 MySQL 那么成熟稳定。</p><p>所以在使用的时候： 尽量使用稳定版，不要在线上使用开发版，这是一个大原则；</p><p>另外一点，备份很重要，MongoDB 如果出现一些异常情况，备份一定是要能跟上。除了通过传统的复制的方式 来做备份，离线备份也还是要有，不管你是用什么方式，都要有一个完整的离线备份。往往最后出现了特殊情况，它能帮助到你；另外，MongoDB 性能的一个关键点就是索引，索引是不是能有比较好的使用效率，索引是不是能够放在内存中，这样能够提升随机读写的性能。如果你的索引不能完全放在内存中，一旦出现随机读写比较高的时候， 它就会频繁地进行磁盘交换，这个时候，MongoDB 的性能就会急剧下降，会出现波动。</p><p>另外，MongoDB 还有一个最大的缺点，就是它占用的空间很大，因为它属于典型空间换时间原则的类型。那么 它的磁盘空间比普通数据库会浪费一些，而且到目前为止它还没有实现在线压缩功能，在 MongoDB 中频繁的进行数据增删改时，如果记录变了，例如数据大小发生了变化，这时候容易产生一些数据碎片，出现碎片引发的结果， 一个是索引会出现性能问题。另外一个就是在一定的时间后，所占空间会莫名其妙地增大，所以要定期把数据库做修复，定期重新做索引， 这样会提升 MongoDB 的稳定性和效率。在最新的版本里，它已经在实现在线压缩，估计应该在 2.0 版左右，应该能够实现在线压缩，可以在后台执行现在 repair DataBase 的一些操作。 如果那样，就解决了目前困扰我们的大问题。</p><h3 id="15-Mysql-数据库中怎么实现分页？"><a href="#15-Mysql-数据库中怎么实现分页？" class="headerlink" title="15.Mysql 数据库中怎么实现分页？"></a><strong>15.Mysql 数据库中怎么实现分页？</strong></h3><p>select * from table limit (start-1)*limit,limit; 其中 start 是页码，limit 是每页显示的条数。</p><h3 id="16-提取数据库中倒数-10-条数据？"><a href="#16-提取数据库中倒数-10-条数据？" class="headerlink" title="16.提取数据库中倒数 10 条数据？"></a><strong>16.提取数据库中倒数 10 条数据？</strong></h3><p>Select * from 表名 order by 主键 desc limit 10</p><h3 id="17-优化数据库？提高数据库的性能？"><a href="#17-优化数据库？提高数据库的性能？" class="headerlink" title="17.优化数据库？提高数据库的性能？"></a><strong>17.优化数据库？提高数据库的性能？</strong></h3><p>1.对语句的优化</p><p>①用程序中，保证在实现功能的基础上，尽量减少对数据库的访问次数；通过搜索参数，尽量减少对表的访问行数,最小化结果集，从而减轻网络负担；</p><p>②能够分开的操作尽量分开处理，提高每次的响应速度；在数据窗口使用 SQL 时，尽量把使用的索引放在选择的首列；算法的结构尽量简单；</p><p>③在查询时，不要过多地使用通配符如 SELECT * FROM T1 语句，要用到几列就选择几列如：SELECT COL1,COL2 FROM T1；</p><p>④在可能的情况下尽量限制尽量结果集行数如：SELECT TOP 300 COL1,COL2,COL3 FROMT1,因为某些情况下用户是不需要那么多的数据的。</p><p>⑤不要在应用中使用数据库游标，游标是非常有用的工具，但比使用常规的、面向集的 SQL 语句需要更大的开销；按照特定顺序提取数据的查找。</p><p>\2. 避免使用不兼容的数据类型</p><p>例如 float 和 int、char 和 varchar、binary 和 varbinary 是不兼容的。</p><p>数据类型的不兼容可能使优化器无法执行一些本来可以进行的优化操作。</p><p>例如:</p><p>SELECT name FROM employee WHERE salary ＞ 60000</p><p>在这条语句中,如 salary 字段是 money 型的,则优化器很难对其进行优化,因为 60000 是个整型数。我们应当在编程时将整型转化成为钱币型,而不要等到运行时转化。若在查询时强制转换，查询速度会明显减慢。</p><p>3.避免在 WHERE 子句中对字段进行函数或表达式操作<strong>。</strong></p><p>若进行函数或表达式操作，将导致引擎放弃使用索引而进行全表扫描。</p><p>4.避免使用!&#x3D;或＜＞、IS NULL 或 IS NOT NULL、IN ，NOT IN 等这样的操作符</p><p>5.尽量使用数字型字段</p><p>6.合理使用 EXISTS,NOT EXISTS 子句。</p><p>7.尽量避免在索引过的字符数据中，使用非打头字母搜索。</p><p>8.分利用连接条件</p><p>9.消除对大型表行数据的顺序存取</p><p>\10. 避免困难的正规表达式</p><p>\11. 使用视图加速查询</p><p>\12. 能够用 BETWEEN 的就不要用 IN</p><p>\13. DISTINCT 的就不用 GROUP BY</p><p>\14. 部分利用索引</p><p>\15. 能用 UNION ALL 就不要用 UNION</p><p>\16. 不要写一些不做任何事的查询</p><p>\17. 尽量不要用 SELECT INTO 语句</p><p>\18. 必要时强制<a href="https://www.zhihu.com/search?q=%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2528417467%7D">查询优化器</a>使用某个索引</p><p>\19. 虽然 UPDATE、DELETE 语句的写法基本固定，但是还是对 UPDATE 语句给点建议：</p><p>a) 尽量不要修改主键字段。</p><p>b) 当修改 VARCHAR 型字段时，尽量使用相同长度内容的值代替。</p><p>c) 尽量最小化对于含有 UPDATE 触发器的表的 UPDATE 操作。</p><p>d) 避免 UPDATE 将要复制到其他数据库的列。</p><p>e) 避免 UPDATE 建有很多索引的列。</p><p>f) 避免 UPDATE 在 WHERE 子句条件中的列。</p><h3 id="18-存储过程和函数的区别"><a href="#18-存储过程和函数的区别" class="headerlink" title="18.存储过程和函数的区别?"></a><strong>18.存储过程和函数的区别?</strong></h3><p>相同点：存储过程和函数都是为了可重复的执行操作数据库的 sql 语句的集合。</p><p>1）存储过程和函数都是一次编译，就会被缓存起来，下次使用就直接命中已经编译好的 sql 语句，不需要重复使用。减少网络交互，减少网络访问流量。</p><p>不同点：标识符不同，函数的标识符是 function，存储过程是 proceduce。</p><p>1）函数中有返回值，且必须有返回值，而过程没有返回值，但是可以通过设置参数类型（in,out)来实现多个参数或者返回值。</p><p>2）存储函数使用 select 调用，存储过程需要使用 call 调用。</p><p>3）select 语句可以在存储过程中调用，但是除了 select..into 之外的 select 语句都不能在函数中使用。</p><p>4）通过 in out 参数，过程相关函数更加灵活，可以返回多个结果。</p><h3 id="19-Mysql-开启-General-log-日志"><a href="#19-Mysql-开启-General-log-日志" class="headerlink" title="19.Mysql 开启 General-log 日志?"></a><strong>19.Mysql 开启 General-log 日志?</strong></h3><p>Show variables like ‘general%’;</p><p>Set global general_log&#x3D;1;</p><p>Set global general_log&#x3D;0;</p><h3 id="20-Student-Sourse-SC-Teacher-表关系如下："><a href="#20-Student-Sourse-SC-Teacher-表关系如下：" class="headerlink" title="20.Student-Sourse-SC-Teacher 表关系如下："></a><strong>20.Student-Sourse-SC-Teacher 表关系如下：</strong></h3><ul><li>Student（sid，Sname，Sage，Ssex）学生表</li><li>Course（cid，Cname，tid）课程表</li><li>SC（sid，cid，score）成绩表</li><li>Teacher（tid，Tname）教师表</li></ul><p>写出 sql 语句：</p><ul><li> 查询课程“001“课程比”002“课程成绩高的所有学生的学号</li><li> 修改学号为 20131201 的语文成绩为 100‘</li><li> 插入一条名为“李四”的教师记录</li><li> 删除学习“叶平”老师课程的 sc 表记录</li></ul><h2 id="八、-Web-测试"><a href="#八、-Web-测试" class="headerlink" title="八、 Web 测试"></a>八、 <strong>Web 测试</strong></h2><h3 id="1-描述用浏览器访问-http-www-baidu-com-的过程？"><a href="#1-描述用浏览器访问-http-www-baidu-com-的过程？" class="headerlink" title="1. 描述用浏览器访问 http://www.baidu.com 的过程？"></a><strong>1. 描述用浏览器访问 <a href="https://link.zhihu.com/?target=http://www.baidu.com">http://www.baidu.com</a> 的过程？</strong></h3><p>先要解析出 <a href="https://link.zhihu.com/?target=http://baidu.com">http://baidu.com</a> 对应的 ip 地址：</p><p> 要先使用 arp 获取默认网关的 mac 地址</p><p> 组织数据发送给默认网关(ip 还是 dns 服务器的 ip，但是 mac 地址是默认网关的 mac 地址)</p><p> 默认网关拥有转发数据的能力，把数据转发给路由器</p><p> 路由器根据自己的路由协议，来选择一个合适的较快的路径转发数据给目的网关</p><p> 目的网关(dns 服务器所在的网关)，把数据转发给 dns 服务</p><p> dns 服务器查询解析出 <a href="https://link.zhihu.com/?target=http://baidu.com">http://baidu.com</a> 对应的 ip 地址，并原路返回请求这个域名的 client 得到了 <a href="https://link.zhihu.com/?target=http://baidu.com">http://baidu.com</a> 对应的 ip 地址之后，会发送 tcp 的 3 次握手，进行连接</p><p> 使用 http 协议发送请求数据给 web 服务器</p><p> web 服务器收到数据请求之后，通过查询自己的服务器得到相应的结果，原路返回给浏览器</p><p> 浏览器接收到数据之后通过浏览器自己的渲染功能来显示这个网页</p><p> 浏览器关闭 tcp 连接，即 4 次挥手结束，完成整个访问过程</p><h3 id="2-了解的常用浏览器有哪些？"><a href="#2-了解的常用浏览器有哪些？" class="headerlink" title="2. 了解的常用浏览器有哪些？"></a><strong>2. 了解的常用浏览器有哪些？</strong></h3><p>IE，Chrome，Safari，Firefox，Opera</p><h3 id="3-什么是-sql-注入，什么是跨站脚本，什么是跨站请求伪造？"><a href="#3-什么是-sql-注入，什么是跨站脚本，什么是跨站请求伪造？" class="headerlink" title="3. 什么是 sql 注入，什么是跨站脚本，什么是跨站请求伪造？"></a><strong>3. 什么是 sql 注入，什么是跨站脚本，什么是跨站请求伪造？</strong></h3><p>SQL 注入攻击是注入攻击最常见的形式（此外还有 OS 注入攻击（Struts 2 的高危漏洞就是通过 OGNL 实施 OS 注入攻击导致的）），当服务器使用请求参数构造 SQL 语句时，恶意的 SQL 被嵌入到 SQL 中交给数据库执行。SQL 注入攻击需要攻击者对数据库结构有所了解才能进行，攻击者想要获得表结构有多种方式：</p><p>（1）如果使用开源系统搭建网站，数据库结构也是公开的（目前有很多现成的系统可以直接搭建论坛，电商网站，虽然方便快捷但是风险是必须要认真评估的）；</p><p>（2）错误回显（如果将服务器的错误信息直接显示在页面上，攻击者可以通过非法参数引发页面错误从而通过错误信息了解数据库结构，Web 应用应当设置友好的错误页，一方面符合最小惊讶原则，一方面屏蔽掉可能给系统带来危险的错误回显信息）；</p><p>（3）盲注。防范 SQL 注入攻击也可以采用消毒的方式，通过正则表达式对请求参数进行验证，此外，参数绑定也是很好的手段，这样恶意的 SQL 会被当做 SQL 的参数而不是命令被执行，JDBC 中的 PreparedStatement 就是支持参数绑定的语句对象，从性能和安全性上都明显优于 Statement。</p><p>XSS（Cross Site Script，<a href="https://www.zhihu.com/search?q=%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2528417467%7D">跨站脚本攻击</a>）是向网页中注入恶意脚本在用户浏览网页时在用户浏览器中执行恶意脚本的攻击方式。</p><p>跨站脚本攻击分有两种形式： 反射型攻击（诱使用户点击一个嵌入恶意脚本的链接以达到攻击的目标，目前有很多攻击者利用论坛、微博发 布含有恶意脚本的 URL 就属于这种方式）</p><p>持久型攻击（将恶意脚本提交到被攻击网站的数据库中，用户浏览网页时，恶意脚本从数据库中被加载到页面执行，QQ 邮箱的早期版本就曾经被利用作为持久型跨站脚本攻击的平台）。</p><p>CSRF 攻击（Cross Site Request Forgery，跨站请求伪造）是攻击者通过跨站请求，以合法的用户身份进行非法操作（如转账或发帖等）。CSRF 的原理是利用浏览器的 Cookie 或服务器的 Session，盗取用户身份，其原理如下图所示。</p><p>防范 CSRF 的主要手段是识别请求者的身份，主要有以下几种方式：</p><p>（1）在表单中添加令牌（token）；</p><p>（2）验证码；</p><p>（3）检查请求头中的 Referer（前面提到防图片盗链接也是用的这种方式）。</p><p>令牌和验证都具有一次消费性的特征，因此在原理上一致的，但是验证码是一种糟糕的用户体验，不是必要的情况下不要轻易使用验证码，目前很多网站的做法是如果在短时间内多次提交一个表单未获得成功后才要求提供验 证码，这样会获得较好的用户体验。</p><h3 id="9-nginx-tomcat-apache-都是什么？"><a href="#9-nginx-tomcat-apache-都是什么？" class="headerlink" title="9. nginx,tomcat,apache 都是什么？"></a><strong>9. nginx,tomcat,apache 都是什么？</strong></h3><p>Nginx (engine x) 是一个高性能的 HTTP 和反向代理服务器，也是一个 IMAP&#x2F;POP3&#x2F;SMTP 服务器。</p><p>Apache HTTP Server 是一个模块化的服务器，源于 NCSAhttpd 服务器</p><p>Tomcat 服务器是一个免费的开放源代码的 Web 应用服务器，属于轻量级应用服务器，是开发和调试 JSP 程序 的首选。</p><h3 id="10-apache-和-nginx-的区别？"><a href="#10-apache-和-nginx-的区别？" class="headerlink" title="10.apache 和 nginx 的区别？"></a><strong>10.apache 和 nginx 的区别？</strong></h3><p><strong>Nginx 相对 Apache 的优点：</strong></p><p>轻量级，同样起 web 服务，比 apache 占用更少的内存及资源；</p><p>抗并发，nginx 处理请求是异步非阻塞的，支持更多的并发连接，而 apache 则是阻塞型的，在高并发下 nginx 能</p><p>保持低资源低消耗高性能；</p><p>配置简洁；</p><p>高度模块化的设计，编写模块相对简单；</p><p>社区活跃。</p><p><strong>Apache 相对 Nginx 的优点：</strong></p><p>rewrite ，比 nginx 的 rewrite 强大；</p><p>模块超多，基本想到的都可以找到；</p><p>少 bug ，nginx 的 bug 相对较多；</p><p>超稳定</p><h2 id="九、-API-测试"><a href="#九、-API-测试" class="headerlink" title="九、 API 测试"></a>九、 <strong>API 测试</strong></h2><h3 id="1-接口类型有哪些？"><a href="#1-接口类型有哪些？" class="headerlink" title="1. 接口类型有哪些？"></a><strong>1. 接口类型有哪些？</strong></h3><p>接口是指外部系统与系统之间以及内部各子系统之间的交互点。</p><p>包括外部接口、内部接口，内部接口又包括：上层服务与下层服务接口、同级接口。</p><h3 id="2-如果模块请求-http-改为了-https，测试方案应该如何制定，修改？"><a href="#2-如果模块请求-http-改为了-https，测试方案应该如何制定，修改？" class="headerlink" title="2. 如果模块请求 http 改为了 https，测试方案应该如何制定，修改？"></a><strong>2. 如果模块请求 http 改为了 https，测试方案应该如何制定，修改？</strong></h3><p>分别用 http 还有 https 登录试试。如果用 https 可以正常登录，地址栏显示一把锁头，那么这个网站是有部署 SSL的。如果 http 和 https 都能够正常登录，进一步说明该网站没有设置强制 https 登录，或者说没有设置 http 链接自动跳转 https 链接；相反如果用 http 登录，结果跳转到 https 页面，说明网站部署了 SSL，而且设置了 http 自动跳转 https。</p><h2 id="十、-App-测试"><a href="#十、-App-测试" class="headerlink" title="十、 App 测试"></a>十、 <strong>App 测试</strong></h2><h3 id="1-APP-测试的内容主要包括哪些，如何开展？"><a href="#1-APP-测试的内容主要包括哪些，如何开展？" class="headerlink" title="1. APP 测试的内容主要包括哪些，如何开展？"></a><strong>1. APP 测试的内容主要包括哪些，如何开展？</strong></h3><p><strong>功能测试：</strong></p><p>1.业务逻辑正确性测试：依据：产品文档-&gt;测试用例编写</p><p>兼容性测试：</p><p>1.系统版本：Android:官方版本,定制版本;IOS：官方提供版本</p><p>2.分辨率：720 * 1280 1080* 1920</p><p>3.网络情况:2g 3g 4g 5g Wi-Fi</p><p><strong>异常测试</strong></p><p>1.热启动应用:应用在后台长时间待机;应用在后台待机过程中，手机重启</p><p>2.网络切换和中断恢复:网络切换;中断恢复：</p><p>3.电话信息中断恢复</p><p><strong>升级，安装，卸载测试</strong></p><p>1.升级测试：临近版本升级(1.0-&gt;1.1);跨版本(1.0-&gt;….-&gt;2.2)</p><p>2.安装测试：首次安装;覆盖安装(同版本，不同版本覆盖);卸载后安装</p><p>3.卸载测试：首次卸载;卸载安装后在卸载</p><p><strong>健壮性测试</strong></p><p>1.手机资源消耗：cpu，内存</p><p>2.流量消耗：图片，数据，视频</p><p>3.电量测试</p><p>4.崩溃恢复</p><h3 id="2-Android-的兼容性测试都考虑哪些内容？"><a href="#2-Android-的兼容性测试都考虑哪些内容？" class="headerlink" title="2. Android 的兼容性测试都考虑哪些内容？"></a><strong>2. Android 的兼容性测试都考虑哪些内容？</strong></h3><p>品牌机型兼容：根据市场占有率、发布时间等指标对主流、最新机型进行重点兼容</p><p>ROM 兼容：需兼容原生的 ROM（2.1、2.2、2.3、4.0、4.1、4.2）；第三方 ROM（小米、百度易、点心、魅族、 阿里云……）</p><p>屏幕兼容：需兼容 HVGA、VGA、WVGA、FWVGA、720p、1080p 屏幕分辨率，并考虑不同 PPI 的情况</p><p>软件兼容：安全类软件（百度手机管家、360 优化大师、360 安全卫士、QQ 手机管家、安卓优化大师、网秦、 LBE），输入法软件（系统自带、Sogou、百度）</p><p>版本兼容：服务器端需要兼容产品早期版本所需的 API 接口</p><p>网络兼容：WiFi、3 大运营商的 2G,3G,4G 网络，需区分 WAP 和 NET 接入</p><h3 id="3-针对-App-的安装功能，写出测试点？"><a href="#3-针对-App-的安装功能，写出测试点？" class="headerlink" title="3. 针对 App 的安装功能，写出测试点？"></a><strong>3. 针对 App 的安装功能，写出测试点？</strong></h3><p> 安装</p><p>1.正常安装测试，检查是否安装成功。</p><p>2.APP 版本覆盖测试。例如：先安装一个 1.0 版本的 APP,再安装一个高版本(1.1 版本)的 APP，检查是否被覆盖。</p><p>3.回退版本测试。例如：先装一个 2.0 版本的 APP,再安装一个 1.0 版本的 APP,正常情况下版本是可以回退的。</p><p>4.安装时内存不足，弹出提示。</p><p>5.根据安装手册操作，是否正确安装。</p><p>6.安装过程中的意外情况（强行断电、断网、来电话了、查看信息）等等，检查会发生的情况。</p><p>7.通过‘<a href="https://www.zhihu.com/search?q=%E5%90%8C%E6%AD%A5%E8%BD%AF%E4%BB%B6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2528417467%7D">同步软件</a>’，检查安装时是否同步安装了一些文件。</p><p>8.在不同型号、系统、屏幕大小、分辨率上的手机进行安装。</p><p>9.安装时是否识别有 SD 卡，并默认安装到 sd 卡中。</p><p>10.安装完成后，能否正常启动应用程序。</p><p>11.安装完成后，重启手机能否正常启动应用程序。</p><p>12.安装完成后，是否对其他应用程序造成影响。</p><p>13.安装完成后，能否添加快捷方式。</p><p>14.安装完成后，杀毒软件是否会对其当做病毒处理。</p><p>15.多进程进行安装，是否安装成功。</p><p>16.在安装过程中，所有的提示信息必须是英文或者中文，提示信息中不能出现代码、符号、乱码等。</p><p>17.安装之后，是否自动启动程序。</p><p>18.是否支持第三方安装。</p><p>19.在安装中点击取消。</p><p> 卸载</p><p>1.用自己的卸载程序进行卸载，检查是否卸载干净。</p><p>2.用第三方工具，检查是否卸载干净。</p><p>3.在卸载过程中，点击取消按钮，看是否正常退出卸载程序，检查软件是否还能继续正常使用。</p><p>4.卸载过程中，出现意外（比如手机关机，没电，查看信息，接打电话），程序是否还能运行。</p><p>5.在卸载过程中，突然重启设备，再次访问程序，是否还能运行。</p><p>6.在没用使用程序时，删除目录文件，看程序是否能运行。</p><p>7.在使用过程中，直接删除目录文件，程序是否还能运行。</p><p>8.不同系统、硬件环境、网络环境下进行卸载。</p><p>9.卸载成功后，是否对其他程序有影响。</p><p>10.卸载后再次安装，是否正常使用。</p><p>11.在卸载过程中，所有的提示信息必须是英文或者中文，提示信息中不能出现代码、符号、乱码等。</p><p> 更新</p><p>1.当客户端有新版本时，提示更新。</p><p>2.非强制更新，可以取消更新，旧版本正常使用，下次使用软件时，仍然会出现更新提示。</p><p>3.强制更新，强制更新而用户没有更新时，退出客户端，下次启动，依然提示更新。</p><p>4.不卸载更新，检查是否可以更新。</p><p>5.不卸载更新，检查资源同名文件如图片等是否更新成最新版本。</p><p>6.非 wifi 网络下，提示是否更新，取消就加入待下载，wifi 下自动更新。</p><h3 id="4-常用的-ADB-命令？"><a href="#4-常用的-ADB-命令？" class="headerlink" title="4. 常用的 ADB 命令？"></a><strong>4. 常用的 ADB 命令？</strong></h3><p>adb –help &#x2F; adb :看见帮助信息</p><p>adb start-server:启动 adb 服务</p><p>adb kill-server:关闭 adb 服务</p><p>adb devices:查看手机设备号</p><p>adb shell getprop ro.build.version.release:获取系统版本</p><p>adb push 电脑 手机</p><p>adb pull 手机 电脑</p><p>adb logcat | grep(unix) 包名</p><p>adb logcat | findstr(win) 包名</p><p>adb shell :进入 shell 命令行，可以操作 Linux 命令</p><p>adb shell dumpsys window windows | grep mFocusedApp:获取包名 启动名(win：adb shell dumpsys window</p><p>windows | findstr mFocusedApp)</p><p>adb install 路径&#x2F;apk 文件:安装 apk 到手机上</p><p>adb uninstall 包名:卸载 app 从手机上</p><p>adb shell am start -W 包名&#x2F;启动名:app 启动时间</p><h3 id="5-在查看-logcat-命令日志时候怎么内容保存到本地文件？"><a href="#5-在查看-logcat-命令日志时候怎么内容保存到本地文件？" class="headerlink" title="5. 在查看 logcat 命令日志时候怎么内容保存到本地文件？"></a><strong>5. 在查看 logcat 命令日志时候怎么内容保存到本地文件？</strong></h3><p>输出重定向：logcat &gt;&gt; log_file_name</p><h3 id="6-App-崩溃（闪退），可能是什么原因导致的？"><a href="#6-App-崩溃（闪退），可能是什么原因导致的？" class="headerlink" title="6. App 崩溃（闪退），可能是什么原因导致的？"></a><strong>6. App 崩溃（闪退），可能是什么原因导致的？</strong></h3><ul><li>缓存垃圾过多：由于安卓系统的特性,如果长时间不清理垃圾文件.会导致越来越卡.也会出现闪退情况.</li><li>运行的程序过多,导致内存不足</li><li>应用版本兼容问题：如果应用版本太低，会导致不兼容，造成闪退。此外，有些新版本在调试中，也会造成应</li><li>用闪退。解决方法：如果是版本太旧，更新为新版本即可；如果是新版本闪退，可能是应用在改版调试，可卸载后</li><li>安装旧版。</li><li>检查 APP 中访问网络的地方，组件中的 ImageView 是否可以正常的下载并显示到 app 页面上。</li><li>检查 APP 的 sdk 和手机的系统是否兼容。</li><li>在一些特定情况下的闪退,比如播放视频,在 Android5.0 升级到 Android6.0 的时候,有些系统 API 老版本有,新版本没有,到时回去对象的时候失败,报空,系统就会出现闪退问题.</li></ul><h3 id="7-弱网测试怎么测"><a href="#7-弱网测试怎么测" class="headerlink" title="7.弱网测试怎么测"></a><strong>7.弱网测试怎么测</strong></h3><p>弱网环境测试主要依赖于弱网环境的模拟。环境搭建方式一般有两种：软件方式和硬件方式。软件方式的成本低，主要就是通过模拟网络参数来配置弱网环境，通常来讲可以达到测试目的.一般可通过热点共享设置。在各类<a href="https://www.zhihu.com/search?q=%E7%BD%91%E7%BB%9C%E8%BD%AF%E4%BB%B6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2528417467%7D">网络软件</a>中，主要就是对带宽、丢包、延时等进行模拟弱网环境。如果要求更接近弱网环境，比如现在很多的专项测试，会更倾向于通过硬件方式来协助测试，但这种方式相对会麻烦很多，一般会由网维协助搭建。当然，对于有些无法模拟的情况，只能靠人工移动到例如电梯、地铁等信号比较弱的地方</p><h2 id="软件测试加油站"><a href="#软件测试加油站" class="headerlink" title="软件测试加油站"></a>软件测试加油站</h2><p><strong>功能测试</strong><br><strong>软件测试基础入门：</strong><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/BV1TP4y1J7BD">最新软件测试视频教程，软件测试基础入门到项目实战（涵盖软件测试基础+黑马头条项目实战）</a><br>Linux系统2天快速入门：<a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/BV11t411M7uZ">Linux系统操作教程2天快速入门linux项目搭建</a><br>MySQL数据库:<a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/BV1M541147Cn">软件测试工程师必备MySQL数据库，mysql系统精讲+课后练习</a><br>Python自动测试教程 ：<a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/BV1av411q7dT">Python自动测试教程，python从基础到UnitTest框架管理测试用例</a></p><p><strong>自动化测试</strong><br><strong>Web自动化:</strong> <a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/BV1QJ41137gj">软件测试web自动化测试，Web自动化流程精讲和移动自动化测试环境</a><br><strong>Appium框架视频 :</strong> <a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/BV1B441197rZ">零基础入门移动自动化测试——Appium框架</a><br><strong>Appium进行IOS真机自动化测试 :</strong> <a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/BV1yE411r7WU">轻松教你使用Appium进行IOS真机自动化测试</a><br><strong>接口测试:</strong> <a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/BV1LJ41137b5">4天玩转接口测试，接口重点全解析+传智健康项目实战（包含requests库，集成UnitTes，Dubbo等诸多工具）</a><br><strong>性能测试:</strong><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/BV1wC4y1Y7yX">性能测试全套教程，4天快速入门性能测试+项目商城实战（含JMeter工具等）</a></p><p><strong>综合项目强化</strong></p><p><strong>微信小程序自动化测试:</strong> <a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/BV11J41137jE">软件测试微信小程序自动化测试实战</a></p><p><strong>金融项目功能测试:</strong><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/BV1EV411S7zB">软件测试4天快速搞定金融项目功能测试实战教程</a></p>]]></content>
      
      
      <categories>
          
          <category> learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试记录</title>
      <link href="/FRank675.github.io/posts/3521423e0c10/"/>
      <url>/FRank675.github.io/posts/3521423e0c10/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，这个密码看着不太对。" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="b4097029efa201a408f0c1ca29ba1bb83f03f52adb01c417498aaecb6e688a69">05f36028e34e215a20bb6ed2e9c75247b73eda1df43f74c2013d1bcb7ffb11e3dcc321d37937843be1d450e75a2c15d8f9a3201c5196ef20732e4b7a1f1f82f4c2b19f70db56a2451ea32b0168295afbeb1328ae7dd199b829e6b0d43044c4697effd4dbf00808d966beee93e923162e8e86b9fe28f802dd010dd1aebbc22092715076196ee5c8bfa5b7b926fcb47717ec91e795aa603e8ef365983a37a1fe0a95cbe47acd60032d11ac4edf2794310c064686b7cd9d3cc5dfdeed0fb6fef4d7719e5c47d01557e845b0b5f329f362264f14a475cea5631b2b9205e5ba7880f8d4233a3240096525224ace83f14fad91f8e7aff68aa0b86dcf02c6c43ea6a8f649230c1f5ab191d9fcf88941361f691139da997b4881277541095ac354242261325ecc16d65aea005a85158006fbd84b1cee69d822921104af417e8f5f47fdde03d63e51d03250bc39a05d148e8158c62c7686ea2d4c1f70271390fcc664b7518053bd61740b3ee64979e8a48fa428a41f522d84747212032f88d3676af1a1783f94c2c494a164c780da3999ce995c0a58d3c734478b408eb839d33235bfe2f77d83e4408a47f55e371c79257ac0d7847d91aadabf400e7a9cac4e7f6738ba0ae52164bc4cfe64f3fa3a9cbcd4767eb5721de0d6b5c0f0d9e27dbae309634b1d607a20d55cd91ccd46fcee062033a7f1ca267d9c7bbe04c79026af8e1caad549d14e62f77071484c48cf6d51f3246448f88b414f8a0641f26e97ec12e844cb1b7a76b876c09a3dc4fa53422f7a3dc663764efe1708bd50c150bb16dfd9efc65204d3e3a2f1454a34d6f56ce62431efec857f9e6d056be08f9208f4811802771dcd4fb24886596489309922a2a3eefef1f5b0ea5cc9f17cbf2c535604833ddef087f6e8dd1f800c5d4372981fc053b9a0640d21dfaff6c92e09e8d5d5ed2e9b9d4d5ba85b1f5a007f9090114ebbc03b1593f54840eb06ba813c33976f050c12d8c4631d1fee17b37bedd3d03711455dd7120e4d160893b89fd7fbda9678b88dddc4dfb720b070fc3b07b630faf987621491857f51da4c256abaebb67e687a26d6a75a4214a4daea9bbb56541d28bed7a6a0b6c012be43499e53c337335644765e6f700684d6ca4cddb1cfa1e3ea93efdecb57a3195b93ea28aa99280f104fc4a2c28add42768835c43374a13530b07d682c85d11b63964d8c6b96fc4ceb234f6eeaf9302ff1c767805efe35d4928a8654b0728c15c22c082d7454baeee74156b76c5dedade557a4754dcc7c1f81d2679e2a9f8e9800a350df26cff880507ebc94a75bebcf6dec99004b97d4cf6352286b849c5a9167f88e30e377b827eef1ea864e68932e2ebdbf5cf5d1f77d19fc6d6dfbff81da28165783f56d9038839ad7a55a398afff388a594678badbc133c0baf23c9f796691f21f0c482fcfb4e34fa28a5e840b8577e65d3fa0a6287a19c8b70922293ae3a3ca51f4c9c3a2a1a15d8fe204c74a905c5704bf4a8b27b0a272bafbe9ab79bbed292479f9012d1802899b3e954c3684e4d2b3755cea03b84d2cb22109734a514f6f541ef2668a85d93c1e5fbe83e826a61490ec71130e80f01bc0c7f8a989e8f0315d3c590eec9cde3e2db769472a3cfa772d41ac7029bb522d07e5d18d99b920fbe8873654bd7e5dc8eb31de0c4c343ff8f5aa496fb61d093aef48aec83fadf02682d1e91a79c3a8904f02fbf3445c57a2d787bf9bdb217482fe9b99bf446f7e38eb6836140545404d331834f82c91dd384b382bdb3d7f49e5db98cc865951cfbae56650487a10a193d4c1f74899a46dbf0501cec75a908208c193d7b948f31450e6f048cce6f5bf94b449d4205da8665b401cd37e82e352c2c018f67368d39f15a711db3b3609af2981393116c131d58b37f117751e80ef8117a8d80e87736fc1f0555bab216e53a144cc5ac86a68f53f33f343942526d4f7b7f24e052c3a2be19ac3445e397d33fc6f229bd911a0d8c15d9471f78e1a886f7adbe841474bcae5bbbadcf8a514976ec7b3073fc4e75d52d7b47bab8d367dce16cb0c5bfcee6324f5025ec8f3fe1f23be77c234ed43e302ccce0008f266c973c68ef54ecaa6cdde6c5e78ef06f0b32ba952ef61771afde08b97b95e4ea853093a5cafec57d677be8ec6c26eb7b6bbc2f5795e078237bf76fb7233deed58e4968a68a183fe82ca32ffac4e0186f720fb68e3c58462d55d085c834778dbb67291beaa38cc069523e493bce61039e9b6f5ab2ebc00e7e589d827346e6d127c5dc33a23cd26ea7546729581140f4b23ef0a80d05c94cebd949afca7af00ec2e24d11ff5c65a265d10c4be0e2715498da05ff93b4e66e4f8028e8715b87b2da7db675370ee2e3ce1e8f9e99f0f0e402357712b6f3b45f4b505c10928adc1158665573a4946137fa9137ac2dae989829df03724ad59dc38b08898e7b6a4db2ccd9807c3ab73b9db7a8d800de5dc31ff590e770b66276c1f8ed7b5feb1a34a061b4bdf16b8516506acb327fce82477fedd8b7159e66cfaefbb09727402b44f886d0de4063</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码！！！</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试资料汇总</title>
      <link href="/FRank675.github.io/posts/e1befbaf572f/"/>
      <url>/FRank675.github.io/posts/e1befbaf572f/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，这个密码看着不太对。" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="34377ae7f8da6cd7bc365d70694070fab305aa849f418baf94e0c3ec07f9c91d">05f36028e34e215a20bb6ed2e9c75247b73eda1df43f74c2013d1bcb7ffb11e3dcc321d37937843be1d450e75a2c15d8f9a3201c5196ef20732e4b7a1f1f82f4c2b19f70db56a2451ea32b0168295afbeb1328ae7dd199b829e6b0d43044c4697effd4dbf00808d966beee93e923162e8e86b9fe28f802dd010dd1aebbc22092715076196ee5c8bfa5b7b926fcb47717ec91e795aa603e8ef365983a37a1fe0a95cbe47acd60032d11ac4edf2794310c064686b7cd9d3cc5dfdeed0fb6fef4d7719e5c47d01557e845b0b5f329f362264f14a475cea5631b2b9205e5ba7880f8d4233a3240096525224ace83f14fad91f8e7aff68aa0b86dcf02c6c43ea6a8f649230c1f5ab191d9fcf88941361f6911ad098fb58bf6fac12ba3cd956102a4b732337ee639377de838215178ff6a2f6742992e5b61e6ff700283e74769b9b73a0ebf836a10f3ca78e2ba29211fba2b2d19c3ee5dbf3bbe284a04aea666632a274c870bb9c214eb7bd31310b26b3a8bf8e1e767cff665f17f655122cf35934773b01718051b6189fa0ca77a968c7ace00c95b25b4d171c6069da4554cff07f02be2c7ee452b0a80fd42916eb89d28ce63bc457a80d573d42ab10caf5d95db65db0f2056a344ee35504907ca8e05c6f6d070d5b56eae53f888141c25279a31c414bc41ce213d2c0467fc835122be4757f49937ecc9c2ee1783640defd74db46f9cae82a167a7ba9e2df38f846bdcc80ea0931777204b47c98de6006048f1a49af6abd495f1222cc53c3000bca5a11e3ccf9d84510d6e7c5a4e18267bec8de1344e6deb6aef354e597870f5235bd3d5f21f4e283c8b9e8fc0aa2dfed4ce946178ad83d6d270632e8c5a5b6e482d8d50ec13c0f762b670c234e67af272276842327f22eba083e09e4fa34827bdf969515344e52f09598b1b5ae8047a5b81b8085508d2463fc825ffc333bb959959e7cad24760cd10c5c42fdfcee07e781479190a88d34429915783cf2baac9befb3d9f9a2097202c622f7312ddff227cb893e2b508ec6ba37daeafeeb2e2b0049f04a8d8730e1a14daa70048c1a1671a7265ced085eb923b62a38eaba2acdfbfb65be3cacb4a004631153b92bc159204d7f5fe8aaa000d57c08aca9fb77897876fa22d53aa1a28635016964cfd895e3a91c6c9efd24ab0a3fed68160aa6d53b248141cbef7c1ea4d2bbe399ae70114382eb164c76f62ac39f3e88b4b07e67bcfd60ee3f8f00a24158aa4b3cb99be88875a1aaf850ed0f8c9b8ba8b4dde69ce0d0e19b3d20dddcea9ceaa20fab539cbd8e315645338973f4cf270f9ec7091c2cd47d898586ad19d1b47efabca3fdf5d6d789481c1ff417d1cc21c7e36cb4344b8445da2590605fec5aef31e8978793b27b30f643c2b8f1e111fa9619d1ff1d1656f9b59382b9137807f70a9ead82701e6b72ab147d753ae77d2f8611ad94a65adf62dba05393f376952d7caddd358b322dd4b57266b71aea9a29936a88979b1c53436129686ff7a239c5c53db7bbe3308e618bed77b07b8ea732ad56eae296a40bec0505edaf254482731e54e31e050075cb91d44333ba635ce860c24ca8e10b8bd815493e1842592c645d277fae620ca6c5c80854f5737659dbb7a33bedc6a12fd106636f0582b4ea4c3e37ff19cb8210f04758eaa0eab0a16741581854c044ac973177097457c8c2f90a1ad918b4cc5c657d7757e893037997342e6d9585bc4b24a33f149df58cc7f6296b6722f129c425eeca6d6d00969cafe5efa2012e16940db537a655bbd611f3928a2c150d2cc2481c7a73451833ea3e129c8165a409f1bc3e1fc96e68602df6f519ad82660784078b99794b4b64c1faa084a2da2a0b39f2f278f56d2019e455aaf584212975f27f01625584975f24a02d73f02756d18d55a527294b447defbf5be9c54e6a71a5f6f2ea8bbd646e2d6f4d18e96c0f296d0736c4a68af15b5c3859e643c6d4de5dfebf452cb0ccc96707305889e5a63e0f316ab9064a5659bc58ce952ac10569b673a29f98b51a4eed3f3d86953ead169dc8878d8f4a06286a173ab4e4259adaa28debe4a405a186722d86b1eaa23930c6a00085c6801c05c93fcd7fb39d53802aaf25a198db3e12063ee639d9de831f8615fc086de27c680ca0bde6284332c4abba3b84ea2e2b3bab3e8c9616b15963d5fe5e278ff09a626ab4628b37586b8a73b3bcced2a3af2f8d08da133de832a584af20a1f8cd3507606deaa828d1fc9d710419da5bdd5b6b6c4209e65af9e82de45f1af2dd28445c082c24894ec976b6586f375daeba73155fdbde9129d5c3e074bdf0ec871caddce477c2d331adf83f08017bd754479e53f9144f2e20aa9508a5051306e2a3005034f0c7d61bedaf62a9ef227df9341110fb292cbb3aca3dde6229f1e00a8b76a462c08e39032037bbfc1abfb5eb0c6519a9efad44ba6f0270ad0d2b50b00109d1a0dad54127fd858d0ba5cd11663f4b9cbd3b488920297549bf61be2f3776b6093e1aa5dcfd939535d4d418ffad0954427d1b264b866c1e34a01577b196664761edf95659a9b3a351a3c1b10400f5251d4c239f4bd350dddb6b43bfcf4983f333ebe09c170b90d8e2d7077ef0a10f8c02c5f49bd87ab53f68f80ef35e5590709ffc13486abecd3fb58044a4820336cb217b17c34bc8e0d59d0cfc77762b59bb8a8326efb69641be30fee3e34d0f78aede3d49594574efcab91c8feeb0914edf0c15cdcf564f4f34be455a4a0b2154b314af60a60eaf1fa48045655109492c9cdb63f38318a290046f1022936e64280068d23bba13ecd58b6c29f435439652bcc550edfe2c6e213e7be84891b57df1a51f8a3ddfc07568baf9932c93dd1053f351eed67d589461c8ab4d7b73f3c0d8c9e8a69dec2517fed830a9fba10e5160fc8cfb9fed998943863c9446e46ed4be70144364b3aae7d7b9d4a51acd891898c63028ef58e9c2350eca9228646a05f181dc430543f3c020e2d28927a5b27e8c7c9713cd6de52684c4708f355cb6758c5f179106b2ac2f651ecf463d24bf4c5638c264c827bd542d6c55ccb89a95ae703217a53276e41b8ba9e4c94884359d692baeec87a3f6edb2d2dd373dc49a179a5b1c6df7cc484c63915c1214df7e99403e399f51ee741da72b30e5380ce147f27c0d02363e9b62fb1f07407e1f01461fc8fe5a3d6ac3507a4b7d41199fa3fe48e9d27e471fe27a8637679f56e28d75c0cd2ac3d7b28f59a293207e6295155a0528c867858587130260791542024986f4dabecfcebe0a0661c983c9cd0bf173f79162da7a49160c7f68103fbb3058963f090fdc3f0c699997ce04342e06ad232b31f393d41fe2f237cb9f26898ad3c4b9c305af11b76bb91537a1d963361c3a60eb877ce98a00129cc837a3224c875ec20151015dd6e6438a6f97c0cd738b4d50e5f5283dffbd996b44506d8fc528e3b53bc86626a11de0a178b80a0e930277a12c6d28746f9403b5da613f1e07fe2f3e9e78c4aa22ef123794c63e410966563fd21ebc5b5a40548658f8d332591aca3f710c758eb40a2cc676a181b5c1176ed6162c051ce6f09af7ac412c52910c2fb2e3eff0a4edba9e8586c50f2f519e1726c9eec63fb45ade4c5af1bba7aa85a7b4771d1cf6bb4f9a8b803948ab2cee9a157402852b46d362d4ba39dd9d116006a786ee2c663ed85d8ec5872114d8d82c26f61f537e46a453f955e117b0414008828323fd357cd5bb90becf7ee380f0c02072ddf35787d25608ed0f86ff54212b5bdee84c9da5875766f8674e71eec9504aa3008ebd86ad5ce86ca7388cd9dd5bd03427c31aefcde37f4a54c84b3d27b2c50e7eff7a508c805b27ebae7cd3150f172df264aeb80561df14da5008ea8789716d25caabd059132dc3c474b734b9adbf56dbc7c2be09882a91c5980e615a8018b6e233ba1adf6cb2bc9e2fb225922cbd25ced5bc37370b3b082f6a1ee7c9387ff73cd7cf1625a5f8058b577b29fdb603a154736e977f44c6bf43056da408fc1e272a2f044bbf3d5d1b351ae67617dda7eb2d261ee5cdf6a741aa92e24b8bb6c3cbd16f78a606249fb4a44a13da70689a1d6c4a383ac3871e2904d3d8030559ea8bf68742b0774ef5e8cc707390e06ab93dd44f5410278715ba47c26c8f40146dad94dcd7b8fdb769a03599ba092544d97f7e68f77ee7ca515d5a4e6dc08beb7f22b2adfbc3f740934326bbda9b5c4affdb93808fd224fb4d687482c10c3787e6f69df266c902fae1eccb2972a3ec1aceaf984e1b11065d3fb5acd77cb4b9fd45d3b086570ad836ac3d0ab8f1c48ca8261da3816d6ed9fe3e20399a67ce7777ca0f55254756f90fe89aaa21ac3bdc8c75258767edad98dc71254d4a3ca025ee7bda6ee3d3df2b9317e9ce0f2775cf656cf5a8d2662dbba046147ab8574e67d5c2b49af0909e4d74a4cf5e188954eafe6714fee3f5f0327dce6b865bf1982daa01711d4f1ad6cbb64b4a57f1fd7395af99fafd86147377c4a75573dd2a91de3fe9d548a1f5369763b516acc2569797b4c4b6879c424115151b5b913f57c04e9d9e456b1afee891e423b673d91ff7326acb8744b5cfe9005b73b49fbce6d6a05921aeb24c84f40eafbd9beb969b239f8a4b73a3d0d97d2a71c42cdbc6984872540026514befeece20a3b8a12a01b142406780c50b7df82b0c40115ff9abba5764474fba8d3858ee7cef33d01dd26ba7117254a643f8b8fa3f4c9b4f4b953296a59d59c87cb4380b0311ce87cba48c8e9158ba4187448abc95700307d56d6f05cf6d2de4a47dee00a47964043493fe6272eca1acc061b56fc97e1d5d3234996529f2c37f6a2accfbff2d5435ef1f84fd6a8adbabdbcec7b86080e8147eaafef0651ed9e2bea409667644ec8ab9ab7ee7aa5b4dfad2c56b620568ab55dd2e97fae2ab4138197ea00b3dbb37e943c6276398cbbf8ce79da659544fc4ef1db12f129e5783202974d7604c5ae23a29eca8758311e8e738cc1f8692393970863f1e0ec2311082268582f48b5fd2d2b60a5d6ead5149cfe66114e5f8d8e0a19f3c91f22af55aafb04df9dbd26b3caeb870d69d2df3f430a1b2cfda4505f993ccc2d548a37be9cce57ecbfca0782f7759242776cf39c3fc344ece6f049251cfbace0cd1d8c8da8a4bd320692a18b12f43bbd93d7ed8222e153e836e08ea4bff9dad6fb6f709e0a31bb52b18cdc0445c23dba5536b8ed78860ea1517de00e69b53f6b03b88d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码！！！</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试理论与基础</title>
      <link href="/FRank675.github.io/posts/f4b1e50edde1/"/>
      <url>/FRank675.github.io/posts/f4b1e50edde1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="1-阐述软件生命周期都有哪些阶段？常见的软件生命周期模型有哪些？"><a href="#1-阐述软件生命周期都有哪些阶段？常见的软件生命周期模型有哪些？" class="headerlink" title="1.阐述软件生命周期都有哪些阶段？常见的软件生命周期模型有哪些？"></a>1.阐述软件生命周期都有哪些阶段？常见的软件生命周期模型有哪些？</h2><p><strong>答：</strong>软件生命周期是指一个计算机软件从功能确定、设计，到开发成功投入使用，并在使用中不断地修改、增补和完善，直到停止该软件的使用的全过程。</p><p>生命周期从收到应用软件开始算起，到该软件不再使用为止。它有如下各方面的内容：初始构思、需求分析、功能设计、内部设计、文档计划、测试计划、文档准备、集成、测试、维护、升级、再测试、逐步淘汰等等。</p><p>常见的软件生命周期模型：瀑布模型、迭代模型、快速原型模型、螺旋模型。</p><h2 id="2-什么是版本控制，常见的版本控制系统有哪些？"><a href="#2-什么是版本控制，常见的版本控制系统有哪些？" class="headerlink" title="2.什么是版本控制，常见的版本控制系统有哪些？"></a>2.什么是版本控制，常见的版本控制系统有哪些？</h2><h2 id="3-简述软件测试与软件开发之间的关系？"><a href="#3-简述软件测试与软件开发之间的关系？" class="headerlink" title="3.简述软件测试与软件开发之间的关系？"></a>3.简述软件测试与软件开发之间的关系？</h2><h2 id="4-常见的测试模型有哪些？"><a href="#4-常见的测试模型有哪些？" class="headerlink" title="4.常见的测试模型有哪些？"></a>4.常见的测试模型有哪些？</h2><h2 id="5-请根据V模型分别概述测试人员在软件的需求定义阶段、设计阶段、编码阶段、系统集成阶段的工作任务及其相应生成的文档？"><a href="#5-请根据V模型分别概述测试人员在软件的需求定义阶段、设计阶段、编码阶段、系统集成阶段的工作任务及其相应生成的文档？" class="headerlink" title="5.请根据V模型分别概述测试人员在软件的需求定义阶段、设计阶段、编码阶段、系统集成阶段的工作任务及其相应生成的文档？"></a>5.请根据V模型分别概述测试人员在软件的需求定义阶段、设计阶段、编码阶段、系统集成阶段的工作任务及其相应生成的文档？</h2><h2 id="6-W模型的描述"><a href="#6-W模型的描述" class="headerlink" title="6.W模型的描述"></a>6.W模型的描述</h2><h2 id="7-编写测试计划的目的是？"><a href="#7-编写测试计划的目的是？" class="headerlink" title="7.编写测试计划的目的是？"></a>7.编写测试计划的目的是？</h2><p><strong>答：</strong>使测试工作顺利进行，使项目参与人员沟通更舒畅；使测试工作更加系统化。</p><h2 id="8-测试计划编写的六要素？"><a href="#8-测试计划编写的六要素？" class="headerlink" title="8.测试计划编写的六要素？"></a>8.测试计划编写的六要素？</h2><p><strong>答：</strong>why-为什么要进行这些测试</p><p>what-测试哪些方面，不同阶段的工作内容</p><p>when-测试不同阶段的起始时间</p><p>where-相应文档，缺陷的存放位置，测试环境等</p><p>who-项目有关人员组成，安排哪些测试人员进行测试</p><p>how-如何去做，使用哪些测试工具以及测试方法进行测试</p><h2 id="9-项目版本执行过程中，测试人员如何把控测试进度？"><a href="#9-项目版本执行过程中，测试人员如何把控测试进度？" class="headerlink" title="9.项目版本执行过程中，测试人员如何把控测试进度？"></a>9.项目版本执行过程中，测试人员如何把控测试进度？</h2><h2 id="10-测试人员在软件开发过程中的任务是什么？"><a href="#10-测试人员在软件开发过程中的任务是什么？" class="headerlink" title="10.测试人员在软件开发过程中的任务是什么？"></a>10.测试人员在软件开发过程中的任务是什么？</h2><p><strong>答：</strong>寻找Bug；避免软件开发过程中的缺陷；衡量软件的品质；关注用户的需求。总的目标就是：确保软件的质量。</p><h2 id="11-请列出你所知道的软件测试种类，至少五种？"><a href="#11-请列出你所知道的软件测试种类，至少五种？" class="headerlink" title="11.请列出你所知道的软件测试种类，至少五种？"></a>11.请列出你所知道的软件测试种类，至少五种？</h2><h2 id="12-黑盒测试、白盒测试、单元测试、集成测试、系统测试、验收测试的区别与联系？"><a href="#12-黑盒测试、白盒测试、单元测试、集成测试、系统测试、验收测试的区别与联系？" class="headerlink" title="12.黑盒测试、白盒测试、单元测试、集成测试、系统测试、验收测试的区别与联系？"></a>12.黑盒测试、白盒测试、单元测试、集成测试、系统测试、验收测试的区别与联系？</h2><h2 id="13-简述常用的Bug管理或者用例管理工具，并且描述其中一个工作流程？"><a href="#13-简述常用的Bug管理或者用例管理工具，并且描述其中一个工作流程？" class="headerlink" title="13.简述常用的Bug管理或者用例管理工具，并且描述其中一个工作流程？"></a>13.简述常用的Bug管理或者用例管理工具，并且描述其中一个工作流程？</h2><h2 id="14-禅道和qc的区别？"><a href="#14-禅道和qc的区别？" class="headerlink" title="14.禅道和qc的区别？"></a>14.禅道和qc的区别？</h2><h2 id="15-黑盒测试和白盒测试常用的测试方法有哪些，举个例子？"><a href="#15-黑盒测试和白盒测试常用的测试方法有哪些，举个例子？" class="headerlink" title="15.黑盒测试和白盒测试常用的测试方法有哪些，举个例子？"></a>15.黑盒测试和白盒测试常用的测试方法有哪些，举个例子？</h2><h2 id="16-简述黑盒测试和白盒测试的优缺点？"><a href="#16-简述黑盒测试和白盒测试的优缺点？" class="headerlink" title="16.简述黑盒测试和白盒测试的优缺点？"></a>16.简述黑盒测试和白盒测试的优缺点？</h2><h2 id="17-在没有产品说明书和需求文档的情况下能够进行黑盒测试的设计吗？"><a href="#17-在没有产品说明书和需求文档的情况下能够进行黑盒测试的设计吗？" class="headerlink" title="17.在没有产品说明书和需求文档的情况下能够进行黑盒测试的设计吗？"></a>17.在没有产品说明书和需求文档的情况下能够进行黑盒测试的设计吗？</h2><h2 id="18-单元测试的策略有哪些，主要内容有哪些？"><a href="#18-单元测试的策略有哪些，主要内容有哪些？" class="headerlink" title="18.单元测试的策略有哪些，主要内容有哪些？"></a>18.单元测试的策略有哪些，主要内容有哪些？</h2><h2 id="19-白盒测试逻辑覆盖有哪几种覆盖标准，覆盖率最高的是什么？"><a href="#19-白盒测试逻辑覆盖有哪几种覆盖标准，覆盖率最高的是什么？" class="headerlink" title="19.白盒测试逻辑覆盖有哪几种覆盖标准，覆盖率最高的是什么？"></a>19.白盒测试逻辑覆盖有哪几种覆盖标准，覆盖率最高的是什么？</h2><h2 id="20-Beta测试和Alpha测试有什么区别？"><a href="#20-Beta测试和Alpha测试有什么区别？" class="headerlink" title="20.Beta测试和Alpha测试有什么区别？"></a>20.Beta测试和Alpha测试有什么区别？</h2>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件体系结构-设计原则</title>
      <link href="/FRank675.github.io/posts/4135ea6587e3/"/>
      <url>/FRank675.github.io/posts/4135ea6587e3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script> <div class="row">    <embed src="../../../../pdfFile/软件体系结构六大原则.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高数需熟记内容</title>
      <link href="/FRank675.github.io/posts/c3e2e27c9995/"/>
      <url>/FRank675.github.io/posts/c3e2e27c9995/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，这个密码看着不太对。" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="260e8885d601d46cf10361a108897367e25063808d6fec63ab0092ae8fce0f8c">05f36028e34e215a20bb6ed2e9c75247b73eda1df43f74c2013d1bcb7ffb11e3dcc321d37937843be1d450e75a2c15d8f9a3201c5196ef20732e4b7a1f1f82f4c2b19f70db56a2451ea32b0168295afbeb1328ae7dd199b829e6b0d43044c4697effd4dbf00808d966beee93e923162e8e86b9fe28f802dd010dd1aebbc22092715076196ee5c8bfa5b7b926fcb47717ec91e795aa603e8ef365983a37a1fe0a95cbe47acd60032d11ac4edf2794310c064686b7cd9d3cc5dfdeed0fb6fef4d7719e5c47d01557e845b0b5f329f362264f14a475cea5631b2b9205e5ba7880f8d4233a3240096525224ace83f14fad91f8e7aff68aa0b86dcf02c6c43ea6a8f649230c1f5ab191d9fcf88941361f6911f3ea5c2c20e54051cd551729d391eb06d3f2375c6e89137c02a0acc2f8cbcb222d69b9f8538723e98b8481bf95a9b90aaa8f66005bd501363bfcb773da278cd9ad0a934416b0522f676759eb6bd42197046ab51ccfaf38ed3c0975ee806d0cf86c1c0b348c6b396fc1d4810dab7e3de61ff575b1bd4543cc2e125a3094ab4e09fdd9dc69c0400392f0ae765294f2f90679f3b56b1ef6b42553f56b495d5f42349203ba9b7fad49a55b91ac10bfc64c4ea9a21ec4e05c409665f9653de2da0aa10695771494a88ad9b21bcf44e54f68a4a749fdf6670faa4ad437e7fea9d0b113db23225ee8a9def49bc96b3bcd5adf0ec6a459f89eb42cbb59a530674bd8e493ea7ce73b477b2771089eef401cbd353f23fb817ebb57288d3f38b53d80ed0cb1209dd34ab58fb5bfedb9946ba16f13f2daf6eedf5b7c32462ef61c51e072f0d66309f1774df16d342fc7e7cc477e03333a3b5c73b292312b777816497fb6235242287b101bff4362c5fcf093c8dc3328fdefcfaa2872cb2a124183308bfd6b2547ade1bde6e52762691b3ac7421cd9b9a61b2b5f825823c198bdfea1ce13159f3f34f213799fd4adbc0d270eb6545e6b0beec1e9f876b5974490eab94674ff04afcce049950c4e0859ecd974e8e9cb34a4c56ca099e086aa2b7531e8ed0cab22bdd0aa84e509e557dcfcda85ba2c5a754c2a0cc78b568b880e85a266782cbb918843e93511f37e8a021504709a6f40db0e681d79876159922c0c5db8ec93efd56090d7262e7c73fa8a211e3da232fdb29c561a51285f2d6fc07a9903b9c19dad782f009b5a8e10ab3729e1a305a4754086b84b85752902cacb51f2cbbb16febfd40aeddfa5208e0dc06d53a51ba4e6ad8c5609a158903304d83a925e7e88d71b1d814b68e8e18eb2294262ef797872079da5734b48978e7cac79b2d007f610e94852398d14195db134546375478e42ea5f21efea98ae1339977cc90ecadf193b4d648fa847e26476d101f7e81766ea1352ae2928de3b583a09bf302132f7e29903ff559ccffd739a023b6ab68c5271c536f2298c7a87cb23cffb90d4d544b0ee66738785cff54bec359589fa06078f2812e46c1970a21b87493021f5a1749637613376ac0e2e64db6c408d63f90a9eed8e9e451ac037946d7dc18a823e8796c08be35cf97e8193af5a310a56e62500a315324c065d9275ed7f1bf9baa7abb9686c112f46806b5ce92a6d99fb5ab6e1d2586accb35b2777e54af80157e12c64c9fde2f8fabb37d4e49629415b2afbfcd1f429113b0721efb151abeb210743ebc9b8167f3dd3bbee57f84fdadecf7e7d68d5b35211efcbcf7592f68f190c4062c5b7f96a17235b85497ce61a65bc9ad752aae38ebcd2bcf0dfffecb191bbbb385135bc040868c77cdbd7ca608e1d7cd0e9678fee8671e47aa681c223098fb64a639f36b3aac3215ad4b9e7c484935ce2e619eacc95137274d7315675c46af3961eda6b8c6c74a00a81bd555b3ba4d6aee304800b89350649496af35c75ca99c6760964ee1963217c70da40f27ec3362da3731d82ee0edb07214d2d1bcf5cc863b540489ea8ee2477e5b1a5ddf673a59e363f52ca115f461636e9ab2a05f5300372a1af982215f2d4afbfdb3adc242b5c12c17a01af049bd824755b1b60cddc14549d1e82847a5767a2914eacd440195344ecabfdc06caf09a710035fef99ff294eb694e3982540fa5389bdcab9a87d8c01fe319144562a0185efdec3ded036f017970a9512eb685d2a4f81380bb7f905b50d2ee3c9eb3af95d2aa15ac3440f2ea23fb6b0695f27e28efa2794277ba1525e9c91ecb825d4b3f34e09b4be809a2894240c20dab56a3b6555c75e8319e647681bc8b5a554faede790a20d18cba1bad32f44a70b168a96e9612d42ba363e4e58b3ce8376cc7d9a597b26d854d700734947bf63c297a375252f52b3b339f474abc59b68d051664904b2356cce1e220637d89b085090e0f64df19c18afe2ed6c8ae3ed3529125b7e9c86fa9f303761982a39d8ae6753f558248e0401eb7e25b5dbc0bba4b7bf6d5b45c7f40343160bc38de22afb64516bf654ce100961d40766203f03b963b273a5bfaf6fbede9a474cd636c7b5ee493218b0d8f3e4c86b54652266fd76bb07979424da81b1587d768d51940dd9a00ec0ff13bb984c7cd6d29b440d7f6567ddb9635201c96decb32f5265fb5615d7586af2b72d038ab491c30508503a324358a2a3530aa81a7746b68c09f0385d3fadea1aa42e57f8998202d6feb8847f792991283f38c50e455f89c666d373f786786ea6a4ef2a04d8de8ea2e05d6e230e572c7fa2f4265dec4032e7d2129d829f4a904dfc8a0a94c6e177d0853d1a6b7f85963bcd02037d80489bef4001eef6c1c43e81192b7a9183a25353749119f820f48d8222a304a1af0a0e130dcd6a0d91335914b28e268cea2e8afb37216ec6c073dbf0e6541144900aac9964ae6b3576fc58521b0b8645d1843e45af49a7359abca51b3b6992826d9c95a30e4dc38bb846c8d436bd8cf418ece70448fd7c59eea4ffe8a957e2c7c1d4e48ea5c19f2c08ddfa8b4f275906cd1854c761914e2676cd18f71817b945a49d3e3b35ab6acc6adb1761faeb90fa977739f81338b421e9a796ba59184dbc0456a9fd47bdee8bdb91897f60378f467a5b42c79b798328263f93a2bc56f6d2f713ec37976af57430e262ee254f23abcfe2dc157dde838641ba7b87f48041118e236109f2f0b7390e53940039d5bebf8e5c0b2c42075a16b0ac0a6b9dbe16276dd4e509389b6167d95aff630b2120e195dfdd394e3fd44875a3fc7f2edbd9cdf5b6d3475024b60c812b19d94e54b4c875b544726d3f9f26f8ba7ebe3d4ccf1a11192049a2689cb9d186767b32dc69411af74b1c7ad0c24e2b865926c931a3080a58c4b8fc6d3d7ad3659df13a013c97dbdb37ff5ad68e60c854866a85c90675138c63ea0e2351e7fad1b7f3586cf50595d2cdd6fd1a4036c88a2966d5fd11a6bc46c484687a1102979ac24b2289231f3b6003f2b0ee5e988779861edf5441414f391831bc677b7a20172501ab3d1bbd0d4889d38e3729c8b798f973f3aa675093c1e0b424011319f2c1f2e02e984f116f8531a68fdee88bfb76db926a01f4e81466ea5c2867344adecbe870a7881e5307829d1cf678fd8b18fc3fd0177c0e960f856f9df681b9a2299c3cceeceaf3180a279cef3999c62ee1749521d61936ffbf08b8a7cac4242994e542234bb78e3fdc7e90eff813af84f06fb626340d475247786f9039fc8bc62843bbc24bb73de5d49e5632758aa8f3f6509dc36dc05ccfddd6a1617e2595bf3b2b6a798bfc57461865e821c8cb680dbe4748fec51962468ba94e221fd2a3f97798c808f25af1337374c0c916</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码！！！</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高数复习笔记</title>
      <link href="/FRank675.github.io/posts/5280956c0654/"/>
      <url>/FRank675.github.io/posts/5280956c0654/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，这个密码看着不太对。" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="046ac740e13c1ea25613765ad532cc8f926d31bdf4856ee104450a1b6ad5cdeb">05f36028e34e215a20bb6ed2e9c75247b73eda1df43f74c2013d1bcb7ffb11e3dcc321d37937843be1d450e75a2c15d8f9a3201c5196ef20732e4b7a1f1f82f4c2b19f70db56a2451ea32b0168295afbeb1328ae7dd199b829e6b0d43044c4697effd4dbf00808d966beee93e923162e8e86b9fe28f802dd010dd1aebbc22092715076196ee5c8bfa5b7b926fcb47717ec91e795aa603e8ef365983a37a1fe0a95cbe47acd60032d11ac4edf2794310c064686b7cd9d3cc5dfdeed0fb6fef4d7719e5c47d01557e845b0b5f329f362264f14a475cea5631b2b9205e5ba7880f8d4233a3240096525224ace83f14fad91f8e7aff68aa0b86dcf02c6c43ea6a8f649230c1f5ab191d9fcf88941361f6911f3ea5c2c20e54051cd551729d391eb0640ff06a693f834d8bb5c0e3eaf6d9c38771202fe4fbfea67ffae0cac12ff1b5a0f8a858cfa4bf19e635d9752014f2f327df6716517d9119c025f9e98753a6ec54495ed1a408a225653c72aaa6ba4a87f262d26772d38c85aa088a9a5c57ef0543958709d0789b806fc81f7ae61c030aa48d3fe338d0c4a7566fdf39245fb57316b78f7cb8c75480db45a51237cfe6c90043c7fb9b61f6b99dcf20660b06b2ef92eed9b45c130b399a1e760e9f48ace6c0de51678ee05065ec49ae26784b849939e16346e8acbdcc0f3edd9e461a0ea02ba9406436549449553f9f1730a79c77449e6db52d5643f0aa3f137830a1e76bf6173ab99dbb50ac6d09e52e6cf80272e7dbe6e2a8416ef7d80a367b43d5fc894b833157d440e486b4a6b88ca71c5077421a38fe5110b0f399cc40498418f5405127fbda3be817c658a753deb31cc66d0745ad837c43f9243a785625762a0c23241b687d9c9556d1db75b4b2321a5d9eaf2e52b91910b1d75601416de6be8c076e715ae29432cc841e186225e4fddc50d4a2140e70408e4f3c48191fb30875802754846650bbbe17e2bf3177d47b36a102c40be0a59996cd63f6e3f8aabc1b7f6e1b7a2e27c897d67a2f5f34939eed89d4a75c578022f9f4b94087626f04fac5061a1713ab17ba749e7c1891d5c98c17c09865a1a221d66061b4f967406617b0c027e383651ba6192dc236cd2da84530373482be062451d00f77e555a88b128baeb4fd10566f862aceb71be810588bc521a53d19a794570cf18e50ab0e548d241dfe275a9147345b9a1c41e3407a63d619d97cda8bca08c5bda1526324fe2bfc4c4e31b9db57a5b8e5bb0da6fa7695aa5899cb758ba179578ece1084e0e4025957c9278b75358f871245705429266c5c8d0684ef1079e0013aea7a7ec269c4efda4d4c30b8fb998148dd8055b2f5852b0a4d6bd2b9694c7b42d0b74abb4b1451955c47d3917051bfcb7962c2b8c84abae8efca4be2bae42e7b24b156ca182cc9f9c5a739e3f735691071ddae17b2820db21bc78a52a7942ae4da24b7299d8528a4b86e6a24447b741a071553a7397f6b4e346966626eb2a29fa6d6ec50da849fd1ee72c10ddb5faedfc72032691959b375818c265642da747aa78f83dc257f9699ef3db8bf958c6642da4b9a1107876b075e3bac27c1594305a4eda436c25d419b8a030d6288a94dd9d6a8dcb1e8446cd18caa69de1fda9fcaad793959d04f2b207bef90a2d965c4d9c83b07a36f553effb425fb6efb6bd27b43c16ed8e160ddfa75aa810161fe3c099be55af7b92f2c5504ef4a3a330151723a268cc0c246447a9992330e2c18a02894bc6320fd4c5e736074562bb6392f738496afd5d8ebff8cfe552a603b94c599caa7a9f8c3fa1e8bc5260dd0281304018208ca7a54ee9308166ee12a67dcb791ddc7cbfc6fc338840fed8aac2305e666e7fe996f9782ec2852e89b3889eb54e8f399fcfa4af77cf095d48bf9b35cb54d779bb0cf45d344f56a29befcf9343559ca4c0e311d01705b9d760ffc364ccf7417c254f8149a9ea0c973bbbc91212d9aeb6282ccdcd58e9b27b17f89d48433fac35c44952db3cc41542814417500d21d931b2caa79348614c8e65a68660319118e6dda65e641f27701fad7abf4e12a606708a14b27b1c5611f4e6d762c092d51f82db8615fdb24731bfcc1075affefd038076751f5e9ba0c573cb5e0f72962f408cfc06476ab9b7deeee6f49f948ed5274aa5c0f04afba7ea9f24d64299f795cff7bf291445a8932156b5a91f76a8772390e258389a808551d3d2abe835a43fe52c36dfa087b2c727adb0f5cbf19e5ef1fed6bfc96bc5602d7df40622f918a147ba292e234c5bd55a59ef285922762f85a39dcb839fa7b496eb382a229486e09be5168530ec7c1031795c8b205417173120b7cb603abc81e6b9265d734dba3d09adf01a8eecc7f11b890f53ae8cfb94f88913207c88d67a6d4fb8f3419e3723996f0a5786e18038f9b52086cfdee2d148076c5715b7ec880fa7a6912eb927ebbc38456aaf8e3824043089ac17efd163e8b2cc89bc45331b26e40b8d387e46d9ae20f11babc6b2c77074d0619caed8a1cb6f5ac7cd47827c24343ed46a1fa4f49ff50a854983c432456758fe41351cc21688872cfb8c073f2429f2a2bf738cea95fff9078409c9f7f9791614878e970958e436d653127cdc357a92174453b134293f1a7018859f29ed04c67e2eb6e778113e05cb379e576489aaca26f07cabeeae6b844d2f8b19c6776425ebabb31a317f3b093a3180b52c71ae05e1410b12d2dfb3efe3b7c9bedf5c836223933529d17fad82bc9bf91edfa277b46be1fa655f78330350a83aec6f80f0bf6245dd7f18866d4006840cde2e5e6b04674962b375d81051d148a68a6ae17ee99f897ff9636d55189782b5c4c1f70dc180f20c0a11f674cd058e80bbe45749c2315c9cdf811b30dba7190ef27ab9bfc433b13d1a722504550005d3e84c5b278ed5f4daf9c25365a7d9be56a0e3c67451d7ea03e399678dc37033a26c77</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码！！！</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024复盘</title>
      <link href="/FRank675.github.io/posts/ebc3a25118d3/"/>
      <url>/FRank675.github.io/posts/ebc3a25118d3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><table><thead><tr><th>02.20-02.26</th><th>星期一</th><th>星期二</th><th>星期三</th><th>星期四</th><th>星期五</th><th>星期六</th><th>星期日</th><th>周总结</th><th>备注</th></tr></thead><tbody><tr><td>今日完成</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>明日安排</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>反思总结</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>02.27-03.05</th><th>星期一</th><th>星期二</th><th>星期三</th><th>星期四</th><th>星期五</th><th>星期六</th><th>星期日</th><th>周总结</th><th>备注</th></tr></thead><tbody><tr><td>今日完成</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>明日安排</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>反思总结</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>03.06-03.12</th><th>星期一</th><th>星期二</th><th>星期三</th><th>星期四</th><th>星期五</th><th>星期六</th><th>星期日</th><th>周总结</th><th>备注</th></tr></thead><tbody><tr><td>今日完成</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>明日安排</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>反思总结</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>03.13-03.19</th><th>星期一</th><th>星期二</th><th>星期三</th><th>星期四</th><th>星期五</th><th>星期六</th><th>星期日</th><th>周总结</th><th>备注</th></tr></thead><tbody><tr><td>今日完成</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>明日安排</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>反思总结</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 复盘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复盘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客更新日志及踩坑经验总结</title>
      <link href="/FRank675.github.io/posts/6033a1afd5e7/"/>
      <url>/FRank675.github.io/posts/6033a1afd5e7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="Hexo博客更新日志及踩坑经验总结"><a href="#Hexo博客更新日志及踩坑经验总结" class="headerlink" title="Hexo博客更新日志及踩坑经验总结"></a>Hexo博客更新日志及踩坑经验总结</h1><h2 id="博客功能"><a href="#博客功能" class="headerlink" title="博客功能"></a>博客功能</h2><ul><li><input checked="" disabled="" type="checkbox"> 基本的Blog文章更新</li><li><input checked="" disabled="" type="checkbox"> 博客文章的分类、标签、归档</li><li><input checked="" disabled="" type="checkbox"> Blog界面优化</li><li><input checked="" disabled="" type="checkbox"> 本地搜索博客功能</li><li><input checked="" disabled="" type="checkbox"> 留言功能（有点问题QAQ待完善）</li><li><input checked="" disabled="" type="checkbox"> 侧边栏时钟</li><li><input checked="" disabled="" type="checkbox"> 音乐🎵功能，可以播放网易云的歌单啦</li><li><input checked="" disabled="" type="checkbox"> 解决上线后icon不显示的问题</li><li><input checked="" disabled="" type="checkbox"> 增加了看板娘（其实是可爱的小男生）</li><li><input disabled="" type="checkbox"> SEO优化</li><li><input disabled="" type="checkbox"> 页脚徽标</li><li><input disabled="" type="checkbox"> 字体样式修改</li><li><input disabled="" type="checkbox"> 滚动的副标题</li></ul><h2 id="一些于我有用的博主文章"><a href="#一些于我有用的博主文章" class="headerlink" title="一些于我有用的博主文章"></a>一些于我有用的博主文章</h2><p> <a href="https://guole.fun/posts/butterfly-custom/">我的Blog美化日记——Hexo+Butterfly | Guo Le’s Blog</a> </p><p> <a href="https://blog.csdn.net/qq_46435629/article/details/106295515?spm=1001.2101.3001.6650.4&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-4-106295515-blog-123481948.pc_relevant_antiscanv2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-4-106295515-blog-123481948.pc_relevant_antiscanv2&utm_relevant_index=6">如何在Hexo博客Butterfly主题开启Aplayer和“音乐”页面</a> </p><p> <a href="https://www.yyyzyyyz.cn/posts/2d51c9bd3490/">hexo-butterfly魔改记录大全 | Black Flies (yyyzyyyz.cn)</a> </p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校园二手交易平台-可行性分析报告</title>
      <link href="/FRank675.github.io/posts/ca23de82c4bf/"/>
      <url>/FRank675.github.io/posts/ca23de82c4bf/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="校园二手交易平台-可行性分析报告"><a href="#校园二手交易平台-可行性分析报告" class="headerlink" title="校园二手交易平台-可行性分析报告"></a><strong>校园二手交易平台</strong>-可行性分析报告</h1><p><strong>编写人员：杨顺杰、魏泽弘、高时玉、赵任生、龚云基、杨笑千</strong></p><p><strong>指导老师：张大林</strong></p><p><strong>编写日期：2022.3.21</strong></p><p><strong>本说明书版权与一切解释权归蓝瞳团队所有</strong></p><h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h2><h3 id="1-1-编写目的"><a href="#1-1-编写目的" class="headerlink" title="1.1 编写目的"></a>1.1 编写目的</h3><p>通过对校园二手物品交易系统项目进行一系列的详细调查研究，明确了该系统项目的实现在技术、经济和社会因素方面的可行性，阐述为了合理地达到项目目标的实现报告，对软件开发中将要面临的问题及其解决方案进行可行性分析；本报告经审核后，交由项目负责人审查。</p><h3 id="1-2-背景"><a href="#1-2-背景" class="headerlink" title="1.2 背景"></a>1.2 背景</h3><h4 id="1-2-1项目名称："><a href="#1-2-1项目名称：" class="headerlink" title="1.2.1项目名称："></a>1.2.1项目名称：</h4><p>校园二手物品交易系统</p><h4 id="1-2-2项目提出者："><a href="#1-2-2项目提出者：" class="headerlink" title="1.2.2项目提出者："></a>1.2.2项目提出者：</h4><p>北交二手交易平台开发小组</p><h4 id="1-2-3用户："><a href="#1-2-3用户：" class="headerlink" title="1.2.3用户："></a>1.2.3用户：</h4><p>北交学生、教职工等</p><h4 id="1-2-4项目说明："><a href="#1-2-4项目说明：" class="headerlink" title="1.2.4项目说明："></a>1.2.4项目说明：</h4><p>目前，随着人们生活水平的提高，人们的生活物质更新速度也在不断地加快。 对于大学生群体，闲置物品繁多，很多大学生买了一件商品，但是只是使用一段时间就被闲置了，着实令人感到可惜，这些物品丢之可惜，藏之无用；但这些东西往往又是另一些学生需要用的物品。就我们的经验和调查发现，大家通常是加一些qq群、或者通过朋友圈了解到相关信息，在这样的前提下，受到互联网思维的影响，我们针对这一现状进行了分析和总结，设计了校园闲置网站，在这里，不仅可以让闲置的物品流通起来，产生价值，还可以发布信息、共享交流。项目的意义在于，支持勤俭节约；倡导互惠互利；开展爱心义卖；践行低碳环保；做到物尽其用；支持以物换物；实现智能管理（机器学习、人工智能）；达到安全平稳。</p><h3 id="1-3-定义"><a href="#1-3-定义" class="headerlink" title="1.3 定义"></a>1.3 定义</h3><p>校园二手物品交易系统：帮助大学生、教职工等有需要的群体进行二手交易的系统。</p><p>技术可行性：使用现有的技术能实现这个系统吗？</p><p>经济可行性：这个系统的经济效益能超过它的开发成本吗？</p><p>操作可行性：用户会使用系统吗？开发的时间够吗？</p><p>社会因素可行性：系统开发过程中是否设计各种合同、侵权、责任等与法律、法规吻合或抵触的问题？</p><h3 id="1-4-参考资料"><a href="#1-4-参考资料" class="headerlink" title="1.4 参考资料"></a>1.4 参考资料</h3><p>​[1]高美珍，洪家平.高校二手物品交易系统的设计与实现[J].湖北师范大学学报（自然科学版），2018，38（04）：65-69.</p><p>​[2]曲蕴慧.校园二手交易平台的构建与实现[J].电子设计工程，2014，22（06）：70-72.</p><p>​[3]庄彦，未培.基于校园网的二手交易平台构建与实践[J].集宁师范学院学报，2016，38（02）：40-43.</p><h2 id="2-可行性研究的前提"><a href="#2-可行性研究的前提" class="headerlink" title="2 可行性研究的前提"></a>2 可行性研究的前提</h2><h3 id="2-1-要求"><a href="#2-1-要求" class="headerlink" title="2.1 要求"></a>2.1 要求</h3><h4 id="2-1-1-功能要求"><a href="#2-1-1-功能要求" class="headerlink" title="2.1.1 功能要求"></a>2.1.1 功能要求</h4><p>此系统需要完成的功能主要有：用户个人信息管理、二手交易平台（发布信息，修改信息，删除信息，浏览信息，搜索信息等）、用户交流功能（发表留言，查看留言，删除留言等）、用户指南（添加二手指南，查看二手指南，修改二手指南，删除二手指南）、智能推荐。</p><h4 id="2-1-2-性能要求"><a href="#2-1-2-性能要求" class="headerlink" title="2.1.2 性能要求"></a>2.1.2 性能要求</h4><p>为了能够为用户提供充足的物品信息和快捷的处理手段，用户使用时系统要保证运行稳定、效率高，能够快速做出响应，迅速处理各项数据、信息，显示出所需信息，所以要有一定的可扩展性和灵活性，当毕业生处理闲置物品高峰期等大量人员操作时，做到节省录入时间、提高交易效率和安全性，系统要保证操作简便、快捷。</p><h4 id="2-1-3-输入要求"><a href="#2-1-3-输入要求" class="headerlink" title="2.1.3 输入要求"></a>2.1.3 输入要求</h4><p>对于卖家，需要上传物品的类型、价格、图片、完好程度等信息；对于买家，可以在物品或者卖家评论区发布自己的意见和建议。</p><h4 id="2-1-4-输出要求"><a href="#2-1-4-输出要求" class="headerlink" title="2.1.4 输出要求"></a>2.1.4 输出要求</h4><p>卖家上传的物品信息会在系统展示出来供用户挑选。界面做到简洁明了，易于操作。</p><h4 id="2-1-5-安全与保密要求"><a href="#2-1-5-安全与保密要求" class="headerlink" title="2.1.5 安全与保密要求"></a>2.1.5 安全与保密要求</h4><p>由于校园二手交易系统涉及到学生利益问题，所以系统的安全性一定是不容忽视的，系统要做到用户交易过程公平公正，并且用户的购买信息、浏览记录和个人信息等隐私可以自由选择保密，不对任何人公布。</p><h4 id="2-1-6-完成期限"><a href="#2-1-6-完成期限" class="headerlink" title="2.1.6 完成期限"></a>2.1.6 完成期限</h4><table><thead><tr><th>模块</th><th>完成期限</th></tr></thead><tbody><tr><td>用户信息模块</td><td>2022-03-27</td></tr><tr><td>交易模块</td><td>2022-04-05</td></tr><tr><td>社区模块</td><td>2022-04-06</td></tr><tr><td>展示模块</td><td>2022-04-10</td></tr><tr><td>活动模块</td><td>2022-04-28</td></tr></tbody></table><h3 id="2-2-目标"><a href="#2-2-目标" class="headerlink" title="2.2 目标"></a>2.2 目标</h3><p>（1）使用最新开发工具开发，运行稳定、效率高</p><p>（2）可扩展性和灵活性强，用户随时可以上传物品信息或者进行交易</p><p>（3）操作简便、快捷，操作逻辑缜密，明了</p><p>（4）易于维护，尽可能减轻系统维护与升级的成本和工作量</p><h3 id="2-3-条件、假定和限制"><a href="#2-3-条件、假定和限制" class="headerlink" title="2.3 条件、假定和限制"></a>2.3 条件、假定和限制</h3><p>假定开发的软件运行的最短寿命为5年，开发期和运行期各一个月；经费来源于项目小组，限制在1000元以内；硬件条件：普通PC机即可，运行环境：windows系列，数据库：MYSQL；建议软件投入使用的最迟时间是2022年6月。</p><h3 id="2-4-进行可行性研究的方法"><a href="#2-4-进行可行性研究的方法" class="headerlink" title="2.4 进行可行性研究的方法"></a>2.4 进行可行性研究的方法</h3><p>采用问卷调查的方法：经过针对性的对该项目制定出调查问卷并在相关学校进行相关调查；在调查过程中，项目组分别与学生进行了深入的交流与统计，发现他们对系统的功能等方面可能会存在的问题有很多顾虑。所以，问卷调查之后，经过小组网上会议组及时总结了调查对象的需求，提出了系统的结构分析，最后确定了解决方案。</p><h3 id="2-5-评价尺度"><a href="#2-5-评价尺度" class="headerlink" title="2.5 评价尺度"></a>2.5 评价尺度</h3><p>本项目对系统进行评价时所使用的主要尺度就是调查对象的满意程度。根据用户提出的要求，总结归纳出系统应该具有以下几点：一、系统安全性要高；二、系统运行稳定且速度要快；三、简易的操作；四、实现网络化的管理系统。</p><h2 id="3-对现有系统的分析"><a href="#3-对现有系统的分析" class="headerlink" title="3 对现有系统的分析"></a>3 对现有系统的分析</h2><h3 id="3-1-数据流程和处理流程"><a href="#3-1-数据流程和处理流程" class="headerlink" title="3.1 数据流程和处理流程"></a>3.1 数据流程和处理流程</h3><p><img src="/%E5%8F%AF%E8%A1%8C%E6%80%A7%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A.assets/1647483591126.png" alt="1647483591126"></p><p><img src="/%E5%8F%AF%E8%A1%8C%E6%80%A7%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A.assets/1647483600024.png" alt="1647483600024"></p><p><img src="/%E5%8F%AF%E8%A1%8C%E6%80%A7%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A.assets/1647483620846.png" alt="1647483620846"></p><p><img src="/%E5%8F%AF%E8%A1%8C%E6%80%A7%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A.assets/1647483630850.png" alt="1647483630850"></p><h3 id="3-2-工作负荷"><a href="#3-2-工作负荷" class="headerlink" title="3.2 工作负荷"></a>3.2 工作负荷</h3><p>1.要实现一个完备的平台开发是一个漫长的过程，这个过程包含着产品的完整开发周期，产品测试，和后期的维护，面对如此大的工作量，我们将面对着人手不够，资金短缺等难题。</p><p>2.系统开发完成后，如何进行推广是一个很大的问题，如今市场上有着很多的相似的产品，如何让我们的产品脱颖而出是一个难题，我们决定从校园出发，在各大高校的微信群和QQ群出发进行推广，这也是一个巨大的工作量。</p><h3 id="3-3-费用开支"><a href="#3-3-费用开支" class="headerlink" title="3.3 费用开支"></a>3.3 费用开支</h3><table><thead><tr><th>开发活动</th><th>预计费用</th></tr></thead><tbody><tr><td>平台开发</td><td>100元</td></tr><tr><td>团队学习</td><td>100元</td></tr><tr><td>开发工具</td><td>100元</td></tr><tr><td>平台推广</td><td>200元</td></tr><tr><td>团队人员补贴</td><td>600元（100&#x2F;人）</td></tr></tbody></table><h3 id="3-4-人员"><a href="#3-4-人员" class="headerlink" title="3.4 人员"></a>3.4 人员</h3><table><thead><tr><th>项目模块</th><th>开发人员</th><th>实现功能</th></tr></thead><tbody><tr><td>用户信息模块</td><td>高时玉</td><td>搜索信息、浏览信息、删除信息、修改信息、发布消息</td></tr><tr><td>交易模块</td><td>杨顺杰、魏泽弘</td><td>用户注册、用户登录、用户密码管理、平台搭建、支付组件</td></tr><tr><td>活动模块</td><td>赵任生</td><td>以物易物、二手物品捐赠、义卖活动</td></tr><tr><td>展示模块</td><td>杨笑千</td><td>智能推荐、视频展示、独家活动、用户指南</td></tr><tr><td>社区模块</td><td>龚云基</td><td>留言管理、动态管理、社交群聊、评论管理</td></tr></tbody></table><h3 id="3-5-设备"><a href="#3-5-设备" class="headerlink" title="3.5 设备"></a>3.5 设备</h3><p>我们的系统准备开发成web端，因此需要用户拥有可以进行访问的设备，当然这在学生群体中是很简单实现的。</p><p>目前我们的开发设备有六台笔记本电脑，配有专业的开发软件，可以实现系统的开发、测试、维护。</p><p>但是在开发的后期可能会缺乏一些其他的开发或者推广的设备。</p><h3 id="3-6-局限性"><a href="#3-6-局限性" class="headerlink" title="3.6 局限性"></a>3.6 局限性</h3><table><thead><tr><th>局限</th><th>原因</th><th>解决方案</th></tr></thead><tbody><tr><td>web端过于单一，不利于推广</td><td>大学生们习惯于使用手机，更愿意使用APP</td><td>将我们的产品开发成多种形式</td></tr><tr><td>功能不够全面</td><td>开发时间短，开发人手不够</td><td>适当地延长开发周期</td></tr><tr><td>推广十分困难</td><td>市场存在相似产品，产品优势不够大</td><td>尽量让产品具有竞争性</td></tr><tr><td>开发资金短缺</td><td>开发团队为6名在校大学生</td><td>寻求赞助</td></tr></tbody></table><h2 id="4-所建议的系统"><a href="#4-所建议的系统" class="headerlink" title="4 所建议的系统"></a>4 所建议的系统</h2><h3 id="4-1-对所建议系统的说明"><a href="#4-1-对所建议系统的说明" class="headerlink" title="4.1 对所建议系统的说明"></a>4.1 对所建议系统的说明</h3><h4 id="4-1-1产品及服务"><a href="#4-1-1产品及服务" class="headerlink" title="4.1.1产品及服务"></a>4.1.1产品及服务</h4><p>​通过校园二手物品交易网站满足学生对二手物品的买卖需求，方便学生的日常生活。校园二手交易平台提供一个买卖双方对物品交易的协商平台。</p><h4 id="4-1-2开发交友平台"><a href="#4-1-2开发交友平台" class="headerlink" title="4.1.2开发交友平台"></a>4.1.2开发交友平台</h4><p>​具备发布信息，浏览信息，买卖双方交流，系统管理员整合信息功能。</p><h4 id="4-1-3-系统管理"><a href="#4-1-3-系统管理" class="headerlink" title="4.1.3.系统管理"></a>4.1.3.系统管理</h4><p>​管理员可以对物品信息和用户进行管理，可以发布公告，更新用户信息。同时对长久未能出售的物品进行清除。</p><h4 id="4-1-4-用户使用"><a href="#4-1-4-用户使用" class="headerlink" title="4.1.4.用户使用"></a>4.1.4.用户使用</h4><p>​学生每人可以用手机号注册一个账号，登陆进入个人界面，管理自己的出售和购入信息。卖家对自己的产品进行描述，发布出售信息。</p><h4 id="4-1-5-目标市场"><a href="#4-1-5-目标市场" class="headerlink" title="4.1.5.目标市场"></a>4.1.5.目标市场</h4><table><thead><tr><th align="left">目标市场</th><th>市场需求</th></tr></thead><tbody><tr><td align="left">大学生</td><td>随着年级的更换，积留一些无用而又占用空间的课本、笔记</td></tr><tr><td align="left">大学生</td><td>即将毕业的大学生需要处理一些无用的生活用品</td></tr><tr><td align="left">大学生</td><td>剁手族在狂欢后常常发现所买物品不符合自身需求</td></tr><tr><td align="left">大学生</td><td>平时的一些小创意希望出手</td></tr><tr><td align="left">大学生</td><td>希望通过交换账号，体验游戏的新装备</td></tr><tr><td align="left">教师及其家属</td><td>对一些普通的生活用品有需求</td></tr></tbody></table><h3 id="4-2-数据流程和处理流程"><a href="#4-2-数据流程和处理流程" class="headerlink" title="4.2 数据流程和处理流程"></a>4.2 数据流程和处理流程</h3><h3 id="4-3-改进之处"><a href="#4-3-改进之处" class="headerlink" title="4.3 改进之处"></a>4.3 改进之处</h3><p>系统被开发成Web端、APP端、小程序端，但是三者极具有相似度，并不能很好地体现出每个形式的优势，应当针对不同的形式进行改进，发挥出每个形式的优势。</p><h3 id="4-4-影响"><a href="#4-4-影响" class="headerlink" title="4.4 影响"></a>4.4 影响</h3><p>通过我们的二手交易平台，学生们的闲置二手物品可以得到很好的利用，不仅响应的国家的绿色的政策，也有利于学生们的生活，不仅仅使自己的物品得到了再次利用，也降低了自己的生活成本，一举两得。</p><h3 id="4-5-局限性"><a href="#4-5-局限性" class="headerlink" title="4.5 局限性"></a>4.5 局限性</h3><p>随着对系统的改进，让我们的工作量增加了许多，所以依旧有着以下的局限性。</p><table><thead><tr><th>局限</th><th>原因</th><th>解决方案</th></tr></thead><tbody><tr><td>推广十分困难</td><td>市场存在相似产品，产品优势不够大</td><td>尽量让产品具有竞争性</td></tr><tr><td>开发资金短缺</td><td>开发团队为6名在校大学生</td><td>寻求赞助</td></tr><tr><td>开发难度大</td><td>系统完善后工作量增加</td><td>适当地延长开发周期</td></tr></tbody></table><h3 id="4-6-技术条件方面的可行性"><a href="#4-6-技术条件方面的可行性" class="headerlink" title="4.6 技术条件方面的可行性"></a>4.6 技术条件方面的可行性</h3><p>1.我们的团队是具有相关的软件开发知识的，且具有相关的开发设备，具有开发这个系统的能力。</p><p>2.线下的推广，我们会有专门的人员去负责二手商品信息的收集，然后将它们进行整合、分类。将它们统一摆放在一个地方方便购买者前去购买，线上的推广，主要是以QQ群、微信公众号，人人网，新浪微博，贴吧等网络媒体的介入，发布我们整合的二手商品的信息，通过这些网络媒体工具进行发布。</p><h4 id="推荐系统（基于用户画像的商品推荐系统）"><a href="#推荐系统（基于用户画像的商品推荐系统）" class="headerlink" title="推荐系统（基于用户画像的商品推荐系统）"></a>推荐系统（基于用户画像的商品推荐系统）</h4><p>基于物品本身属性的推荐，与个性化是没有确定关系，推荐候选集只跟物品主体有关。</p><p>而基于用户画像（基于用户标签）的推荐，则更大程度上依赖于用户的画像属性来推荐，这就体现了用户偏好信息，根据偏好信息来选择候选集</p><p> 业务处理的逻辑是，先根据行为数据，抽取用户浏览的新闻，然后根据做浏览的新闻的标签，映射到用户，进行用户画像的构建，最后根据新闻标签结合用户画像为用户进行信息推荐。注意，这里与之前的实例不同的是，我们是基于用户进行推荐的，而上个实例是在浏览某个内容的时候，进行相关内容推荐，这里以及进化到了根据人进行推荐了。 </p><p>市面上已经有很成熟的基于用户画像的推荐系统。</p><h4 id="用户管理系统"><a href="#用户管理系统" class="headerlink" title="用户管理系统"></a>用户管理系统</h4><p>该项目采用mysql数据库存储用户，物品信息，并且实现与后端的实时交互， Mysql功能强大，支持事务、视图、存储过程、触发器等 ，并且可以跨平台使用，满足至少20种以上的开发平台，同时还支持多种语言，其数据库存储容量大， 可以轻松处理拥有上千万条记录。</p><h2 id="6-经济可行性分析"><a href="#6-经济可行性分析" class="headerlink" title="6 经济可行性分析"></a>6 经济可行性分析</h2><h3 id="6-1-支出"><a href="#6-1-支出" class="headerlink" title="6.1 支出"></a>6.1 支出</h3><p>  二手交易平台项目着重于软件的开发，成本主要表现为人力消耗，具体体现在前期软件代码的编写以及后期对平台的维护费用，由于项目复杂程度不高，代码的编写费用与后期的维护费用也不会太高。除此之外，作为一个交易平台需要系统持续运作，所以成本还应包括系统持续运行所需的费用。</p><h3 id="6-2-收益"><a href="#6-2-收益" class="headerlink" title="6.2 收益"></a>6.2 收益</h3><p>  二手交易平台的推行将使交易更加便捷，支持以物易物的方式将更加有效且环保地利用资源。同时由于其便捷、实用的属性，该平台将吸引更多学生来购买或换取自己需要的物件，极大的提升了平台竞争力。</p><p>  平台通过每单成功的交易抽取一定的手续费来持续获取非一次性收益，同时可以通过帮助个人或企业刊登相关帖子或广告来抽取一部分收益。</p><h3 id="6-3-收益-x2F-投资比"><a href="#6-3-收益-x2F-投资比" class="headerlink" title="6.3 收益&#x2F;投资比"></a>6.3 收益&#x2F;投资比</h3><p>  整个系统生命期的收益&#x2F;投资比：8&#x2F;3</p><h3 id="6-4-投资回收周期"><a href="#6-4-投资回收周期" class="headerlink" title="6.4 投资回收周期"></a>6.4 投资回收周期</h3><p> 大约3个月收益将超过支出。</p><h3 id="6-5-敏感性分析"><a href="#6-5-敏感性分析" class="headerlink" title="6.5 敏感性分析"></a>6.5 敏感性分析</h3><p>  该二手交易平台可供约100笔交易同时进行，订单数量过多，又可能造成网络拥堵。</p><h2 id="7-技术可行性分析"><a href="#7-技术可行性分析" class="headerlink" title="7 技术可行性分析"></a>7 技术可行性分析</h2><p>tip：评价技术可行性需回答下面问题：<br>系统规划所选用的技术路线及其方案是否具有可行性与合理性？<br>组织机构或开发公司是否拥有系统解决方案所需技术？<br>组织机构或开发公司是否拥有所需的技术专家？</p><h3 id="7-1主要技术路线"><a href="#7-1主要技术路线" class="headerlink" title="7.1主要技术路线"></a>7.1主要技术路线</h3><p><img src="/%E5%8F%AF%E8%A1%8C%E6%80%A7%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A.assets/1647411792576.png" alt="1647411792576"></p><h3 id="7-2技术可行性分析"><a href="#7-2技术可行性分析" class="headerlink" title="7.2技术可行性分析"></a>7.2技术可行性分析</h3><h4 id="7-2-1-开发风险分析"><a href="#7-2-1-开发风险分析" class="headerlink" title="7.2.1 开发风险分析"></a>7.2.1 开发风险分析</h4><p>​    由于疫情的影响，线下交易变得难以实现，更加便捷且支持以物换物的线上二手交易平台将更具有竞争力，风险性极小。</p><h4 id="7-2-2-资源分析"><a href="#7-2-2-资源分析" class="headerlink" title="7.2.2 资源分析"></a>7.2.2 资源分析</h4><p>​    二手交易平台项目着重于软件的开发，几乎只消耗人力资源，而项目体量不大，组内成员已满足人力资源需要，主要负责项目初期的代码编写以及后期的维护和优化。在规定期限内，能够完成该平台的开发。</p><h4 id="7-2-3-相关技术应用"><a href="#7-2-3-相关技术应用" class="headerlink" title="7.2.3 相关技术应用"></a>7.2.3 相关技术应用</h4><p>​    该项目主要利用 html，CSS 和 JavaScript 技术开发，并运用了SQL sever语言。</p><h2 id="8-进度可行性分析"><a href="#8-进度可行性分析" class="headerlink" title="8 进度可行性分析"></a>8 进度可行性分析</h2><h3 id="8-1项目工期评估"><a href="#8-1项目工期评估" class="headerlink" title="8.1项目工期评估"></a>8.1项目工期评估</h3><p>​项目工期评估具体如下图所示：</p><p><img src="/%E5%8F%AF%E8%A1%8C%E6%80%A7%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A.assets/1647426444568.png" alt="1647426444568"></p><h3 id="8-2项目进度可行性分析"><a href="#8-2项目进度可行性分析" class="headerlink" title="8.2项目进度可行性分析"></a>8.2项目进度可行性分析</h3><p>我们在安排本项目总进度计划时，考虑用时55天完成计划进度内的所有项目任务，我们同时亦对各节点进度完成时间提出了较高的要求，进行了细致的划分，具体到每一个小任务，最后在进行汇总整合，根据我们团队以往同类型项目的工作经验，在这些节点进度时间内团队成员完成各自的分配任务是完全可能并且肯定可以完成的。</p><h2 id="9-社会可行性分析"><a href="#9-社会可行性分析" class="headerlink" title="9 社会可行性分析"></a>9 社会可行性分析</h2><h3 id="9-1社会法律政策可行性"><a href="#9-1社会法律政策可行性" class="headerlink" title="9.1社会法律政策可行性"></a>9.1社会法律政策可行性</h3><p>​该系统规划所建设信息系统与投入运行完全符合国家政策与法律，通过信息加密，后台储存等手段确保信息系统的使用可以很好地保护组织机构的信息安全与用户隐私保护，没有如合同责任、侵犯专利权、侵犯版权等方面的非法违法行为。</p><h3 id="9-2社会公共环境可行性"><a href="#9-2社会公共环境可行性" class="headerlink" title="9.2社会公共环境可行性"></a>9.2社会公共环境可行性</h3><p>​该系统从行政管理、工作制度等方面来看，社会大众都能够使用该软件系统，从工作人员的素质来看，能满足使用该软件系统的社会安全要求，同时该信息系统的使用严格遵从工程伦理道德规范，确保全心全意服务社会，为社会进步保驾护航。</p><h3 id="9-3操作可行性"><a href="#9-3操作可行性" class="headerlink" title="9.3操作可行性"></a>9.3操作可行性</h3><p>​该信息系统聚焦于校园二手物品的交易，需求量很大，需要一个合格规范的平台系统去合理安全地组织二手物品的交易活动，可以在用户实际业务处理中方便的、有效的解决领域问题。</p><p>​该信息系统将校园内二手物品的交易统计在一起，方便买家对比，选择更合心意的物品，同时便于卖家放心交易二手物品，可以有效提高用户的工作效率，提升二手交易活动的质量和服务质量。</p><p>​该信息系统具有很好的操作可行性，后续可以推广到其他校园或者社区，可以在组织机构不同部门广泛应用和行业推广。</p><h2 id="10-结论"><a href="#10-结论" class="headerlink" title="10 结论"></a>10 结论</h2><h3 id="10-1可行性结论"><a href="#10-1可行性结论" class="headerlink" title="10.1可行性结论"></a>10.1可行性结论</h3><p>  通过上述分析，该项目可以开始执行。</p><h3 id="10-2结论的解释"><a href="#10-2结论的解释" class="headerlink" title="10.2结论的解释"></a>10.2结论的解释</h3><p>  经济方面，该项目建设所需开销的经费不高，将在3个月左右被系统投入运行后所产生的经济效益所补充；技术方面，项目开发风险小，资源足够支持项目开发，且小组成员已能熟练应用项目开发所需的语言以及技术；同时该项目进度安排合理，时间充裕，符合各类法律法规。综上，该项目具有很好的可行性。</p>]]></content>
      
      
      <categories>
          
          <category> 软件系统构思综合训练 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校园二手交易平台-项目开发计划</title>
      <link href="/FRank675.github.io/posts/2e6a2d0c4fcd/"/>
      <url>/FRank675.github.io/posts/2e6a2d0c4fcd/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="校园二手交易平台-项目开发计划"><a href="#校园二手交易平台-项目开发计划" class="headerlink" title="校园二手交易平台-项目开发计划"></a><strong>校园二手交易平台</strong>-项目开发计划</h1><p><strong>编写人员：杨顺杰、魏泽弘、高时玉、赵任生、龚云基、杨笑千</strong></p><p><strong>指导老师：张大林</strong></p><p><strong>编写日期：2022.3.10</strong></p><p><strong>本说明书版权与一切解释权归蓝瞳团队所有</strong></p><h2 id="具体项目"><a href="#具体项目" class="headerlink" title="具体项目"></a>具体项目</h2><p>项目名称：校园二手物品交易系统（校园在线跳蚤市场）<br>项目目的和意义：支持勤俭节约；倡导互惠互利；开展爱心义卖；践行低碳环保；做到物尽其用；支持以物换物；实现智能管理（机器学习、人工智能）；达到安全平稳。</p><h2 id="1、引言"><a href="#1、引言" class="headerlink" title="1、引言"></a>1、引言</h2><h3 id="1-1编写目的"><a href="#1-1编写目的" class="headerlink" title="1.1编写目的"></a>1.1编写目的</h3><p>​    此项目开发计划书的编写主要是为“校园二手物品交易系统”做主要的规划和整合，在开发过程中起到引导作用，保证项目团队按时保质地完成项目目标，便于项目团队成员更好地了解项目情况，使项目工作开展的各个过程合理有序，以文件化的形式，把对于在项目生存周期内的工作任务范围、各项工作的任务分解、项目团队组织结构、各团队成员的工作责任、团队内外沟通协作方式、开发进度、风险对策等内容做出的安排以书面的方式，作为项目团队成员以及项目干系人之间的共识与约定，它又是项目生命周期内的所有项目活动的行动基础、项目团队开展和检查项目工作的依据。</p><h3 id="1-2背景"><a href="#1-2背景" class="headerlink" title="1.2背景"></a>1.2背景</h3><p>​随着网络技术的不断更新，网上交易在现代人的生活中越来越常见，我们生活环境的变化与人们日益增长的需求不断推动着电子商务的发展。现在学生闲置的物品种类繁多，有些东西闲置在宿舍很占空间，丢掉的话却又是对资源的一种浪费，中不乏书籍资料、电子设备、生活用品这些高度重复利用的物品，并且高校学生有很强的流动性，使得高校二手市场有着庞大的需求。所以我们决定借助于方便快捷并且成本低的网络开发一个校园闲置资源交换交易信息平台，这个平台不仅能解决同学们闲置物品的交换同时也支持专业技能和学习资料信息之间的交换。并且这个平台也可以作为一个栏目挂放在学校首页上，这样不仅解决了同学们闲置物品的交换和购物需求，也加强了各个专业同学之间的交流。近年来，我国经济快速发展，人民生活水平有了很大的提高，大学生的生活费也有所提高，每月可支配资金普遍可达到1500元以上，但是物价也随之上涨了，除去每个月的固定生活必需品支出，也所剩无几。<br>​据中国考试网（<a href="http://www.chinazhaokao.com)报告频道为大家整理的《大学生消费水平分析》所知大学生一个月的消费水平分析,每月消费550元900元以及900元1400元的占大多数,仅有少数大学生每月消费为1400元以上.可见,现在大学生一个月的生活费还是比较宽裕的,但不足以支撑他们强大的消费需求,一些较为贵重的物品还是无法靠自己的生活费来承担的./">www.chinazhaokao.com）报告频道为大家整理的《大学生消费水平分析》所知大学生一个月的消费水平分析，每月消费550元900元以及900元1400元的占大多数，仅有少数大学生每月消费为1400元以上。可见，现在大学生一个月的生活费还是比较宽裕的，但不足以支撑他们强大的消费需求，一些较为贵重的物品还是无法靠自己的生活费来承担的。</a><br>​很多大学生买了一件商品，但是只是使用一段时间就被闲置了，着实令人感到可惜，这些物品丢之可惜，藏之无用；但这些东西往往又是另一些学生需要用的物品。我们针对这一现状进行了分析和总结，设计了校园闲置网站，在这里，不仅可以让闲置的物品流通起来，产生价值，还可以发布信息、共享交流。<br>​目前主流的闲置物品交易平台有闲鱼、拍拍，但这些平台的用户群体很大且复杂，信息审核不够严格，所以就经常会发生用户到手的实物与卖家所描述的不相符，更严重的有买到假货，从而引发纠纷，踏上漫长的维权路。而我们的目标客户群体为在校大学生，用户交易范围最大也只到学校，这样方便我们管理，同时利用学校已经备案的学生信息，还有我们每一次交易双方都会确认自动生成的交易合同，能够更好的保障学生之前的闲置交易，避免了很多不必要的纠纷。</p><p>1.待开发系统名称：校园二手物品交易系统</p><p>2.本项目的任务提出者、开发者、用户：</p><p>​①任务提出者：张老师</p><p>​②开发者：杨顺杰，魏泽弘，杨笑千，龚云基，赵任生，高时玉</p><p>​③用户：校园内的所有人员</p><p>3.该软件与其他系统或机构的关系：该系统的应用十分广泛，我们会考虑到其与其他系统或机构的兼容性问题</p><h3 id="1-3定义"><a href="#1-3定义" class="headerlink" title="1.3定义"></a>1.3定义</h3><p>暂无，待后续补充</p><h3 id="1-4参考资料"><a href="#1-4参考资料" class="headerlink" title="1.4参考资料"></a>1.4参考资料</h3><p>​[1]高美珍，洪家平.高校二手物品交易系统的设计与实现[J].湖北师范大学学报（自然科学版），2018，38（04）：65-69.</p><p>​[2]曲蕴慧.校园二手交易平台的构建与实现[J].电子设计工程，2014，22（06）：70-72.</p><p>​[3]庄彦，未培.基于校园网的二手交易平台构建与实践[J].集宁师范学院学报，2016，38（02）：40-43.</p><h2 id="2、项目概述"><a href="#2、项目概述" class="headerlink" title="2、项目概述"></a>2、项目概述</h2><h3 id="2-1-项目目标"><a href="#2-1-项目目标" class="headerlink" title="2.1 项目目标"></a>2.1 项目目标</h3><p><strong>总体目标:</strong>   我们主要提供一个校园二手物品交易平台。我们可以将收集的需要出售的二手物品，进行整合、分类以供需要购买二手物品的同学方便购买。校园二手物品交易平台为在校学生提供一个供需平台,学生可以将自己不用的东西放到我们这里也可在固定的地方找到自己需要的东西物美价廉,达到双赢。我们的宗旨是全心全意服务学生、方便学生。诚待在校学生积极参与，帮助自己，帮助他人。</p><p><strong>我们的项目将实现以下部分：</strong></p><table><thead><tr><th>项目模块</th><th>实现功能</th><th>预期结果</th></tr></thead><tbody><tr><td>信息展示模块</td><td>平台首页展示现有的二手物品</td><td>平台二手物品首页可以完整的具有一定美观的展示二手物品</td></tr><tr><td>信息收集模块</td><td>可以让用户进行二手物品信息的发布</td><td>用户可以便捷地发布自己想要出售的二手物品</td></tr><tr><td>用户交流模块</td><td>可以让买方和卖方进行交流</td><td>买卖双方可以围绕想要交易的二手物品进行交流，并且有效的保护双方的隐私</td></tr><tr><td>购物交易模块</td><td>买卖双方进行交易</td><td>买卖双方可以安全地进行交易，支付方式可以结合微信支付与支付宝支付等支付方式</td></tr><tr><td>用户管理模块</td><td>用户对自己的信息进行管理</td><td>用户可以进行注册，登录，和对自己的基本信息进行修改等</td></tr></tbody></table><h3 id="2-2项目范围"><a href="#2-2项目范围" class="headerlink" title="2.2项目范围"></a>2.2项目范围</h3><table><thead><tr><th>项目目标</th><th>项目任务</th><th>所需工时</th></tr></thead><tbody><tr><td>校园二手平台的搭建</td><td>设计一个美观实用的校园二手平台的网页端</td><td>一周</td></tr><tr><td>支付安全的保护</td><td>采取微信支付和支付宝的支付方式等安全支付方式</td><td>一天至两天</td></tr><tr><td>用户的隐私保护</td><td>采取一定的措施来保护用户的信息以确定用户的隐私不被暴露</td><td>一天至两天</td></tr><tr><td>项目的推广</td><td>在各大高校的微信群与QQ群里进行推广，或者与各大高校进行合作推广</td><td>贯穿整个开发过程</td></tr></tbody></table><h3 id="2-3假设和约束"><a href="#2-3假设和约束" class="headerlink" title="2.3假设和约束"></a>2.3假设和约束</h3><table><thead><tr><th>约束</th><th>具体内容</th></tr></thead><tbody><tr><td>时间约束</td><td>本次项目的开发需要在课程要求提交的时间之前完成并加以完善</td></tr><tr><td>人员约束</td><td>需要由六名组员分工合作，独立完成</td></tr><tr><td>财力约束</td><td>本次项目的开发的预算和后续资源的经济来源是由六名组员共同承担，花费需要在组员承受范围之内</td></tr><tr><td>设备约束</td><td>项目需要在装有Window10系统的笔记本电脑上完成</td></tr><tr><td>建议开发软件运行的最短寿命</td><td>两年</td></tr><tr><td>建议开发软件投入使用的最迟时间</td><td>开发完成后试运行1个月</td></tr><tr><td>进行系统方案选择比较的时间</td><td>一个月</td></tr><tr><td>可利用的信息和资源</td><td>各大平台的二手交易信息，包括微信群、QQ群等</td></tr></tbody></table><h3 id="2-4应交付的成果"><a href="#2-4应交付的成果" class="headerlink" title="2.4应交付的成果"></a>2.4应交付的成果</h3><h4 id="2-4-1程序：列出程序名称，编程语言，存储形式"><a href="#2-4-1程序：列出程序名称，编程语言，存储形式" class="headerlink" title="2.4.1程序：列出程序名称，编程语言，存储形式"></a>2.4.1程序：列出程序名称，编程语言，存储形式</h4><table><thead><tr><th>程序名称</th><th>编程语言</th><th>存储形式</th></tr></thead><tbody><tr><td>北交跳蚤市场智能平台</td><td>html、css、JavaScript</td><td>mysql存储用户账户密码，以及操作历史</td></tr></tbody></table><h4 id="2-4-2文档"><a href="#2-4-2文档" class="headerlink" title="2.4.2文档"></a>2.4.2文档</h4><table><thead><tr><th><span style="display:inline-block;width: 120px"> 文档 </span></th><th><span style="display:inline-block;width: 120px"> 面向对象 </span></th><th>具体要求</th></tr></thead><tbody><tr><td>需求规格说明书</td><td>业务人员、用户</td><td>对所开发软件的功能、性能、用户界面及运行环境等作出详细的说明。它是在用户与开发人员双方对软件需求取得共同理解并达成协议的条件下编写的，也是实施开发工作的基础。该说明书应给出数据逻辑和数据采集的各项要求，为生成和维护系统数据文件做好准备</td></tr><tr><td>概要设计说明书</td><td>设计、开发人员</td><td>该说明书是概要实际阶段的工作成果，它应说明功能分配、模块划分、程序的总体结构、输入输出以及接口设计、运行设计、数据结构设计和出错处理设计等，为详细设计提供基础</td></tr><tr><td>详细设计说明书</td><td>设计、开发人员</td><td>着重描述每一模块是怎样实现的，包括实现算法、逻辑流程等。</td></tr><tr><td>可行性研究报告</td><td>设计、开发人员</td><td>说明该软件开发项目的实现在技术上、经济上和社会因素上的可行性，评述为了合理地达到开发目标可供选择的各种可能实施方案，说明并论证所选定实施方案的理由</td></tr><tr><td>项目开发计划</td><td>设计、开发人员、用户</td><td>为软件项目实施方案制订出具体计划，应该包括各部分工作的负责人员、开发的进度、开发经费的预算、所需的硬件及软件资源等。</td></tr><tr><td>开发进度月报</td><td>设计、开发人员</td><td>该月报系软件人员按月向管理部门提交的项目进展情况报告，报告应包括进度计划与实际执行情况的比较、阶段成果、遇到的问题和解决的办法以及下个月的打算等</td></tr><tr><td>用户操作手册</td><td>用户</td><td>本手册详细描述软件的功能、性能和用户界面，使用户对如何使用该软件得到具体的了解,为操作人员提供该软件各种运行情况的有关知识，特别是操作方法的具体细节。</td></tr><tr><td>产品测试文档</td><td>设计、开发人员</td><td>为做好集成测试和验收测试，需为如何组织测试制订实施计划。计划应包括测试的内容、进度、条件、人员、测试用例的选取原则、测试结果允许的偏差范围等</td></tr><tr><td>测试分析报告</td><td>设计、开发人员</td><td>测试工作完成以后，应提交测试计划执行情况的说明，对测试结果加以分析，并提出测试的结论意见。</td></tr><tr><td>项目开发总结报告</td><td>设计、开发人员</td><td>软件项目开发完成以后，应与项目实施计划对照，总结实际执行的情况，如进度、成果、资源利用、成本和投入的人力，此外，还需对开发工作做出评价，总结出经验和教训。</td></tr></tbody></table><h4 id="2-4-3服务"><a href="#2-4-3服务" class="headerlink" title="2.4.3服务"></a>2.4.3服务</h4><table><thead><tr><th><span style="display:inline-block;width: 120px"> 服务 </span></th><th><span style="display:inline-block;width: 60px"> 优先级 </span></th><th>具体内容</th></tr></thead><tbody><tr><td>用户注册</td><td>1</td><td>学生可利用自已学号进行注册，注册实现实名制</td></tr><tr><td>用户登录</td><td>1</td><td>只有登录用户才能进行信息发布。管理员登录后可以进行系统管理</td></tr><tr><td>发布信息</td><td>1</td><td>普通用户和管理员登录后都可以发布信息</td></tr><tr><td>修改信息</td><td>1</td><td>普通用户可以修改自己发布的信息，管理员可以修改所有信息</td></tr><tr><td>删除信息</td><td>1</td><td>普通用户可以删除自己发布的信息，管理员可以删除所有信息</td></tr><tr><td>浏览信息</td><td>1</td><td>游客、普通用户和管理员可以浏览所有发布的信息</td></tr><tr><td>搜索信息</td><td>1</td><td>游客、普通用户和管理员可以用关键字搜索所有发布的信息。普通用户可以搜索自己发布的所有信息</td></tr><tr><td>发表留言</td><td>1</td><td>普通用户和管理员登录后都可以对发布信息进行留言</td></tr><tr><td>查看留言</td><td>1</td><td>游客、普通用户和管理员都可以查看发布信息的留言</td></tr><tr><td>删除留言</td><td>1</td><td>管理员可以删除留言</td></tr><tr><td>添加二手指南</td><td>1</td><td>管理员可以添加二手指南</td></tr><tr><td>查看二手指南</td><td>1</td><td>游客、普通用户和管理员都可以查看二手指南</td></tr><tr><td>修改二手指南</td><td>1</td><td>管理员可以修改二手指南</td></tr><tr><td>删除二手指南</td><td>1</td><td>管理员可以删除二手指南</td></tr><tr><td>私信交流</td><td>1</td><td>用户之间可以相互私信交流</td></tr><tr><td>智能推荐</td><td>2</td><td>智能推荐用户喜欢的产品</td></tr><tr><td>图像识别</td><td>3</td><td>自动识别客户上传的图片</td></tr><tr><td>社区交流</td><td>3</td><td>用户可以在社区当中发帖交流</td></tr><tr><td>爱心公益</td><td>3</td><td>用户可以将自己不需要的物品进行爱心捐献</td></tr></tbody></table><h4 id="2-4-4验收标准和验收方式"><a href="#2-4-4验收标准和验收方式" class="headerlink" title="2.4.4验收标准和验收方式"></a>2.4.4验收标准和验收方式</h4><table><thead><tr><th><span style="display:inline-block;width: 100px"> 验收标准 </span></th><th>验收方式</th></tr></thead><tbody><tr><td>功能项测试</td><td>由第三方测试公司对软件需求规格说明书中所有功能进行测试</td></tr><tr><td>业务流程测试</td><td>由第三方测试公司对软件项目的典型业务流程进行测试</td></tr><tr><td>容错测试</td><td>由第三方测试公司对用户常见的误操作，软件错误进行测试是否有明确的容错提示</td></tr><tr><td>安全性测试</td><td>由第三方测试公司对软件安全性进行分析，包括软件密钥是否以密文方式存储，软件是否保存用户的操作日志</td></tr><tr><td>性能测试</td><td>由第三方测试公司对软件需求规格说明书中的性能介绍进行测试</td></tr></tbody></table><h4 id="2-4-5完成项目最后期限及批准日期"><a href="#2-4-5完成项目最后期限及批准日期" class="headerlink" title="2.4.5完成项目最后期限及批准日期"></a>2.4.5完成项目最后期限及批准日期</h4><table><thead><tr><th>最后期限</th><th>批准时间</th></tr></thead><tbody><tr><td>2022.5.21</td><td>待定</td></tr></tbody></table><h2 id="3、项目团队结构和角色分工"><a href="#3、项目团队结构和角色分工" class="headerlink" title="3、项目团队结构和角色分工"></a>3、项目团队结构和角色分工</h2><table><thead><tr><th align="center"><span style="display:inline-block;width: 90px"> 角色 </span></th><th align="center"><span style="display:inline-block;width: 70px"> 成员 </span></th><th>职责</th></tr></thead><tbody><tr><td align="center">项目组长</td><td align="center">杨顺杰</td><td>激励成员工作、主持周例会、分配工作、维护资料、组织项目总结</td></tr><tr><td align="center">计划经理</td><td align="center">龚云基</td><td>开发完整准确的团队计划和个人计划。每周准确报告项目小组状态、数据翔实</td></tr><tr><td align="center">开发经理</td><td align="center">杨笑千</td><td>带领小组开发计划、带领小组平衡计划、跟踪项目进度、参与项目总结</td></tr><tr><td align="center">质量经理</td><td align="center">高时玉</td><td>带领制定开发策略、带领开展产品规模估算、时间资源估算、带领制定需求规格说明书、带领概要设计、设计说明书、实现产品、测试、用户支持文档</td></tr><tr><td align="center">支持经理</td><td align="center">赵任生</td><td>领导和管理售前、售后技术团队，制定并不断完善技术支持方案； 大型项目的实施安排及指导，重大项目的技术支持； 配合技术和研发部门分析并解决疑难问题； 收集公司产品与技术部的资料，负责相关人员的技术培训。</td></tr><tr><td align="center">过程经理</td><td align="center">魏泽弘</td><td>完善制程质量数据统计和分析,评估各工序及设备过程能力,对异常进行分析并制定改进方案; 贯彻执行质量体系,确保生产过程中的质量问题能得到及时的解决。</td></tr></tbody></table><h2 id="4、计划与进度"><a href="#4、计划与进度" class="headerlink" title="4、计划与进度"></a>4、计划与进度</h2><table><thead><tr><th align="center">需求</th><th align="left">任务</th><th align="center">预估工时&#x2F;h</th><th align="center">预定日期</th><th align="center">完成日期</th><th align="center">优先级</th><th align="center">里程碑</th></tr></thead><tbody><tr><td align="center">用户登录功能</td><td align="left">用户通过账号、手机、微信或者qq等进行账号登陆，可以实现密码的修改和找回</td><td align="center">3</td><td align="center">2022.3.15</td><td align="center">2022.3.17</td><td align="center">中等</td><td align="center">实现登陆验证</td></tr><tr><td align="center">用户注册功能</td><td align="left">用户通过账号、手机、微信或者qq等进行账号注册</td><td align="center">3</td><td align="center">2022.3.16</td><td align="center">2022.3.18</td><td align="center">中等</td><td align="center">实现手机账号注册等</td></tr><tr><td align="center">二手交易</td><td align="left">发布信息：普通用户和管理员登录后都可以发布信息<br/>修改信息：普通用户可以修改自己发布的信息，管理员可以修改所有信息<br/>删除信息：普通用户可以删除自己发布的信息，管理员可以删除所有信息<br/>浏览信息：游客、普通用户和管理员可以浏览所有发布的信息<br/>搜索信息：游客、普通用户和管理员可以用关键字搜索所有发布的信息。普通用户可以搜索自己发布的所有信息</td><td align="center">15</td><td align="center">2022.3.20</td><td align="center">2022.4.15</td><td align="center">高</td><td align="center">实现基本的交易功能</td></tr><tr><td align="center">用户交流</td><td align="left">发表留言：普通用户和管理员登录后都可以对发布信息进行留言<br/>查看留言：游客、普通用户和管理员都可以查看发布信息的留言<br/>删除留言：管理员可以删除留言</td><td align="center">6</td><td align="center">2022.4.15</td><td align="center">2022.4.20</td><td align="center">中等</td><td align="center">实现用户留言功能</td></tr><tr><td align="center">用户指南</td><td align="left">添加二手指南：管理员可以添加二手指南<br/>查看二手指南：游客、普通用户和管理员都可以查看二手指南<br/>修改二手指南：管理员可以修改二手指南<br/>删除二手指南：管理员可以删除二手指南</td><td align="center">6</td><td align="center">2022.4.21</td><td align="center">2022.4.25</td><td align="center">低</td><td align="center">用户可使用二手指南</td></tr><tr><td align="center">智能推荐</td><td align="left">搜集用户点击信息<br/>实现推荐算法获得推荐商品<br/>将商品信息推荐到用户首页</td><td align="center">8</td><td align="center">2022.4.13</td><td align="center">2022.4.25</td><td align="center">高</td><td align="center">首页自动推荐用户商品信息</td></tr><tr><td align="center">独家活动</td><td align="left">社区交流，促进二手交易进行<br/>爱心公益，用户可以登记捐献的物品，将其捐献给有需要的人</td><td align="center">8</td><td align="center">2022.4.23</td><td align="center">2022.4.28</td><td align="center">中等</td><td align="center">活动界面完善</td></tr></tbody></table><h2 id="5、支持条件"><a href="#5、支持条件" class="headerlink" title="5、支持条件"></a>5、支持条件</h2><table><thead><tr><th align="center">支持条件</th><th align="center">数量</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center">阿里云服务器</td><td align="center">1</td><td align="center">为平台提供稳定的服务器</td></tr><tr><td align="center">打印机</td><td align="center">1</td><td align="center">打印项目相关材料</td></tr></tbody></table><h2 id="6、预算"><a href="#6、预算" class="headerlink" title="6、预算"></a>6、预算</h2><table><thead><tr><th align="center">用途</th><th align="center">预算&#x2F;元</th></tr></thead><tbody><tr><td align="center">前期宣传</td><td align="center">200</td></tr><tr><td align="center">服务器</td><td align="center">150</td></tr><tr><td align="center">打印相关费用</td><td align="center">50</td></tr></tbody></table><h2 id="7、关键问题"><a href="#7、关键问题" class="headerlink" title="7、关键问题"></a>7、关键问题</h2><table><thead><tr><th>关键问题</th><th>具体描述</th><th>拟解决办法</th></tr></thead><tbody><tr><td>专业基础知识不牢</td><td>本次项目开发过程中涉及知识较多，给项目开发人员带来一定的困难</td><td>对相应的知识进行学习</td></tr><tr><td>经验欠缺</td><td>小组成员开发经验不足，使项目质量难以保证</td><td>在实践过程中不断优化</td></tr><tr><td>软件性能影响</td><td>使用过程中可能由于体量等问题，使服务器出现延迟</td><td>搭建良好的配置开发环境</td></tr><tr><td>小组成员异地开发</td><td>前三周的网络教学让小组成员只能通过线上交流进行工作汇报，给协同开发带来了一定难度</td><td>定期开展小组会议，利用GitHub进行协同开发</td></tr><tr><td>系统安全问题</td><td>作为二手交易平台，涉及网络货币支付等问题，需要对用户财产以及隐私进行保障</td><td>向一些已有的交易平台进行学习，并定期对系统进行维护</td></tr><tr><td>项目成果宣发使用问题</td><td>校园二手交易系统项目完成后，在投入使用时需要让本校师生了解并愿意使用本系统</td><td>在校园各个学生平台进行宣传，并开展一定程度的线下宣传</td></tr></tbody></table><h2 id="8、各种专题计划：合同计划、培训计划、测试计划、系统安全计划等等"><a href="#8、各种专题计划：合同计划、培训计划、测试计划、系统安全计划等等" class="headerlink" title="8、各种专题计划：合同计划、培训计划、测试计划、系统安全计划等等"></a>8、各种专题计划：合同计划、培训计划、测试计划、系统安全计划等等</h2>]]></content>
      
      
      <categories>
          
          <category> 软件系统构思综合训练 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校园二手交易平台-需求规格说明书</title>
      <link href="/FRank675.github.io/posts/a5bf220480aa/"/>
      <url>/FRank675.github.io/posts/a5bf220480aa/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="校园二手交易平台-需求规格说明书"><a href="#校园二手交易平台-需求规格说明书" class="headerlink" title="校园二手交易平台-需求规格说明书"></a>校园二手交易平台-需求规格说明书</h1><p><strong>编写人员：杨顺杰、魏泽弘、高时玉、赵任生、龚云基、杨笑千</strong></p><p><strong>指导老师：张大林</strong></p><p><strong>编写日期：2022.3.28</strong></p><p><strong>本说明书版权与一切解释权归蓝瞳团队所有</strong></p><p>[TOC]</p><h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><h3 id="1-1-定位与目标"><a href="#1-1-定位与目标" class="headerlink" title="1.1 定位与目标"></a>1.1 定位与目标</h3><p>目前我校的校园二手交易市场多是利用超级课程表上的“跳蚤市场”以及本校的贴吧进行，两者都形成了一定的规模。但是贴吧上的交易不够规范，而超级课程表改版之后对“跳蚤市场”这一模块也不够重视，对其入口进行了更改，进入不方便了，导致流量减少，目前在上面发布交易信息的人寥寥无几。因此我们建立二手交易市场的目的是：</p><p>1、为我校师生提供一个比较规范、方便的二手交易平台。</p><p>2、为学生提供廉价、有用的二手物品。目前我校的二手交易需求还是比较旺盛的，建立校内二手交易市场，可以让校内的师生将自己闲置的教材、数码设备、体育用具、自行车甚至是自己手工制作的小装饰品等物品挂上交易市场进行交易。这样既避免了手中有闲置品的师生废弃了这些物品，又可以让有需要的师生用较低的价格获得自己需要的物品。</p><p>3、每到毕业季，毕业的学长学姐都会有大量的物品无法带离学校的，这时学长学姐们都会在固定的几天时间，在学校的某个地点将自己不需要的物品拿出来摆卖，但是由于摆卖的时间短，有很多闲置物品不能及时出售。因此建立二手交易市场可以方便毕业离校的学长学姐将自己不需要的物品早早挂上交易市场进行出售。</p><h3 id="1-2-对象"><a href="#1-2-对象" class="headerlink" title="1.2 对象"></a>1.2 对象</h3><p><strong>本《软件需求规格说明书》的预期读者是：</strong> </p><ul><li>二手交易平台平台开发经理</li><li>项目组所有人员</li><li>测试组人员</li><li>开发团队授权调阅本文档的其他人员</li></ul><h3 id="1-3-软件需求分析理论"><a href="#1-3-软件需求分析理论" class="headerlink" title="1.3 软件需求分析理论"></a><strong>1.3 软件需求分析理论</strong></h3><p>​软件需求分析是研究用户需求得到的东西，完全理解用户对软件需求的完整功能，确认用户软件功能需求， 建立可确认的、可验证的一个基本依据。软件需求分析是一个项目的开端， 也是项目实施最重要的关键点。 据有关的机构分析结果表明， 设计的软件产品存在不完整性、 不正确性等问题 <strong>80％</strong>以上是需求分析错误所导致的，而且由于需求分析错误造成根本性的功能问题尤为突出。因此，一个项目的成功软件需求分析是关键的一步。</p><h3 id="1-4-软件需求分析目标"><a href="#1-4-软件需求分析目标" class="headerlink" title="1.4 软件需求分析目标"></a><strong>1.4 软件需求分析目标</strong></h3><p>​对实现软件的功能做全面的描述，帮助用户判断实现功能的正确性、一致性和完整性，促使用户在软件设计启动之前周密地、全面地思考软件需求。了解和描述软件实现所需的全部信息，为软件设计、确认和验证提供一个基准。</p><p>​为软件管理人员进行软件成本计价和编制软件开发计划书提供依据。</p><p>​需求分析的具体内容可以归纳为六个方面： 软件的功能需求， 软件与硬件或其他外部系统接口，软件的非功能性需求， 软件的反向需求， 软件设计和实现上的限制，阅读支持信息。</p><p>​软件需求分析应尽量提供软件实现功能需求的全部信息， 使得软件设计人员和软件测试人员不再需要需求方的接触。 这就要求软件需求分析内容应正确、 完整、一致和可验证。此外，为保证软件设计质量，便于软件功能的休整和验证，软件需求表达无岔意性，具有可追踪性和可修改性。</p><h3 id="1-5-参考资料"><a href="#1-5-参考资料" class="headerlink" title="1.5 参考资料"></a>1.5 参考资料</h3><p>1、张海藩 《软件工程导论》        清华大学出版社</p><p>2、侯爱民 《面向对象分析与设计（UML）》  清华大学出版社</p><p>3、王珊  《数据库系统概论》      高等教育出版社</p><h2 id="二、需求概述"><a href="#二、需求概述" class="headerlink" title="二、需求概述"></a><strong>二、需求概述</strong></h2><h3 id="2-1-项目背景"><a href="#2-1-项目背景" class="headerlink" title="2.1 项目背景"></a><strong>2.1 项目背景</strong></h3><p>将要开发的软件名为《校园二手交易网站》，本项目的提出者是北京交通大学软件学院蓝瞳研发团队，而开发者是蓝瞳研发团队，主要用户是北京交通大学全体学生， 该软件独立于其他系统，自成一个完整的系统，应用方便。</p><h3 id="2-2-需求概述"><a href="#2-2-需求概述" class="headerlink" title="2.2 需求概述"></a><strong>2.2 需求概述</strong></h3><p>下面就对校园二手交易网站分模块进行需求分析。</p><h4 id="用户信息模块"><a href="#用户信息模块" class="headerlink" title="用户信息模块"></a>用户信息模块</h4><table><thead><tr><th><span style="display:inline-block;width: 120px">需求</span></th><th>详细分析</th></tr></thead><tbody><tr><td>注册功能</td><td>系统应该为用户提供手机号注册和邮箱注册两个方式，为用户发送验证码，并确认验证码，设置账号密码时密码隐藏显示，并且提供确认密码输入框以避免出现差错，相关协议默认未勾中，账号和用户学号绑定。</td></tr><tr><td>登录功能</td><td>系统应该为用户提供输入框可以输入账号密码进行登陆，如果密码错误显示提示，输入密码错误超过三次需要输入验证码，密码显示为隐藏</td></tr><tr><td>忘记密码</td><td>系统应该给用户手机号发送验证码，确认验证码正确过后再提供重新设置密码的机会，设置完成后，退回到登录界面</td></tr><tr><td>修改密码</td><td>系统应该与用户确认原来密码，确认密码正确过后再提供重新设置密码的机会，设置完成后，退回到登录界面</td></tr><tr><td>注销用户</td><td>系统应该弹出确认注销的窗口，并在窗口提示用户，注销用户将删除一切用户信息</td></tr></tbody></table><h4 id="展示模块"><a href="#展示模块" class="headerlink" title="展示模块"></a>展示模块</h4><table><thead><tr><th><span style="display:inline-block;width: 120px">需求</span></th><th>详细分析</th></tr></thead><tbody><tr><td>智能推荐</td><td>系统应该通过一系列最优算法为用户提供满足其需求的二手物品推荐，具体表现为通过用户类型，最近浏览的物品种类以及倾向于购买的物品种类等信息为其推荐最适合的二手物品</td></tr><tr><td>视频展示</td><td>系统应该能够稳定流畅运行，通过录制新手使用指导视频对该项目的全部功能进行一个介绍和展示，让用户可以通过视频去直观的了解该项目的使用方式，从而轻松入手购买自己心怡的二手物品。</td></tr><tr><td>独家活动</td><td>系统应该举行一些独家活动激励卖家主动出售自己不需要的二手物品，同时鼓励买家积极购买平台的二手物品，通过活动提高平台的知名度，让买家与卖家享受到平台的便利实惠，打赢信誉战。</td></tr><tr><td>用户指南</td><td>系统应该配备一本便于新用户使用的用户指南。一份精心制作、对用户友好的用户指南可谓一件必需品，其影响着客户体验的优劣程度，对于新用户来说， 用户指南能够帮助它们快速了解本产品的用法，减少自己摸索使用所花费的时间，同时提高对产品的满意度。</td></tr></tbody></table><h4 id="交易模块"><a href="#交易模块" class="headerlink" title="交易模块"></a>交易模块</h4><table><thead><tr><th><span style="display:inline-block;width: 120px">需求</span></th><th>详细分析</th><th></th></tr></thead><tbody><tr><td>搜索信息</td><td>系统应该为想要搜索特定信息的用户提供文本输入框，当在文本输入框输入搜索的信息，如好友名，物品名，历史订单，活动名等，点击“搜索”按钮后，系统应该弹出相应主页给用户。</td><td></td></tr><tr><td>删除信息</td><td>系统应该为想要删除特定信息的用户提供删除，用户可在个人主页简介处，历史订单主页，好友页面，活动页面，点击选择所要删除的特定好友、历史订单、简介等，点击“删除”按钮后，系统将从数据库中删去该信息。</td><td></td></tr></tbody></table><h4 id="活动模块"><a href="#活动模块" class="headerlink" title="活动模块"></a>活动模块</h4><table><thead><tr><th><span style="display:inline-block;width: 120px">需求</span></th><th>详细分析</th><th></th></tr></thead><tbody><tr><td>以物易物—物品登记功能</td><td>系统应该为想要交换的用户提供交易物品登记表去登记想要交换的物品的基本信息，登记完之后点击提交，如果提交成功，系统将记录所登记的物品信息，如果登记的信息中含有敏感信息，则系统不会通过用户的提交。</td><td></td></tr><tr><td>以物易物—双方联系功能</td><td>系统应该为想要进行以物易物的双方提供一个临时的聊天框，让用户双方进行交流，如果交谈的过程中出现敏感词句，系统将删除敏感语句，并对违规用户进行警告。</td><td></td></tr><tr><td>捐赠二手物品—物品登记功能</td><td>系统应该为想要捐赠的用户提供捐赠物品登记表去登记想要去捐赠的物品的基本信息，登记完之后点击提交，如果提交成功，系统将记录所登记的物品信息，如果登记的信息中含有敏感信息，则系统不会通过用户的提交。</td><td></td></tr><tr><td>捐赠二手物品—捐赠情况反馈功能</td><td>系统应该为捐赠二手物品的用户提供一个反馈的渠道，让用户可以知道自己捐赠的物品的最终的去向</td><td></td></tr><tr><td>义卖—物品登记功能</td><td>系统应该为想要义卖的用户提供义卖物品登记表去登记想要义卖的物品的基本信息，登记完之后点击提交，如果提交成功，系统将记录所登记的物品信息，如果登记的信息中含有敏感信息，则系统不会通过用户的提交。</td><td></td></tr><tr><td>义卖—捐赠情况反馈功能</td><td>系统应该为义卖的用户提供一个反馈的渠道，让用户可以知道最后义卖所卖出的金额，和这些钱的使用情况和捐赠情况。</td><td></td></tr></tbody></table><h4 id="社区模块"><a href="#社区模块" class="headerlink" title="社区模块"></a>社区模块</h4><table><thead><tr><th><span style="display:inline-block;width: 120px">需求</span></th><th>详细分析</th></tr></thead><tbody><tr><td>私信交流</td><td>系统应该在用户信息处设置私聊按钮，以供点击后可以通过发信息、图片进行相互交流</td></tr><tr><td>发布留言</td><td>系统应该在社区的帖子中添加发布留言按钮，让用户对某件商品或事务发表看法</td></tr><tr><td>查看留言</td><td>系统应该为每个进入社区的用户提供他所查看的帖子的所有留言</td></tr><tr><td>删除留言</td><td>系统应该在用户已经发布的留言下添加删除按钮，让用户可以删除自己的留言</td></tr><tr><td>社区群聊</td><td>系统应该让用户能够在社区中点击按钮创建群聊，让更多对相关话题感兴趣的用户加入聊天，通过发送消息或图片进行多人讨论</td></tr><tr><td>发布动态</td><td>系统应该支持用户通过添加图片，配写文案等方式发布自己的动态</td></tr><tr><td>删除动态</td><td>系统应该支持在用户已经发布的动态下添加删除按钮，支持用户删除自己的动态</td></tr><tr><td>动态评论</td><td>系统应该在每位用户发表的动态下添加评论功能，其他用户可以通过输入框输入个人的评论</td></tr></tbody></table><h3 id="2-3-需求获取"><a href="#2-3-需求获取" class="headerlink" title="2.3 需求获取"></a>2.3 需求获取</h3><p>采用问卷调查法，线上了解需求，根据需求做出调整，具体的问卷附在文末。</p><h2 id="三、系统功能需求"><a href="#三、系统功能需求" class="headerlink" title="三、系统功能需求"></a><strong>三、系统功能需求</strong></h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><table><thead><tr><th align="center"><span style="display:inline-block;width: 80px">概念</span></th><th>具体定义</th></tr></thead><tbody><tr><td align="center">活动图</td><td>活动图是UML用于对系统的动态行为建模的另一种常用工具，它描述活动的顺序，展现从一个活动到另一个活动的控制流。活动图在本质上是一种流程图。虽然活动图与状态图都是状态机的表现形式，但是两者还是有本质区别：活动图着重表现从一个活动到另一个活动的控制流，是内部处理驱动的流程；而状态图着重描述从一个状态到另一个状态的流程，主要有外部事件的参与。</td></tr><tr><td align="center">用例图</td><td>用例图（英语：use case diagram）是用户与系统交互的最简表示形式，展现了用户和与他相关的用例之间的关系。通过用例图，人们可以获知系统不同种类的用户和用例。用例图也经常和其他图表配合使用。</td></tr><tr><td align="center">时序图</td><td>时序图（Sequence Diagram），又名序列图、循序图，是一种UML交互图。它通过描述对象之间发送消息的时间顺序显示多个对象之间的动态协作。它可以表示用例的行为顺序，当执行一个用例行为时，其中的每条消息对应一个类操作或状态机中引起转换的触发事件。</td></tr><tr><td align="center">类图</td><td>类图(Class diagram)由许多（静态）说明性的模型元素（例如类、包和它们之间的关系，这些元素和它们的内容互相连接）组成。类图可以组织在（并且属于）包中，仅显示特定包中的相关内容。类图(Class diagram)是最常用的UML图，显示出类、接口以及它们之间的静态结构和关系；它用于描述系统的结构化设计。类图(Class diagram)最基本的元素是类或者接口。<br/>类图主要用在面向对象软件开发的分析和设计阶段，描述系统的静态结构。类图图示了所构建系统的所有实体、实体的内部结构以及实体之间的关系。即．类图中包含从用户的客观世界模型中抽象出来的类、类的内部结构和类与类之间的关系。它是构建其他设计模型的基础，没有类图，就没有对象图、状态图、协作图等其他UMI．动态模型图．也就无法表示系统的动态行为。类图也是面向对象编程的起点和依据。<br/>类图用于描述系统中所包含的类以及它们之间的相互关系，帮助人们简化对系统的理解，它是系统分析和设计阶段的重要产物，也是系统编码和测试的重要模型依据。</td></tr><tr><td align="center">状态图</td><td>状态图(Statechart Diagram)是描述一个实体基于事件反应的动态行为，显示了该实体如何根据当前所处的状态对不同的事件做出反应。通常我们创建一个UML状态图是为了以下的研究目的：研究类、角色、子系统、或组件的复杂行为。UML通过使用状态图来支持基于事件的模型，状态图用来来描述一个类对象在不同用例间状态的迁移。当一个用例或某个事件发生时，类对象的状态就会发生迁移，状态图有助于分析人员审核业务逻辑，以及完善静态模型。</td></tr><tr><td align="center">数据流图</td><td>数据流图或数据流程图（Data Flow Diagram），缩写为DFD。数据流图DFD是描述系统中数据流程的一种图形工具，它标志了一个系统的逻辑输入和逻辑输出，以及把逻辑输入转换逻辑输出所需的加工处理。DFD显示系统将输入和输出什么样的信息，数据如何通过系统前进以及数据将被存储在何处。它不显示关于进程计时的信息，也不显示关于进程将按顺序还是并行运行的信息，而不像传统的关注控制流的结构化流程图，或者UML活动工作流程图，它将控制流和数据流作为一个统一的模型。<br/>数据流图从数据传递和加工的角度，以图形的方式刻画数据流从输入到输出的移动变换过程。</td></tr></tbody></table><h3 id="3-1-功能总览"><a href="#3-1-功能总览" class="headerlink" title="3.1 功能总览"></a><strong>3.1 功能总览</strong></h3><table><thead><tr><th align="center"><span style="display:inline-block;width: 120px">功能</span></th><th align="left">具体内容</th></tr></thead><tbody><tr><td align="center">用户注册</td><td align="left">学生可利用自已学号进行注册，注册实现实名制</td></tr><tr><td align="center">用户登录</td><td align="left">只有登录用户才能进行信息发布。管理员登录后可以进行系统管理</td></tr><tr><td align="center">发布信息</td><td align="left">普通用户和管理员登录后都可以发布信息</td></tr><tr><td align="center">修改信息</td><td align="left">普通用户可以修改自己发布的信息，管理员可以修改所有信息</td></tr><tr><td align="center">删除信息</td><td align="left">普通用户可以删除自己发布的信息，管理员可以删除所有信息</td></tr><tr><td align="center">浏览信息</td><td align="left">游客、普通用户和管理员可以浏览所有发布的信息</td></tr><tr><td align="center">搜索信息</td><td align="left">游客、普通用户和管理员可以用关键字搜索所有发布的信息。普通用户可以搜索自己发布的所有信息</td></tr><tr><td align="center">发表留言</td><td align="left">普通用户和管理员登录后都可以对发布信息进行留言</td></tr><tr><td align="center">查看留言</td><td align="left">游客、普通用户和管理员都可以查看发布信息的留言</td></tr><tr><td align="center">删除留言</td><td align="left">管理员可以删除留言</td></tr><tr><td align="center">添加二手指南</td><td align="left">管理员可以添加二手指南</td></tr><tr><td align="center">查看二手指南</td><td align="left">游客、普通用户和管理员都可以查看二手指南</td></tr><tr><td align="center">修改二手指南</td><td align="left">管理员可以修改二手指南</td></tr><tr><td align="center">删除二手指南</td><td align="left">管理员可以删除二手指南</td></tr><tr><td align="center">私信交流</td><td align="left">用户之间可以相互私信交流</td></tr><tr><td align="center">智能推荐</td><td align="left">智能推荐用户喜欢的产品</td></tr><tr><td align="center">图像识别</td><td align="left">自动识别客户上传的图片</td></tr><tr><td align="center">社区交流</td><td align="left">用户可以在社区当中发帖交流</td></tr><tr><td align="center">爱心公益</td><td align="left">用户可以将自己不需要的物品进行爱心捐献</td></tr></tbody></table><h3 id="3-2-功能结构图"><a href="#3-2-功能结构图" class="headerlink" title="3.2 功能结构图"></a><strong>3.2 功能结构图</strong></h3><p>![未命名文件 (软件需求规格说明书.assets&#x2F;未命名文件 (2).png)](..&#x2F;..&#x2F;Download&#x2F;未命名文件 (2).png)</p><h3 id="3-3-数据流分析"><a href="#3-3-数据流分析" class="headerlink" title="3.3 数据流分析"></a><strong>3.3 数据流分析</strong></h3><p>[^用户信息模块数据流图]: </p><p><img src="/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E8%A7%84%E6%A0%BC%E8%AF%B4%E6%98%8E%E4%B9%A6.assets/1647483600024.png" alt="1647483600024"></p><p><img src="/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E8%A7%84%E6%A0%BC%E8%AF%B4%E6%98%8E%E4%B9%A6.assets/1647483620846.png" alt="1647483620846"></p><p><img src="/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E8%A7%84%E6%A0%BC%E8%AF%B4%E6%98%8E%E4%B9%A6.assets/1647483630850.png" alt="1647483630850"></p><h3 id="3-4-功能分析"><a href="#3-4-功能分析" class="headerlink" title="3.4 功能分析"></a>3.4 功能分析</h3><p>在此部分将从用例图、活动图、时序图、状态图和类图从不同视角对用户信息模块、交易模块、展示模块、社区模块、活动模块进行刻画和描述。</p><h4 id="3-4-1-用户信息模块"><a href="#3-4-1-用户信息模块" class="headerlink" title="3.4.1 用户信息模块"></a>3.4.1 用户信息模块</h4><h5 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h5><p><img src="/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E8%A7%84%E6%A0%BC%E8%AF%B4%E6%98%8E%E4%B9%A6.assets/%E7%94%A8%E4%BE%8B%E5%9B%BE-1648648796754.png" alt="用例图"></p><table><thead><tr><th><span style="display:inline-block;width: 120px">用例名称</span></th><th>注册</th></tr></thead><tbody><tr><td>简述</td><td>该用例允许用户将用户名，密码，电话号码三段信息提交至系统注册账号</td></tr><tr><td>参与者</td><td>用户</td></tr><tr><td>前置条件</td><td>打开网页点击注册</td></tr><tr><td>正常流</td><td>①用户输入用户名，密码，电话号码三段信息， ②用户点击获取验证码，并将其填入到验证码一栏中， ③用户点击注册按钮，注册成功.</td></tr><tr><td>替代流</td><td>①若用户未输入用户名，密码，电话号码三段信息，则无法点击获取验证码，并在缺失信息的一栏提示 ②若用户未点击发送验证码，则无法点击注册按钮，并在验证码一栏提示 ③若用户输入错误的验证码，点击会提示验证码错误</td></tr><tr><td>后置条件</td><td>如果用例成功，用户信息在系统的数据库中，否则系统状态不变。</td></tr></tbody></table><table><thead><tr><th><span style="display:inline-block;width: 120px">用例名称</span></th><th>注册</th></tr></thead><tbody><tr><td>简述</td><td>该用例允许用户将用户名，密码，两段信息提交至系统登录账号</td></tr><tr><td>参与者</td><td>用户</td></tr><tr><td>前置条件</td><td>打开网页点击登录</td></tr><tr><td>正常流</td><td>①用户输入用户名，密码三段信息， ②用户点击登录按钮，登录成功.</td></tr><tr><td>替代流</td><td>①若用户未输入用户名，密码，则无法点击登录，并在缺失的一栏提示 ②若用户输入不存在的用户名，点击登录会提示该用户不存在 ③若用户输入错误的密码，点击登录会提示密码错误 ④若用户输入密码错误五次则登录失败，一小时内不可再次登录。</td></tr><tr><td>后置条件</td><td>如果用例成功，系统向用户展示主界面。</td></tr></tbody></table><table><thead><tr><th><span style="display:inline-block;width: 120px">用例名称</span></th><th>修改密码</th></tr></thead><tbody><tr><td>简述</td><td>该用例允许用户将手机号，新密码提交至系统修改密码</td></tr><tr><td>参与者</td><td>用户</td></tr><tr><td>前置条件</td><td>打开个人信息界面点击修改密码</td></tr><tr><td>正常流</td><td>①用户输入电话号码，新密码， ②用户点击获取验证码，并将其填入到验证码一栏中， ③用户点击修改密码按钮，修改成功.</td></tr><tr><td>替代流</td><td>①若用户未输入新密码或手机号，则无法获取验证吗，并在缺失的一栏提示 ②若用户未点击发送验证码，则无法点击注册按钮，并在验证码一栏提示 ③若用户输入错误的验证码，点击会提示验证码错误</td></tr><tr><td>后置条件</td><td>如果用例成功，在系统的数据库中修改用户信息，否则系统状态不变。</td></tr></tbody></table><h5 id="活动图"><a href="#活动图" class="headerlink" title="活动图"></a>活动图</h5><p>活动图1 中简单描述了，从开始到登录有账号则直接登录结束，没有账号则填写相关信息来注册账号最后回到登录账号再结束。 </p><p><img src="/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E8%A7%84%E6%A0%BC%E8%AF%B4%E6%98%8E%E4%B9%A6.assets/%E6%B4%BB%E5%8A%A8%E5%9B%BE1-1648648746339.png" alt="活动图1"></p><p>活动图2 中简单描述了，从开始填写信息，填写验证码，最后成功修改密码直接结束。</p><p><img src="/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E8%A7%84%E6%A0%BC%E8%AF%B4%E6%98%8E%E4%B9%A6.assets/%E6%B4%BB%E5%8A%A8%E5%9B%BE2-1648648753740.png" alt="活动图2"></p><h5 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h5><p><img src="/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E8%A7%84%E6%A0%BC%E8%AF%B4%E6%98%8E%E4%B9%A6.assets/%E6%97%B6%E5%BA%8F%E5%9B%BE-1648648763772.jpg" alt="时序图"></p><h5 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h5><p><img src="/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E8%A7%84%E6%A0%BC%E8%AF%B4%E6%98%8E%E4%B9%A6.assets/%E7%8A%B6%E6%80%81%E5%9B%BE-1648648785838.png" alt="状态图"></p><h5 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h5><p><img src="/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E8%A7%84%E6%A0%BC%E8%AF%B4%E6%98%8E%E4%B9%A6.assets/%E7%B1%BB%E5%9B%BE-1648648780872.png" alt="类图"></p><table><thead><tr><th><span style="display:inline-block;width: 120px">类图综述</span></th><th>类图名称</th></tr></thead><tbody><tr><td>目的</td><td>围绕用户注册模块分析类图</td></tr><tr><td>结构</td><td>用户-登录-账号</td></tr><tr><td>功能</td><td>提供用户登录功能</td></tr><tr><td>组织</td><td>大体上以为LoginBO类为中心</td></tr></tbody></table><table><thead><tr><th>LoginForm</th><th></th></tr></thead><tbody><tr><td>整体说明</td><td>展示登录界面</td></tr><tr><td>属性说明</td><td>login: LoginBO</td></tr><tr><td>操作说明</td><td>LoginForm(), validate( String account, String password) : void</td></tr><tr><td>关系说明</td><td>LoginForm类没有子类或父类</td></tr></tbody></table><table><thead><tr><th>LoginBO</th><th></th></tr></thead><tbody><tr><td>整体说明</td><td>登录业务逻辑类，封装实现登录功能的业务逻辑类</td></tr><tr><td>属性说明</td><td>userDAO : IUserDAO</td></tr><tr><td>操作说明</td><td>setlUserDAO(UserDAO userDAO) : void,  validate( String account, String password ) : boolean</td></tr><tr><td>关系说明</td><td>LoginBO类没有子类或父类</td></tr></tbody></table><table><thead><tr><th>lUserDAO</th><th></th></tr></thead><tbody><tr><td>整体说明</td><td>抽象数据访问类接口，声明对User表的数据操作方法，</td></tr><tr><td>属性说明</td><td>–</td></tr><tr><td>操作说明</td><td>findUserByAccAndPwd( String account, String password ) : boolean</td></tr><tr><td>关系说明</td><td>lUserDAO类没有子类或父类</td></tr></tbody></table><table><thead><tr><th>UserDAO</th><th></th></tr></thead><tbody><tr><td>整体说明</td><td>狊体数据访问类，实现对User表的数据操作方法</td></tr><tr><td>属性说明</td><td>–</td></tr><tr><td>操作说明</td><td>findUserByAccAndPwd( String account, String password ) : boolean</td></tr><tr><td>关系说明</td><td>UserDAO类没有子类或父类</td></tr></tbody></table><table><thead><tr><th><span style="display:inline-block;width: 100px">关联描述</span></th><th></th></tr></thead><tbody><tr><td>关联一</td><td>LoginForm类 和 LoginBO类是组合关系，LoginForm类是LoginBO类的整体部分且控制其生命周期。</td></tr><tr><td>关联二</td><td>LoginBO类 和 lUserDAO类是聚合关系，LoginBO类是lUserDAO类的整体部分，但部分lUserDAO类可以脱离整体部分单独存在。</td></tr><tr><td>关联三</td><td>UserDAO类是lUserDAO类的实现接口，在UserDAO类中具体声明了一些方法。</td></tr></tbody></table><h4 id="3-4-2-交易模块"><a href="#3-4-2-交易模块" class="headerlink" title="3.4.2 交易模块"></a>3.4.2 交易模块</h4><h5 id="用例图-1"><a href="#用例图-1" class="headerlink" title="用例图"></a>用例图</h5><img src="软件需求规格说明书.assets/交易模块用例图.png" alt="交易模块用例图" style="zoom: 80%;" /><table><thead><tr><th align="center"><span style="display:inline-block;width: 120px">用例名称</span></th><th>搜索信息</th></tr></thead><tbody><tr><td align="center">简述</td><td>该用例允许用户输入所需要搜索的信息，该信息包括所需要购买的物品名，好友名，历史订单以及现有开放活动。</td></tr><tr><td align="center">参与者</td><td>用户</td></tr><tr><td align="center">前置条件</td><td>用户需要进入搜索框，并且输入对应所需查找的物品、好友、历史订单或活动名。当用户单击“搜索”按钮时，该用例启动。</td></tr><tr><td align="center">正常流</td><td>① 当用户输入物品名，并点击”搜索“按钮时，系统显示用户搜索的物品售卖页面。② 当用户输入好友名，并点击”搜索“按钮时，系统显示用户搜索的好友主页。③ 当用户输入历史订单名，并点击”搜索“按钮时，系统显示用户搜索的历史订单详情页面。④ 当用户输入活动名，并点击”搜索“按钮时，系统显示</td></tr><tr><td align="center">替代流</td><td>① 当用户未输入物品名，并点击”搜索“按钮时，系统显示弹窗提示用户未输入文本。② 当用户未输入好友名，并点击”搜索“按钮时，系统显示弹窗提示用户未输入文本。③ 当用户未输入历史订单名，并点击”搜索“按钮时，系统显示弹窗提示用户未输入文本。④ 当用户未输入活动名，并点击”搜索“按钮时，系统显示弹窗提示用户未输入文本。</td></tr><tr><td align="center">后置条件</td><td>如果用例成功，搜索记录在系统的数据库中，否则系统状态不变。</td></tr></tbody></table><table><thead><tr><th align="center"><span style="display:inline-block;width: 120px">用例名称</span></th><th>删除信息</th></tr></thead><tbody><tr><td align="center">简述</td><td>该用例允许用户删除信息，该信息包括所需要曾经历史订单，好友，所参与活动的记录，个人主页，售卖物品主页。</td></tr><tr><td align="center">参与者</td><td>用户、管理员</td></tr><tr><td align="center">前置条件</td><td>用户需要进入个人主页，在不同模块如好友、历史订单、活动、个人主页处点击”删除“按钮，该用例启动。</td></tr><tr><td align="center">正常流</td><td>① 当用户进入个人主页，并点击”删除简介“按钮时，系统删除用户的个人主页信息（如签名，简介）。② 当用户进入个人主页-售卖物品主页，选择要删除的物品，并点击”删除“按钮时，系统删除用户的所售卖物品主页。③ 当用户进入好友主页，选择要删除的好友，并点击”删除“按钮时，系统删除用户的对应好友。④ 当用户进入历史订单主页，选择要删除的历史订单，并点击”删除“按钮时，系统删除用户的对应历史订单。⑤ 当用户进入活动主页，选择要删除的参与过的活动，并点击”删除“按钮时，系统删除用户的对应参与过活动。</td></tr><tr><td align="center">替代流</td><td>① 当用户未选择售卖物品，并点击”删除“按钮时，系统显示弹窗提示用户未选择售卖物品。② 当用户未选择好友，并点击”删除“按钮时，系统显示弹窗提示用户未选择好友。③ 当用户未选择历史订单，并点击”删除“按钮时，系统显示弹窗提示用户未选择历史订单。④ 当用户未选择活动，并点击”删除“按钮时，系统显示弹窗提示用户未选择活动。⑤ 当用户未选择个人主页简介，并点击”删除“按钮时，系统显示弹窗提示用户未选择简介。</td></tr><tr><td align="center">后置条件</td><td>如果用例成功，对应的删除记录会在系统的数据库消失中，否则系统状态不变。</td></tr></tbody></table><table><thead><tr><th align="center"><span style="display:inline-block;width: 120px">用例名称</span></th><th>浏览信息</th></tr></thead><tbody><tr><td align="center">简述</td><td>该用例允许用户浏览好友、物品、个人主页和活动信息，该信息包括历史订单，好友，所参与活动的记录，个人主页，售卖物品主页等。</td></tr><tr><td align="center">参与者</td><td>用户</td></tr><tr><td align="center">前置条件</td><td>用户需要进入个人主页、好友主页、物品主页、活动主页等，点击图片或名字，该用例启动。</td></tr><tr><td align="center">正常流</td><td>① 当用户进入个人主页，并点击下方个人主页按钮时，系统显示用户的个人主页信息（如签名，简介）。② 当用户进入个人主页-售卖物品主页，点击售卖的物品，系统显示用户的所售卖物品主页。③ 当用户进入好友主页，点击要选择的好友，系统显示用户的对应好友主页。④ 当用户进入历史订单主页，选择要点击的历史订单，系统显示用户的对应历史订单。⑤ 当用户进入活动主页，选择要参与过的活动，系统显示用户的对应参与过活动。</td></tr><tr><td align="center">替代流</td><td>① 当用户未选择个人主页，系统不会显示个人主页。② 当用户未选择好友，系统不会显示好友主页。③ 当用户未选择历史订单主页，系统不会显示历史订单主页。④ 当用户未选择物品，系统不会显示物品主页。⑤ 当用户未选择活动，系统不会显示活动主页。</td></tr><tr><td align="center">后置条件</td><td>如果用例成功，系统会显示相应点击的详情主页，否则系统状态不变。</td></tr></tbody></table><table><thead><tr><th align="center"><span style="display:inline-block;width: 120px">用例名称</span></th><th>修改信息</th></tr></thead><tbody><tr><td align="center">简述</td><td>该用例允许用户修改信息，该信息包括个人主页，自己所售卖物品的价格、图片、简介信息。</td></tr><tr><td align="center">参与者</td><td>用户</td></tr><tr><td align="center">前置条件</td><td>用户需要进入个人主页，在不同模块如签名简介或售卖物品的主页点击修改，该用例启动。</td></tr><tr><td align="center">正常流</td><td>① 当用户进入个人主页，并点击”修改“按钮时，用户的个人主页信息（如签名，简介）显示可修改状态。② 当用户进入个人主页-售卖物品主页，选择要修改的物品，并点击”修改“按钮时，用户的所售卖物品主页显示可修改状态。</td></tr><tr><td align="center">替代流</td><td>① 当用户未选择售卖物品，并点击”修改“按钮时，系统显示弹窗提示用户未选择售卖物品。</td></tr><tr><td align="center">后置条件</td><td>如果用例成功，对应的修改记录会在系统的数据库出现并覆盖之前的信息，否则系统状态不变。</td></tr></tbody></table><table><thead><tr><th align="center"><span style="display:inline-block;width: 120px">用例名称</span></th><th>发布信息</th></tr></thead><tbody><tr><td align="center">简述</td><td>该用例允许用户发布信息，该信息包括售卖物品主页。</td></tr><tr><td align="center">参与者</td><td>用户、管理员</td></tr><tr><td align="center">前置条件</td><td>用户需要进入个人主页-物品主页，点击发布“按钮，该用例启动。</td></tr><tr><td align="center">正常流</td><td>① 当用户进入个人主页，并点击”发布“按钮时，系统会发布用户的所售卖的物品主页信息。</td></tr><tr><td align="center">替代流</td><td>① 当用户未选择售卖物品，并点击”发布“按钮时，系统显示弹窗提示用户未选择售卖物品。</td></tr><tr><td align="center">后置条件</td><td>如果用例成功，发布售卖物品记录会在系统的数据库出现中，否则系统状态不变。</td></tr></tbody></table><h5 id="活动图-1"><a href="#活动图-1" class="headerlink" title="活动图"></a>活动图</h5><p><img src="/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E8%A7%84%E6%A0%BC%E8%AF%B4%E6%98%8E%E4%B9%A6.assets/%E6%90%9C%E7%B4%A2%E4%BF%A1%E6%81%AF-1648647967592.png" alt="搜索信息"></p><p>![删除信息 (软件需求规格说明书.assets&#x2F;删除信息 (2)-1648648030631.png)](C:&#x2F;Users&#x2F;Lenovo&#x2F;Desktop&#x2F;交易模块&#x2F;删除信息 (2).png)</p><h5 id="时序图-1"><a href="#时序图-1" class="headerlink" title="时序图"></a>时序图</h5><p><img src="/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E8%A7%84%E6%A0%BC%E8%AF%B4%E6%98%8E%E4%B9%A6.assets/%E6%B7%BB%E5%8A%A0%E5%87%BA%E5%85%A5%E5%BA%93%E8%AE%B0%E5%BD%95%E5%BA%8F%E5%88%97%E5%9B%BE.png" alt="添加出入库记录序列图"></p><h5 id="状态图-1"><a href="#状态图-1" class="headerlink" title="状态图"></a>状态图</h5><p><img src="/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E8%A7%84%E6%A0%BC%E8%AF%B4%E6%98%8E%E4%B9%A6.assets/%E7%8A%B6%E6%80%81%E5%9B%BE-1648648042817.png" alt="状态图"></p><h5 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h5><p>![未命名文件 (软件需求规格说明书.assets&#x2F;未命名文件 (11).png)](G:&#x2F;Download&#x2F;未命名文件 (11).png)</p><table><thead><tr><th><span style="display:inline-block;width: 120px">类图综述</span></th><th>类图名称</th></tr></thead><tbody><tr><td>目的</td><td>围绕交易模块分析类图</td></tr><tr><td>结构</td><td>界面-控制-实体</td></tr><tr><td>功能</td><td>提供了二手物品交易功能、二手物品发布功能，可以进行二手物品信息的设置，包括名称，价格，是否包邮等等</td></tr><tr><td>组织</td><td>大体上以交易功能为中心</td></tr></tbody></table><table><thead><tr><th>DealPart类描述</th><th></th></tr></thead><tbody><tr><td>整体说明</td><td>用于验证用户信息和交易信息</td></tr><tr><td>属性说明</td><td>- string userName - string dealInfo</td></tr><tr><td>操作说明</td><td>+ getShopInfo(): string<br/>+ validate( String account , String password ) : void</td></tr><tr><td>关系说明</td><td>有两个子类：<strong>DealDonePart</strong>类和<strong>ReleaseInfoPart</strong>类</td></tr></tbody></table><table><thead><tr><th><strong>DealDonePart</strong>类描述</th><th></th></tr></thead><tbody><tr><td>整体说明</td><td>用于判断交易是否成功以及展示交易信息</td></tr><tr><td>属性说明</td><td>- string passWord</td></tr><tr><td>操作说明</td><td>+ dealSuccess():bool<br/>+ dealInfo(string dealNum):string</td></tr><tr><td>关系说明</td><td>是DealPart类的子类</td></tr></tbody></table><table><thead><tr><th><strong>ReleaseInfoPart</strong>类描述</th><th></th></tr></thead><tbody><tr><td>整体说明</td><td>用于验证用户信息和交易信息</td></tr><tr><td>属性说明</td><td>- string Info<br/>- string nameOfSell<br/>- string prize<br/>- bool postal<br/>- bool release</td></tr><tr><td>操作说明</td><td>+ setInfo(): void<br/>+ getInfo(int dealNum): string<br/>+ getReleaseOrNot(int dealNum): bool<br/>+ getPostalOrNot(int dealNum): bool<br/>+ releaseNew(string info): void</td></tr><tr><td>关系说明</td><td>是DealPart类的子类</td></tr></tbody></table><h4 id="3-4-3-展示模块"><a href="#3-4-3-展示模块" class="headerlink" title="3.4.3 展示模块"></a>3.4.3 展示模块</h4><h5 id="用例图-2"><a href="#用例图-2" class="headerlink" title="用例图"></a>用例图</h5><img src="软件需求规格说明书.assets/用例图-1648648353326.png" alt="用例图" style="zoom: 33%;" /><table><thead><tr><th><span style="display:inline-block;width: 120px">用例名称</span></th><th>视频展示</th></tr></thead><tbody><tr><td>简述</td><td>该用例将系统的使用以及注意事项通过视频的方式展现给用户，并可供用户下载</td></tr><tr><td>参与者</td><td>用户</td></tr><tr><td>前置条件</td><td>用户进入系统主页面，该页面显示系统各种功能，当用户单击“视频简介”按钮时，该用例启动。</td></tr><tr><td>正常流</td><td>①系统打开视频展示视频 ②用户观看视频，可暂停，跳转等 ③系统提供下载该视频功能</td></tr><tr><td>替代流</td><td>① 若系统打开视频失败，用户可提交投诉将错误及时反馈。 ② 若客户下载视频失败，用户可联系工作人员获取备用下载地址。</td></tr><tr><td>后置条件</td><td>如果用例成功，播放展示视频并提共下载源，否则系统状态不变。</td></tr></tbody></table><table><thead><tr><th><span style="display:inline-block;width: 120px">用例名称</span></th><th>智能推荐</th></tr></thead><tbody><tr><td>简述</td><td>该用例将用户最希望购置到的物品和最热门的物品推荐给用户，并提供评价服务。</td></tr><tr><td>参与者</td><td>用户</td></tr><tr><td>前置条件</td><td>客户进入购物页面，该页面显示各类二手物品及其价格，当用户单击“智能推荐”按钮时，该用例启动</td></tr><tr><td>正常流</td><td>①系统显示客户最希望购买的和最热门的商品列表供客户选择 ②客户选择心怡的物品，使用“购买”功能，选择付款方式，系统给订单唯一的订单编号，将订单信息存储到数据库.</td></tr><tr><td>替代流</td><td>①若客户未购买物品，返回主页面 ②若客户未选择付款方式，选择“购买”功能，则无法提交，仍然回到订单页面提示客户选择付款方式(网上支付&#x2F;货到付款)</td></tr><tr><td>后置条件</td><td>如果用例成功，购物订单记录在系统的数据库中，更新智能推荐物品列表，否则系统状态不变</td></tr></tbody></table><table><thead><tr><th><span style="display:inline-block;width: 120px">用例名称</span></th><th>用户指南</th></tr></thead><tbody><tr><td>简述</td><td>该用例将系统的使用以及注意事项通过文本的方式展现给用户。</td></tr><tr><td>参与者</td><td>用户</td></tr><tr><td>前置条件</td><td>客户进入系统主页面，该页面显示系统各种功能，当用户单击“用户指南”按钮时，该用例启动</td></tr><tr><td>正常流</td><td>① 系统显示系统的使用指南和注意事项。</td></tr><tr><td>替代流</td><td>① 若客户打开用户指南失败，用户可提交投诉将错误及时反馈。</td></tr><tr><td>后置条件</td><td>如果用例成功，打开用户指南，否则系统状态不变。</td></tr></tbody></table><h5 id="活动图-2"><a href="#活动图-2" class="headerlink" title="活动图"></a>活动图</h5><p>图中简单描述了：从打开视频简介开始，若视频打开失败则向客户发送错误反馈，若打开成功则可以查看视频，观看时有四个功能选项，即全屏播放、挑战进度、调节音量、暂停播放，播放完成后用户可选择是否下载，若选择下载且下载成功后，返回主界面；若下载失败，向客服发送错误反馈；若不下载则返回主页面，结束该活动。</p><img src="软件需求规格说明书.assets/活动图1-1648648358013.png" alt="活动图1" style="zoom: 50%;" /><p>图中简单描述了：从打开智能推荐开始，可以选择三种功能，即心意物品推荐、热门物品推荐和查看评价，找到自己想要购买的二手物品后，进行购买，选择付款方式后进行付款，付款成功后返回主界面，结束活动。</p><img src="软件需求规格说明书.assets/活动图2-1648648366272.png" alt="活动图2" style="zoom:50%;" /><p>图中简单描述了：从打开用户指南开始，若打开失败则自动提交错误反馈；若打开成功开始查看指南，结束后返回主界面，结束活动。</p><img src="软件需求规格说明书.assets/活动图3.png" alt="活动图3" style="zoom:50%;" /><h5 id="时序图-2"><a href="#时序图-2" class="headerlink" title="时序图"></a>时序图</h5><p>图中展示的是展示模块场景下的序列图。</p><img src="软件需求规格说明书.assets/序列图.png" alt="序列图" style="zoom: 50%;" /><h5 id="状态图-2"><a href="#状态图-2" class="headerlink" title="状态图"></a>状态图</h5><p>图中描述了展示模块在其生命周期内所经历的状态。</p><p><img src="/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E8%A7%84%E6%A0%BC%E8%AF%B4%E6%98%8E%E4%B9%A6.assets/%E7%8A%B6%E6%80%81%E5%9B%BE-1648648386871.png" alt="状态图"></p><h5 id="类图-2"><a href="#类图-2" class="headerlink" title="类图"></a>类图</h5><img src="软件需求规格说明书.assets/类图-1648648392587.png" alt="类图"  /><table><thead><tr><th><span style="display:inline-block;width: 120px">类图综述</span></th><th>展示模块</th></tr></thead><tbody><tr><td>目的</td><td>围绕展示的目的将该产品的使用方法和建议介绍给用户</td></tr><tr><td>结构</td><td>展示界面控制用户使用这三个功能</td></tr><tr><td>功能</td><td>提供视频介绍、用户指南、智能推荐购买功能</td></tr><tr><td>组织</td><td>大体上以智能推荐购买功能为中心</td></tr></tbody></table><table><thead><tr><th>user类描述</th><th></th></tr></thead><tbody><tr><td>整体说明</td><td>记录用户相关信息</td></tr><tr><td>属性说明</td><td>-ID : int  -name: String</td></tr><tr><td>操作说明</td><td>+show() : void</td></tr><tr><td>关系说明</td><td>无子类、父类</td></tr></tbody></table><table><thead><tr><th>recommend类描述</th><th></th></tr></thead><tbody><tr><td>整体说明</td><td>推荐用户心意和热门的二手物品</td></tr><tr><td>属性说明</td><td>-judge : bool<br/> -ID : String<br/>  -type : int</td></tr><tr><td>操作说明</td><td>+recommendationAlgorithm() : void</td></tr><tr><td>关系说明</td><td>无子类、父类</td></tr></tbody></table><table><thead><tr><th>buy类描述</th><th></th></tr></thead><tbody><tr><td>整体说明</td><td>用户购买物品</td></tr><tr><td>属性说明</td><td>-Buy : bool<br/>-price : double</td></tr><tr><td>操作说明</td><td>+ifBuy() : void<br/>+pay() : void</td></tr><tr><td>关系说明</td><td>无子类、父类</td></tr></tbody></table><table><thead><tr><th>video类描述</th><th></th></tr></thead><tbody><tr><td>整体说明</td><td>播放以及下载介绍视频</td></tr><tr><td>属性说明</td><td>-judge : bool<br/>-type : int</td></tr><tr><td>操作说明</td><td>+ifDownload() : void<br/>+ifOpen() : void</td></tr><tr><td>关系说明</td><td>无子类、父类</td></tr></tbody></table><table><thead><tr><th>guide类描述</th><th></th></tr></thead><tbody><tr><td>整体说明</td><td>查看用户指南</td></tr><tr><td>属性说明</td><td>-judge : bool<br/>-type : int<br/>-content : String</td></tr><tr><td>操作说明</td><td>+ifOpen() : void</td></tr><tr><td>关系说明</td><td>无子类、父类</td></tr></tbody></table><table><thead><tr><th>关联描述</th><th></th></tr></thead><tbody><tr><td>关联一</td><td>user与recommend是聚合关系，推荐与用户功能是部分与整体之间的关系，且可以脱离整体单独存在</td></tr><tr><td>关联二</td><td>user与video是聚合关系，视频与用户功能是部分与整体之间的关系，且可以脱离整体单独存在</td></tr><tr><td>关联三</td><td>user与guide是聚合关系，用户指南与用户功能是部分与整体之间的关系，且可以脱离整体单独存在</td></tr><tr><td>关联四</td><td>recommend与buy是聚合关系，购买与推荐系统是部分与整体之间的关系，且可以脱离整体单独存在</td></tr></tbody></table><h4 id="3-4-4-社区模块"><a href="#3-4-4-社区模块" class="headerlink" title="3.4.4 社区模块"></a>3.4.4 社区模块</h4><h5 id="用例图-3"><a href="#用例图-3" class="headerlink" title="用例图"></a>用例图</h5><p><img src="/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E8%A7%84%E6%A0%BC%E8%AF%B4%E6%98%8E%E4%B9%A6.assets/%E7%94%A8%E4%BE%8B%E5%9B%BE-1648647112149.png" alt="用例图"></p><table><thead><tr><th><span style="display:inline-block;width: 120px">用例名称</span></th><th>用户交流</th></tr></thead><tbody><tr><td>简述</td><td>该用例用户交流部分让用户通过点击其他用户或社区进行私信聊天或者社区群聊。</td></tr><tr><td>参与者</td><td>用户</td></tr><tr><td>前置条件</td><td>用户进入社区界面，该界面显示所有与该用户有关的其他用户和社区，用户单击其他用户或社区时，用例启动。</td></tr><tr><td>正常流</td><td>1.系统显示与单个用户或社区内聊天的历史记录。2.系统支持用户在聊天框中添加文字、语音、图片和视频等内容。3.用户点击“发送”，聊天框中的内容储存至数据库并发送至聊天模块。</td></tr><tr><td>替代流</td><td>1.若用户没有在聊天框中添加任何信息，则消息不会发送。2.若用户添加内容过大，则显示发送失败3.若用户发送的文本内容或图片、视频涉嫌传播非法或淫秽信息，则不会发送消息。</td></tr><tr><td>后置条件</td><td>如果用例成功，聊天内容储存在数据库中并显示于聊天模块，否则系统状态不变。</td></tr></tbody></table><table><thead><tr><th><span style="display:inline-block;width: 120px">用例名称</span></th><th>帖子留言</th></tr></thead><tbody><tr><td>简述</td><td>该用例帖子留言部分让用户可以查看他人在各个帖子下的留言，并可以在各个帖子下发布留言或删除自己已发布的留言。</td></tr><tr><td>参与者</td><td>用户</td></tr><tr><td>前置条件</td><td>用户进入贴吧界面，该页面显示各个帖子标题和简介，用户可以点击进入各个帖子，当用户进入帖子时，该用例启动。</td></tr><tr><td>正常流</td><td>1.系统显示该帖下所有用户的留言，若用户自己有历史留言，则在个人用户端高亮置顶显示。2.系统支持用户在输入框中添加文字、图片和视频等内容。3.用户点击“发布”，输入框中的内容储存至数据库并发送至留言模块。4.用户自己发送的留言下有”删除“按钮，用户点击“删除”，留言在留言面板上抹除并在数据库中删除该记录。</td></tr><tr><td>替代流</td><td>1.若用户没有在输入框中添加任何信息，则无法发布留言。2.若用户添加内容过大，则显示发送失败。3.若用户发送的文本内容或图片、视频涉嫌传播非法或淫秽信息，则不会发布留言。</td></tr><tr><td>后置条件</td><td>如果用例成功，发布的留言将储存至数据库并显示在留言面板，删除的留言将在数据库中删除该记录并在留言面板上抹除，否则系统状态不变。</td></tr></tbody></table><table><thead><tr><th><span style="display:inline-block;width: 120px">用例名称</span></th><th>动态</th></tr></thead><tbody><tr><td>简述</td><td>该用例动态部分让用户可以发布自己的动态并进行修改或删除。</td></tr><tr><td>参与者</td><td>用户</td></tr><tr><td>前置条件</td><td>用户进入动态界面，该界面显示用户自己发布的历史动态，当用户点击“发布动态”或“管理动态”时，该用例启动。</td></tr><tr><td>正常流</td><td>1.系统显示用户自己发布的历史动态。2.系统支持用户在输入框中添加文字、图片和视频等内容。3.用户点击“发布动态”，输入框中的内容储存至数据库并发送至动态模块。4.用户点击“管理动态”，可以选择修改动态文本内容或删除该动态，并于数据库中做相应修改。</td></tr><tr><td>替代流</td><td>1.若用户没有在输入框中添加任何信息，则无法发布动态。2.若用户添加内容过大，则显示发送失败。3.若用户发送的文本内容或图片涉嫌传播非法或淫秽信息，则不会发布动态。</td></tr><tr><td>后置条件</td><td>如果用例成功，发布的动态将储存至数据库并显示在动态面板，删除或修改的动态将在数据库中删除或修改该记录并在动态面板上抹除，否则系统状态不变。</td></tr></tbody></table><h5 id="活动图-3"><a href="#活动图-3" class="headerlink" title="活动图"></a>活动图</h5><p>用户打开聊天界面，如私信聊天或社区群聊，在聊天框中输入文字或编辑语音、图片、视频等内容，点击发送，系统检测文本内容和图片视频是否含有非法淫秽信息，如果有则发送失败，提示用户“内容含有非法信息，发送失败” ；如果没有，则发送成功并将内容储存至数据库，在聊天面板显示发送的内容，退出聊天界面后结束。</p><p><img src="/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E8%A7%84%E6%A0%BC%E8%AF%B4%E6%98%8E%E4%B9%A6.assets/%E6%B4%BB%E5%8A%A8%E5%9B%BE-1648647098082.png" alt="活动图"></p><h5 id="时序图-3"><a href="#时序图-3" class="headerlink" title="时序图"></a>时序图</h5><p>下图展示的是用户交流场景下的时序图</p><p><img src="/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E8%A7%84%E6%A0%BC%E8%AF%B4%E6%98%8E%E4%B9%A6.assets/%E6%97%B6%E5%BA%8F%E5%9B%BE-1648647104487.png" alt="时序图"></p><h5 id="状态图-3"><a href="#状态图-3" class="headerlink" title="状态图"></a>状态图</h5><p>下图描述了用户交流在其生命周期内所经历的状态</p><p><img src="/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E8%A7%84%E6%A0%BC%E8%AF%B4%E6%98%8E%E4%B9%A6.assets/%E7%8A%B6%E6%80%81%E5%9B%BE-1648647108348.png" alt="状态图"></p><h5 id="类图-3"><a href="#类图-3" class="headerlink" title="类图"></a>类图</h5><p><img src="/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E8%A7%84%E6%A0%BC%E8%AF%B4%E6%98%8E%E4%B9%A6.assets/%E7%B1%BB%E5%9B%BE%E6%96%B0.png" alt="类图新"></p><table><thead><tr><th><span style="display:inline-block;width: 120px">类图综述</span></th><th>描述</th></tr></thead><tbody><tr><td>目的</td><td>围绕用户交流分析类图</td></tr><tr><td>结构</td><td>用户—聊天室—信息</td></tr><tr><td>功能</td><td>提供用户交流功能</td></tr><tr><td>组织</td><td>大体上以message类为中心</td></tr></tbody></table><table><thead><tr><th>User</th><th></th></tr></thead><tbody><tr><td>整体说明</td><td>定义用户类</td></tr><tr><td>属性说明</td><td>-ID:int<br/>-name:String<br/>-password:String</td></tr><tr><td>操作说明</td><td>+login():void</td></tr><tr><td>关系说明</td><td>User类没有子类或父类</td></tr></tbody></table><table><thead><tr><th>Chatroom</th><th></th></tr></thead><tbody><tr><td>整体说明</td><td>定义聊天室类</td></tr><tr><td>属性说明</td><td>-userName:String</td></tr><tr><td>操作说明</td><td>+sendMessage():void</td></tr><tr><td>关系说明</td><td>Chatroom类没有子类或父类</td></tr></tbody></table><table><thead><tr><th>Message</th><th></th></tr></thead><tbody><tr><td>整体说明</td><td>定义信息类</td></tr><tr><td>属性说明</td><td>-content:String<br/>-type:int</td></tr><tr><td>操作说明</td><td>+sendMsg():void</td></tr><tr><td>关系说明</td><td>Message有三个子类，分别是textMessage、picMessage、videoMessage</td></tr></tbody></table><table><thead><tr><th>textMessage</th><th></th></tr></thead><tbody><tr><td>整体说明</td><td>定义文本信息类</td></tr><tr><td>属性说明</td><td>-content:String<br/>-type:int</td></tr><tr><td>操作说明</td><td>+sendText():void</td></tr><tr><td>关系说明</td><td>textMessage有父类message</td></tr></tbody></table><table><thead><tr><th>picMessage</th><th></th></tr></thead><tbody><tr><td>整体说明</td><td>定义图片信息类</td></tr><tr><td>属性说明</td><td>-content:Image<br/>-type:int</td></tr><tr><td>操作说明</td><td>+sendPicture():void</td></tr><tr><td>关系说明</td><td>picMessage有父类message</td></tr></tbody></table><table><thead><tr><th>videoMessage</th><th></th></tr></thead><tbody><tr><td>整体说明</td><td>定义视频信息类</td></tr><tr><td>属性说明</td><td>-src:String   <br/>-type:int</td></tr><tr><td>操作说明</td><td>+sendVideo():void</td></tr><tr><td>关系说明</td><td>videoMessage有父类message</td></tr></tbody></table><table><thead><tr><th>关联描述</th><th></th></tr></thead><tbody><tr><td>关联一</td><td>用户进入聊天室</td></tr><tr><td>关联二</td><td>聊天室编辑并发送信息</td></tr></tbody></table><table><thead><tr><th>继承描述</th><th></th></tr></thead><tbody><tr><td>继承一</td><td>textMessage是message子类，因为其文本信息属于信息中的一种</td></tr><tr><td>继承二</td><td>picMessage是message子类，因为其图片信息属于信息中的一种</td></tr><tr><td>继承三</td><td>videoMessage是message子类，因为其视频信息属于信息中的一种</td></tr></tbody></table><h4 id="3-4-5-活动模块"><a href="#3-4-5-活动模块" class="headerlink" title="3.4.5 活动模块"></a>3.4.5 活动模块</h4><h5 id="用例图-4"><a href="#用例图-4" class="headerlink" title="用例图"></a>用例图</h5><p><img src="/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E8%A7%84%E6%A0%BC%E8%AF%B4%E6%98%8E%E4%B9%A6.assets/%E7%94%A8%E4%BE%8B%E5%9B%BE-1648649896513.png" alt="用例图"></p><table><thead><tr><th><span style="display:inline-block;width: 120px">用例名称</span></th><th>活动模块—以物易物</th></tr></thead><tbody><tr><td>简述</td><td>该用例允许用户填写一份物品登记表，该物品登记表包括用户信息、物品信息、交换需求，完成填写后将数据存进数据库，当发现可匹配的用户后，双方进行联系，并且进行交换</td></tr><tr><td>参与</td><td>用户</td></tr><tr><td>前置条件</td><td>用户登录系统</td></tr><tr><td>正常流</td><td>① 系统显示登记表供客户确认 ② 系统请求客户填写用户信息、物品信息、交换需求 ③ 客户选择“提交”功能，将登记表存储到数据库</td></tr><tr><td>替代流</td><td>① 若用户未填写用户信息，选择“提交”功能，则无法提交，仍然回到登记表页面提示用户填写用户信息 ② 若用户未填写物品信息，选择“提交”功能，仍然回到登记表页面提示用户填写物品信息</td></tr><tr><td>后置条件</td><td>如果用例成功，登记表记录在系统的数据库中，否则系统状态不变</td></tr></tbody></table><table><thead><tr><th><span style="display:inline-block;width: 120px">用例名称</span></th><th>活动模块—捐赠二手物品</th></tr></thead><tbody><tr><td>简述</td><td>该用例允许用户填写一份物品登记表，该物品登记表包括用户信息、物品信息、需求，完成填写后将数据存进数据库，当物品被捐赠后，系统会对用户进行反馈</td></tr><tr><td>参与</td><td>用户</td></tr><tr><td>前置条件</td><td>用户登录系统</td></tr><tr><td>正常流</td><td>① 系统显示登记表供客户确认 ② 系统请求客户填写用户信息、物品信息、需求 ③ 客户选择“提交”功能，将登记表存储到数据库</td></tr><tr><td>替代流</td><td>① 若用户未填写用户信息，选择“提交”功能，则无法提交，仍然回到登记表页面提示用户填写用户信息 ② 若用户未填写物品信息，选择“提交”功能，仍然回到登记表页面提示用户填写物品信息</td></tr><tr><td>后置条件</td><td>如果用例成功，登记表记录在系统的数据库中，否则系统状态不变</td></tr></tbody></table><table><thead><tr><th><span style="display:inline-block;width: 120px">用例名称</span></th><th>活动模块—义卖</th></tr></thead><tbody><tr><td>简述</td><td>该用例允许用户填写一份物品登记表，该物品登记表包括用户信息、物品信息、需求，完成填写后将数据存进数据库，最终义卖的结果系统会对用户进行反馈</td></tr><tr><td>参与</td><td>用户</td></tr><tr><td>前置条件</td><td>用户登录系统</td></tr><tr><td>正常流</td><td>① 系统显示登记表供客户确认 ② 系统请求客户填写用户信息、物品信息、需求 ③ 客户选择“提交”功能，将登记表存储到数据库</td></tr><tr><td>替代流</td><td>① 若用户未填写用户信息，选择“提交”功能，则无法提交，仍然回到登记表页面提示用户填写用户信息 ② 若用户未填写物品信息，选择“提交”功能，仍然回到登记表页面提示用户填写物品信息</td></tr><tr><td>后置条件</td><td>如果用例成功，登记表记录在系统的数据库中，否则系统状态不变</td></tr></tbody></table><h5 id="活动图-4"><a href="#活动图-4" class="headerlink" title="活动图"></a>活动图</h5><p>​ 图中简单描述了，用户从打开登记表到填写表中的信息，填写完毕后点击提交，系统将对表中的内容进行审核，如果不存在违规的词句就提示用户填写完成，等待之后售卖的结果，退出界面并结束；如果存在违规的词句就警告用户再退出界面直接结束。 </p><p><img src="/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E8%A7%84%E6%A0%BC%E8%AF%B4%E6%98%8E%E4%B9%A6.assets/%E6%B4%BB%E5%8A%A8%E5%9B%BE-1648649902753.png" alt="活动图"></p><h5 id="时序图-4"><a href="#时序图-4" class="headerlink" title="时序图"></a>时序图</h5><p>图中展示的是填写登记表场景下的序列图</p><p><img src="/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E8%A7%84%E6%A0%BC%E8%AF%B4%E6%98%8E%E4%B9%A6.assets/%E5%A1%AB%E5%86%99%E7%99%BB%E8%AE%B0%E8%A1%A8%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="填写登记表时序图"></p><h5 id="状态图-4"><a href="#状态图-4" class="headerlink" title="状态图"></a>状态图</h5><p>图中描述了登记物品信息活动在其生命周期内所经历的状态</p><p><img src="/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E8%A7%84%E6%A0%BC%E8%AF%B4%E6%98%8E%E4%B9%A6.assets/%E7%8A%B6%E6%80%81%E5%9B%BE-1648649918190.png" alt="状态图"></p><h5 id="类图-4"><a href="#类图-4" class="headerlink" title="类图"></a>类图</h5><p><img src="/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E8%A7%84%E6%A0%BC%E8%AF%B4%E6%98%8E%E4%B9%A6.assets/%E7%B1%BB%E5%9B%BE-1648649924522.png" alt="类图"></p><table><thead><tr><th>类图综述</th><th>类图名称</th></tr></thead><tbody><tr><td>目的</td><td>围绕类的关系分析类图</td></tr><tr><td>结构</td><td>父类-子类-依赖</td></tr><tr><td>功能</td><td>提供填写二手物品登记表并写入数据库功能</td></tr><tr><td>组织</td><td>大体上以填写二手物品登记表为中心</td></tr></tbody></table><table><thead><tr><th><span style="display:inline-block;width: 120px">登记表类描述</span></th><th align="left"></th></tr></thead><tbody><tr><td>整体说明</td><td align="left">这是所有登记表的父类</td></tr><tr><td>属性说明</td><td align="left">UserName：用户姓名；<br/>UserIphoneNumber：用户联系方式；<br/>Adress：用户地址；<br/>ObjectName：物品名称；<br/>ObjectDescribe：物品描述；<br/>ObjectPrice：物品价格；<br/>ObjectInformation：物品附加信息说明</td></tr><tr><td>操作说明</td><td align="left">Write（）：填写登记表 ；<br/>Confirm（）：确认登记表信息；<br/>Submit（）：提交登记表；</td></tr><tr><td>关系说明</td><td align="left">无父类；Table1；Table2；Table3 是他的子类；</td></tr></tbody></table><table><thead><tr><th><span style="display:inline-block;width: 120px">登记表类描述</span></th><th align="left"></th></tr></thead><tbody><tr><td>整体说明</td><td align="left">以物易物的二手物品物品信息登记表</td></tr><tr><td>属性说明</td><td align="left">UserName：用户姓名；<br/>UserIphoneNumber：用户联系方式；<br/>Adress：用户地址；<br/>ObjectName：物品名称；<br/>ObjectDescribe：物品描述；<br/>ObjectPrice：物品价格；<br/>ObjectInformation：物品附加信息说明</td></tr><tr><td>操作说明</td><td align="left">Write（）：填写登记表 ；<br/>Confirm（）：确认登记表信息； <br/>Submit（）：提交登记表；</td></tr><tr><td>关系说明</td><td align="left">Table是他的父类；无子类</td></tr></tbody></table><table><thead><tr><th><span style="display:inline-block;width: 120px">登记表类描述</span></th><th align="left"></th></tr></thead><tbody><tr><td>整体说明</td><td align="left">捐赠的二手物品物品信息登记表</td></tr><tr><td>属性说明</td><td align="left">UserName：用户姓名；<br/>UserIphoneNumber：用户联系方式；<br/>Adress：用户地址；<br/>ObjectName：物品名称；<br/>ObjectDescribe：物品描述；<br/>ObjectPrice：物品价格；<br/>ObjectInformation：物品附加信息说明</td></tr><tr><td>操作说明</td><td align="left">Write（）：填写登记表 ；<br/>Confirm（）：确认登记表信息； <br/>Submit（）：提交登记表；</td></tr><tr><td>关系说明</td><td align="left">Table是他的父类；无子类</td></tr></tbody></table><table><thead><tr><th><span style="display:inline-block;width: 120px">登记表类描述</span></th><th align="left"></th></tr></thead><tbody><tr><td>整体说明</td><td align="left">义卖的二手物品物品信息登记表</td></tr><tr><td>属性说明</td><td align="left">UserName：用户姓名；<br/>UserIphoneNumber：用户联系方式；<br/>Adress：用户地址；<br/>ObjectName：物品名称；<br/>ObjectDescribe：物品描述；<br/>ObjectPrice：物品价格；<br/>ObjectInformation：物品附加信息说明</td></tr><tr><td>操作说明</td><td align="left">Write（）：填写登记表 ；<br/>Confirm（）：确认登记表信息； <br/>Submit（）：提交登记表；</td></tr><tr><td>关系说明</td><td align="left">Table是他的父类；无子类</td></tr></tbody></table><table><thead><tr><th><span style="display:inline-block;width: 120px">登记表类描述</span></th><th align="left"></th></tr></thead><tbody><tr><td>整体说明</td><td align="left">不同物品信息登记表在数据库中的读写</td></tr><tr><td>属性说明</td><td align="left">-Table：需要操作的物品信息登记表</td></tr><tr><td>操作说明</td><td align="left">TableWriteIntoDBS（Object table）：物品信息登记表写入数据库；ReadTableFromDBS（）：物品信息登记表从数据库读出</td></tr><tr><td>关系说明</td><td align="left">无父类；无子类</td></tr></tbody></table><table><thead><tr><th><span style="display:inline-block;width: 120px">继承描述</span></th><th></th></tr></thead><tbody><tr><td>继承一</td><td>Table1是Table的子类；Table1是以物易物的二手物品物品信息登记表，二手物品物品信息登记表类型之一</td></tr><tr><td>继承二</td><td>Table2是Table的子类；Table2是捐赠的二手物品物品信息登记表，二手物品物品信息登记表类型之一</td></tr><tr><td>继承三</td><td>Table3是Table的子类；Table3是义卖的二手物品物品信息登记表，二手物品物品信息登记表类型之一</td></tr></tbody></table><table><thead><tr><th><span style="display:inline-block;width: 120px">依赖描述</span></th><th></th></tr></thead><tbody><tr><td>依赖一</td><td>DBS类依赖于Table1类，Table3类，或者Table3类；因为数据库的读写需要表格</td></tr></tbody></table><h2 id="四、软硬件及外部系统接口需求"><a href="#四、软硬件及外部系统接口需求" class="headerlink" title="四、软硬件及外部系统接口需求"></a>四、软硬件及外部系统接口需求</h2><h3 id="4-1-用户界面"><a href="#4-1-用户界面" class="headerlink" title="4.1 用户界面"></a><strong>4.1 用户界面</strong></h3><p>​用户界面是程序中用户能看见并与之交互作用的部分,设计一个好的用户界面是非常重要的,本设计将为用户提供美观,大方,直观,操作简单的用户界面。</p><h3 id="4-2-硬件需求"><a href="#4-2-硬件需求" class="headerlink" title="4.2 硬件需求"></a><strong>4.2 硬件需求</strong></h3><p>​移动终端硬件配置应遵循如下原则：具有高的可靠性，可用性和安全性。【描述系统中软件和硬件每一接口的特征。这种描述可能包括支持的硬件类型、软硬件之间的交流的数据和控制信息的性质以及使用的通信协议。】</p><h3 id="4-3-运行环境"><a href="#4-3-运行环境" class="headerlink" title="4.3 运行环境"></a><strong>4.3 运行环境</strong></h3><ul><li><strong>Web 浏览器：</strong>0+、Chrome、Opera、Safari、Firefox及任何支持HTML5标准的浏览器。</li><li><strong>标准分辨率：</strong>1024<em>768、1920</em>1080、2K</li></ul><h2 id="五、可靠性与可用性需求"><a href="#五、可靠性与可用性需求" class="headerlink" title="五、可靠性与可用性需求"></a><strong>五、可靠性与可用性需求</strong></h2><h3 id="5-1-性能需求"><a href="#5-1-性能需求" class="headerlink" title="5.1 性能需求"></a><strong>5.1 性能需求</strong></h3><h4 id="处理能力"><a href="#处理能力" class="headerlink" title="处理能力"></a>处理能力</h4><p>​由于是在线二手交易平台，其处理能力主要考虑系统能承载的最大并发用户数，按照实际情况的规划，系统至少能承载的最大并发用户数要求达到全校学生总人数*φ，φ为0至1的常数，随服务器容量而定。</p><h4 id="应时间"><a href="#应时间" class="headerlink" title="应时间"></a>应时间</h4><p>​为了能够快捷地提供在线测评服务，系统应该能够快速地响应在线测评请求。用户最终得到结果的响应时间除了与系统响应速度有关外，还与网络状况有关。因此对Web服务器端需要较高的要求。</p><h3 id="5-2-安全性需求"><a href="#5-2-安全性需求" class="headerlink" title="5.2 安全性需求"></a><strong>5.2 安全性需求</strong></h3><p>​传输的数据都采用高强度的加密算法加密 (DES)，使得数据即使泄漏、被截获后，也无法识别相关的数据内容，确保数据安全。对于客户端与服务器交互的数据，使用安全套接子层 (SSL,SSL 加密传输主要是针对 WEB的数据传输，基于重要信息的传输安全考虑而设计的) 进行信息交换，并在客户移动终端和服务器之间重要的信息的交换。</p><h2 id="六、附录"><a href="#六、附录" class="headerlink" title="六、附录"></a>六、附录</h2><h3 id="大学生二手交易平台问卷调查"><a href="#大学生二手交易平台问卷调查" class="headerlink" title="大学生二手交易平台问卷调查"></a>大学生二手交易平台问卷调查</h3><p>在校园里，网购已成为一种趋势，足不出户便达成买卖。而二手商品交易也逐步走进我们的生活中，为我们大多数人所接纳。无论网购或二手交易，于商家于买家都是一种既实际又环保的途径。为此，我们针对北京交通大学展开此次调查，了解本校学生对二手交易的需求，更好地构建一个满足本校学生们的校园App二手交易平台。希望同学们能积极参与，感谢您的配合与合作！</p><p>1、性别 【单选题】</p><p> ○ 男</p><p> ○ 女</p><p>2、您有在二手市场购买或卖出东西的经历么？ 【单选题】</p><p> ○ 有</p><p> ○ 没有</p><p> ○ 有想过但没实施过</p><p>3、您对购买二手物品持何种态度？ 【单选题】</p><p> ○ 质量差，不支持</p><p> ○ 只要价钱合理，质量可靠就可以购买</p><p> ○ 看物品而定</p><p> ○ 二手物品价格低廉，很喜欢购买</p><p>4、您购买二手货的原因是？ 【单选题】</p><p> ○ 价格便宜</p><p> ○ 实用价值高</p><p> ○ 物超所值</p><p>5、对于二手物品多少程度的磨损您可以接受？ 【单选题】</p><p> ○ 一成到两成</p><p> ○ 三成到五成</p><p> ○ 六成到八成</p><p> ○ 九成到十成</p><p>6、您在购买二手商品过程中存在的疑虑？ 【单选题】</p><p> ○ 质量问题</p><p> ○ 卫生问题</p><p> ○ 心理作用</p><p> ○ 购买机会</p><p>7、您对二手物品交易网网站上的哪些物品比较感兴趣？（多项） 【多选题】</p><p> □ 专业书籍</p><p> □ 娱乐书籍或杂志</p><p> □ 服装</p><p> □ 饰物、精品类</p><p> □ 文体用品</p><p> □ 电器类</p><p> □ 鞋类</p><p> □ 电子产品</p><p>8、如果建立一个专门的校园二手物品交易网上交易平台，您的态度是？ 【单选题】</p><p> ○ 非常欢迎，能在交易平台上交易</p><p> ○ 持续关注，会推荐给同学</p><p> ○ 偶尔关注</p><p> ○ 持怀疑观望态度</p><p> ○ 不看好网站的发展</p><p>9、对于本校二手网站你最希望淘到什么二手物品？（多项） 【多选题】</p><p> □ 二手教科书</p><p> □ 二手期末复习资料</p><p> □ 二手电脑MP3等数码物品</p><p> □ 二手运动器械</p><p> □ 其它二手物品</p><p>10、如本校二手平台向您收购商品，您一般有哪些物品愿意出售？（多项） 【多选题】</p><p> □ 专业书籍</p><p> □ 娱乐书籍或杂志</p><p> □ 服装</p><p> □ 饰物、精品类</p><p> □ 文体用品</p><p> □ 电器类</p><p> □ 鞋类</p><p> □ 电子产品</p><p>11、您购买二手物品希望卖家能提供哪些信息？（多项） 【多选题】</p><p> □ 购买时间</p><p> □ 生产时间</p><p> □ 物品使用情况</p><p> □ 保修期是否已过</p><p>12、您认为二手物品交易平台应提供哪些服务？ （多项） 【多选题】</p><p> □ 提供物流服务</p><p> □ 提供有信用的第三方支付体系服务</p><p> □ 提供退货等售后服务</p><p> □ 提供货到付款服务</p><p> □ 提供手递手的送货</p><p> □ 质量评价体系</p><p>13、对即将出现的本校校园二手物品交易网站，有什么好的建议？ 【填空题】</p><hr>]]></content>
      
      
      <categories>
          
          <category> 软件系统构思综合训练 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欢迎来到舜桀BB的秘密基地！</title>
      <link href="/FRank675.github.io/posts/2fa1216955e2/"/>
      <url>/FRank675.github.io/posts/2fa1216955e2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>欢迎来到<strong>舜桀BB</strong>的秘密基地呀！<br>在这里你会看到我的日常分享，你也可以通过留言功能与我交流。<br>希望你我都能在这个复杂的世界找到一份专属于自己的喜乐！</p><img src="https://s3.bmp.ovh/imgs/2022/05/16/e5404ce657de463a.png" />]]></content>
      
      
      <categories>
          
          <category> 博客相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 欢迎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DeepAI经典框架总结</title>
      <link href="/FRank675.github.io/posts/8e74962e7eee/"/>
      <url>/FRank675.github.io/posts/8e74962e7eee/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><table><thead><tr><th>框架名称</th><th>应用场景</th><th>策略</th><th>代码</th></tr></thead><tbody><tr><td>CEAL</td><td>深度图像分类问题</td><td>CEAL是第一个结合AL与DL解决深度图像分类问题的工作之一。CEAL将深度卷积神经网络合并到AL中，提出了一个新颖的DAL框架。它通过将来自未标注数据集中的样本逐步送入CNN，由CNN分类器输出两种类别的样本：少量不确定性的样本和大量高预测置信度样本。通过orcal为少量不确定性样本进行标注，同时使用CNN分类器为大量的高预测置信度样本自动分配伪标签。然后，使用这两种类型的样本对CNN进行微调，并重复这个更新过程。在Fig2中，我们展示了CEAL的总体框架图。类似的，HDAL也采用了类似的框架用于人脸识别任务中，它将AL与深度CNN模型进行结合从而一体化的同时考虑特征学习和AL查询模型的训练。</td><td></td></tr><tr><td>HDAL</td><td>人脸识别任务</td><td>将AL与深度CNN模型进行结合从而一体化的同时考虑特征学习和AL查询模型的训练</td><td></td></tr><tr><td>【243】</td><td>医学图像分割问题</td><td>提出使用全卷积网络和AL进行结合的框架来解决使用少量标注进行医学图像分割的问题。它首先将FCN在少量的标注数据集上进行训练，然后将未标注数据集中的样本通过FCN进行特征提取，并使用这些特征来对未标注样本进行不确定性和相似度估计。这种类似于2.1.2中的策略有助于选择具有高度不确定性和多样化的样本被添加到标注数据集中，从而开始下一阶段的训练。</td><td></td></tr><tr><td>【56】</td><td>掌纹识别任务</td><td>受到域适应的启发，将AL视为一个二分类任务，期待标注样本集与未标注样本集拥有相同的数据分布并使得二者难以区分，这样就可以直接在少量的标注数据集上进行监督训练了，从而减轻标注负担。</td><td></td></tr><tr><td>MetaQNN【140】</td><td>缺陷检测</td><td>基于检测模型的输出特征执行不确定性抽样，以生成用于注释的候选样本列表；设计了一种平均裕度方法来控制每个缺陷类别的抽样比</td><td></td></tr><tr><td>LLAL[245]</td><td>图像分类、目标检测和人体姿态估计</td><td>设计了一个损耗预测模块的小型参数模块附加到目标网络，使用目标网络的多个隐藏层的输出作为损耗预测模块的输入。通过学习损耗预测模块来预测未标记数据集的目标损耗，并以top-k的策略选择查询样本。LLAL以较小的参数代价实现了与任务无关的AL框架设计，并在多种主流的视觉任务（即，图像分类、目标检测和人体姿态估计）上都取得了有竞争力的性能表现。</td><td></td></tr><tr><td>[17]</td><td>手指骨分割任务</td><td>将Deeply Supervised U-Net作为分割网络，然后将多级分割隐藏层的输出以及最后一层的输出作为AL的输入，综合这些输入信息作为样本信息量大小的评估依据。</td><td></td></tr><tr><td>AL-MV[16]</td><td></td><td>将来自CNN中间不同隐藏层的特征视为多视图数据，同时考虑两个阶段的不确定性，并设计了AL-MV算法来实现对各层的不确定性进行自适应加权，从而更加准确的测量样本的不确定性。</td><td></td></tr><tr><td>[100]</td><td>视频任务</td><td>提出使用模仿学习来执行导航任务。教师从第一人称角度看待的视觉环境和所采取的行动被用作训练集。通过培训，希望学生们能够在自己的环境中预测和执行相应的行动。学生在执行任务时，使用深度cnn进行特征提取，学习模仿策略，并进一步使用AL方法选择置信度不足的样本，并将其添加到训练集中，更新动作策略。</td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 人工智能算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NASA MDP 软件缺陷数据集</title>
      <link href="/FRank675.github.io/posts/7818ebd11df5/"/>
      <url>/FRank675.github.io/posts/7818ebd11df5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>软件缺陷预测研究中心广泛应用的由美国航空航天局（NASA）公布的NASA IV＆V Facility Metrics Data Program(MDP)数据集，MDP 是一个开放的数据仓库，数据集的开放性方便了不同的研究者进行实验的重复、改进甚至反驳。 MDP包括 13个不同的数据集，这些数据均来自NASA 的13个实际软件项目，由最常见的开发语言编写。每个数据集包含来自不同软件项目的若干模块，规模从 125个模块到 17186 个模块不等。各个数据集由LOC、McCabe、Halstead等几类度量元属性和是否包含缺陷的类别标记（defective）组成。MDP数据集所提供的记录，一行代表一个模块，每个字段对应一个属性。 </p><p>资源链接: https:&#x2F;&#x2F;<a href="https://so.csdn.net/so/search?q=github&spm=1001.2101.3001.7020">github</a>.com&#x2F;klainfo&#x2F;NASADefectDataset&#x2F; <a href="https://github.com/klainfo/NASADefectDataset/">点此跳转</a></p><p>NASA MDP 软件缺陷数据集统计规模如下表：</p><p> <img src="https://img-blog.csdnimg.cn/20190709073518136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pxenExOTk1MDcyNQ==,size_16,color_FFFFFF,t_70" alt="img"> </p><p>MDP包括13个来自NASA的实际项目。在每一个数据集的开头，会标注项目名称，然后是度量元解释，之后就是数据。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@relation</span> <span class="string">&#x27;CM1&#x27;</span> <span class="comment">// 项目名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下为度量元</span></span><br><span class="line"><span class="meta">@attribute</span> LOC_BLANK numeric <span class="comment">// 空白行数量</span></span><br><span class="line"><span class="meta">@attribute</span> BRANCH_COUNT numeric <span class="comment">// 分支数量</span></span><br><span class="line"><span class="meta">@attribute</span> CALL_PAIRS numeric <span class="comment">// 调用对数</span></span><br><span class="line"><span class="meta">@attribute</span> LOC_CODE_AND_COMMENT numeric <span class="comment">// 代码和注释行数</span></span><br><span class="line"><span class="meta">@attribute</span> LOC_COMMENTS numeric <span class="comment">// 注释行数</span></span><br><span class="line"><span class="meta">@attribute</span> CONDITION_COUNT numeric <span class="comment">// 条件语句计数</span></span><br><span class="line"><span class="meta">@attribute</span> CYCLOMATIC_COMPLEXITY numeric <span class="comment">// 圈复杂度</span></span><br><span class="line"><span class="meta">@attribute</span> CYCLOMATIC_DENSITY numeric <span class="comment">// 圈密度</span></span><br><span class="line"><span class="meta">@attribute</span> DECISION_COUNT numeric <span class="comment">// 决策数量</span></span><br><span class="line"><span class="meta">@attribute</span> DECISION_DENSITY numeric <span class="comment">// 决策复杂度</span></span><br><span class="line"><span class="meta">@attribute</span> DESIGN_COMPLEXITY numeric <span class="comment">// 设计复杂度</span></span><br><span class="line"><span class="meta">@attribute</span> DESIGN_DENSITY numeric <span class="comment">// 设计密度</span></span><br><span class="line"><span class="meta">@attribute</span> EDGE_COUNT numeric <span class="comment">// 边界统计</span></span><br><span class="line"><span class="meta">@attribute</span> ESSENTIAL_COMPLEXITY numeric <span class="comment">// 本质复杂度</span></span><br><span class="line"><span class="meta">@attribute</span> ESSENTIAL_DENSITY numeric <span class="comment">// 本质密度</span></span><br><span class="line"><span class="meta">@attribute</span> LOC_EXECUTABLE numeric <span class="comment">// 可执行行数</span></span><br><span class="line"><span class="meta">@attribute</span> PARAMETER_COUNT numeric <span class="comment">// 参数计数</span></span><br><span class="line"><span class="meta">@attribute</span> GLOBAL_DATA_COMPLEXITY numeric <span class="comment">// 全局数据复杂度</span></span><br><span class="line"><span class="meta">@attribute</span> GLOBAL_DATA_DENSITY numeric <span class="comment">// 全局数据密度</span></span><br><span class="line"><span class="meta">@attribute</span> HALSTEAD_CONTENT numeric <span class="comment">// Halstead 内容</span></span><br><span class="line"><span class="meta">@attribute</span> HALSTEAD_DIFFICULTY numeric <span class="comment">// Halstead 复杂度</span></span><br><span class="line"><span class="meta">@attribute</span> HALSTEAD_EFFORT numeric <span class="comment">// Halstead 编程效率</span></span><br><span class="line"><span class="meta">@attribute</span> HALSTEAD_ERROR_EST numeric <span class="comment">// Halstead 错误预测</span></span><br><span class="line"><span class="meta">@attribute</span> HALSTEAD_LENGTH numeric <span class="comment">// Halstead 程序长度</span></span><br><span class="line"><span class="meta">@attribute</span> HALSTEAD_LEVEL numeric <span class="comment">// Halstead 程序语言等级</span></span><br><span class="line"><span class="meta">@attribute</span> HALSTEAD_PROG_TIME numeric <span class="comment">// Halstead 编写程序的时间</span></span><br><span class="line"><span class="meta">@attribute</span> HALSTEAD_VOLUME numeric <span class="comment">// Halstead 程序容量</span></span><br><span class="line"><span class="meta">@attribute</span> MAINTENANCE_SEVERITY numeric <span class="comment">// 维护严重性</span></span><br><span class="line"><span class="meta">@attribute</span> MODIFIED_CONDITION_COUNT numeric <span class="comment">// 修改条件语句数</span></span><br><span class="line"><span class="meta">@attribute</span> MULTIPLE_CONDITION_COUNT numeric <span class="comment">// 多条件语句数</span></span><br><span class="line"><span class="meta">@attribute</span> NODE_COUNT numeric <span class="comment">// 节点计数</span></span><br><span class="line"><span class="meta">@attribute</span> NORMALIZED_CYLOMATIC_COMPLEXITY numeric <span class="comment">// 规范圈复杂度</span></span><br><span class="line"><span class="meta">@attribute</span> NUM_OPERANDS numeric <span class="comment">// 操作数数量</span></span><br><span class="line"><span class="meta">@attribute</span> NUM_OPERATORS numeric <span class="comment">// 操作符数量</span></span><br><span class="line"><span class="meta">@attribute</span> NUM_UNIQUE_OPERANDS numeric <span class="comment">// 特殊操作数数量</span></span><br><span class="line"><span class="meta">@attribute</span> NUM_UNIQUE_OPERATORS numeric <span class="comment">// 特殊操作符数量</span></span><br><span class="line"><span class="meta">@attribute</span> NUMBER_OF_LINES numeric <span class="comment">// 行数量</span></span><br><span class="line"><span class="meta">@attribute</span> PATHOLOGICAL_COMPLEXITY numeric <span class="comment">// 病理复杂度</span></span><br><span class="line"><span class="meta">@attribute</span> PERCENT_COMMENTS numeric <span class="comment">// 注释比例</span></span><br><span class="line"><span class="meta">@attribute</span> LOC_TOTAL numeric <span class="comment">// 总行数</span></span><br><span class="line"><span class="meta">@attribute</span> Defective &#123;Y,N&#125; <span class="comment">// 是否存在缺陷</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@data</span> <span class="comment">//以下为数据，每行数据代表一个模块</span></span><br><span class="line"><span class="number">6</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">16</span>,<span class="number">5</span>,<span class="number">0.2</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0.6</span>,<span class="number">17</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">24</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">32.54</span>,<span class="number">9.5</span>,<span class="number">2936.77</span>,<span class="number">0.1</span>,<span class="number">63</span>,<span class="number">0.11</span>,<span class="number">163.15</span>,<span class="number">309.13</span>,<span class="number">0.2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">0.16</span>,<span class="number">19</span>,<span class="number">44</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="number">32</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">25</span>,N</span><br><span class="line"><span class="comment">// 数据用逗号隔开，与之前定义的元组相对应，N代表存在缺陷</span></span><br><span class="line"><span class="number">15</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">19</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">0.13</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">0.5</span>,<span class="number">17</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">31</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">38.55</span>,<span class="number">21.52</span>,<span class="number">17846.19</span>,<span class="number">0.28</span>,<span class="number">141</span>,<span class="number">0.05</span>,<span class="number">991.46</span>,<span class="number">829.45</span>,<span class="number">0.25</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">0.06</span>,<span class="number">51</span>,<span class="number">90</span>,<span class="number">32</span>,<span class="number">27</span>,<span class="number">67</span>,<span class="number">1</span>,<span class="number">39.22</span>,<span class="number">32</span>,Y</span><br><span class="line"><span class="comment">// Y代表不存在问题</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 新生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> learning </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
