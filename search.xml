<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LangChain中的Runnable接口</title>
      <link href="/FRank675.github.io/posts/10a291913132/"/>
      <url>/FRank675.github.io/posts/10a291913132/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\FRank675.github.io\css\APlayer.min.css"><script src="\FRank675.github.io\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\FRank675.github.io\js\Meting.min.js"></script><p><code>Runnable</code> 接口是使用 <code>LangChain</code> 组件的基础，它在很多组件中实现，例如语言模型（<code>language models</code>）、输出解析器（<code>output parsers</code>）、检索器（<code>retrievers</code>）、编译的 <code>LangGraph</code> 图，该接口允许开发人员以一致且可预测的方式与各种 <code>LangChain</code> 组件进行交互。</p><h1 id="Runnable-接口概述"><a href="#Runnable-接口概述" class="headerlink" title="Runnable 接口概述"></a>Runnable 接口概述</h1><p>Runnable 的方式定义了一个标准的接口，允许 Runnable 组件：</p><ul><li><code>Invoked</code>：将单个输入转换为输出。</li><li><code>Batched</code>：多个输入被有效地转换为输出。</li><li><code>Streamed</code>：输出在生成时进行流式传输。</li><li><code>Inspected</code>：可以访问有关 <code>Runnable</code> 的输入、输出和配置的示意图信息。</li><li><code>Composed</code>：可以组合多个 <code>Runnable</code>，使用 <code>LangChain</code> 表达语言（<code>LCEL</code>)协同工作，以创建复杂的管道。</li></ul><h2 id="优化的并行执行（batch）"><a href="#优化的并行执行（batch）" class="headerlink" title="优化的并行执行（batch）"></a>优化的并行执行（batch）</h2><p><code>LangChain Runnables</code> 提供内置<code>batch</code>（和<code>batch_as_completed</code>）API，允许您并行处理多个输入。</p><p>当需要处理多个独立输入时，使用这些方法可以显著提高性能，因为处理可以并行进行而不是顺序进行。</p><p>两个批处理选项是：</p><ul><li><code>batch</code>：并行处理多个输入，按与输入相同的顺序返回结果。</li><li><code>batch_as_completed</code>：并行处理多个输入，并在完成后返回结果。结果可能无序到达，但每个结果都包含用于匹配的输入索引。</li></ul><p><code>batch</code>和<code>batch_as_completed</code>的默认实现使用线程池执行器来并行运行该<code>invoke</code>方法。这允许高效的并行执行，无需用户管理线程，并加速 I&#x2F;O 密集型代码（例如发出 API 请求、读取文件等）。对于 CPU 密集型操作，它的效果不佳，因为 Python 中的 GIL（全局解释器锁）会阻止真正的并行执行。</p><p>一些 Runnable 可能会针对其特定用例进行优化，提供自己的<code>batch</code>和<code>batch_as_completed</code>实现（例如，依赖<code>batch</code>模型提供者提供的 API）。</p><blockquote><p><code>batch</code>和<code>batch_as_completed</code>的异步版本依赖于<code>asyncio</code>的<code>gather</code>和<code>as_completed</code>函数来并行允许<code>ainvoke</code>方法。</p></blockquote><blockquote><p>当使用<code>batch</code>和<code>batch_as_completed</code>处理大量的输入时，用户可能会想控制最大并行调用数。这可以通过设置<code>RunnableConfig</code>字典中的<code>max_concurrency</code>参数来实现。</p><p>聊天模型还具有内置速率限制器，可用于控制请求的速率。</p></blockquote><h2 id="异步支持（Asynchronous-support）"><a href="#异步支持（Asynchronous-support）" class="headerlink" title="异步支持（Asynchronous support）"></a>异步支持（Asynchronous support）</h2><p><code>Runnable</code>暴露了一个异步 API，允许通过使用<code>Python</code>中的<code>await</code>语法来调用它们。异步方法可以通过<code>a</code>前缀来识别（例如，<code>ainvoke</code>，<code>abatch</code>，<code>astream</code>，<code>abatch_as_completed</code>）。</p><h1 id="流式API（Streaming-APIs）"><a href="#流式API（Streaming-APIs）" class="headerlink" title="流式API（Streaming APIs）"></a>流式API（Streaming APIs）</h1><p>流式传输对于使基于 LLM 的应用程序对最终用户的响应至关重要。</p><p><code>Runnables</code>暴露了下面三个流式API：</p><ol><li><strong>同步流（sync stream）与异步流（async astream）</strong>：会在输出内容生成时，立即将输出作为<code>Runnable</code>进行<code>yield</code>操作。</li><li><strong>异步流事件（async astream_events）</strong>：一种更高级的流式处理 API，支持实时流式传输中间计算步骤和最终输出结果。</li><li><strong>旧版异步流日志（legacy async astream_log）</strong>：一种遗留的流式处理 API，用于流式传输中间计算步骤和最终输出结果。</li></ol><h1 id="输入和输出类型"><a href="#输入和输出类型" class="headerlink" title="输入和输出类型"></a>输入和输出类型</h1><p>每个<code>Runnable</code>对象都有一个输入和输出类型。这些输入和输出类型可以是任何 Python 对象，由 Runnable 本身定义。</p><p><code>Runnable</code>方法（如 <code>invoke</code>、<code>batch</code>、<code>stream</code>、<code>astream_events</code>）在执行 Runnable 时，支持以下输入输出类型：</p><ul><li><strong>invoke</strong>: 接受一个输入并返回一个输出。</li><li><strong>batch</strong>: 接受输入列表并返回输出列表。</li><li><strong>stream</strong>: 接受一个输入并返回一个生成器，该生成器会逐个产出输出结果。</li></ul><p>输入类型和输出类型因组件而异：</p><table><thead><tr><th>组件</th><th>输入类型</th><th>输出类型</th></tr></thead><tbody><tr><td><strong>Prompt</strong></td><td>dictionary</td><td>PromptValue</td></tr><tr><td><strong>ChatModel</strong></td><td>字符串、聊天消息列表或 PromptValue</td><td>ChatMessage</td></tr><tr><td><strong>LLM</strong></td><td>字符串、聊天消息列表或 PromptValue</td><td>String</td></tr><tr><td><strong>OutputParser</strong></td><td>LLM 或 ChatModel 的输出</td><td>取决于解析器实现</td></tr><tr><td><strong>Retriever</strong></td><td>字符串</td><td>文档列表 (List of Documents)</td></tr><tr><td><strong>Tool</strong></td><td>字符串或字典（取决于工具定义）</td><td>取决于工具实现</td></tr></tbody></table><h1 id="RunnableConfig"><a href="#RunnableConfig" class="headerlink" title="RunnableConfig"></a>RunnableConfig</h1><p>任何用于执行 Runnable 的方法（例如，<code>invoke</code>、<code>batch</code>、<code>stream</code>、<code>astream_events</code>）都接受第二个参数，称为 <code>RunnableConfig</code>。此参数是一个字典，其中包含 Runnable 的配置，这些配置将在 Runnable 执行期间使用。</p><p>RunnableConfig 可定义以下任意属性：</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>run_name</strong></td><td>当前调用Runnable的名称（不会被子调用继承）。</td></tr><tr><td><strong>run_id</strong></td><td>本次调用的唯一标识符。子调用会生成自己的唯一 ID。</td></tr><tr><td><strong>tags</strong></td><td>本次调用及其所有子调用的标签列表。</td></tr><tr><td><strong>metadata</strong></td><td>本次调用及其所有子调用的元数据。</td></tr><tr><td><strong>callbacks</strong></td><td>本次调用及其所有子调用的回调函数列表。</td></tr><tr><td><strong>max_concurrency</strong></td><td>最大并行调用数（如在批量处理中）。</td></tr><tr><td><strong>recursion_limit</strong></td><td>最大递归深度（如处理返回 Runnable 的 Runnable）。</td></tr><tr><td><strong>configurable</strong></td><td>Runnable 可配置属性的运行时取值。</td></tr></tbody></table><p>如果想传递<code>config</code>给<code>invoke</code>方法可以这么做：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">some_runnable.invoke(</span><br><span class="line">   some_input, </span><br><span class="line">   config=&#123;</span><br><span class="line">      <span class="string">&#x27;run_name&#x27;</span>: <span class="string">&#x27;my_run&#x27;</span>, </span><br><span class="line">      <span class="string">&#x27;tags&#x27;</span>: [<span class="string">&#x27;tag1&#x27;</span>, <span class="string">&#x27;tag2&#x27;</span>], </span><br><span class="line">      <span class="string">&#x27;metadata&#x27;</span>: &#123;<span class="string">&#x27;key&#x27;</span>: <span class="string">&#x27;value&#x27;</span>&#125;</span><br><span class="line">      </span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="RunnableConfig-的传播"><a href="#RunnableConfig-的传播" class="headerlink" title="RunnableConfig 的传播"></a>RunnableConfig 的传播</h2><p>很多的<code>Runnables</code>是由其他的Runnables组成，因此将<code>RunnableConfig</code>传播到<code>Runnables</code>的所有的子调用就显得很重要了。这允许向父级<code>Runnables</code>提供运行时配置值，这些值将被所有子调用继承。</p><p>如果不是这样的话，将无法设置和传播回调函数或其他配置值（如标签和元数据），而这些配置本应被所有子调用继承。</p><p>创建新的 Runnable 主要有两种模式：</p><ol><li><p>使用 LangChain 表达式语言（LCEL）进行声明式创建：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">chain = prompt | chat_model | output_parser</span><br></pre></td></tr></table></figure></li><li><p>使用自定义 Runnable（如 RunnableLambda）或使用 @tool 装饰器：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params"><span class="built_in">input</span></span>):</span><br><span class="line">    <span class="comment"># Note that .invoke() is used directly here</span></span><br><span class="line">    <span class="keyword">return</span> bar_runnable.invoke(<span class="built_in">input</span>)</span><br><span class="line">foo_runnable = RunnableLambda(foo)</span><br></pre></td></tr></table></figure></li></ol><p>LangChain 将尝试为这两种模型自动传播 RunnableConfig。</p><p>为处理第二种模式，LangChain 依赖于 Python 的 contextvars（上下文变量）。</p><p>在 Python 3.11 及以上版本中，此功能开箱即用，无需执行任何特殊操作即可将 RunnableConfig 传播至子调用。</p><p>在 Python 3.9 和 3.10 版本中，如果使用异步代码，则需要在调用 Runnable 时手动将 RunnableConfig 传递给它。</p><p>这是由于 Python 3.9 和 3.10 中 asyncio 任务的限制 —— 这些版本不接受上下文参数。</p><p>手动传播 RunnableConfig 的方式如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params"><span class="built_in">input</span>, config</span>): <span class="comment"># &lt;-- Note the config argument</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> bar_runnable.ainvoke(<span class="built_in">input</span>, config=config)</span><br><span class="line">    </span><br><span class="line">foo_runnable = RunnableLambda(foo)</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><p>在使用 Python 3.10 及更低版本并编写异步代码时，RunnableConfig 无法自动传播，需要手动进行传播！这是尝试使用<code>astream_events</code>和<code>astream_log</code>进行数据流式处理时的常见陷阱，因为这些方法依赖于 RunnableConfig 中定义的回调函数的正确传播。</p></blockquote><h2 id="设置自定义运行名称、标签和元数据"><a href="#设置自定义运行名称、标签和元数据" class="headerlink" title="设置自定义运行名称、标签和元数据"></a>设置自定义运行名称、标签和元数据</h2><p>RunnableConfig字典中的<code>run_name</code>、<code>tags</code>和<code>metadata</code>属性可用于为特定Runnable设置自定义的运行名称、标签和元数据值。   </p><ul><li><p><strong>run_name</strong>是一个字符串，用于设置运行的自定义名称。该名称将在日志等场景中用于标识运行，且不会被子调用继承。   </p></li><li><p><strong>tags</strong>和<strong>metadata</strong>属性分别为列表和字典类型，用于设置运行的自定义标签和元数据。这些值会被子调用继承。</p></li></ul><p>使用这些属性有助于跟踪和调试运行，因为它们会在LangSmith中作为跟踪属性显示，支持筛选和搜索。</p><p>此外，这些属性还会传播至回调函数，并在<code>astream_events</code>等流式API中作为流中每个事件的一部分出现。</p><h2 id="设置-run-id"><a href="#设置-run-id" class="headerlink" title="设置 run id"></a>设置 run id</h2><p>在需要后续引用某个运行或与其他系统关联时，可能需要为该运行设置自定义<code>run_id</code>。   </p><p><code>run_id</code>必须是有效的UUID字符串，且每次运行需唯一。它用于标识父级运行，子类会自动生成各自的唯一<code>run_id</code>。   </p><p>要设置自定义<code>run_id</code>，可在调用Runnable时在配置字典中以键值对形式传递：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"></span><br><span class="line">run_id = uuid.uuid4()</span><br><span class="line"></span><br><span class="line">some_runnable.invoke(</span><br><span class="line">   some_input, </span><br><span class="line">   config=&#123;</span><br><span class="line">      <span class="string">&#x27;run_id&#x27;</span>: run_id</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Do something with the run_id</span></span><br></pre></td></tr></table></figure><h2 id="设置递归限制"><a href="#设置递归限制" class="headerlink" title="设置递归限制"></a>设置递归限制</h2><p>某些 Runnable 可能会返回其他 Runnable，若处理不当可能导致无限递归。</p><p>为避免这种情况，可在 RunnableConfig 字典中设置<code>recursion_limit</code>，用于限制 Runnable 的递归次数。</p><h2 id="设置最大并发数"><a href="#设置最大并发数" class="headerlink" title="设置最大并发数"></a>设置最大并发数</h2><p>如果使用<code>batch</code>或<code>batch_as_completed</code>方法，可以在 RunnableConfig 字典中设置<code>max_concurrency</code>属性，以控制并行调用的最大数量。当需要限制并行调用次数以避免服务器或 API 过载时，此设置非常有用。</p><p>如果需要对聊天模型的请求进行速率限制，建议使用内置的速率限制器而非设置最大并发数，这会更有效。</p><h2 id="设置可配置参数"><a href="#设置可配置参数" class="headerlink" title="设置可配置参数"></a>设置可配置参数</h2><p><code>configurable</code>字段用于为 Runnable 的可配置属性传递运行时值。</p><p>该字段在结合 LangGraph 持久化和内存功能的 LangGraph 中频繁使用。</p><p>在<code>RunnableWithMessageHistory</code>中，其用途类似，用于指定会话 ID &#x2F; 对话 ID 以跟踪对话历史。</p><p>此外，您可通过该字段指定任何自定义配置选项，以传递给所创建的任何可配置 Runnable。</p><h2 id="设置回调函数"><a href="#设置回调函数" class="headerlink" title="设置回调函数"></a>设置回调函数</h2><p>使用此选项可在运行时为Runnable配置回调函数。这些回调函数将被传递给Runnable发起的所有子调用。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">some_runnable.invoke(</span><br><span class="line">   some_input,</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="string">&quot;callbacks&quot;</span>: [</span><br><span class="line">         SomeCallbackHandler(),</span><br><span class="line">         AnotherCallbackHandler(),</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="从函数创建可运行对象"><a href="#从函数创建可运行对象" class="headerlink" title="从函数创建可运行对象"></a>从函数创建可运行对象</h1><p>您可能需要创建一个运行任意逻辑的自定义 Runnable。当使用 LangChain 表达式语言（LCEL）组合多个 Runnable 且需要在某一步骤中添加自定义处理逻辑时，这一需求尤为常见。   </p><p>通过函数创建自定义 Runnable 有两种方式：   </p><ul><li><strong>RunnableLambda</strong>：适用于无需流式处理的简单转换场景。   </li><li><strong>RunnableGenerator</strong>：当需要流式处理时，用于更复杂的转换场景。</li></ul><h1 id="可配置的Runnable"><a href="#可配置的Runnable" class="headerlink" title="可配置的Runnable"></a>可配置的Runnable</h1><p>这是一项高级功能，大多数用户无需使用。</p><p>它有助于配置通过LangChain表达式语言（LCEL）创建的大型“链”，并被LangServe用于部署Runnable。</p><p>有时，您可能希望尝试甚至向最终用户开放Runnable的多种不同使用方式。这可能包括调整聊天模型中的温度等参数，甚至在不同聊天模型之间切换。   </p><p>为简化这一流程，Runnable接口提供了两种在运行时创建可配置Runnable的方法：   </p><ul><li><strong>configurable_fields</strong>：此方法允许您配置Runnable中的特定属性。例如，聊天模型的temperature属性。   </li><li><strong>configurable_alternatives</strong>：此方法使您能够指定可在运行时使用的备选Runnable。例如，您可以指定可使用的不同聊天模型列表。</li></ul><hr><blockquote><p><strong>参考内容：</strong></p><p><a href="https://python.langchain.com/docs/concepts/runnables/">https://python.langchain.com/docs/concepts/runnables/</a></p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LangChain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何让 LLM 的返回值流式输出？</title>
      <link href="/FRank675.github.io/posts/c7da7bbb1a7b/"/>
      <url>/FRank675.github.io/posts/c7da7bbb1a7b/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\FRank675.github.io\css\APlayer.min.css"><script src="\FRank675.github.io\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\FRank675.github.io\js\Meting.min.js"></script><h1 id="如何让-LLM-的返回值流式输出？"><a href="#如何让-LLM-的返回值流式输出？" class="headerlink" title="如何让 LLM 的返回值流式输出？"></a>如何让 LLM 的返回值流式输出？</h1><h2 id="流式输出"><a href="#流式输出" class="headerlink" title="流式输出"></a>流式输出</h2><p>大模型收到输入后并不是一次性生成最终结果，而是逐步地生成中间结果，最终结果由中间结果拼接而成。用流式输出的方式调用大模型 API，能够实时返回中间结果，减少用户的阅读等待时间，并降低请求的超时风险。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>流式输出，也称为流式传输，指的是服务器持续地将数据推送到客户端，而不是一次性发送完毕。这种模式下，连接一旦建立，服务器就能实时地发送更新给客户端。</p><p>相比非流式输出，流式输出可以实时地将中间结果返回，您可以在模型进行输出的同时进行阅读，减少等待模型回复的时间；并且当输出内容较长时，有效降低请求超时的风险。</p><blockquote><p>请求超时错误的报错信息：Request timed out, please try again later. 或 Response timeout。</p></blockquote><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>流式输出的典型应用场景包括实时消息推送、股票行情更新、实时通知等，任何需要服务器向客户端实时传输数据的场合都可以使用。</p><h4 id="与普通请求的区别"><a href="#与普通请求的区别" class="headerlink" title="与普通请求的区别"></a>与普通请求的区别</h4><p>与传统的 HTTP 请求不同，普通请求是基于请求-响应模型，客户端发送请求后，服务器处理完毕即刻响应并关闭连接。流式输出则保持连接开放，允许服务器连续发送多个响应。</p><h2 id="如何创建一个-SSE"><a href="#如何创建一个-SSE" class="headerlink" title="如何创建一个 SSE"></a>如何创建一个 SSE</h2><p>在 Python 中，可以使用 fastAPI 框架来实现 Server-Sent Event。以下是一个示例：</p><ol><li>安装 FastAPI 和 Uvicorn 首先，确保你已经安装了 FastAPI 和 Uvicorn ：</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install fastapi uvicorn</span><br></pre></td></tr></table></figure><ol start="2"><li>创建 FastAPI 应用 接下来，创建一个 FastAPI 应用，并定义一个流式接口。我们将使用异步生成器来逐步生成数据，并使用 StreamingResponse 来流式发送数据给客户端。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> sse_starlette.sse <span class="keyword">import</span> EventSourceResponse</span><br><span class="line"><span class="keyword">import</span> uvicorn</span><br><span class="line"><span class="keyword">from</span> fastapi.middleware.cors <span class="keyword">import</span> CORSMiddleware</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line">app.add_middleware(</span><br><span class="line">    CORSMiddleware,</span><br><span class="line">    allow_origins=[<span class="string">&#x27;*&#x27;</span>], <span class="comment"># 设置允许跨域的域名列表，* 代表所有域名</span></span><br><span class="line">    allow_credentials=<span class="literal">True</span>,</span><br><span class="line">    allow_methods=[<span class="string">&#x27;*&#x27;</span>],</span><br><span class="line">    allow_headers=[<span class="string">&#x27;*&#x27;</span>],</span><br><span class="line">)</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">event_generator</span>():</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        data = &#123;<span class="string">&quot;count&quot;</span>: count&#125;</span><br><span class="line">        <span class="keyword">yield</span> json.dumps(data)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/events&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get_events</span>():</span><br><span class="line">    <span class="keyword">return</span> EventSourceResponse(event_generator())</span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/events&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">post_events</span>():</span><br><span class="line">      <span class="keyword">return</span> EventSourceResponse(event_generator())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    uvicorn.run(app, host=<span class="string">&#x27;0.0.0.0&#x27;</span>, port=<span class="number">4000</span>)</span><br></pre></td></tr></table></figure><ol start="3"><li>运行应用 保存上述代码到一个文件（例如main.py），然后运行应用：</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python main.py</span><br></pre></td></tr></table></figure><ol start="4"><li>测试流式接口</li></ol><ul><li>get 接口</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">curl http://<span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">4000</span>/events</span><br></pre></td></tr></table></figure><ul><li>post 接口</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">curl -X POST <span class="string">&quot;http://0.0.0.0:4000/events&quot;</span> -H <span class="string">&quot;Content-Type: application/json&quot;</span></span><br></pre></td></tr></table></figure><p>预期输出如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data: &#123;&quot;count&quot;: 1&#125;</span><br><span class="line"></span><br><span class="line">data: &#123;&quot;count&quot;: 2&#125;</span><br><span class="line"></span><br><span class="line">data: &#123;&quot;count&quot;: 3&#125;</span><br><span class="line"></span><br><span class="line">data: &#123;&quot;count&quot;: 4&#125;</span><br><span class="line"></span><br><span class="line">data: &#123;&quot;count&quot;: 5&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>为什么大模型需要使用 SSE ？</p><p>从某种意义上说，现阶段 LLM 模型采用 SSE 是历史遗留原因。</p><p>Transformer 前后内容是需要推理拼接的，且不说内容很多的时候，推理的时间会很长（还有 Max Token 的限制）。推理上下文的时候也是逐步推理生成的，因此默认就是流式输出进行包裹。如果哪天 AI 的速度可以不受这些内容的限制了，可能一次性返回是一个更好的交互。</p><h2 id="解析流式接口请求"><a href="#解析流式接口请求" class="headerlink" title="解析流式接口请求"></a>解析流式接口请求</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">fetchSSE</span> = <span class="keyword">async</span> (<span class="params">options: FetchSSEOptions = &#123;&#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; success, fail, complete &#125; = options;</span><br><span class="line">  <span class="comment">// fetch请求流式接口url，需传入接口url和参数</span></span><br><span class="line">  <span class="keyword">const</span> responsePromise = <span class="title function_">fetch</span>().<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> msg = e.<span class="title function_">toString</span>() || <span class="string">&#x27;流式接口异常&#x27;</span>;</span><br><span class="line">    complete?.(<span class="literal">false</span>, msg);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(e); <span class="comment">// 确保错误能够被后续的.catch()捕获</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  responsePromise</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!response?.<span class="property">ok</span>) &#123;</span><br><span class="line">        complete?.(<span class="literal">false</span>, response.<span class="property">statusText</span>);</span><br><span class="line">        fail?.();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Request failed&#x27;</span>); <span class="comment">// 抛出错误以便链式调用中的下一个.catch()处理</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> reader = response.<span class="property">body</span>.<span class="title function_">getReader</span>();</span><br><span class="line">      <span class="keyword">const</span> decoder = <span class="keyword">new</span> <span class="title class_">TextDecoder</span>();</span><br><span class="line">      <span class="keyword">if</span> (!reader) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;No reader available&#x27;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> <span class="attr">bufferArr</span>: string[] = [];</span><br><span class="line">      <span class="keyword">let</span> dataText = <span class="string">&#x27;&#x27;</span>; <span class="comment">// 记录数据</span></span><br><span class="line">      <span class="keyword">const</span> <span class="attr">event</span>: <span class="title class_">SSEEvent</span> = &#123; <span class="attr">type</span>: <span class="literal">null</span>, <span class="attr">data</span>: <span class="literal">null</span> &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">processText</span>(<span class="params">&#123; done, value &#125;: ReadableStreamReadResult&lt;<span class="built_in">Uint8Array</span>&gt;</span>): <span class="title class_">Promise</span>&lt;<span class="keyword">void</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (done) &#123;</span><br><span class="line">          complete?.(<span class="literal">true</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> chunk = decoder.<span class="title function_">decode</span>(value);</span><br><span class="line">        <span class="keyword">const</span> buffers = chunk.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="regexp">/\r?\n/</span>);</span><br><span class="line">        bufferArr.<span class="title function_">push</span>(...buffers);</span><br><span class="line">        <span class="keyword">const</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; bufferArr.<span class="property">length</span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> line = bufferArr[i];</span><br><span class="line">          <span class="keyword">if</span> (line) &#123;</span><br><span class="line">            dataText += line;</span><br><span class="line">            <span class="keyword">const</span> response = line.<span class="title function_">slice</span>(<span class="number">6</span>);</span><br><span class="line">            <span class="keyword">if</span> (response === <span class="string">&#x27;[DONE]&#x27;</span>) &#123;</span><br><span class="line">              event.<span class="property">type</span> = <span class="string">&#x27;finish&#x27;</span>;</span><br><span class="line">              dataText = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">const</span> choices = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(response.<span class="title function_">trim</span>())?.<span class="property">choices</span>?.[<span class="number">0</span>];</span><br><span class="line">              <span class="keyword">if</span> (choices.<span class="property">finish_reason</span> === <span class="string">&#x27;stop&#x27;</span>) &#123;</span><br><span class="line">                event.<span class="property">type</span> = <span class="string">&#x27;finish&#x27;</span>;</span><br><span class="line">                dataText = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                event.<span class="property">type</span> = <span class="string">&#x27;delta&#x27;</span>;</span><br><span class="line">                event.<span class="property">data</span> = choices;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (event.<span class="property">type</span> &amp;&amp; event.<span class="property">data</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> jsonData = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(event));</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;流式数据解析结果:&#x27;</span>, jsonData);</span><br><span class="line">            <span class="comment">// 回调更新数据</span></span><br><span class="line">            <span class="title function_">success</span>(jsonData);</span><br><span class="line">            event.<span class="property">type</span> = <span class="literal">null</span>;</span><br><span class="line">            event.<span class="property">data</span> = <span class="literal">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          bufferArr.<span class="title function_">splice</span>(i, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reader.<span class="title function_">read</span>().<span class="title function_">then</span>(processText);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> reader.<span class="title function_">read</span>().<span class="title function_">then</span>(processText);</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 处理整个链式调用过程中发生的任何错误</span></span><br><span class="line">      fail?.();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="如何让通义千问模型流式输出结果"><a href="#如何让通义千问模型流式输出结果" class="headerlink" title="如何让通义千问模型流式输出结果"></a>如何让通义千问模型流式输出结果</h2><h3 id="OpenAI-兼容"><a href="#OpenAI-兼容" class="headerlink" title="OpenAI 兼容"></a>OpenAI 兼容</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> openai <span class="keyword">import</span> OpenAI</span><br><span class="line"></span><br><span class="line">client = OpenAI(</span><br><span class="line">    <span class="comment"># 若没有配置环境变量，请用阿里云百炼API Key将下行替换为：api_key=&quot;sk-xxx&quot;,</span></span><br><span class="line">    api_key=os.getenv(<span class="string">&quot;DASHSCOPE_API_KEY&quot;</span>),</span><br><span class="line">    base_url=<span class="string">&quot;https://dashscope.aliyuncs.com/compatible-mode/v1&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">completion = client.chat.completions.create(</span><br><span class="line">    model=<span class="string">&quot;qwen-plus&quot;</span>,  <span class="comment"># 此处以qwen-plus为例，您可按需更换模型名称。模型列表：https://help.aliyun.com/zh/model-studio/getting-started/models</span></span><br><span class="line">    messages=[</span><br><span class="line">        &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;system&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;You are a helpful assistant.&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;你是谁？&quot;</span>&#125;</span><br><span class="line">    ],</span><br><span class="line">    stream=<span class="literal">True</span>,</span><br><span class="line">    <span class="comment"># Qwen3模型通过enable_thinking参数控制思考过程（开源版默认True，商业版默认False）</span></span><br><span class="line">    <span class="comment"># 使用Qwen3开源版模型时，请将下行取消注释，否则会报错</span></span><br><span class="line">    <span class="comment"># extra_body=&#123;&quot;enable_thinking&quot;: False&#125;,</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">full_content = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;流式输出内容为：&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> chunk <span class="keyword">in</span> completion:</span><br><span class="line">    <span class="comment"># 如果stream_options.include_usage为True，则最后一个chunk的choices字段为空列表，需要跳过（可以通过chunk.usage获取 Token 使用量）</span></span><br><span class="line">    <span class="keyword">if</span> chunk.choices:</span><br><span class="line">        full_content += chunk.choices[<span class="number">0</span>].delta.content</span><br><span class="line">        <span class="built_in">print</span>(chunk.choices[<span class="number">0</span>].delta.content)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;完整内容为：<span class="subst">&#123;full_content&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="DashScope"><a href="#DashScope" class="headerlink" title="DashScope"></a>DashScope</h3><blockquote><p>流式输出的内容默认是非增量式（即每次返回的内容都包含之前生成的内容），如果您需要使用增量式流式输出，请设置<code>incremental_output</code>（Java 为<code>incrementalOutput</code>）参数为 <code>true</code> 。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> dashscope <span class="keyword">import</span> Generation</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">messages = [</span><br><span class="line">    &#123;<span class="string">&#x27;role&#x27;</span>:<span class="string">&#x27;system&#x27;</span>,<span class="string">&#x27;content&#x27;</span>:<span class="string">&#x27;you are a helpful assistant&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;role&#x27;</span>: <span class="string">&#x27;user&#x27;</span>,<span class="string">&#x27;content&#x27;</span>: <span class="string">&#x27;你是谁？&#x27;</span>&#125;]</span><br><span class="line">responses = Generation.call(</span><br><span class="line">    <span class="comment"># 若没有配置环境变量，请用阿里云百炼API Key将下行替换为：api_key=&quot;sk-xxx&quot;,</span></span><br><span class="line">    api_key=os.getenv(<span class="string">&quot;DASHSCOPE_API_KEY&quot;</span>),</span><br><span class="line">    model=<span class="string">&quot;qwen-plus&quot;</span>, <span class="comment"># 此处以qwen-plus为例，您可按需更换模型名称。模型列表：https://help.aliyun.com/zh/model-studio/getting-started/models</span></span><br><span class="line">    messages=messages,</span><br><span class="line">    result_format=<span class="string">&#x27;message&#x27;</span>,</span><br><span class="line">    stream=<span class="literal">True</span>,</span><br><span class="line">    <span class="comment"># 增量式流式输出</span></span><br><span class="line">    incremental_output=<span class="literal">True</span>,</span><br><span class="line">    <span class="comment"># Qwen3模型通过enable_thinking参数控制思考过程（开源版默认True，商业版默认False）</span></span><br><span class="line">    <span class="comment"># 使用Qwen3开源版模型时，若未启用流式输出，请将下行取消注释，否则会报错</span></span><br><span class="line">    <span class="comment"># enable_thinking=False</span></span><br><span class="line">    )</span><br><span class="line">full_content = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;流式输出内容为：&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> response <span class="keyword">in</span> responses:</span><br><span class="line">    full_content += response.output.choices[<span class="number">0</span>].message.content</span><br><span class="line">    <span class="built_in">print</span>(response.output.choices[<span class="number">0</span>].message.content)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;完整内容为：<span class="subst">&#123;full_content&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><hr><blockquote><p><strong>参考内容：</strong></p><ul><li><a href="https://tdesign.tencent.com/chat/sse">https://tdesign.tencent.com/chat/sse</a></li><li><a href="https://help.aliyun.com/zh/model-studio/stream#62e34380ae0kg">https://help.aliyun.com/zh/model-studio/stream#62e34380ae0kg</a></li></ul></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LLM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>协程 &amp; 异步编程(asyncio)</title>
      <link href="/FRank675.github.io/posts/795db927122f/"/>
      <url>/FRank675.github.io/posts/795db927122f/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\FRank675.github.io\css\APlayer.min.css"><script src="\FRank675.github.io\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\FRank675.github.io\js\Meting.min.js"></script><h1 id="协程-amp-异步编程-asyncio"><a href="#协程-amp-异步编程-asyncio" class="headerlink" title="协程 &amp; 异步编程(asyncio)"></a>协程 &amp; 异步编程(asyncio)</h1><p>协程（Coroutine），也可以被称为微线程，是一种用户态内的上下文切换技术。简而言之，其实就是通过一个线程实现代码块相互切换执行。例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">    ...</span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>():</span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span>)</span><br><span class="line">    ...</span><br><span class="line"><span class="built_in">print</span>(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">func1()</span><br><span class="line">func2()</span><br></pre></td></tr></table></figure><p>上述代码是普通的函数定义和执行，按流程分别执行两个函数中的代码，并先后会输出：<code>1、2、3、4</code>。但如果介入协程技术那么就可以实现函数见代码切换执行，最终输入：<code>1、3、2、4</code> 。</p><h2 id="1-协程的实现"><a href="#1-协程的实现" class="headerlink" title="1. 协程的实现"></a>1. 协程的实现</h2><p>在Python中有多种方式可以实现协程，例如：</p><ul><li>greenlet，是一个第三方模块，用于实现协程代码（Gevent协程就是基于greenlet实现）</li><li>yield，生成器，借助生成器的特点也可以实现协程代码。</li><li>asyncio，在Python3.4中引入的模块用于编写协程代码。</li><li>async &amp; awiat，在Python3.5中引入的两个关键字，结合asyncio模块可以更方便的编写协程代码。</li></ul><h3 id="1-1-greenlet"><a href="#1-1-greenlet" class="headerlink" title="1.1 greenlet"></a>1.1 greenlet</h3><p>greentlet是一个第三方模块，需要提前安装 <code>pip3 install greenlet</code>才能使用。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> greenlet <span class="keyword">import</span> greenlet</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>)        <span class="comment"># 第1步：输出 1</span></span><br><span class="line">    gr2.switch()    <span class="comment"># 第3步：切换到 func2 函数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">2</span>)        <span class="comment"># 第6步：输出 2</span></span><br><span class="line">    gr2.switch()    <span class="comment"># 第7步：切换到 func2 函数，从上一次执行的位置继续向后执行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">3</span>)        <span class="comment"># 第4步：输出 3</span></span><br><span class="line">    gr1.switch()    <span class="comment"># 第5步：切换到 func1 函数，从上一次执行的位置继续向后执行</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">4</span>)        <span class="comment"># 第8步：输出 4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gr1 = greenlet(func1)</span><br><span class="line">gr2 = greenlet(func2)</span><br><span class="line">gr1.switch() <span class="comment"># 第1步：去执行 func1 函数</span></span><br></pre></td></tr></table></figure><p>注意：switch中也可以传递参数用于在切换执行时相互传递值。</p><h3 id="1-2-yield"><a href="#1-2-yield" class="headerlink" title="1.2 yield"></a>1.2 yield</h3><p>基于Python的生成器的yield和yield form关键字实现协程代码。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> func2()</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>():</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f1 = func1()</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> f1:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure><p>注意：yield form关键字是在Python3.3中引入的。</p><h3 id="1-3-asyncio"><a href="#1-3-asyncio" class="headerlink" title="1.3 asyncio"></a>1.3 asyncio</h3><p>在Python3.4之前官方未提供协程的类库，一般大家都是使用greenlet等其他来实现。在Python3.4发布后官方正式支持协程，即：asyncio模块。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">2</span>)  <span class="comment"># 遇到IO耗时操作，自动化切换到tasks中的其他任务</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">2</span>) <span class="comment"># 遇到IO耗时操作，自动化切换到tasks中的其他任务</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tasks = [</span><br><span class="line">    asyncio.ensure_future( func1() ),</span><br><span class="line">    asyncio.ensure_future( func2() )</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br></pre></td></tr></table></figure><p>注意：基于asyncio模块实现的协程比之前的要更厉害，因为他的内部还集成了遇到IO耗时操作自动切花的功能。</p><h3 id="1-4-async-amp-awit"><a href="#1-4-async-amp-awit" class="headerlink" title="1.4 async &amp; awit"></a>1.4 async &amp; awit</h3><p>async &amp; awit 关键字在Python3.5版本中正式引入，基于他编写的协程代码其实就是 上一示例 的加强版，让代码可以更加简便。</p><p>Python3.8之后 <code>@asyncio.coroutine</code> 装饰器就会被移除，推荐使用async &amp; awit 关键字实现协程代码。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tasks = [</span><br><span class="line">    asyncio.ensure_future(func1()),</span><br><span class="line">    asyncio.ensure_future(func2())</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br></pre></td></tr></table></figure><h3 id="1-5-小结"><a href="#1-5-小结" class="headerlink" title="1.5 小结"></a>1.5 小结</h3><p>关于协程有多种实现方式，目前主流使用是Python官方推荐的asyncio模块和async&amp;await关键字的方式，例如：在tonado、sanic、fastapi、django3 中均已支持。</p><p>接下来，我们也会针对 <code>asyncio模块</code> + <code>async &amp; await</code> 关键字进行更加详细的讲解。</p><h2 id="2-协程的意义"><a href="#2-协程的意义" class="headerlink" title="2.协程的意义"></a>2.协程的意义</h2><p>通过学习，我们已经了解到协程可以通过一个线程在多个上下文中进行来回切换执行。</p><p><span><strong>但是</strong></span>，协程来回切换执行的意义何在呢？（网上看到很多文章舔协程，协程牛逼之处是哪里呢？）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">计算型的操作，利用协程来回切换执行，没有任何意义，来回切换并保存状态 反倒会降低性能。</span><br><span class="line">IO型的操作，利用协程在IO等待时间就去切换执行其他任务，当IO操作结束后再自动回调，那么就会大大节省资源并提供性能，从而实现异步编程（不等待任务结束就可以去执行其他代码）。</span><br></pre></td></tr></table></figure><h3 id="2-1-爬虫案例"><a href="#2-1-爬虫案例" class="headerlink" title="2.1 爬虫案例"></a>2.1 爬虫案例</h3><p>例如：用代码实现下载 <code>url_list</code> 中的图片。</p><ul><li><p>方式一：同步编程实现</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">下载图片使用第三方模块requests，请提前安装：pip3 install requests</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download_image</span>(<span class="params">url</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;开始下载:&quot;</span>,url)</span><br><span class="line">    <span class="comment"># 发送网络请求，下载图片</span></span><br><span class="line">    response = requests.get(url)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;下载完成&quot;</span>)</span><br><span class="line">    <span class="comment"># 图片保存到本地文件</span></span><br><span class="line">    file_name = url.rsplit(<span class="string">&#x27;_&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_name, mode=<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">        file_object.write(response.content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    url_list = [</span><br><span class="line">        <span class="string">&#x27;https://www3.autoimg.cn/newsdfs/g26/M02/35/A9/120x90_0_autohomecar__ChsEe12AXQ6AOOH_AAFocMs8nzU621.jpg&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;https://www2.autoimg.cn/newsdfs/g30/M01/3C/E2/120x90_0_autohomecar__ChcCSV2BBICAUntfAADjJFd6800429.jpg&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;https://www3.autoimg.cn/newsdfs/g26/M0B/3C/65/120x90_0_autohomecar__ChcCP12BFCmAIO83AAGq7vK0sGY193.jpg&#x27;</span></span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> url_list:</span><br><span class="line">        download_image(item)</span><br></pre></td></tr></table></figure></li><li><p>方式二：基于协程的异步编程实现</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">下载图片使用第三方模块aiohttp，请提前安装：pip3 install aiohttp</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">fetch</span>(<span class="params">session, url</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;发送请求：&quot;</span>, url)</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> session.get(url, verify_ssl=<span class="literal">False</span>) <span class="keyword">as</span> response:</span><br><span class="line">        content = <span class="keyword">await</span> response.content.read()</span><br><span class="line">        file_name = url.rsplit(<span class="string">&#x27;_&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(file_name, mode=<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">            file_object.write(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        url_list = [</span><br><span class="line">            <span class="string">&#x27;https://www3.autoimg.cn/newsdfs/g26/M02/35/A9/120x90_0_autohomecar__ChsEe12AXQ6AOOH_AAFocMs8nzU621.jpg&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;https://www2.autoimg.cn/newsdfs/g30/M01/3C/E2/120x90_0_autohomecar__ChcCSV2BBICAUntfAADjJFd6800429.jpg&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;https://www3.autoimg.cn/newsdfs/g26/M0B/3C/65/120x90_0_autohomecar__ChcCP12BFCmAIO83AAGq7vK0sGY193.jpg&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">        tasks = [asyncio.create_task(fetch(session, url)) <span class="keyword">for</span> url <span class="keyword">in</span> url_list]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> asyncio.wait(tasks)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    asyncio.run(main())</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>上述两种的执行对比之后会发现，<code>基于协程的异步编程</code> 要比 <code>同步编程</code>的效率高了很多。因为：</p><ul><li>同步编程，按照顺序逐一排队执行，如果图片下载时间为2分钟，那么全部执行完则需要6分钟。</li><li>异步编程，几乎同时发出了3个下载任务的请求（遇到IO请求自动切换去发送其他任务请求），如果图片下载时间为2分钟，那么全部执行完毕也大概需要2分钟左右就可以了。</li></ul><h3 id="2-2-小结"><a href="#2-2-小结" class="headerlink" title="2.2 小结"></a>2.2 小结</h3><p>协程一般应用在有IO操作的程序中，因为协程可以利用IO等待的时间去执行一些其他的代码，从而提升代码执行效率。</p><p>生活中不也是这样的么，假设 你是一家制造汽车的老板，员工点击设备的【开始】按钮之后，在设备前需等待30分钟，然后点击【结束】按钮，此时作为老板的你一定希望这个员工在等待的那30分钟的时间去做点其他的工作。</p><h2 id="3-异步编程"><a href="#3-异步编程" class="headerlink" title="3.异步编程"></a>3.异步编程</h2><p>基于<code>async</code> &amp; <code>await</code>关键字的协程可以实现异步编程，这也是目前python异步相关的主流技术。</p><p>想要真正的了解Python中内置的异步编程，根据下文的顺序一点点来看。</p><h3 id="3-1-事件循环"><a href="#3-1-事件循环" class="headerlink" title="3.1 事件循环"></a>3.1 事件循环</h3><p>事件循环，可以把他当做是一个while循环，这个while循环在周期性的运行并执行一些<code>任务</code>，在特定条件下终止循环。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 伪代码</span></span><br><span class="line"></span><br><span class="line">任务列表 = [ 任务<span class="number">1</span>, 任务<span class="number">2</span>, 任务<span class="number">3</span>,... ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    可执行的任务列表，已完成的任务列表 = 去任务列表中检查所有的任务，将<span class="string">&#x27;可执行&#x27;</span>和<span class="string">&#x27;已完成&#x27;</span>的任务返回</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> 就绪任务 <span class="keyword">in</span> 已准备就绪的任务列表:</span><br><span class="line">        执行已就绪的任务</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> 已完成的任务 <span class="keyword">in</span> 已完成的任务列表:</span><br><span class="line">        在任务列表中移除 已完成的任务 </span><br><span class="line"></span><br><span class="line">如果 任务列表 中的任务都已完成，则终止循环</span><br></pre></td></tr></table></figure><p>在编写程序时候可以通过如下代码来获取和创建事件循环。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去生成或获取一个事件循环</span></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将任务放到任务列表</span></span><br><span class="line">loop.run_until_complete(任务)</span><br></pre></td></tr></table></figure><h3 id="3-2-协程和异步编程"><a href="#3-2-协程和异步编程" class="headerlink" title="3.2 协程和异步编程"></a>3.2 协程和异步编程</h3><p>协程函数，定义形式为 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#async-def"><code>async def</code></a> 的函数。</p><p>协程对象，调用 <em>协程函数</em> 所返回的对象。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义一个协程函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用协程函数，返回一个协程对象</span></span><br><span class="line">result = func()</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：调用协程函数时，函数内部代码不会执行，只是会返回一个协程对象。</p><h4 id="3-2-1-基本应用"><a href="#3-2-1-基本应用" class="headerlink" title="3.2.1 基本应用"></a>3.2.1 基本应用</h4><p>程序中，如果想要执行协程函数的内部代码，需要 <code>事件循环</code> 和 <code>协程对象</code> 配合才能实现，如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;协程内部代码&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用协程函数，返回一个协程对象。</span></span><br><span class="line">result = func()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式一</span></span><br><span class="line"><span class="comment"># loop = asyncio.get_event_loop() # 创建一个事件循环</span></span><br><span class="line"><span class="comment"># loop.run_until_complete(result) # 将协程当做任务提交到事件循环的任务列表中，协程执行完成之后终止。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式二</span></span><br><span class="line"><span class="comment"># 本质上方式一是一样的，内部先 创建事件循环 然后执行 run_until_complete，一个简便的写法。</span></span><br><span class="line"><span class="comment"># asyncio.run 函数在 Python 3.7 中加入 asyncio 模块，</span></span><br><span class="line">asyncio.run(result)</span><br></pre></td></tr></table></figure><p>这个过程可以简单理解为：将<code>协程</code>当做任务添加到 <code>事件循环</code> 的任务列表，然后事件循环检测列表中的<code>协程</code>是否 已准备就绪（默认可理解为就绪状态），如果准备就绪则执行其内部代码。</p><h4 id="3-2-2-await"><a href="#3-2-2-await" class="headerlink" title="3.2.2 await"></a>3.2.2 await</h4><p>await是一个只能在协程函数中使用的关键字，用于遇到IO操作时挂起 当前协程（任务），当前协程（任务）挂起过程中 事件循环可以去执行其他的协程（任务），当前协程IO处理完成时，可以再次切换回来执行await之后的代码。代码如下：</p><p><strong>示例1：</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;执行协程函数内部代码&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遇到IO操作挂起当前协程（任务），等IO操作完成之后再继续往下执行。</span></span><br><span class="line">    <span class="comment"># 当前协程挂起时，事件循环可以去执行其他协程（任务）。</span></span><br><span class="line">    response = <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;IO请求结束，结果为：&quot;</span>, response)</span><br><span class="line"></span><br><span class="line">result = func()</span><br><span class="line"></span><br><span class="line">asyncio.run(result)</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">others</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;返回值&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;执行协程函数内部代码&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遇到IO操作挂起当前协程（任务），等IO操作完成之后再继续往下执行。当前协程挂起时，事件循环可以去执行其他协程（任务）。</span></span><br><span class="line">    response = <span class="keyword">await</span> others()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;IO请求结束，结果为：&quot;</span>, response)</span><br><span class="line">    </span><br><span class="line">asyncio.run( func() )</span><br></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">others</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;返回值&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;执行协程函数内部代码&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遇到IO操作挂起当前协程（任务），等IO操作完成之后再继续往下执行。当前协程挂起时，事件循环可以去执行其他协程（任务）。</span></span><br><span class="line">    response1 = <span class="keyword">await</span> others()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;IO请求结束，结果为：&quot;</span>, response1)</span><br><span class="line">    </span><br><span class="line">    response2 = <span class="keyword">await</span> others()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;IO请求结束，结果为：&quot;</span>, response2)</span><br><span class="line">    </span><br><span class="line">asyncio.run( func() )</span><br></pre></td></tr></table></figure><p>上述的所有示例都只是创建了一个任务，即：事件循环的任务列表中只有一个任务，所以在IO等待时无法演示切换到其他任务效果。</p><p>在程序想要创建多个任务对象，需要使用Task对象来实现。</p><h4 id="3-2-3-Task对象"><a href="#3-2-3-Task对象" class="headerlink" title="3.2.3 Task对象"></a>3.2.3 Task对象</h4><blockquote><p><em>Tasks</em> are used to schedule coroutines <em>concurrently</em>.</p><p>When a coroutine is wrapped into a <em>Task</em> with functions like <a href="https://docs.python.org/3.8/library/asyncio-task.html#asyncio.create_task"><code>asyncio.create_task()</code></a> the coroutine is automatically scheduled to run soon。</p></blockquote><p>Tasks用于并发调度协程，通过<code>asyncio.create_task(协程对象)</code>的方式创建Task对象，这样可以让协程加入事件循环中等待被调度执行。除了使用 <code>asyncio.create_task()</code> 函数以外，还可以用低层级的 <code>loop.create_task()</code> 或 <code>ensure_future()</code> 函数。不建议手动实例化 Task 对象。</p><p>本质上是将协程对象封装成task对象，并将协程立即加入事件循环，同时追踪协程的状态。</p><p>注意：<code>asyncio.create_task()</code> 函数在 Python 3.7 中被加入。在 Python 3.7 之前，可以改用低层级的 <code>asyncio.ensure_future()</code> 函数。</p><p><strong>示例1：</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;返回值&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;main开始&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建协程，将协程封装到一个Task对象中并立即添加到事件循环的任务列表中，等待事件循环去执行（默认是就绪状态）。</span></span><br><span class="line">    task1 = asyncio.create_task(func())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建协程，将协程封装到一个Task对象中并立即添加到事件循环的任务列表中，等待事件循环去执行（默认是就绪状态）。</span></span><br><span class="line">    task2 = asyncio.create_task(func())</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;main结束&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 当执行某协程遇到IO操作时，会自动化切换执行其他任务。</span></span><br><span class="line">    <span class="comment"># 此处的await是等待相对应的协程全都执行完毕并获取结果</span></span><br><span class="line">    ret1 = <span class="keyword">await</span> task1</span><br><span class="line">    ret2 = <span class="keyword">await</span> task2</span><br><span class="line">    <span class="built_in">print</span>(ret1, ret2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;返回值&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;main开始&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建协程，将协程封装到Task对象中并添加到事件循环的任务列表中，等待事件循环去执行（默认是就绪状态）。</span></span><br><span class="line">    <span class="comment"># 在调用</span></span><br><span class="line">    task_list = [</span><br><span class="line">        asyncio.create_task(func(), name=<span class="string">&quot;n1&quot;</span>),</span><br><span class="line">        asyncio.create_task(func(), name=<span class="string">&quot;n2&quot;</span>)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;main结束&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 当执行某协程遇到IO操作时，会自动化切换执行其他任务。</span></span><br><span class="line">    <span class="comment"># 此处的await是等待所有协程执行完毕，并将所有协程的返回值保存到done</span></span><br><span class="line">    <span class="comment"># 如果设置了timeout值，则意味着此处最多等待的秒，完成的协程返回值写入到done中，未完成则写到pending中。</span></span><br><span class="line">    done, pending = <span class="keyword">await</span> asyncio.wait(task_list, timeout=<span class="literal">None</span>)</span><br><span class="line">    <span class="built_in">print</span>(done, pending)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>注意：<code>asyncio.wait</code> 源码内部会对列表中的每个协程执行ensure_future从而封装为Task对象，所以在和wait配合使用时task_list的值为<code>[func(),func()]</code> 也是可以的。</p><p><strong>示例3：</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;执行协程函数内部代码&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遇到IO操作挂起当前协程（任务），等IO操作完成之后再继续往下执行。当前协程挂起时，事件循环可以去执行其他协程（任务）。</span></span><br><span class="line">    response = <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;IO请求结束，结果为：&quot;</span>, response)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">coroutine_list = [func(), func()]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误：coroutine_list = [ asyncio.create_task(func()), asyncio.create_task(func()) ]  </span></span><br><span class="line"><span class="comment"># 此处不能直接 asyncio.create_task，因为将Task立即加入到事件循环的任务列表，</span></span><br><span class="line"><span class="comment"># 但此时事件循环还未创建，所以会报错。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用asyncio.wait将列表封装为一个协程，并调用asyncio.run实现执行两个协程</span></span><br><span class="line"><span class="comment"># asyncio.wait内部会对列表中的每个协程执行ensure_future，封装为Task对象。</span></span><br><span class="line">done,pending = asyncio.run( asyncio.wait(coroutine_list) )</span><br></pre></td></tr></table></figure><h4 id="3-2-4-asyncio-Future对象"><a href="#3-2-4-asyncio-Future对象" class="headerlink" title="3.2.4 asyncio.Future对象"></a>3.2.4 asyncio.Future对象</h4><blockquote><p>A <code>Future</code>is a special <strong>low-level</strong> awaitable object that represents an <strong>eventual result</strong> of an asynchronous operation.</p></blockquote><p>asyncio中的Future对象是一个相对更偏向底层的可对象，通常我们不会直接用到这个对象，而是直接使用Task对象来完成任务的并和状态的追踪。（ Task 是 Futrue的子类 ）</p><p>Future为我们提供了异步编程中的 最终结果 的处理（Task类也具备状态处理的功能）。</p><p>示例1：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 获取当前事件循环</span></span><br><span class="line">    loop = asyncio.get_running_loop()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># # 创建一个任务（Future对象），这个任务什么都不干。</span></span><br><span class="line">    fut = loop.create_future()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待任务最终结果（Future对象），没有结果则会一直等下去。</span></span><br><span class="line">    <span class="keyword">await</span> fut</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">set_after</span>(<span class="params">fut</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    fut.set_result(<span class="string">&quot;666&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 获取当前事件循环</span></span><br><span class="line">    loop = asyncio.get_running_loop()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建一个任务（Future对象），没绑定任何行为，则这个任务永远不知道什么时候结束。</span></span><br><span class="line">    fut = loop.create_future()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建一个任务（Task对象），绑定了set_after函数，函数内部在2s之后，会给fut赋值。</span></span><br><span class="line">    <span class="comment"># 即手动设置future任务的最终结果，那么fut就可以结束了。</span></span><br><span class="line">    <span class="keyword">await</span> loop.create_task(set_after(fut))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待 Future对象获取 最终结果，否则一直等下去</span></span><br><span class="line">    data = <span class="keyword">await</span> fut</span><br><span class="line">    <span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>Future对象本身函数进行绑定，所以想要让事件循环获取Future的结果，则需要手动设置。而Task对象继承了Future对象，其实就对Future进行扩展，他可以实现在对应绑定的函数执行完成之后，自动执行<code>set_result</code>，从而实现自动结束。</p><p>虽然，平时使用的是Task对象，但对于结果的处理本质是基于Future对象来实现的。</p><p>扩展：支持 <code>await 对象</code>语 法的对象课成为可等待对象，所以 <code>协程对象</code>、<code>Task对象</code>、<code>Future对象</code> 都可以被成为可等待对象。</p><h4 id="3-2-5-futures-Future对象"><a href="#3-2-5-futures-Future对象" class="headerlink" title="3.2.5 futures.Future对象"></a>3.2.5 futures.Future对象</h4><p>在Python的<code>concurrent.futures</code>模块中也有一个Future对象，这个对象是基于线程池和进程池实现异步操作时使用的对象。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> Future</span><br><span class="line"><span class="keyword">from</span> concurrent.futures.thread <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">from</span> concurrent.futures.process <span class="keyword">import</span> ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">value</span>):</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pool = ThreadPoolExecutor(max_workers=<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 或 pool = ProcessPoolExecutor(max_workers=5)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    fut = pool.submit(func, i)</span><br><span class="line">    <span class="built_in">print</span>(fut)</span><br></pre></td></tr></table></figure><p>两个Future对象是不同的，他们是为不同的应用场景而设计，例如：<code>concurrent.futures.Future</code>不支持await语法 等。</p><p>官方提示两对象之间不同：</p><ul><li><p>unlike asyncio Futures, <a href="https://docs.python.org/3.8/library/concurrent.futures.html#concurrent.futures.Future"><code>concurrent.futures.Future</code></a> instances cannot be awaited.</p></li><li><p><a href="https://docs.python.org/3.8/library/asyncio-future.html#asyncio.Future.result"><code>asyncio.Future.result()</code></a> and <a href="https://docs.python.org/3.8/library/asyncio-future.html#asyncio.Future.exception"><code>asyncio.Future.exception()</code></a> do not accept the <em>timeout</em> argument.</p></li><li><p><a href="https://docs.python.org/3.8/library/asyncio-future.html#asyncio.Future.result"><code>asyncio.Future.result()</code></a> and <a href="https://docs.python.org/3.8/library/asyncio-future.html#asyncio.Future.exception"><code>asyncio.Future.exception()</code></a> raise an <a href="https://docs.python.org/3.8/library/asyncio-exceptions.html#asyncio.InvalidStateError"><code>InvalidStateError</code></a> exception when the Future is not <em>done</em>.</p></li><li><p>Callbacks registered with <a href="https://docs.python.org/3.8/library/asyncio-future.html#asyncio.Future.add_done_callback"><code>asyncio.Future.add_done_callback()</code></a> are not called immediately. They are scheduled with <a href="https://docs.python.org/3.8/library/asyncio-eventloop.html#asyncio.loop.call_soon"><code>loop.call_soon()</code></a> instead.</p></li><li><p>asyncio Future is not compatible with the <a href="https://docs.python.org/3.8/library/concurrent.futures.html#concurrent.futures.wait"><code>concurrent.futures.wait()</code></a> and <a href="https://docs.python.org/3.8/library/concurrent.futures.html#concurrent.futures.as_completed"><code>concurrent.futures.as_completed()</code></a> functions.</p></li></ul><p>在Python提供了一个将<code>futures.Future</code> 对象包装成<code>asyncio.Future</code>对象的函数 <code>asynic.wrap_future</code>。</p><p>接下里你肯定问：为什么python会提供这种功能？</p><p>其实，一般在程序开发中我们要么统一使用 asycio 的协程实现异步操作、要么都使用进程池和线程池实现异步操作。但如果 <code>协程的异步</code>和 <code>进程池/线程池的异步</code> 混搭时，那么就会用到此功能了。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">    <span class="comment"># 某个耗时操作</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;SB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    loop = asyncio.get_running_loop()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. Run in the default loop&#x27;s executor ( 默认ThreadPoolExecutor )</span></span><br><span class="line">    <span class="comment"># 第一步：内部会先调用 ThreadPoolExecutor 的 submit 方法去线程池中申请一个线程去执行func1函数，并返回一个concurrent.futures.Future对象</span></span><br><span class="line">    <span class="comment"># 第二步：调用asyncio.wrap_future将concurrent.futures.Future对象包装为asycio.Future对象。</span></span><br><span class="line">    <span class="comment"># 因为concurrent.futures.Future对象不支持await语法，所以需要包装为 asycio.Future对象 才能使用。</span></span><br><span class="line">    fut = loop.run_in_executor(<span class="literal">None</span>, func1)</span><br><span class="line">    result = <span class="keyword">await</span> fut</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;default thread pool&#x27;</span>, result)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. Run in a custom thread pool:</span></span><br><span class="line">    <span class="comment"># with concurrent.futures.ThreadPoolExecutor() as pool:</span></span><br><span class="line">    <span class="comment">#     result = await loop.run_in_executor(</span></span><br><span class="line">    <span class="comment">#         pool, func1)</span></span><br><span class="line">    <span class="comment">#     print(&#x27;custom thread pool&#x27;, result)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. Run in a custom process pool:</span></span><br><span class="line">    <span class="comment"># with concurrent.futures.ProcessPoolExecutor() as pool:</span></span><br><span class="line">    <span class="comment">#     result = await loop.run_in_executor(</span></span><br><span class="line">    <span class="comment">#         pool, func1)</span></span><br><span class="line">    <span class="comment">#     print(&#x27;custom process pool&#x27;, result)</span></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>应用场景：当项目以协程式的异步编程开发时，如果要使用一个第三方模块，而第三方模块不支持协程方式异步编程时，就需要用到这个功能，例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">download_image</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="comment"># 发送网络请求，下载图片（遇到网络下载图片的IO请求，自动化切换到其他任务）</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始下载:&quot;</span>, url)</span><br><span class="line"></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    <span class="comment"># requests模块默认不支持异步操作，所以就使用线程池来配合实现了。</span></span><br><span class="line">    future = loop.run_in_executor(<span class="literal">None</span>, requests.get, url)</span><br><span class="line"></span><br><span class="line">    response = <span class="keyword">await</span> future</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;下载完成&#x27;</span>)</span><br><span class="line">    <span class="comment"># 图片保存到本地文件</span></span><br><span class="line">    file_name = url.rsplit(<span class="string">&#x27;_&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_name, mode=<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">        file_object.write(response.content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    url_list = [</span><br><span class="line">        <span class="string">&#x27;https://www3.autoimg.cn/newsdfs/g26/M02/35/A9/120x90_0_autohomecar__ChsEe12AXQ6AOOH_AAFocMs8nzU621.jpg&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;https://www2.autoimg.cn/newsdfs/g30/M01/3C/E2/120x90_0_autohomecar__ChcCSV2BBICAUntfAADjJFd6800429.jpg&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;https://www3.autoimg.cn/newsdfs/g26/M0B/3C/65/120x90_0_autohomecar__ChcCP12BFCmAIO83AAGq7vK0sGY193.jpg&#x27;</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    tasks = [download_image(url) <span class="keyword">for</span> url <span class="keyword">in</span> url_list]</span><br><span class="line"></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    loop.run_until_complete( asyncio.wait(tasks) )</span><br></pre></td></tr></table></figure><h4 id="3-2-6-异步迭代器"><a href="#3-2-6-异步迭代器" class="headerlink" title="3.2.6 异步迭代器"></a>3.2.6 异步迭代器</h4><p><strong>什么是异步迭代器</strong></p><p>实现了 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__aiter__"><code>__aiter__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__anext__"><code>__anext__()</code></a> 方法的对象。<code>__anext__</code> 必须返回一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-awaitable">awaitable</a> 对象。<a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#async-for"><code>async for</code></a> 会处理异步迭代器的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__anext__"><code>__anext__()</code></a> 方法所返回的可等待对象，直到其引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#StopAsyncIteration"><code>StopAsyncIteration</code></a> 异常。由 <a href="https://www.python.org/dev/peps/pep-0492"><strong>PEP 492</strong></a> 引入。</p><p><strong>什么是异步可迭代对象？</strong></p><p>可在 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#async-for"><code>async for</code></a> 语句中被使用的对象。必须通过它的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__aiter__"><code>__aiter__()</code></a> 方法返回一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-asynchronous-iterator">asynchronous iterator</a>。由 <a href="https://www.python.org/dev/peps/pep-0492"><strong>PEP 492</strong></a> 引入。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Reader</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 自定义异步迭代器（同时也是异步可迭代对象） &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">readline</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># await asyncio.sleep(1)</span></span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.count == <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.count</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__aiter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">__anext__</span>(<span class="params">self</span>):</span><br><span class="line">        val = <span class="keyword">await</span> self.readline()</span><br><span class="line">        <span class="keyword">if</span> val == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopAsyncIteration</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="comment"># 创建异步可迭代对象</span></span><br><span class="line">    async_iter = Reader()</span><br><span class="line">    <span class="comment"># async for 必须要放在async def函数内，否则语法错误。</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">for</span> item <span class="keyword">in</span> async_iter:</span><br><span class="line">        <span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line">asyncio.run(func())</span><br></pre></td></tr></table></figure><p>异步迭代器其实没什么太大的作用，只是支持了async for语法而已。</p><h4 id="3-2-6-异步上下文管理器"><a href="#3-2-6-异步上下文管理器" class="headerlink" title="3.2.6 异步上下文管理器"></a>3.2.6 异步上下文管理器</h4><p>此种对象通过定义 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__aenter__"><code>__aenter__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__aexit__"><code>__aexit__()</code></a> 方法来对 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#async-with"><code>async with</code></a> 语句中的环境进行控制。由 <a href="https://www.python.org/dev/peps/pep-0492"><strong>PEP 492</strong></a> 引入。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AsyncContextManager</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.conn = conn</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">do_something</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 异步操作数据库</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">666</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">__aenter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 异步链接数据库</span></span><br><span class="line">        self.conn = <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">__aexit__</span>(<span class="params">self, exc_type, exc, tb</span>):</span><br><span class="line">        <span class="comment"># 异步关闭数据库链接</span></span><br><span class="line"><span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> AsyncContextManager() <span class="keyword">as</span> f:</span><br><span class="line">        result = <span class="keyword">await</span> f.do_something()</span><br><span class="line">        <span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(func())</span><br></pre></td></tr></table></figure><p>这个异步的上下文管理器还是比较有用的，平时在开发过程中 打开、处理、关闭 操作时，就可以用这种方式来处理。</p><h3 id="3-3-小结"><a href="#3-3-小结" class="headerlink" title="3.3 小结"></a>3.3 小结</h3><p>在程序中只要看到<code>async</code>和<code>await</code>关键字，其内部就是基于协程实现的异步编程，这种异步编程是通过一个线程在IO等待时间去执行其他任务，从而实现并发。</p><p>以上就是异步编程的常见操作，内容参考官方文档。</p><ul><li>中文版：<a href="https://docs.python.org/zh-cn/3.8/library/asyncio.html">https://docs.python.org/zh-cn/3.8/library/asyncio.html</a></li><li>英文本：<a href="https://docs.python.org/3.8/library/asyncio.html">https://docs.python.org/3.8/library/asyncio.html</a></li></ul><h2 id="4-uvloop"><a href="#4-uvloop" class="headerlink" title="4. uvloop"></a>4. uvloop</h2><p>Python标准库中提供了<code>asyncio</code>模块，用于支持基于协程的异步编程。</p><p>uvloop是 asyncio 中的事件循环的替代方案，替换后可以使得asyncio性能提高。事实上，uvloop要比nodejs、gevent等其他python异步框架至少要快2倍，性能可以比肩Go语言。</p><p>安装uvloop</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install uvloop</span><br></pre></td></tr></table></figure><p>在项目中想要使用uvloop替换asyncio的事件循环也非常简单，只要在代码中这么做就行。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> uvloop</span><br><span class="line">asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编写asyncio的代码，与之前写的代码一致。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 内部的事件循环自动化会变为uvloop</span></span><br><span class="line">asyncio.run(...)</span><br></pre></td></tr></table></figure><p>注意：知名的asgi uvicorn内部就是使用的uvloop的事件循环。</p><h2 id="5-实战案例"><a href="#5-实战案例" class="headerlink" title="5.实战案例"></a>5.实战案例</h2><p>为了更好理解，上述所有示例的IO情况都是以 <code>asyncio.sleep</code> 为例，而真实的项目开发中会用到很多IO的情况。</p><h3 id="5-1-异步Redis"><a href="#5-1-异步Redis" class="headerlink" title="5.1 异步Redis"></a>5.1 异步Redis</h3><p>当通过python去操作redis时，链接、设置值、获取值 这些都涉及网络IO请求，使用asycio异步的方式可以在IO等待时去做一些其他任务，从而提升性能。</p><p>安装Python异步操作redis模块</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install aioredis</span><br></pre></td></tr></table></figure><p>示例1：异步操作redis。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aioredis</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">address, password</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始执行&quot;</span>, address)</span><br><span class="line">    <span class="comment"># 网络IO操作：创建redis连接</span></span><br><span class="line">    redis = <span class="keyword">await</span> aioredis.create_redis(address, password=password)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 网络IO操作：在redis中设置哈希值car，内部在设三个键值对，即： redis = &#123; car:&#123;key1:1,key2:2,key3:3&#125;&#125;</span></span><br><span class="line">    <span class="keyword">await</span> redis.hmset_dict(<span class="string">&#x27;car&#x27;</span>, key1=<span class="number">1</span>, key2=<span class="number">2</span>, key3=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 网络IO操作：去redis中获取值</span></span><br><span class="line">    result = <span class="keyword">await</span> redis.hgetall(<span class="string">&#x27;car&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line">    redis.close()</span><br><span class="line">    <span class="comment"># 网络IO操作：关闭redis连接</span></span><br><span class="line">    <span class="keyword">await</span> redis.wait_closed()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;结束&quot;</span>, address)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(execute(<span class="string">&#x27;redis://47.93.4.198:6379&#x27;</span>, <span class="string">&quot;root!2345&quot;</span>))</span><br></pre></td></tr></table></figure><p>示例2：连接多个redis做操作（遇到IO会切换其他任务，提供了性能）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aioredis</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">address, password</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始执行&quot;</span>, address)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 网络IO操作：先去连接 47.93.4.197:6379，遇到IO则自动切换任务，去连接47.93.4.198:6379</span></span><br><span class="line">    redis = <span class="keyword">await</span> aioredis.create_redis_pool(address, password=password)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 网络IO操作：遇到IO会自动切换任务</span></span><br><span class="line">    <span class="keyword">await</span> redis.hmset_dict(<span class="string">&#x27;car&#x27;</span>, key1=<span class="number">1</span>, key2=<span class="number">2</span>, key3=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 网络IO操作：遇到IO会自动切换任务</span></span><br><span class="line">    result = <span class="keyword">await</span> redis.hgetall(<span class="string">&#x27;car&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line">    redis.close()</span><br><span class="line">    <span class="comment"># 网络IO操作：遇到IO会自动切换任务</span></span><br><span class="line">    <span class="keyword">await</span> redis.wait_closed()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;结束&quot;</span>, address)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">task_list = [</span><br><span class="line">    execute(<span class="string">&#x27;redis://47.93.4.197:6379&#x27;</span>, <span class="string">&quot;root!2345&quot;</span>),</span><br><span class="line">    execute(<span class="string">&#x27;redis://47.93.4.198:6379&#x27;</span>, <span class="string">&quot;root!2345&quot;</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">asyncio.run(asyncio.wait(task_list))</span><br></pre></td></tr></table></figure><p>更多redis操作参考aioredis官网：<a href="https://aioredis.readthedocs.io/en/v1.3.0/start.html">https://aioredis.readthedocs.io/en/v1.3.0/start.html</a></p><h3 id="5-2-异步MySQL"><a href="#5-2-异步MySQL" class="headerlink" title="5.2 异步MySQL"></a>5.2 异步MySQL</h3><p>当通过python去操作MySQL时，连接、执行SQL、关闭都涉及网络IO请求，使用asycio异步的方式可以在IO等待时去做一些其他任务，从而提升性能。</p><p>安装Python异步操作redis模块</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install aiomysql</span><br></pre></td></tr></table></figure><p>示例1：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiomysql</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">execute</span>():</span><br><span class="line">    <span class="comment"># 网络IO操作：连接MySQL</span></span><br><span class="line">    conn = <span class="keyword">await</span> aiomysql.connect(host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">3306</span>, user=<span class="string">&#x27;root&#x27;</span>, password=<span class="string">&#x27;123&#x27;</span>, db=<span class="string">&#x27;mysql&#x27;</span>, )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 网络IO操作：创建CURSOR</span></span><br><span class="line">    cur = <span class="keyword">await</span> conn.cursor()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 网络IO操作：执行SQL</span></span><br><span class="line">    <span class="keyword">await</span> cur.execute(<span class="string">&quot;SELECT Host,User FROM user&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 网络IO操作：获取SQL结果</span></span><br><span class="line">    result = <span class="keyword">await</span> cur.fetchall()</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 网络IO操作：关闭链接</span></span><br><span class="line">    <span class="keyword">await</span> cur.close()</span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(execute())</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiomysql</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">host, password</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始&quot;</span>, host)</span><br><span class="line">    <span class="comment"># 网络IO操作：先去连接 47.93.40.197，遇到IO则自动切换任务，去连接47.93.40.198:6379</span></span><br><span class="line">    conn = <span class="keyword">await</span> aiomysql.connect(host=host, port=<span class="number">3306</span>, user=<span class="string">&#x27;root&#x27;</span>, password=password, db=<span class="string">&#x27;mysql&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 网络IO操作：遇到IO会自动切换任务</span></span><br><span class="line">    cur = <span class="keyword">await</span> conn.cursor()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 网络IO操作：遇到IO会自动切换任务</span></span><br><span class="line">    <span class="keyword">await</span> cur.execute(<span class="string">&quot;SELECT Host,User FROM user&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 网络IO操作：遇到IO会自动切换任务</span></span><br><span class="line">    result = <span class="keyword">await</span> cur.fetchall()</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 网络IO操作：遇到IO会自动切换任务</span></span><br><span class="line">    <span class="keyword">await</span> cur.close()</span><br><span class="line">    conn.close()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;结束&quot;</span>, host)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">task_list = [</span><br><span class="line">    execute(<span class="string">&#x27;47.93.40.197&#x27;</span>, <span class="string">&quot;root!2345&quot;</span>),</span><br><span class="line">    execute(<span class="string">&#x27;47.93.40.197&#x27;</span>, <span class="string">&quot;root!2345&quot;</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">asyncio.run(asyncio.wait(task_list))</span><br></pre></td></tr></table></figure><h3 id="5-3-FastAPI框架"><a href="#5-3-FastAPI框架" class="headerlink" title="5.3 FastAPI框架"></a>5.3 FastAPI框架</h3><p>FastAPI是一款用于构建API的高性能web框架，框架基于Python3.6+的 <code>type hints</code>搭建。</p><p>接下里的异步示例以<code>FastAPI</code>和<code>uvicorn</code>来讲解（uvicorn是一个支持异步的asgi）。</p><p>安装FastAPI web 框架，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install fastapi</span><br></pre></td></tr></table></figure><p>安装uvicorn，本质上为web提供socket server的支持的asgi（一般支持异步称asgi、不支持异步称wsgi）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install uvicorn</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> uvicorn</span><br><span class="line"><span class="keyword">import</span> aioredis</span><br><span class="line"><span class="keyword">from</span> aioredis <span class="keyword">import</span> Redis</span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line">REDIS_POOL = aioredis.ConnectionsPool(<span class="string">&#x27;redis://47.193.14.198:6379&#x27;</span>, password=<span class="string">&quot;root123&quot;</span>, minsize=<span class="number">1</span>, maxsize=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 普通操作接口 &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello World&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/red&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">red</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 异步操作接口 &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;请求来了&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="comment"># 连接池获取一个连接</span></span><br><span class="line">    conn = <span class="keyword">await</span> REDIS_POOL.acquire()</span><br><span class="line">    redis = Redis(conn)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置值</span></span><br><span class="line">    <span class="keyword">await</span> redis.hmset_dict(<span class="string">&#x27;car&#x27;</span>, key1=<span class="number">1</span>, key2=<span class="number">2</span>, key3=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取值</span></span><br><span class="line">    result = <span class="keyword">await</span> redis.hgetall(<span class="string">&#x27;car&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 连接归还连接池</span></span><br><span class="line">    REDIS_POOL.release(conn)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    uvicorn.run(<span class="string">&quot;luffy:app&quot;</span>, host=<span class="string">&quot;127.0.0.1&quot;</span>, port=<span class="number">5000</span>, log_level=<span class="string">&quot;info&quot;</span>)</span><br></pre></td></tr></table></figure><p>在有多个用户并发请求的情况下，异步方式来编写的接口可以在IO等待过程中去处理其他的请求，提供性能。</p><p>例如：同时有两个用户并发来向接口 <code>http://127.0.0.1:5000/red</code> 发送请求，服务端只有一个线程，同一时刻只有一个请求被处理。  异步处理可以提供并发是因为：当视图函数在处理第一个请求时，第二个请求此时是等待被处理的状态，当第一个请求遇到IO等待时，会自动切换去接收并处理第二个请求，当遇到IO时自动化切换至其他请求，一旦有请求IO执行完毕，则会再次回到指定请求向下继续执行其功能代码。</p><h3 id="5-4-爬虫"><a href="#5-4-爬虫" class="headerlink" title="5.4 爬虫"></a>5.4 爬虫</h3><p>在编写爬虫应用时，需要通过网络IO去请求目标数据，这种情况适合使用异步编程来提升性能，接下来我们使用支持异步编程的aiohttp模块来实现。</p><p>安装aiohttp模块</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install aiohttp</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">fetch</span>(<span class="params">session, url</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;发送请求：&quot;</span>, url)</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> session.get(url, verify_ssl=<span class="literal">False</span>) <span class="keyword">as</span> response:</span><br><span class="line">        text = <span class="keyword">await</span> response.text()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;得到结果：&quot;</span>, url, <span class="built_in">len</span>(text))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        url_list = [</span><br><span class="line">            <span class="string">&#x27;https://python.org&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;https://www.baidu.com&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;https://www.pythonav.com&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">        tasks = [asyncio.create_task(fetch(session, url)) <span class="keyword">for</span> url <span class="keyword">in</span> url_list]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> asyncio.wait(tasks)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    asyncio.run(main())</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>为了提升性能越来越多的框架都在向异步编程靠拢，例如：sanic、tornado、django3.0、django channels组件 等，用更少资源可以做处理更多的事，何乐而不为呢。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>舜桀的算法笔记</title>
      <link href="/FRank675.github.io/posts/91e582f5bac5/"/>
      <url>/FRank675.github.io/posts/91e582f5bac5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>这里主要记录我学习算法的历程~</p><p>主要参考资料为<strong>labuladong的算法笔记</strong></p><p>下面开始学习算法吧！</p><h2 id="数据结构基础"><a href="#数据结构基础" class="headerlink" title="数据结构基础"></a>数据结构基础</h2><h3 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h3><h4 id="Java标准库数据结构的基本用法"><a href="#Java标准库数据结构的基本用法" class="headerlink" title="Java标准库数据结构的基本用法"></a>Java标准库数据结构的基本用法</h4><h5 id="1-数组"><a href="#1-数组" class="headerlink" title="1.数组"></a>1.数组</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">5</span>, n = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个大小为 10 的 int 数组</span></span><br><span class="line"><span class="comment">// 其中的值默认初始化为 0</span></span><br><span class="line"><span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 初始化一个 m * n 的二维布尔数组</span></span><br><span class="line"><span class="comment">// 其中的元素默认初始化为 false</span></span><br><span class="line"><span class="type">boolean</span>[][] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[m][n];</span><br></pre></td></tr></table></figure><h5 id="2-字符串String"><a href="#2-字符串String" class="headerlink" title="2.字符串String"></a>2.字符串String</h5><p>Java 字符串不支持用 [] 直接访问其中的字符，且不能直接修改，需要转化为 char[] 类型才能修改。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="comment">// 获取 s1[2] 的那个字符</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s1.charAt(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>[] chars = s1.toCharArray();</span><br><span class="line">chars[<span class="number">1</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line"><span class="comment">// 输出：hallo world</span></span><br><span class="line">System.out.println(s2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，一定要使用 equals 方法判断字符串是否相同</span></span><br><span class="line"><span class="keyword">if</span>(s1.equals(s2))&#123;</span><br><span class="line">    <span class="comment">// s1 和 s2 相同</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// s1 和 s2 不相同</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串可以用加号进行拼接</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s1 + <span class="string">&quot;!&quot;</span>;</span><br><span class="line"><span class="comment">// 输出：hello world!</span></span><br><span class="line">System.out.println(s3);</span><br></pre></td></tr></table></figure><p>Java 的字符串不能直接修改，要用 toCharArray 转化成 char[] 的数组进行修改，然后再转换成 String 类型。</p><p>另外，虽然字符串支持用 + 进行拼接，但是效率并不高，并不建议在for循环中使用。</p><p>如果要进行频繁的字符串拼接，推荐使用 StringBuilder&#x2F;StringBuffer：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>; c &lt;= <span class="string">&#x27;f&#x27;</span>; c++)&#123;</span><br><span class="line">    sb.append(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// append 方法支持拼接字符、字符串、数字等类型</span></span><br><span class="line">sb.append(<span class="string">&#x27;g&#x27;</span>).append(<span class="string">&quot;hij&quot;</span>).append0(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> sb.toString();</span><br><span class="line"><span class="comment">// 输出：abcdefghij123</span></span><br><span class="line">System.out.println(res);</span><br></pre></td></tr></table></figure><p>一定要用字符串的 equals 方法比较两个字符是否相同，不要用 &#x3D;&#x3D; 比较。</p><h5 id="3-动态数组-ArrayList"><a href="#3-动态数组-ArrayList" class="headerlink" title="3.动态数组 ArrayList"></a>3.动态数组 ArrayList</h5><p>ArrayList 相当于把Java内置的数组类型做了包装，初始化方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化一个存储 String 类型的动态数组</span></span><br><span class="line">ArrayList&lt;String&gt; strings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个存储 int 类型的动态数组</span></span><br><span class="line">ArrayList&lt;Integer&gt; nums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>常用方法如下：（ E 代表元素类型）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断数组是否为空</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回数组的元素个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回索引 index 的元素</span></span><br><span class="line">E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 在数组尾部添加元素 e</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span></span><br></pre></td></tr></table></figure><h5 id="4-双链表-LinkedList"><a href="#4-双链表-LinkedList" class="headerlink" title="4.双链表 LinkedList"></a>4.双链表 LinkedList</h5><p>ArrayList 列表底层是数组实现的，而 LinkedList 底层是双链表实现的，初始化方法也是类似的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化一个存储 int 类型的双链表</span></span><br><span class="line">LinkedList&lt;Integer&gt; nums = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个存储 String 类型的双链表</span></span><br><span class="line">LinkedList&lt;String&gt; strings = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>双链表常用方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断链表是否为空</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 返回链表的元素个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 判断链表中是否存在元素 o</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 在链表尾部添加元素 e</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 在链表尾部添加元素 e</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(E e)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 在链表头部添加元素 e</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 删除链表头部第一个元素</span></span><br><span class="line">E <span class="title function_">removeFirst</span><span class="params">()</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 删除链表尾部最后一个元素</span></span><br><span class="line">E <span class="title function_">removeLast</span><span class="params">()</span></span><br></pre></td></tr></table></figure><p>和 ArrayList 不同，在 LinkedList 中更多地使用了对于头部和尾部元素地操作，因为底层数据结构为链表，直接操作头尾地元素效率较高。</p><p>其中只有 contains 方法的时间复杂度是 O(n)， 因为必须遍历整个链表才能判断元素是否存在。</p><h5 id="5-哈希表-HashMap"><a href="#5-哈希表-HashMap" class="headerlink" title="5.哈希表 HashMap"></a>5.哈希表 HashMap</h5><p>哈希表是常用的数据结构，用于存储键值对映射，初始化方法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 整数映射到字符串的哈希表</span></span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串映射到数组的哈希表</span></span><br><span class="line">HashMap&lt;String, <span class="type">int</span>[]&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>常用方法如下：（ K 代表键的类型， V 代表值得类型）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断哈希表中是否存在键 Key</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 获得键 Key 对应得值，若 Key 不存在，则返回 null</span></span><br><span class="line">V <span class="title function_">get</span><span class="params">(Object key)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 将 key， value 键值对存入哈希表</span></span><br><span class="line">V <span class="title function_">put</span><span class="params">(K key, V value)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 key 存在，则删除 key 并返回对应的值</span></span><br><span class="line">V <span class="title function_">remove</span><span class="params">(Object key)</span></span><br></pre></td></tr></table></figure><h5 id="6-哈希集合-HashSet"><a href="#6-哈希集合-HashSet" class="headerlink" title="6.哈希集合 HashSet"></a>6.哈希集合 HashSet</h5><p>初始化方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新建一个存储 String 的哈希集合</span></span><br><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>可能使用的方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果 e 不存在，则添加 e 到哈希集合</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 判断元素 o 是否存在于哈希集合中</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">// 如果元素 o 存在，再删除元素 o</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span></span><br></pre></td></tr></table></figure><h4 id="Java类基本用法"><a href="#Java类基本用法" class="headerlink" title="Java类基本用法"></a>Java类基本用法</h4><h5 id="泛型编程"><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h5><p>泛型是 Java 提供的一种模板，能够将数据结构的实现和数据类型解耦。</p><p>比如在使用 LinkedList 双链表时，可以随意设置其中的元素类型。</p><p>不过需要注意，在泛型中只能使用类，不能使用原始类型。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 装整数的双链表</span></span><br><span class="line">LinkedList&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//报错，不能用 int 这种原始类型作为泛型</span></span><br><span class="line">LinkedList&lt;<span class="type">int</span>&gt; list2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 装字符串的双链表</span></span><br><span class="line">LinkedList&lt;String&gt; list3 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>在实现自己的数据结构类时，也需要使用泛型，以便实现的数据结构能够装任何类型。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLinkedList</span>&lt;E&gt;&#123;</span><br><span class="line">    <span class="comment">// 在链表尾部添加元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(E e)</span>&#123;</span><br><span class="line">        <span class="comment">// ..</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line">MyLinkedList&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">MyLinkedList</span>&lt;&gt;();</span><br><span class="line">MyLinkedList&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">MyLinkedList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>需要注意的是，某些特殊的数据结构对存储的数据类型有要求。</p><p>比如 TreeMap 这种数据结构，由于底层是用 BST （二叉搜索树）来存储键值对，所以 TreeMap 要求存入其中的键必须是可比较的，即对于任意两个键，必须能够知道它俩谁大谁小。</p><p>在 Java 中，可以给泛型变量添加 extends 来指定该泛型的某些特性。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MyTreeMap 接受两个泛型 K 和 V，其中 K 必须实现 Comparable 接口</span></span><br><span class="line"><span class="comment">// 即必须实现 compareTo 方法，这样才可以比较大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTreeMap</span>&lt;K <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;K&gt;, V&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, v val)</span>&#123;</span><br><span class="line">        <span class="comment">// ..</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方法：</span></span><br><span class="line">MyTreeMap&lt;Integer, Integer&gt; map1 = <span class="keyword">new</span> <span class="title class_">MyTreeMap</span>&lt;&gt;();</span><br><span class="line">MyTreeMap&lt;String, Integer&gt; map2 = <span class="keyword">new</span> <span class="title class_">MyTreeMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>Comparable 是 Java 标准库提供的一个接口，实现如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(T o)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以 K extends Comparable<K> 的意思是泛型 K 实现了这个接口，即类型 K 有compareTo这个方法，意味着这两个 K 类型的数据可以比较大小。</p><h5 id="Java接口"><a href="#Java接口" class="headerlink" title="Java接口"></a>Java接口</h5><p>有时候可能看到以下写法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue&lt;String&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>实际 new 出来对的是 LinkedList 类型，但为什么使用 Queue 类型和 List 类型接受呢？</p><p>因为 Queue 和 List 都是 Java 标准库中的接口类型：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Queue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Collection</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span>;</span><br><span class="line">    E <span class="title function_">poll</span><span class="params">()</span>;</span><br><span class="line">    E <span class="title function_">peek</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 还有若干方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Collection</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">// 若干方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所谓接口，就是一组方法的集合，只要一个类使用 implements 关键词申明自己实现了接口中的所有方法，那么就可以用这个接口的类型来接受这个类的实例化对象。</p><p>具体地，标准库提供的 LinkedList 类实现了List 接口中的所有方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Deque 是 Queue 的子接口，包含了 Queue 接口的所有方法，所以实现了 Deque 就等于实现了 Queue 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;&#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Queue 接口中声明的若干方法都会被实现</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span>&#123;...&#125;</span><br><span class="line">    E <span class="title function_">poll</span><span class="params">()</span>&#123;...&#125;</span><br><span class="line">    E <span class="title function_">peek</span><span class="params">()</span>&#123;...&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// List 接口的若干方法也会被实现</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以可以用 List 接口接受 LinkedList 类型，Queue 接口同理。</p><h3 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h3><h4 id="数组（顺序存储）基本原理"><a href="#数组（顺序存储）基本原理" class="headerlink" title="数组（顺序存储）基本原理"></a>数组（顺序存储）基本原理</h4><p>数组可以分为静态数组和动态数组。</p><p>静态数组就是一块连续的内存空间，可以通过索引来访问这块内存空间中的元素。</p><p>动态数组是编程语言为了方便用户使用，在静态数组的基础上增加了一些常用的API，例如 push ， insert ， remove 等方法，通过这些 API 可以更方便地操作数组元素，不需要自己去写代码完成这些操作。</p><p>基于动态数组，可以实现更复杂地数据结构如队列、栈、哈希表等。</p><h5 id="静态数组"><a href="#静态数组" class="headerlink" title="静态数组"></a>静态数组</h5><p>静态数组在创建时就确定数组的元素类型和元素数量。</p><p>只有 C++ 、Java 、 Golang 这类语言才提供了创建静态数组的方式，类似 Python 、 JavaScript 等并没有提供静态数组的定义方式。</p><p>定义一个静态数组的方法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个大小为 10 的静态数组</span></span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用索引赋值</span></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用索引取值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>以 C++ 为例， int arr[10] 这段代码主要完成以下功能：</p><ol><li>在内存中开辟出一段连续的内存空间，大小为 10 * sizeof(int) 字节。一个 int 在计算机内存中占 4 字节，也就是总共 40 字节。</li><li>定义一个名为 arr 的数组指针，指向这段内存空间的首地址。</li></ol><p>arr[1] &#x3D; 2 这段代码做了以下事情：</p><ol><li>计算 arr 的首地址加上 1 * sizeof(int) 字节（ 4 字节）的偏移量，找到内存空间中的第二个元素的地址。</li><li>从这个地址开始的 4 个字节的内存空间中写入整数 2 。</li></ol><p>静态数组本质上是一块连续的内存空间，可以随机访问，即：只要给定任何一个数组索引，我们可以在 O(1) 的时间内直接获取到对应元素的值。</p><h5 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h5><h6 id="增"><a href="#增" class="headerlink" title="增"></a>增</h6><p>给静态数组增加元素，分为以下情况：</p><p>情况一，数组末尾追加（append）元素</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 大小为 10 的数组已经装了 4 个元素</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">    arr[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在想在数组末尾追加一个元素 4</span></span><br><span class="line">arr[<span class="number">4</span>] = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再在数组末尾追加一个元素 5</span></span><br><span class="line">arr[<span class="number">5</span>] = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>可以看到，由于只是对索引赋值，所以在数组末尾追加元素的时间复杂度为 O(1)</p><p>情况二，数组中间插入（insert）元素</p><p>例如，有一个大小为 10 的数组 arr ，前四个索引装了元素，现在想在第 3 个位置（arr[2]）插入一个新元素。</p><p>这部分操作涉及数据搬移，给新元素腾出空位，然后才能插入新元素。基本代码逻辑如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 大小为 10 的数组已经装了 4 个元素</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">    arr[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在第 3 个位置插入元素 666</span></span><br><span class="line"><span class="comment">// 需要把第 3 个位置及之后的元素都往后移动一位</span></span><br><span class="line"><span class="comment">// 注意要倒着遍历数组中已有元素避免覆盖</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">4</span>; i &gt; <span class="number">2</span>; i--)&#123;</span><br><span class="line">    arr[i] = arr[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在第 3 个位置空出，可以插入新元素</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="number">666</span>;</span><br></pre></td></tr></table></figure><p>综上，在数组中间插入元素的时间复杂度为 O(N) ，因为涉及到数据搬移，需要给新元素腾出地方。</p><p>情况三，数组空间已满</p><p>由于静态数组在创建时就需要确定大小，所以会存在插入数据时数组空间已满的情况。</p><p>由于连续内存必须一次性分配，分配完了就不能随意增减，所以只能重新申请一块更大的内存空间，把原来的数据复制过去，再插入新的元素，也就是数组的扩容操作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 大小为 10 的数组已经装满</span></span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">    arr[i] = i;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在想在数组末尾追加一个元素 10</span></span><br><span class="line"><span class="comment">// 需要先扩容数组</span></span><br><span class="line"><span class="type">int</span>[] newArr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">20</span>];</span><br><span class="line"><span class="comment">// 把原来的 10 个元素复制过去</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">    newArr[i] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放旧数组的内存空间</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在新的数组中追加新元素</span></span><br><span class="line">newArr[<span class="number">10</span>] = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>综上，数组的扩容操作会涉及到数组的开辟和数据的复制，时间复杂度为 O(N) 。</p><h5 id="删"><a href="#删" class="headerlink" title="删"></a>删</h5><p>情况一，删除末尾元素</p><p>简单的方法，直接把末尾元素标记为一个特殊值代表已删除即可，例如使用 -1 作为特殊值代表已删除。</p><p>删除数组尾部元素本质就是进行一次随机访问，时间复杂度为 O(1) 。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 大小为 10 的数组已经装了 5 个元素</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">    arr[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除末尾元素，暂时用 -1 代表元素已删除</span></span><br><span class="line">arr[<span class="number">4</span>] = -<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>情况二，删除中间元素</p><p>删除中间元素涉及到数据搬移，把被删元素后面的元素都往前移动一位，保持数组元素的连续性。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 大小为 10 的数组已经装了 5 个元素</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">    arr[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除 arr[1]</span></span><br><span class="line"><span class="comment">// 需要把 arr[1] 之后的元素都往前移动一位</span></span><br><span class="line"><span class="comment">// 主要要正着遍历数组中已有的元素避免覆盖</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">    arr[i] = arr[i + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后一个元素置为 -1 代表已删除</span></span><br><span class="line">arr[<span class="number">4</span>] = -<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>综上，在数组中间删除元素的时间复杂度是 O(N) ，因为涉及了数据搬移。</p><h5 id="动态数组-1"><a href="#动态数组-1" class="headerlink" title="动态数组"></a>动态数组</h5><p>动态数组无法解决静态数组在中间增删元素效率差的问题。</p><p>数组之所以能够随机访问是由于数组连续的内存空间，而连续的内存空间就不可避免地面对数据搬移和扩缩容的问题。</p><p>动态数组底层还是静态数组，但是它能够自动帮助进行数组空间的扩缩容，并把增删改查操作进行了封装，使得使用起来更加方便。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建动态数组</span></span><br><span class="line"><span class="comment">// 不用显示指定数组大小，它会根据实际存储的元素数量进行自动扩缩容</span></span><br><span class="line">ArrayList&lt;Integer&gt; arr = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">    <span class="comment">// 在末尾追加元素，时间复杂度为 O(1)</span></span><br><span class="line">    arr.add(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在中间插入元素，时间复杂度为 O(N)</span></span><br><span class="line"><span class="comment">// 在索引 2 的位置插入元素 666</span></span><br><span class="line">arr.add(<span class="number">2</span>, <span class="number">666</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在头部插入元素，时间复杂度为 O(N)</span></span><br><span class="line">arr.add(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除末尾元素，时间复杂度为 O(1)</span></span><br><span class="line">arr.remove(arr.size() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除中间元素，时间复杂度为 O(N)</span></span><br><span class="line"><span class="comment">// 删除索引为 2 的元素</span></span><br><span class="line">arr.remove(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据索引查询元素，时间复杂度为 O(1)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> arr.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据索引修改元素，时间复杂度为 O(1)</span></span><br><span class="line">arr.set(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据元素值查找索引，时间复杂度为 O(N)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> arr.indexOf(<span class="number">666</span>);</span><br></pre></td></tr></table></figure><h4 id="动态数组代码实现"><a href="#动态数组代码实现" class="headerlink" title="动态数组代码实现"></a>动态数组代码实现</h4><h5 id="关键点一、自动扩缩容"><a href="#关键点一、自动扩缩容" class="headerlink" title="关键点一、自动扩缩容"></a>关键点一、自动扩缩容</h5><h5 id="关键点二、索引越界的检查"><a href="#关键点二、索引越界的检查" class="headerlink" title="关键点二、索引越界的检查"></a>关键点二、索引越界的检查</h5><h5 id="关键点三、删除元素谨防内存泄露"><a href="#关键点三、删除元素谨防内存泄露" class="headerlink" title="关键点三、删除元素谨防内存泄露"></a>关键点三、删除元素谨防内存泄露</h5><h5 id="其他细节优化"><a href="#其他细节优化" class="headerlink" title="其他细节优化"></a>其他细节优化</h5><h3 id="单-x2F-双链表"><a href="#单-x2F-双链表" class="headerlink" title="单&#x2F;双链表"></a>单&#x2F;双链表</h3><h4 id="链表（链式存储）基本原理"><a href="#链表（链式存储）基本原理" class="headerlink" title="链表（链式存储）基本原理"></a>链表（链式存储）基本原理</h4><h4 id="链表代码实现"><a href="#链表代码实现" class="headerlink" title="链表代码实现"></a>链表代码实现</h4><h3 id="队列-x2F-栈"><a href="#队列-x2F-栈" class="headerlink" title="队列&#x2F;栈"></a>队列&#x2F;栈</h3><h4 id="队列-x2F-栈基本原理"><a href="#队列-x2F-栈基本原理" class="headerlink" title="队列&#x2F;栈基本原理"></a>队列&#x2F;栈基本原理</h4><h4 id="用链表实现队列-x2F-栈"><a href="#用链表实现队列-x2F-栈" class="headerlink" title="用链表实现队列&#x2F;栈"></a>用链表实现队列&#x2F;栈</h4><h4 id="环形数组技巧"><a href="#环形数组技巧" class="headerlink" title="环形数组技巧"></a>环形数组技巧</h4><h4 id="用数组实现队列-x2F-栈"><a href="#用数组实现队列-x2F-栈" class="headerlink" title="用数组实现队列&#x2F;栈"></a>用数组实现队列&#x2F;栈</h4><h4 id="双端队列（Deque）原理及实现"><a href="#双端队列（Deque）原理及实现" class="headerlink" title="双端队列（Deque）原理及实现"></a>双端队列（Deque）原理及实现</h4><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><h4 id="哈希表基本原理"><a href="#哈希表基本原理" class="headerlink" title="哈希表基本原理"></a>哈希表基本原理</h4><h4 id="用拉链法实现哈希表"><a href="#用拉链法实现哈希表" class="headerlink" title="用拉链法实现哈希表"></a>用拉链法实现哈希表</h4><h4 id="线性探查法的两个难点"><a href="#线性探查法的两个难点" class="headerlink" title="线性探查法的两个难点"></a>线性探查法的两个难点</h4><h4 id="线性探查法的两种代码实现"><a href="#线性探查法的两种代码实现" class="headerlink" title="线性探查法的两种代码实现"></a>线性探查法的两种代码实现</h4><h3 id="哈希集合"><a href="#哈希集合" class="headerlink" title="哈希集合"></a>哈希集合</h3><h4 id="哈希集合的原理"><a href="#哈希集合的原理" class="headerlink" title="哈希集合的原理"></a>哈希集合的原理</h4><h4 id="哈希集合的代码实现"><a href="#哈希集合的代码实现" class="headerlink" title="哈希集合的代码实现"></a>哈希集合的代码实现</h4><h3 id="二叉树结构"><a href="#二叉树结构" class="headerlink" title="二叉树结构"></a>二叉树结构</h3><h4 id="二叉树基础及常见类型"><a href="#二叉树基础及常见类型" class="headerlink" title="二叉树基础及常见类型"></a>二叉树基础及常见类型</h4><h3 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h3><h4 id="二叉堆的基本原理"><a href="#二叉堆的基本原理" class="headerlink" title="二叉堆的基本原理"></a>二叉堆的基本原理</h4><h4 id="二叉堆的代码实现"><a href="#二叉堆的代码实现" class="headerlink" title="二叉堆的代码实现"></a>二叉堆的代码实现</h4>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动手学习深度学习-记录</title>
      <link href="/FRank675.github.io/posts/4ae195802452/"/>
      <url>/FRank675.github.io/posts/4ae195802452/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h3 id="torch-arange"><a href="#torch-arange" class="headerlink" title="torch.arange"></a>torch.arange</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.arange(start, end, step=<span class="number">1</span>, out=<span class="literal">None</span>) -&gt; Tensor</span><br><span class="line"><span class="comment">#返回一个1维张量，长度floor((end - start)/step)</span></span><br><span class="line"><span class="comment">#包含从start到end，以step为步长的一组序列值（默认步长为1）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#参数</span></span><br><span class="line"><span class="comment">##start(float) - 序列的起始点</span></span><br><span class="line"><span class="comment">##end(float) - 序列的终止点</span></span><br><span class="line"><span class="comment">##step(float) - 相邻点的间隔大小</span></span><br><span class="line"><span class="comment">##out(Tensor, optional) - 结果张量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#例子</span></span><br><span class="line">x = torch.arange(<span class="number">12</span>)</span><br><span class="line">y = torch.arange(<span class="number">2</span>, <span class="number">9</span>)</span><br><span class="line">z = torch.arange(<span class="number">2</span>, <span class="number">9</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"><span class="built_in">print</span>(z)</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">tensor([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>])</span><br><span class="line">tensor([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])</span><br><span class="line">tensor([<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>])</span><br></pre></td></tr></table></figure><h3 id="torch-zeros"><a href="#torch-zeros" class="headerlink" title="torch.zeros"></a>torch.zeros</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.zeros(*sizes, out=<span class="literal">None</span>) -&gt; Tensor</span><br><span class="line"><span class="comment">#返回一个全为标量0的张量，形状可由可变参数sizes定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#参数</span></span><br><span class="line"><span class="comment">##sizes(int...) - 整数序列，定义了输出形状</span></span><br><span class="line"><span class="comment">##out(Tensor, optional) - 结果张量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#例子</span></span><br><span class="line">x = torch.zeros(<span class="number">3</span>)</span><br><span class="line">y = torch.zeros(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">z = torch.zeros(<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"><span class="built_in">print</span>(z)</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">tensor([<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>])</span><br><span class="line">tensor([[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">        [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>]])</span><br><span class="line">tensor([[[<span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">         [<span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">         [<span class="number">0.</span>, <span class="number">0.</span>]],</span><br><span class="line">        [[<span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">         [<span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">         [<span class="number">0.</span>, <span class="number">0.</span>]]])</span><br></pre></td></tr></table></figure><h3 id="torch-ones"><a href="#torch-ones" class="headerlink" title="torch.ones"></a>torch.ones</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.ones(*sizes, out=<span class="literal">None</span>) -&gt; Tensor</span><br><span class="line"><span class="comment">#返回一个全为1的张量，形状由可变参数sizes定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#参数</span></span><br><span class="line"><span class="comment">##sizes(int...) - 整数序列，定义了输出形状</span></span><br><span class="line"><span class="comment">##out(Tensor, optional) - 结果张量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#例子</span></span><br><span class="line">x = torch.ones(<span class="number">3</span>)</span><br><span class="line">y = torch.ones(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">z = torch.ones(<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"><span class="built_in">print</span>(z)</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">tensor([<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>])</span><br><span class="line">tensor([[<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>]])</span><br><span class="line">tensor([[[<span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">         [<span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">         [<span class="number">1.</span>, <span class="number">1.</span>]],</span><br><span class="line">        [[<span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">         [<span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">         [<span class="number">1.</span>, <span class="number">1.</span>]]])</span><br></pre></td></tr></table></figure><h3 id="torch-randn"><a href="#torch-randn" class="headerlink" title="torch.randn"></a>torch.randn</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.randn(*sizes, out=<span class="literal">None</span>) -&gt; Tensor</span><br><span class="line"><span class="comment">#返回一个张量，包含了从标准正态分布（均值为0，方差为1，即高斯白噪声）种抽取一组随机数</span></span><br><span class="line"><span class="comment">#形状由可变参数sizes定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#参数</span></span><br><span class="line"><span class="comment">##sizes(int...) - 整数序列，定义了输出形状</span></span><br><span class="line"><span class="comment">##out(Tensor, optional) - 结果张量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#例子</span></span><br><span class="line">x = torch.randn(<span class="number">3</span>)</span><br><span class="line">y = torch.randn(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">z = torch.randn(<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"><span class="built_in">print</span>(z)</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">tensor([ <span class="number">1.6708</span>, -<span class="number">0.9269</span>, -<span class="number">0.6244</span>])</span><br><span class="line">tensor([[ <span class="number">0.0745</span>, -<span class="number">1.1297</span>, -<span class="number">0.8780</span>],</span><br><span class="line">        [ <span class="number">0.0630</span>, -<span class="number">1.0166</span>, -<span class="number">1.8237</span>]])</span><br><span class="line">tensor([[[-<span class="number">0.8598</span>,  <span class="number">0.7275</span>],</span><br><span class="line">         [-<span class="number">0.3070</span>,  <span class="number">0.0244</span>],</span><br><span class="line">         [ <span class="number">0.8968</span>,  <span class="number">1.4401</span>]],</span><br><span class="line">        [[ <span class="number">1.5100</span>,  <span class="number">2.2971</span>],</span><br><span class="line">         [-<span class="number">0.2009</span>, -<span class="number">1.5679</span>],</span><br><span class="line">         [-<span class="number">0.4775</span>, -<span class="number">0.4814</span>]]])</span><br></pre></td></tr></table></figure><h3 id="torch-cat"><a href="#torch-cat" class="headerlink" title="torch.cat"></a>torch.cat</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.cat(inputs, dimension=<span class="number">0</span>) -&gt; Tensor</span><br><span class="line"><span class="comment">#在给定维度上对输入的张量序列sep进行连接操作</span></span><br><span class="line"><span class="comment">#把多个张量连结（concatenate）在一起， 把它们端对端地叠起来形成一个更大的张量。</span></span><br><span class="line"><span class="comment">#只需要提供张量列表，并给出沿哪个轴连结</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#torch.cat()可以看作torch.split()和torch.chunk()的反操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#参数</span></span><br><span class="line"><span class="comment">##inputs(sequence of Tensors) - 可以是任意相同Tensor类型的python序列</span></span><br><span class="line"><span class="comment">##dimension(int,optional) - 沿着此维连接张量序列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#例子</span></span><br><span class="line">X = torch.arange(<span class="number">12</span>, dtype=torch.float32).reshape((<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(X)</span><br><span class="line">Y = torch.tensor([[<span class="number">2.0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line"><span class="built_in">print</span>(Y)</span><br><span class="line"><span class="built_in">print</span>(torch.cat((X, Y), dim=<span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(torch.cat((X, Y), dim=<span class="number">1</span>))</span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">tensor([[ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>],</span><br><span class="line">        [ <span class="number">4.</span>,  <span class="number">5.</span>,  <span class="number">6.</span>,  <span class="number">7.</span>],</span><br><span class="line">        [ <span class="number">8.</span>,  <span class="number">9.</span>, <span class="number">10.</span>, <span class="number">11.</span>]])</span><br><span class="line">tensor([[<span class="number">2.</span>, <span class="number">1.</span>, <span class="number">4.</span>, <span class="number">3.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>, <span class="number">4.</span>],</span><br><span class="line">        [<span class="number">4.</span>, <span class="number">3.</span>, <span class="number">2.</span>, <span class="number">1.</span>]])</span><br><span class="line">tensor([[ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>],</span><br><span class="line">        [ <span class="number">4.</span>,  <span class="number">5.</span>,  <span class="number">6.</span>,  <span class="number">7.</span>],</span><br><span class="line">        [ <span class="number">8.</span>,  <span class="number">9.</span>, <span class="number">10.</span>, <span class="number">11.</span>],</span><br><span class="line">        [ <span class="number">2.</span>,  <span class="number">1.</span>,  <span class="number">4.</span>,  <span class="number">3.</span>],</span><br><span class="line">        [ <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>,  <span class="number">4.</span>],</span><br><span class="line">        [ <span class="number">4.</span>,  <span class="number">3.</span>,  <span class="number">2.</span>,  <span class="number">1.</span>]])</span><br><span class="line">tensor([[ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>,  <span class="number">2.</span>,  <span class="number">1.</span>,  <span class="number">4.</span>,  <span class="number">3.</span>],</span><br><span class="line">        [ <span class="number">4.</span>,  <span class="number">5.</span>,  <span class="number">6.</span>,  <span class="number">7.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>,  <span class="number">4.</span>],</span><br><span class="line">        [ <span class="number">8.</span>,  <span class="number">9.</span>, <span class="number">10.</span>, <span class="number">11.</span>,  <span class="number">4.</span>,  <span class="number">3.</span>,  <span class="number">2.</span>,  <span class="number">1.</span>]])</span><br></pre></td></tr></table></figure><h3 id="torch-shape"><a href="#torch-shape" class="headerlink" title="torch.shape"></a>torch.shape</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#通过张量的shape属性来访问张量（沿每个轴的长度）的形状</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#例子</span></span><br><span class="line">x = torch.zeros(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(x.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">torch.Size([<span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure><h3 id="torch-numel"><a href="#torch-numel" class="headerlink" title="torch.numel"></a>torch.numel</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.numel(<span class="built_in">input</span>) -&gt; <span class="built_in">int</span></span><br><span class="line"><span class="comment">#返回input张量中的元素个数，即形状的所有元素乘积，可以检查它的大小（size）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#参数</span></span><br><span class="line"><span class="comment">##input(Tnsor) - 输入张量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#例子</span></span><br><span class="line">x = torch.randn(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">y = torch.zeros(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(torch.numel(x))</span><br><span class="line"><span class="built_in">print</span>(torch.numel(y))</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line"><span class="number">120</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="torch-reshape"><a href="#torch-reshape" class="headerlink" title="torch.reshape"></a>torch.reshape</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#要想改变一个张量的形状而不改变元素数量和元素值，可以调用reshape函数。 </span></span><br><span class="line"><span class="comment">#例如，可以把张量x从形状为（12,）的行向量转换为形状为（3,4）的矩阵。 </span></span><br><span class="line"><span class="comment">#这个新的张量包含与转换前相同的值，但是它被看成一个3行4列的矩阵。 </span></span><br><span class="line"><span class="comment">#要重点说明一下，虽然张量的形状发生了改变，但其元素值并没有变。 </span></span><br><span class="line"><span class="comment">#注意，通过改变张量的形状，张量的大小不会改变。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#例子</span></span><br><span class="line">x = torch.arange(<span class="number">12</span>)</span><br><span class="line">y = torch.reshape(x, [<span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">tensor([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>])</span><br><span class="line">tensor([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">        [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">        [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment">#我们不需要通过手动指定每个维度来改变形状。 </span></span><br><span class="line"><span class="comment">#也就是说，如果我们的目标形状是（高度,宽度）， 那么在知道宽度后，高度会被自动计算得出，不必我们自己做除法。 </span></span><br><span class="line"><span class="comment">#在上面的例子中，为了获得一个3行的矩阵，我们手动指定了它有3行和4列。 </span></span><br><span class="line"><span class="comment">#幸运的是，我们可以通过-1来调用此自动计算出维度的功能。 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#例子</span></span><br><span class="line">x = torch.arange(<span class="number">12</span>)</span><br><span class="line">y = torch.reshape(x, [-<span class="number">1</span>, <span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">tensor([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>])</span><br><span class="line">tensor([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">        [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">        [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br></pre></td></tr></table></figure><h3 id="torch-tensor"><a href="#torch-tensor" class="headerlink" title="torch.tensor"></a>torch.tensor</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#可以通过提供包含数值的Python列表（或嵌套列表），来为所需张量中的每个元素赋予确定值。 </span></span><br><span class="line"><span class="comment">#在这里，最外层的列表对应于轴0，内层的列表对应于轴1。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#例子</span></span><br><span class="line">x = torch.tensor([[<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">tensor([[<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">        [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br></pre></td></tr></table></figure><h3 id="在相同形状的两个张量上执行按元素操作"><a href="#在相同形状的两个张量上执行按元素操作" class="headerlink" title="在相同形状的两个张量上执行按元素操作"></a>在相同形状的两个张量上执行按元素操作</h3><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#例子</span></span><br><span class="line">x = torch.tensor([<span class="number">1.0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>])</span><br><span class="line">y = torch.tensor([<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x:\n&quot;</span>, x)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;y:\n&quot;</span>, y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x+y:\n&quot;</span>, x + y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x-y:\n&quot;</span>, x + y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x*y:\n&quot;</span>, x * y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x**y:\n&quot;</span>, x ** y)  <span class="comment"># **运算符是求幂运算</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;e^x:\n&quot;</span>, torch.exp(x))</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">x:</span><br><span class="line"> tensor([<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">4.</span>, <span class="number">8.</span>])</span><br><span class="line">y:</span><br><span class="line"> tensor([<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>])</span><br><span class="line">x+y:</span><br><span class="line"> tensor([ <span class="number">3.</span>,  <span class="number">4.</span>,  <span class="number">6.</span>, <span class="number">10.</span>])</span><br><span class="line">x-y:</span><br><span class="line"> tensor([ <span class="number">3.</span>,  <span class="number">4.</span>,  <span class="number">6.</span>, <span class="number">10.</span>])</span><br><span class="line">x*y:</span><br><span class="line"> tensor([ <span class="number">2.</span>,  <span class="number">4.</span>,  <span class="number">8.</span>, <span class="number">16.</span>])</span><br><span class="line">x**y:</span><br><span class="line"> tensor([ <span class="number">1.</span>,  <span class="number">4.</span>, <span class="number">16.</span>, <span class="number">64.</span>])</span><br><span class="line">e^x:</span><br><span class="line"> tensor([<span class="number">2.7183e+00</span>, <span class="number">7.3891e+00</span>, <span class="number">5.4598e+01</span>, <span class="number">2.9810e+03</span>])</span><br></pre></td></tr></table></figure><h4 id="逻辑运算符构建二元张量"><a href="#逻辑运算符构建二元张量" class="headerlink" title="逻辑运算符构建二元张量"></a>逻辑运算符构建二元张量</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#通过逻辑运算符构建二元张量。 </span></span><br><span class="line"><span class="comment">#以X == Y为例： </span></span><br><span class="line"><span class="comment">#对于每个位置，如果X和Y在该位置相等，则新张量中相应项的值为1。 </span></span><br><span class="line"><span class="comment">#这意味着逻辑语句X == Y在该位置处为真，否则该位置为0。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#例子</span></span><br><span class="line">x = torch.arange(<span class="number">12</span>, dtype=torch.float32).reshape((<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">y = torch.tensor([[<span class="number">2.0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"><span class="built_in">print</span>(x == y)</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">tensor([[ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>],</span><br><span class="line">        [ <span class="number">4.</span>,  <span class="number">5.</span>,  <span class="number">6.</span>,  <span class="number">7.</span>],</span><br><span class="line">        [ <span class="number">8.</span>,  <span class="number">9.</span>, <span class="number">10.</span>, <span class="number">11.</span>]])</span><br><span class="line">tensor([[<span class="number">2.</span>, <span class="number">1.</span>, <span class="number">4.</span>, <span class="number">3.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>, <span class="number">4.</span>],</span><br><span class="line">        [<span class="number">4.</span>, <span class="number">3.</span>, <span class="number">2.</span>, <span class="number">1.</span>]])</span><br><span class="line">tensor([[<span class="literal">False</span>,  <span class="literal">True</span>, <span class="literal">False</span>,  <span class="literal">True</span>],</span><br><span class="line">        [<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>],</span><br><span class="line">        [<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>]])</span><br></pre></td></tr></table></figure><h4 id="对张量所有元素求和"><a href="#对张量所有元素求和" class="headerlink" title="对张量所有元素求和"></a>对张量所有元素求和</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#对张量中的所有元素进行求和，会产生一个单元素张量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#例子</span></span><br><span class="line">x = torch.arange(<span class="number">12</span>, dtype=torch.float32).reshape((<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="built_in">print</span>(x.<span class="built_in">sum</span>())</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">tensor([[ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>],</span><br><span class="line">        [ <span class="number">4.</span>,  <span class="number">5.</span>,  <span class="number">6.</span>,  <span class="number">7.</span>],</span><br><span class="line">        [ <span class="number">8.</span>,  <span class="number">9.</span>, <span class="number">10.</span>, <span class="number">11.</span>]])</span><br><span class="line">tensor(<span class="number">66.</span>)</span><br></pre></td></tr></table></figure><h3 id="在不同形状的两个张量上执行按元素操作（广播机制）"><a href="#在不同形状的两个张量上执行按元素操作（广播机制）" class="headerlink" title="在不同形状的两个张量上执行按元素操作（广播机制）"></a>在不同形状的两个张量上执行按元素操作（广播机制）</h3><p><strong>广播机制工作方式如下：</strong></p><ol><li><strong>通过适当复制元素来扩展一个或两个数组，以便在转换之后，两个张量具有相同的形状；</strong></li><li><strong>对生成的数组执行按元素操作。</strong></li></ol><h3 id="torch-numel-1"><a href="#torch-numel-1" class="headerlink" title="torch.numel"></a>torch.numel</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在大多数情况下，沿着数组中长度为1的轴进行广播</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#例子</span></span><br><span class="line">a = torch.arange(<span class="number">3</span>).reshape((<span class="number">3</span>, <span class="number">1</span>))</span><br><span class="line">b = torch.arange(<span class="number">2</span>).reshape((<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(a + b)</span><br><span class="line"></span><br><span class="line"><span class="comment">#由于a和b分别是3*1和1*2矩阵，如果让它们相加，它们的形状不匹配。 </span></span><br><span class="line"><span class="comment">#故将两个矩阵广播为一个更大的矩阵</span></span><br><span class="line"><span class="comment">#矩阵a将复制列， 矩阵b将复制行，然后再按元素相加</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">tensor([[<span class="number">0</span>],</span><br><span class="line">        [<span class="number">1</span>],</span><br><span class="line">        [<span class="number">2</span>]])</span><br><span class="line">tensor([[<span class="number">0</span>, <span class="number">1</span>]])</span><br><span class="line">tensor([[<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">        [<span class="number">2</span>, <span class="number">3</span>]])</span><br></pre></td></tr></table></figure><h2 id="索引和切片"><a href="#索引和切片" class="headerlink" title="索引和切片"></a>索引和切片</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#像在任何其他Python数组中一样，张量中的元素可以通过索引访问。 </span></span><br><span class="line"><span class="comment">#与任何Python数组一样：第一个元素的索引是0，最后一个元素索引是-1； </span></span><br><span class="line"><span class="comment">#可以指定范围以包含第一个元素和最后一个之前的元素。</span></span><br><span class="line"><span class="comment">#可以用[-1]选择最后一个元素，可以用[1:3]选择第二个和第三个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#例子</span></span><br><span class="line">x = torch.tensor([[<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line"><span class="built_in">print</span>(x[-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(x[<span class="number">1</span>:<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">tensor([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br><span class="line">tensor([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">        [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#除读取外，还可以通过指定索引来将元素写入矩阵。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#例子</span></span><br><span class="line">x = torch.tensor([[<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line">x[<span class="number">1</span>, <span class="number">2</span>] = <span class="number">6</span></span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">tensor([[<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>],</span><br><span class="line">        [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#如果我们想为多个元素赋值相同的值，我们只需要索引所有元素，然后为它们赋值。 </span></span><br><span class="line"><span class="comment">#例如，[0:2, :]访问第1行和第2行，其中“:”代表沿轴1（列）的所有元素。</span></span><br><span class="line"><span class="comment">#虽然我们讨论的是矩阵的索引，但这也适用于向量和超过2个维度的张量。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#例子</span></span><br><span class="line">x = torch.tensor([[<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line">x[<span class="number">0</span>:<span class="number">2</span>, :] = <span class="number">12</span></span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">tensor([[<span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>],</span><br><span class="line">        [<span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>],</span><br><span class="line">        [ <span class="number">4</span>,  <span class="number">3</span>,  <span class="number">2</span>,  <span class="number">1</span>]])</span><br></pre></td></tr></table></figure><h3 id="节省内存"><a href="#节省内存" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#运行一些操作可能会导致为新结果分配内存。 </span></span><br><span class="line"><span class="comment">#例如，如果我们用x = x + y，我们将取消引用x指向的张量，而是指向新分配的内存处的张量。</span></span><br><span class="line"><span class="comment">#在下面的例子中，我们用Python的id()函数演示了这一点， 它给我们提供了内存中引用对象的确切地址。 运行x = x + y后，我们会发现id(x)指向另一个位置。 这是因为Python首先计算x + y，为结果分配新的内存，然后使x指向内存中的这个新位置。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##这可能是不可取的，原因有两个：</span></span><br><span class="line"><span class="comment">###首先，我们不想总是不必要地分配内存。在机器学习中，我们可能有数百兆的参数，并且在一秒内多次更新所有参数。通常情况下，我们希望原地执行这些更新；</span></span><br><span class="line"><span class="comment">###如果我们不原地更新，其他引用仍然会指向旧的内存位置，这样我们的某些代码可能会无意中引用旧的参数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##要执行原地操作，我们可以使用切片表示法将操作的结果分配给先前分配的数组，例如x[:] = &lt;expression&gt;。 为了说明这一点，我们首先创建一个新的矩阵z，其形状与另一个z相同， 使用zeros_like来分配一个全0的块。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果在后续计算中没有重复使用X， 我们也可以使用x[:] = x + y或x += y来减少操作的内存开销。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#例子</span></span><br><span class="line">x = torch.tensor([[<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line">y = torch.tensor([[<span class="number">2.0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line">before = <span class="built_in">id</span>(x)</span><br><span class="line">x = x + y</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(x) == before)</span><br><span class="line"></span><br><span class="line">z = torch.zeros_like(x)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;id(z):&quot;</span>, <span class="built_in">id</span>(z))</span><br><span class="line">z[:] = x + y</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;id(z):&quot;</span>, <span class="built_in">id</span>(z))</span><br><span class="line"></span><br><span class="line">before = <span class="built_in">id</span>(x)</span><br><span class="line">x[:] = x + y</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(x) == before)</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="built_in">id</span>(z): <span class="number">1590385395328</span></span><br><span class="line"><span class="built_in">id</span>(z): <span class="number">1590385395328</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h3 id="节省内存-1"><a href="#节省内存-1" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-2"><a href="#节省内存-2" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-3"><a href="#节省内存-3" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-4"><a href="#节省内存-4" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-5"><a href="#节省内存-5" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-6"><a href="#节省内存-6" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-7"><a href="#节省内存-7" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-8"><a href="#节省内存-8" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-9"><a href="#节省内存-9" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-10"><a href="#节省内存-10" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-11"><a href="#节省内存-11" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-12"><a href="#节省内存-12" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-13"><a href="#节省内存-13" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-14"><a href="#节省内存-14" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-15"><a href="#节省内存-15" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-16"><a href="#节省内存-16" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-17"><a href="#节省内存-17" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-18"><a href="#节省内存-18" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-19"><a href="#节省内存-19" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-20"><a href="#节省内存-20" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-21"><a href="#节省内存-21" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-22"><a href="#节省内存-22" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-23"><a href="#节省内存-23" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-24"><a href="#节省内存-24" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-25"><a href="#节省内存-25" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-26"><a href="#节省内存-26" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-27"><a href="#节省内存-27" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-28"><a href="#节省内存-28" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-29"><a href="#节省内存-29" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-30"><a href="#节省内存-30" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-31"><a href="#节省内存-31" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-32"><a href="#节省内存-32" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-33"><a href="#节省内存-33" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-34"><a href="#节省内存-34" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-35"><a href="#节省内存-35" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-36"><a href="#节省内存-36" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-37"><a href="#节省内存-37" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-38"><a href="#节省内存-38" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-39"><a href="#节省内存-39" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-40"><a href="#节省内存-40" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-41"><a href="#节省内存-41" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-42"><a href="#节省内存-42" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-43"><a href="#节省内存-43" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-44"><a href="#节省内存-44" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-45"><a href="#节省内存-45" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-46"><a href="#节省内存-46" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-47"><a href="#节省内存-47" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-48"><a href="#节省内存-48" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-49"><a href="#节省内存-49" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-50"><a href="#节省内存-50" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-51"><a href="#节省内存-51" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-52"><a href="#节省内存-52" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-53"><a href="#节省内存-53" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-54"><a href="#节省内存-54" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-55"><a href="#节省内存-55" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-56"><a href="#节省内存-56" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-57"><a href="#节省内存-57" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-58"><a href="#节省内存-58" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-59"><a href="#节省内存-59" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-60"><a href="#节省内存-60" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-61"><a href="#节省内存-61" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-62"><a href="#节省内存-62" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-63"><a href="#节省内存-63" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-64"><a href="#节省内存-64" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-65"><a href="#节省内存-65" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-66"><a href="#节省内存-66" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节省内存-67"><a href="#节省内存-67" class="headerlink" title="节省内存"></a>节省内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构算法总结-自用</title>
      <link href="/FRank675.github.io/posts/36da8636de8d/"/>
      <url>/FRank675.github.io/posts/36da8636de8d/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="数据结构算法整理"><a href="#数据结构算法整理" class="headerlink" title="数据结构算法整理"></a>数据结构算法整理</h1><h2 id="By-舜桀BB"><a href="#By-舜桀BB" class="headerlink" title="By 舜桀BB"></a><strong>By 舜桀BB</strong></h2><h2 id="循环双链表的存储结构"><a href="#循环双链表的存储结构" class="headerlink" title="循环双链表的存储结构"></a>循环双链表的存储结构</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>,*<span class="title">next</span>;</span></span><br><span class="line">&#125;DNode,*DLinklist;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化空的循环双链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitDLinkList</span><span class="params">(DLinklist &amp;L)</span>&#123;</span><br><span class="line">    L = (DNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));     <span class="comment">//分配一个头结点</span></span><br><span class="line">    <span class="keyword">if</span>(L==<span class="literal">NULL</span>)     <span class="comment">//内存不足，分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;prior = L;    <span class="comment">//头结点的prior指向头结点</span></span><br><span class="line">    L-&gt;next = L;     <span class="comment">//头结点的next指向头结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断循环双链表是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Empty</span><span class="params">(DLinklist L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next==L)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断结点p是否为循环单链表的表尾结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isTail</span><span class="params">(DLinklist L, DNode *p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next==L)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在p结点之后插入s结点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertNextDNode</span><span class="params">(DNode *p, DNode *s)</span>&#123;</span><br><span class="line">    s-&gt;next=p-&gt;next;  <span class="comment">//s的下一个结点为当前p的下一个结点，即把s插到p后面</span></span><br><span class="line">    p-&gt;next-&gt;prior=s; <span class="comment">//将第三个结点的头接到s</span></span><br><span class="line">    s-&gt;prior=p;       <span class="comment">//将s的头接到p</span></span><br><span class="line">    p-&gt;next=s;        <span class="comment">//将p的尾接到s</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在带头结点的双向循环链表L中第i个位置之前插入元素e</span></span><br><span class="line"><span class="comment">//i的合法值为1=&lt;i=&lt;表长+1</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InsertBeforeI</span><span class="params">(DLinklist &amp;L, <span class="type">int</span> i,Elemtype e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(p=GetElem(L,i))) <span class="comment">//GetElem(L,i):获取表中第i个位置的元素的值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//插入位置不合法</span></span><br><span class="line">    <span class="keyword">if</span>(!(s=(DLinklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode))))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//内存空间不足，无法创建新结点</span></span><br><span class="line">    s-&gt;data=e;</span><br><span class="line">    s-&gt;prior=p-&gt;prior;</span><br><span class="line">    p-&gt;prior-&gt;next=s;</span><br><span class="line">    s-&gt;next=p;</span><br><span class="line">    p-&gt;prior=s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除p的后继节点q</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">deleteNextDNode</span><span class="params">(DNode *p, DNode *q)</span>&#123;</span><br><span class="line">    p-&gt;next=q-&gt;next;  <span class="comment">//将p的尾接到q的下一个结点</span></span><br><span class="line">    q-&gt;next-&gt;prior=p; <span class="comment">//将q的下一个结点的头接到p</span></span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除带头结点的双向循环链表L中第i个元素</span></span><br><span class="line"><span class="comment">//i的合法值为1=&lt;i=&lt;表长</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeleteElemI</span><span class="params">(DLinklist &amp;L, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(p=GetElem(L,i)))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    p-&gt;prior-&gt;next=p-&gt;next;</span><br><span class="line">    p-&gt;next-&gt;prior=p-&gt;prior;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栈、队列和数组"><a href="#栈、队列和数组" class="headerlink" title="栈、队列和数组"></a>栈、队列和数组</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//队列是一种操作受限的线性表，只允许在表的一端插入，在表的另一端删除（先进先出）</span></span><br><span class="line"><span class="comment">//队列常见基本操作</span></span><br><span class="line"><span class="comment">//InitQueue(&amp;Q):初始化队列，构造一个空队列Q</span></span><br><span class="line"><span class="comment">//QueueEmpty(Q):判队列空，若队列为空则返回true，否则返回false</span></span><br><span class="line"><span class="comment">//EnQueue(&amp;Q,x):入队，若队列Q未满，将x加入，使其成为新的队尾</span></span><br><span class="line"><span class="comment">//DeQueue(&amp;Q,&amp;x):出队，若队列Q非空，删除队头元素，并用x返回</span></span><br><span class="line"><span class="comment">//GetHead(Q,&amp;x):读队头元素，若队列Q非空，则将队头元素赋值给x</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//队列的顺序存储</span></span><br><span class="line"><span class="comment">//分配一块连续的存储单元存放队列中的元素，并附设两个指针：队头指针front指向队头元素，队尾指针rear指向队尾元素的下一个位置</span></span><br><span class="line"><span class="comment">//循环队列：把存储队列元素的表从逻辑上视为一个环</span></span><br><span class="line"><span class="comment">//当队首指针Q.front=MaxSize-1后，再前进一个位置就自动到0，通过除数取余运算%实现</span></span><br><span class="line"><span class="comment">//初始时：Q.front=Q.rear=0</span></span><br><span class="line"><span class="comment">//队首指针进1：Q.front=(Q.front+1)%MaxSize</span></span><br><span class="line"><span class="comment">//队尾指针进1：Q.rear=(Q.rear+1)%MaxSize</span></span><br><span class="line"><span class="comment">//队列长度：(Q.rear+MaxSize-Q.front)%MaxSize</span></span><br><span class="line"><span class="comment">//出队入队时：指针都按顺时针方向进1</span></span><br><span class="line"><span class="comment">//判断队空队满：牺牲一个单元来区分队空队满，入队时少用一个队列单元</span></span><br><span class="line"><span class="comment">//队头指针在队尾指针的下一位置为队满的标志</span></span><br><span class="line"><span class="comment">//队满条件：(Q.rear+1)%MaxSize==Q.front</span></span><br><span class="line"><span class="comment">//队空条件：Q.front==Q.rear</span></span><br><span class="line"><span class="comment">//队列中元素的个数：(Q.rear+MaxSize-Q.front)%MaxSize</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//循环队列的操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50      <span class="comment">//定义队列中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];   <span class="comment">//存放队列元素</span></span><br><span class="line">    <span class="type">int</span> front,rear;           <span class="comment">//队头指针和队尾指针</span></span><br><span class="line">&#125;SqQueue;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(SqQueue &amp;Q)</span>&#123;</span><br><span class="line">    Q.rear=Q.front=<span class="number">0</span>;       <span class="comment">//初始化队首队尾指/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判队空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(SqQueue Q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear=Q.front) <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">//队空条件</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">EnQueue</span><span class="params">(SqQueue &amp;Q,ElemType x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MaxSize==Q.front) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//队满则报错</span></span><br><span class="line">    Q.data[Q.rear]=x;</span><br><span class="line">    Q.rear=(Q.rear+<span class="number">1</span>)%MaxSize;     <span class="comment">//队尾指针加一取模</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(SqQueue &amp;Q,ElemType &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear==Q.front) <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//队空则报错</span></span><br><span class="line">    x=Q.data[Q.front];</span><br><span class="line">    Q.front=(Q.front+<span class="number">1</span>)%MaxSize;   <span class="comment">//队头指针加一取模</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h2 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h2><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//树中的结点数=所有结点的度数之和+1=分支数+1</span></span><br><span class="line"><span class="comment">//n个结点的树中由n-1条边</span></span><br><span class="line"><span class="comment">//度为m的树中第i层至多有m^(i-1)个结点</span></span><br><span class="line"><span class="comment">//高度为h的m叉树至多有(m^h-1)/(m-1)个结点</span></span><br><span class="line"><span class="comment">//具有n个结点的m叉树的最小高度为⌈logm(n(m-1)+1)⌉ </span></span><br></pre></td></tr></table></figure><h3 id="特殊的二叉树"><a href="#特殊的二叉树" class="headerlink" title="特殊的二叉树"></a>特殊的二叉树</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//满二叉树</span></span><br><span class="line"><span class="comment">//高度为h，含有2^h-1个结点的二叉树</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//完全二叉树</span></span><br><span class="line"><span class="comment">//高度为h、有n个结点的二叉树，且每个结点都与高度为h的满二叉树中编号为1-n的结点一一对应。</span></span><br><span class="line"><span class="comment">//对于完全二叉树，若i&lt;=⌊n/2⌋,则结点i为分支结点，否则为叶节点</span></span><br><span class="line"><span class="comment">//若有度为1的结点，则只有可能有一个，且该结点有左孩子无右孩子</span></span><br><span class="line"><span class="comment">//若n为奇数，则每个分支结点都有左右孩子，</span></span><br><span class="line"><span class="comment">//若n为偶数，则编号最大的分支结点（编号为n/2）只有左孩子，无右孩子，其余分支结点左右孩子都有</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉排序树</span></span><br><span class="line"><span class="comment">//左子树上所有结点的关键字均小于根结点的关键字；右子树上所有结点的关键字均大于根结点的关键字</span></span><br><span class="line"><span class="comment">//左子树和右子树又各是一棵二叉排序树</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//平衡二叉树</span></span><br><span class="line"><span class="comment">//树上任意一个结点的左子树和右子树的深度之差不超过1</span></span><br></pre></td></tr></table></figure><h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉树</span></span><br><span class="line"><span class="comment">//非空二叉树上的叶结点数等于度为2的结点数加1，即n0=n2+1</span></span><br><span class="line"><span class="comment">//非空二叉树上第k层上至多2^(k-1)个结点</span></span><br><span class="line"><span class="comment">//高度为h的二叉树至多有2^h-1个结点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//完全二叉树</span></span><br><span class="line"><span class="comment">//具有n个结点的完全二叉树的高度h为⌈log2(n+1)⌉或⌊log2n⌋+1</span></span><br><span class="line"><span class="comment">//对于完全二叉树，可以由结点数推出度为0、1和2的结点个数n0、n1、n2（突破口：完全二叉树最多只有会有一个度为1的结点；n0=n2+1，所以n0+n2为奇数，若结点数为偶数，则n1=1；若结点数为奇数，则n1=0）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树的链式存储结构</span></span><br><span class="line"><span class="comment">// |lchid|data|rchild|</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span>&#123;</span></span><br><span class="line">    ElemType data;                    <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span>    <span class="comment">//左右孩子指针</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"><span class="comment">//在含有n个结点的二叉链表中，含有n+1个空链域</span></span><br></pre></td></tr></table></figure><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉树的遍历是指按某条搜索路径访问树中的每个结点，使得每个结点均被访问一次，而且仅被访问一次</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//三种遍历算法中，遍历递归左右子树的顺序都是固定的，只是访问根结点的顺序不同。</span></span><br><span class="line"><span class="comment">//不管采用哪种遍历算法，每个结点都访问一次且仅访问一次，所以时间复杂度为O(n)</span></span><br><span class="line"><span class="comment">//在递归遍历中，递归工作栈的栈深恰好为树的深度，所以在最坏情况下，二叉树是由n个结点且深度为n的单支树，遍历算法的空间复杂度为O(n)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTree)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        visit(T);             <span class="comment">//访问根节点</span></span><br><span class="line">        PreOrder(T-&gt;lchild);  <span class="comment">//递归遍历左子树</span></span><br><span class="line">        PreOrder(T-&gt;rchild);  <span class="comment">//递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTree)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        PreOrder(T-&gt;lchild);  <span class="comment">//递归遍历左子树</span></span><br><span class="line">        visit(T);             <span class="comment">//访问根节点</span></span><br><span class="line">        PreOrder(T-&gt;rchild);  <span class="comment">//递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTree)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        PreOrder(T-&gt;lchild);  <span class="comment">//递归遍历左子树</span></span><br><span class="line">        PreOrder(T-&gt;rchild);  <span class="comment">//递归遍历右子树</span></span><br><span class="line">        visit(T);             <span class="comment">//访问根节点        </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历非递归算法</span></span><br><span class="line"><span class="comment">//1.沿着根的左孩子，依次入栈，直到左孩子为空，说明已找到可以输出的结点</span></span><br><span class="line"><span class="comment">//2.栈顶元素出栈并访问：若其右孩子为空，继续执行2，若其右孩子不为空，将右子树执行1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrder2</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    InitStack(S);           <span class="comment">//初始化栈S</span></span><br><span class="line">    BiTree p = T;           <span class="comment">//p是遍历指针</span></span><br><span class="line">    <span class="keyword">while</span>(p||!IsEmpty(S))&#123;  <span class="comment">//栈不为空或p不空时循环</span></span><br><span class="line">        <span class="keyword">if</span>(p)&#123;              <span class="comment">//一路向左</span></span><br><span class="line">            Push(S,p);      <span class="comment">//当前结点入栈</span></span><br><span class="line">            p=p-&gt;lchild;    <span class="comment">//左孩子不空，一直向左走</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;               <span class="comment">//出栈，并转向出栈结点的右子树</span></span><br><span class="line">            Pop(S,p);       <span class="comment">//栈顶元素出栈</span></span><br><span class="line">            visit(p);       <span class="comment">//访问出栈结点</span></span><br><span class="line">            p=p-&gt;rchild;    <span class="comment">//向右子树走，p赋值为当前结点的右孩子</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序遍历非递归算法</span></span><br><span class="line"><span class="comment">//1.访问该结点，沿着根的左孩子，依次入栈，直到左孩子为空，说明已找到可以输出的结点</span></span><br><span class="line"><span class="comment">//2.栈顶元素出栈：若其右孩子为空，继续执行2，若其右孩子不为空，将右子树执行1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder2</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    InitStack(S);           <span class="comment">//初始化栈S</span></span><br><span class="line">    BiTree p = T;           <span class="comment">//p是遍历指针</span></span><br><span class="line">    <span class="keyword">while</span>(p||!IsEmpty(S))&#123;  <span class="comment">//栈不为空或p不空时循环</span></span><br><span class="line">        <span class="keyword">if</span>(p)&#123;              <span class="comment">//一路向左</span></span><br><span class="line">            visit(p);       <span class="comment">//访问结点</span></span><br><span class="line">            Push(S,p);      <span class="comment">//当前结点入栈</span></span><br><span class="line">            p=p-&gt;lchild;    <span class="comment">//左孩子不空，一直向左走</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;               <span class="comment">//出栈，并转向出栈结点的右子树</span></span><br><span class="line">            Pop(S,p);       <span class="comment">//栈顶元素出栈</span></span><br><span class="line">            p=p-&gt;rchild;    <span class="comment">//向右子树走，p赋值为当前结点的右孩子</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树的层次遍历算法</span></span><br><span class="line"><span class="comment">//进行层次遍历需要借助一个队列。</span></span><br><span class="line"><span class="comment">//首先将二叉树根结点入队，然后出队，访问出队结点</span></span><br><span class="line"><span class="comment">//若它有左子树，则将左子树根结点入队；若它有右子树，则将右子树根结点入队。</span></span><br><span class="line"><span class="comment">//完成入队后出队，访问出队结点</span></span><br><span class="line"><span class="comment">//如此反复，直到队列为空</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LevelOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    InitQueue(Q);                  <span class="comment">//初始化辅助队列</span></span><br><span class="line">    BiTree p;                      </span><br><span class="line">    EnQueue(Q,T);                  <span class="comment">//将根结点入队</span></span><br><span class="line">    <span class="keyword">while</span>(!isEmpty(Q))&#123;            <span class="comment">//队列不为空则循环</span></span><br><span class="line">        DeQueue(Q,p);              <span class="comment">//队头结点出队</span></span><br><span class="line">        visit(p);                  <span class="comment">//访问队头结点</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild!=<span class="literal">NULL</span>)</span><br><span class="line">            EnQueue(Q,p-&gt;lchild);  <span class="comment">//左子树不为空，则左子树根结点入队</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild!=<span class="literal">NULL</span>)</span><br><span class="line">            EnQueue(Q,p-&gt;rchild);  <span class="comment">//右子树不为空，则右子树根结点入队</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由遍历构造二叉树</span></span><br><span class="line"><span class="comment">//先序+中序 后序+中序 层序+中序</span></span><br></pre></td></tr></table></figure><h3 id="二叉树常见应用"><a href="#二叉树常见应用" class="headerlink" title="二叉树常见应用"></a>二叉树常见应用</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//求树的深度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">treeDepth</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> l = treeDepth(T-&gt;lchild);</span><br><span class="line">        <span class="type">int</span> r = treeDepth(T-&gt;rchild);</span><br><span class="line">        <span class="comment">//树的深度=Max(左子树深度，右子树深度)+1</span></span><br><span class="line">        <span class="keyword">return</span> l&gt;r ? l+<span class="number">1</span> : r+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//求二叉树带权路径长度</span></span><br><span class="line"><span class="comment">//二叉树带权路径长度为每个叶结点的深度与权值之积的总和，可以使用先序遍历或者层次遍历解决问题</span></span><br><span class="line"><span class="comment">//先序遍历思想：</span></span><br><span class="line"><span class="comment">//用一个static变量记录wpl，把每个结点的深度作为递归函数的一个参数传递</span></span><br><span class="line"><span class="comment">//若该结点为叶结点，则变量wpl加上该结点的深度与权值之和</span></span><br><span class="line"><span class="comment">//若该结点为非叶结点，则左子树不为空，对左子树调用递归算法，右子树不为空，对右子树调用递归算法，深度参数均为本结点的深度参数加1</span></span><br><span class="line"><span class="comment">//最后返回计算出的wpl即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树结点的数据结构定义如下</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">WPL</span><span class="params">(BiTree root)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> wpl_PreOrder(root,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">wpl_PreOrder</span><span class="params">(BiTree root,<span class="type">int</span> deep)</span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> wpl=<span class="number">0</span>;      <span class="comment">//定义变量存储wpl</span></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;lchild==<span class="literal">NULL</span>&amp;&amp;root-&gt;rchild==<span class="literal">NULL</span>)    <span class="comment">//若为叶结点，则累积wpl</span></span><br><span class="line">        <span class="keyword">return</span> wpl+=deep*root-&gt;weight;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;lchild!=<span class="literal">NULL</span>)                        <span class="comment">//若左子树不为空，则对左子树递归遍历</span></span><br><span class="line">        wpl_PreOrder(root-&gt;lchild,deep+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;rchild!=<span class="literal">NULL</span>)                        <span class="comment">//若右子树不为空，则对右子树递归遍历</span></span><br><span class="line">        wpl_PreOrder(root-&gt;rchild,deep+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> wpl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判定给定二叉树是否为完全二叉树</span></span><br><span class="line"><span class="comment">//根据完全二叉树定义，具有n个结点的完全二叉树与满二叉树中编号从1-n的结点一一对应</span></span><br><span class="line"><span class="comment">//算法思想：采用层次遍历算法，将所有结点加入队列（包括空结点）。遇到空结点时，查看其后是否有非空结点。若有，则二叉树不是完全二叉树。</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsComplete</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    InitQueue(Q);</span><br><span class="line">    <span class="keyword">if</span>(!T)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;      <span class="comment">//空树为满二叉树</span></span><br><span class="line">    EnQueue(Q,T);</span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))&#123;</span><br><span class="line">        DeQueue(Q,p);</span><br><span class="line">        <span class="keyword">if</span>(p)&#123;                       <span class="comment">//p不为空结点</span></span><br><span class="line">            EnQueue(Q,p-&gt;lchild);    <span class="comment">//将结点左子树加入队列（可能是空结点）</span></span><br><span class="line">            EnQueue(Q,p-&gt;rchild);    <span class="comment">//将结点右子树加入队列（可能是空结点）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>                         <span class="comment">//结点为空结点</span></span><br><span class="line">            <span class="keyword">while</span>(!IsEmpty(Q))&#123;      <span class="comment">//遇到空结点，就将队列中的元素全部输出，看是否有非空结点</span></span><br><span class="line">                DeQueue(Q,p);</span><br><span class="line">                <span class="keyword">if</span>(p)                <span class="comment">//有非空结点，说明不是完全二叉树</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//采用递归算法实现交换二叉树左右子树</span></span><br><span class="line"><span class="comment">//首先交换b结点的左孩子的左右子树，然后交换b结点的右孩子的左右子树，最后交换b结点的左右子树，当结点为空时递归结束（后序遍历的思想）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(BiTree b)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b)&#123;</span><br><span class="line">        swap(b-&gt;lchild);     <span class="comment">//递归交换左子树</span></span><br><span class="line">        swap(b-&gt;rchild);     <span class="comment">//递归交换右子树</span></span><br><span class="line">        temp=b-&gt;lchild;      <span class="comment">//交换左右孩子结点</span></span><br><span class="line">        b-&gt;lchild=b-&gt;rchild;</span><br><span class="line">        b-&gt;rchild=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//孩子兄弟表示法，求叶子节点个数之和</span></span><br><span class="line"><span class="comment">//当森林以孩子兄弟表示法存储时，若结点没有孩子（fch=NULL），则它必是叶子结点。</span></span><br><span class="line"><span class="comment">//总的叶子结点个数是孩子子树(fch)上的叶子数和兄弟子树(nsib)上的叶结点数之和</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    ElemType data;    <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">fch</span>,*<span class="title">nsib</span>;</span>    <span class="comment">//孩子与兄弟域 </span></span><br><span class="line">&#125;*Tree;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Leaves</span><span class="params">(Tree t)</span>&#123;                 <span class="comment">//计算以孩子兄弟表示法存储的森林的叶子数</span></span><br><span class="line">    <span class="keyword">if</span>(t==<span class="literal">NULL</span>)                     <span class="comment">//树空返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">if</span>(t-&gt;fch==<span class="literal">NULL</span>)                <span class="comment">//若结点无孩子，则该结点必是叶子</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+Leaves(t-&gt;nsib);   <span class="comment">//返回叶结点和其兄弟子树中的叶结点数</span></span><br><span class="line">    <span class="keyword">else</span>                            <span class="comment">//若结点有孩子，则返回孩子子树和兄弟子树中叶子结点个数</span></span><br><span class="line">        <span class="keyword">return</span> Leaves(t-&gt;fch)+Leaves(t-&gt;nsib);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传统的二叉链表存储仅能体现一种父子关系，不能直接得到结点在遍历中的前驱或后继</span></span><br><span class="line"><span class="comment">//在含n个结点的二叉树中，有n+1个空指针，可以利用这些空指针存放指向其前驱或者后驱的指针</span></span><br><span class="line"><span class="comment">//引入线索二叉树就是为了加快查找结点前驱和后继的速度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//规定：若无左子树，令lchild指向其前驱结点；若无右子树，令rchild指向其后继结点</span></span><br><span class="line"><span class="comment">//线索二叉树的结点结构：|lchild|ltag|data|rtag|rchild|</span></span><br><span class="line"><span class="comment">//ltag=0,lchild域指示结点的左孩子；ltag=1,lchild域指示结点的前驱</span></span><br><span class="line"><span class="comment">//rtag=0,rchild域指示结点的右孩子；rtag=1,rchild域指示结点的后继</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线索化的实质就是遍历一次二叉树</span></span><br><span class="line"><span class="comment">//pre指向刚刚访问过的结点，p指向正在访问的结点，即pre指向p的前驱</span></span><br><span class="line"><span class="comment">//中序遍历过程中，检查p的左指针是否为空，若为空则将它指向pre；检查pre的右指针是否为空，若为空则将它指向p</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线索二叉树结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">    ElemType data;                      <span class="comment">//数据元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span>  <span class="comment">//左、右孩子指针</span></span><br><span class="line">    <span class="type">int</span> ltag,rtag;                      <span class="comment">//左、右线索标志</span></span><br><span class="line">&#125;ThreadNode,*ThreadTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量pre，指向当前访问结点的前驱</span></span><br><span class="line">ThreadNode *pre=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序线索化二叉树T</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreatInThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">    pre=<span class="literal">NULL</span>;            <span class="comment">//pre初始为NULL</span></span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;         <span class="comment">//非空二叉树才能线索化</span></span><br><span class="line">        InThread(T);     <span class="comment">//中序线索化二叉树</span></span><br><span class="line">        <span class="keyword">if</span>(pre-&gt;rchild==<span class="literal">NULL</span>)</span><br><span class="line">            pre-&gt;rtag=<span class="number">1</span>;  <span class="comment">//处理遍历的最后一个结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历二叉树，一边遍历一边线索化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        InThread(T-&gt;lchild);   <span class="comment">//中序遍历左子树，线索化左子树</span></span><br><span class="line">        visit(T);              <span class="comment">//访问根结点</span></span><br><span class="line">        InThread(T-&gt;rchild);   <span class="comment">//中序遍历右子树，线索化右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(ThreadNode *q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;lchild==<span class="literal">NULL</span>)&#123; <span class="comment">//左子树为空，建立前驱线索</span></span><br><span class="line">        q-&gt;lchild=pre;</span><br><span class="line">        q-&gt;ltag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre!=<span class="literal">NULL</span>&amp;&amp;pre-&gt;rchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        pre-&gt;rchild=q;   <span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">        pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre=q;               <span class="comment">//标记当前结点成为刚刚访问过的结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//在线索二叉树中找前驱后继</span></span><br><span class="line"><span class="comment">//若ltag/rtag=0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//中序线索二叉树（左根右）</span></span><br><span class="line"><span class="comment">//后继：p的右子树最左下结点；</span></span><br><span class="line"><span class="comment">//前驱：p的左子树最右下结点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//先序线索二叉树（根左右）</span></span><br><span class="line"><span class="comment">//后继</span></span><br><span class="line"><span class="comment">//1.若p有左孩子，则先序后继为其左孩子</span></span><br><span class="line"><span class="comment">//2.若p没有左孩子，则先序后继为其右孩子</span></span><br><span class="line"><span class="comment">//前驱：</span></span><br><span class="line"><span class="comment">//1.若有父结点，且p为左孩子，则前驱为父结点</span></span><br><span class="line"><span class="comment">//2.若有父结点，且p为右孩子，其左兄弟为空，则前驱为父结点</span></span><br><span class="line"><span class="comment">//3.若有父结点，且p为右孩子，其左兄弟非空，则前驱为其左兄弟子树的最后一个被先序遍历的结点</span></span><br><span class="line"><span class="comment">//4.若p为根结点，则p没有先序前驱</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//后序线索二叉树（左右根）</span></span><br><span class="line"><span class="comment">//后继</span></span><br><span class="line"><span class="comment">//1.若p有父结点，且p为右孩子，则其后继为父结点</span></span><br><span class="line"><span class="comment">//2.若p有父结点，且p为左孩子，其右兄弟为空，则其后继为父结点</span></span><br><span class="line"><span class="comment">//3.若p有父结点，且p为左孩子，其右兄弟非空，则其后继为其右兄弟子树中第一个被后序遍历的结点</span></span><br><span class="line"><span class="comment">//4.若p为根结点，则p没有后序后继</span></span><br><span class="line"><span class="comment">//前驱</span></span><br><span class="line"><span class="comment">//1.若p有右孩子，则其前驱为右孩子</span></span><br><span class="line"><span class="comment">//2.若p没有右孩子，则其前驱为左孩子</span></span><br></pre></td></tr></table></figure><h3 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双亲表示法</span></span><br><span class="line"><span class="comment">//顺序存储结点数据，结点中保存父结点在数组中的下标</span></span><br><span class="line"><span class="comment">//利用了每个结点（根结点除外）只有唯一双亲的性质，找父结点很方便，但是求结点的孩子时则需要遍历整个结构</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//孩子表示法</span></span><br><span class="line"><span class="comment">//顺序存储结点数据，结点中保存孩子链表头指针（顺序存储+链式存储）</span></span><br><span class="line"><span class="comment">//寻找子女方便，但是寻找双亲需要遍历n个结点中孩子链表指针域所指向的n个孩子链表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//孩子兄弟表示法（二叉树表示法）</span></span><br><span class="line"><span class="comment">//用二叉链表存储树--左孩子右兄弟</span></span><br><span class="line"><span class="comment">//每个结点包括三部分：结点值，指向结点第一个孩子结点的指针，以及指向结点下一个兄弟结点的指针（沿此域可以找到结点的所有兄弟结点）</span></span><br><span class="line"><span class="comment">//方便实现树转换为二叉树，易于查找结点的孩子</span></span><br></pre></td></tr></table></figure><h3 id="树、森林和二叉树的相互转换"><a href="#树、森林和二叉树的相互转换" class="headerlink" title="树、森林和二叉树的相互转换"></a>树、森林和二叉树的相互转换</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//树转换为二叉树</span></span><br><span class="line"><span class="comment">//左孩子右兄弟</span></span><br><span class="line"><span class="comment">//由于根结点没有兄弟，所以对应二叉树没有右子树</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//森林转换为二叉树</span></span><br><span class="line"><span class="comment">//先将森林中的每棵树转换为二叉树（左孩子右兄弟），把第二棵树根视为第一棵树的右兄弟</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树转换为森林</span></span><br><span class="line"><span class="comment">//二叉树的根和其右子树为第一棵树的二叉树形式，将根的右链断开，以此类推直到最后只剩一棵没有右子树的二叉树为止，再将每棵二叉树转换为树，即得到森林</span></span><br></pre></td></tr></table></figure><h3 id="树和森林的遍历"><a href="#树和森林的遍历" class="headerlink" title="树和森林的遍历"></a>树和森林的遍历</h3><table><thead><tr><th align="center">树</th><th align="center">森林</th><th align="center">二叉树</th></tr></thead><tbody><tr><td align="center">先根遍历</td><td align="center">先序遍历</td><td align="center">先序遍历</td></tr><tr><td align="center"><u><strong>后根遍历</strong></u></td><td align="center">中序遍历</td><td align="center">中序遍历</td></tr></tbody></table><h3 id="哈夫曼树和哈夫曼编码"><a href="#哈夫曼树和哈夫曼编码" class="headerlink" title="哈夫曼树和哈夫曼编码"></a>哈夫曼树和哈夫曼编码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//树的带权路径长度(WPL)=树中所有叶子结点的带权路径长度之和</span></span><br><span class="line"><span class="comment">//哈夫曼树（最优二叉树）：在含有给定的n个带权叶结点的二叉树中，WPL最小的二叉树</span></span><br><span class="line"><span class="comment">//构造哈夫曼树：每次选两个根结点权值最小的树合并，并将二者权值之和作为新的根结点的权值</span></span><br><span class="line"><span class="comment">//哈夫曼树不唯一，但WPL必然都是最小值</span></span><br><span class="line"><span class="comment">//每个初始结点最终都成为叶结点，且权值越小的结点到根结点的路径长度越大</span></span><br><span class="line"><span class="comment">//构建过程中共新建了n-1个结点，哈夫曼树结点总数为2n-1</span></span><br><span class="line"><span class="comment">//哈夫曼树不存在度为1的结点（每次构造都选择两棵树作为新结点的孩子）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//哈夫曼编码</span></span><br><span class="line"><span class="comment">//将每个出现的字符当作一个独立结点，其权值为出现的频数，构造对应的哈夫曼树</span></span><br><span class="line"><span class="comment">//所有的字符结点都会出现在叶结点</span></span><br><span class="line"><span class="comment">//边标记0表示转向左孩子，边标记1表示转向右孩子</span></span><br></pre></td></tr></table></figure><h2 id="图算法"><a href="#图算法" class="headerlink" title="图算法"></a>图算法</h2><h3 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h3><h4 id="邻接矩阵法"><a href="#邻接矩阵法" class="headerlink" title="邻接矩阵法"></a>邻接矩阵法</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//图的邻接矩阵存储结构定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100               <span class="comment">//顶点数目的最大值</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VertexType;               <span class="comment">//顶点的数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> EdgeType;                  <span class="comment">//带权图中边上权值的数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    VertextType Vex[MaxVertexNum];     <span class="comment">//顶点表</span></span><br><span class="line">    EdgeType Edge[MaxVertexNum][MaxVertexNum];  <span class="comment">//邻接矩阵，边表</span></span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;                 <span class="comment">//图的当前顶点数和弧数</span></span><br><span class="line">&#125;MGraph;</span><br><span class="line"><span class="comment">//当邻接矩阵的元素仅表示相应边是否存在时，EdgeType可采用0和1的枚举类型</span></span><br><span class="line"><span class="comment">//无向图的邻接矩阵是对称矩阵，对规模特大的邻接矩阵可采用压缩存储</span></span><br><span class="line"><span class="comment">//邻接矩阵表示法的空间复杂度为O(n^2)，其中n为图的顶点数|V|</span></span><br><span class="line"><span class="comment">//对于无向图，邻接矩阵的第i行（或第i列）的非零元素的个数正好是顶点i的度TD(vi)</span></span><br><span class="line"><span class="comment">//对于有向图，邻接矩阵的第i行的非零元素的个数正好是顶点i的出度OD(vi)，第i列的非零元素个数正好是顶点i的入度ID(vi)</span></span><br><span class="line"><span class="comment">//邻接矩阵存储法容易确定任意两个顶点之间是否有边相连，但是确定多少条边必须按行、按列对各个元素进行检测，所花费时间代价很大</span></span><br><span class="line"><span class="comment">//稠密图适合邻接矩阵的存储表示</span></span><br></pre></td></tr></table></figure><h4 id="邻接表法"><a href="#邻接表法" class="headerlink" title="邻接表法"></a>邻接表法</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//邻接表结合了顺序存储和链式存储方法，减少了空间的浪费</span></span><br><span class="line"><span class="comment">//邻接表是指对每个顶点建立一个单链表，单链表中的结点表示依附于该顶点的边（对于有向图则是以该顶点为尾的弧），这个单链表称为该顶点的边表（对于有向图称为出边表）</span></span><br><span class="line"><span class="comment">//边表的头指针和顶点的数据信息采用顺序存储，称为顶点表</span></span><br><span class="line"><span class="comment">//邻接表中存在两种结点：顶点表结点和边表结点</span></span><br><span class="line"><span class="comment">//顶点表结点由顶点域(data)和指向第一条邻接表的指针(firstarc)构成</span></span><br><span class="line"><span class="comment">//边表结点由邻接点域(adjvex)和指向下一条邻接边的指针域(nextarc)构成</span></span><br><span class="line"><span class="comment">//图的邻接表存储结构定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100               <span class="comment">//顶点数目的最大值</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span>                <span class="comment">//边表结点</span></span><br><span class="line">    <span class="type">int</span> adjvex;                        <span class="comment">//该弧所指向的顶点位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">next</span>;</span>              <span class="comment">//指向下一条弧的指针</span></span><br><span class="line">    <span class="comment">//InfoType info;                   //网的边权值</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span>                  <span class="comment">//顶点表结点</span></span><br><span class="line">    VertextType data;                  <span class="comment">//顶点信息</span></span><br><span class="line">    ArcNode *first;                    <span class="comment">//指向第一条依附于该顶点的弧的指针</span></span><br><span class="line">&#125;VNode,AdjList[MaxVertexNum];</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    AdjList vertices;                  <span class="comment">//邻接表</span></span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;                 <span class="comment">//图的顶点数和弧数</span></span><br><span class="line">&#125;ALGraph;                              <span class="comment">//ALGraph是以邻接表存储的图类型</span></span><br><span class="line"><span class="comment">//对于无向图，邻接表所需存储空间为O(|V|+2|E|)</span></span><br><span class="line"><span class="comment">//对于有向图，邻接表所需存储空间为O(|V|+|E|)</span></span><br><span class="line"><span class="comment">//前者的倍数2是由于在无向图中，每条边在邻接表中出现了两次</span></span><br><span class="line"><span class="comment">//对于稀疏图，采用邻接表将大大节省存储空间</span></span><br><span class="line"><span class="comment">//在邻接表中很容易找到给定一个顶点的所有邻边，因为只需要读取邻接表，而在邻接矩阵中则需要扫描一行，花费的时间为O(n)。</span></span><br><span class="line"><span class="comment">//确定给定两个顶点是否存在边，在邻接矩阵中可以立刻查到，在邻接表中则需要在相应结点对应的边表中查找另一个结点，效率较低</span></span><br><span class="line"><span class="comment">//在有向图的邻接表表示中，求一个给定点的出度只需计算其邻接表中的结点个数；但求入度就要遍历全部的邻接表（可采用逆邻接表的存储方式加速求解入度）</span></span><br><span class="line"><span class="comment">//图的邻接表不唯一</span></span><br></pre></td></tr></table></figure><h3 id="图的基本操作"><a href="#图的基本操作" class="headerlink" title="图的基本操作"></a>图的基本操作</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Adjacent(G,x,y)          //判断图G是否存在边&lt;x,y&gt;</span></span><br><span class="line"><span class="comment">//Neighbors(G,X)           //列出图G中与结点x邻接的边</span></span><br><span class="line"><span class="comment">//InsertVertex(G.x)        //在图G中插入顶点x</span></span><br><span class="line"><span class="comment">//DeleteVertex(G,x)        //从图G中删除顶点x</span></span><br><span class="line"><span class="comment">//AddEdge(G,x,y)           //若无向边(x,y)或有向边&lt;x,y&gt;不存在，则向图G中添加该边</span></span><br><span class="line"><span class="comment">//RemoveEdge(G,x,y)        //若无向边(x,y)或有向边&lt;x,y&gt;存在，则从图G中删除该边</span></span><br><span class="line"><span class="comment">//FirstNeighbor(G,x)       //求图G中顶点x的第一个邻接点，若有则返回顶点号。若x没有邻接点或者图中不存在x则返回-1</span></span><br><span class="line"><span class="comment">//NextNeighbor(G,x,y)      //假设图G中顶点y是顶点x的一个邻接点，返回除y外顶点x的下一个邻接点的顶点号，若y是x的最后一个邻接点，则返回-1</span></span><br><span class="line"><span class="comment">//Get_edge_value(G,x,y)    //获取图G中边(x,y)或&lt;x,y&gt;对应的权值</span></span><br><span class="line"><span class="comment">//Set_edge_value(G,x,y,v)  //设置图G中边(x,y)或&lt;x,y&gt;对应的权值为v</span></span><br></pre></td></tr></table></figure><h3 id="广度优先搜索-BFS"><a href="#广度优先搜索-BFS" class="headerlink" title="广度优先搜索-BFS"></a>广度优先搜索-BFS</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> visited[MAX_VERTEX_NUM];   <span class="comment">//访问标记数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFSTraverse</span><span class="params">(Graph G)</span>&#123;      <span class="comment">//对图G进行广度优先遍历</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i)</span><br><span class="line">        visited[i]=FALSE;       <span class="comment">//访问标记数组初始化</span></span><br><span class="line">    InitQueue(Q);               <span class="comment">//初始化辅助队列Q</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++<span class="number">1</span>)&#123;    <span class="comment">//从0号顶点开始遍历</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[i])&#123;        <span class="comment">//对每个连通分量调用一次BFS</span></span><br><span class="line">            visit(i);           <span class="comment">//访问初始顶点i</span></span><br><span class="line">            visited[i]=TRUE;    <span class="comment">//对i做已访问标记</span></span><br><span class="line">            Enqueue(Q,i);       <span class="comment">//顶点i入队列</span></span><br><span class="line">            <span class="keyword">while</span>(!isEmpty(Q))&#123;</span><br><span class="line">                DeQueue(Q,i);   <span class="comment">//顶点i出队列</span></span><br><span class="line">                <span class="comment">//检测i所有的邻接点</span></span><br><span class="line">                <span class="keyword">for</span>(w=FirstNeighbor(G,i);w&gt;=<span class="number">0</span>;w=NextNeighbor(G,i,w))</span><br><span class="line">                    <span class="keyword">if</span>(!visited[w])&#123;  <span class="comment">//w为i的尚未被访问的邻接顶点</span></span><br><span class="line">                        visit(w);     <span class="comment">//访问顶点w</span></span><br><span class="line">                        visited[w]=TRUE; <span class="comment">//对w做已访问标记</span></span><br><span class="line">                        EnQueue(Q,w);    <span class="comment">//顶点w入队列</span></span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BFS求解单源最短路径问题"><a href="#BFS求解单源最短路径问题" class="headerlink" title="BFS求解单源最短路径问题"></a>BFS求解单源最短路径问题</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//求顶点u到其他顶点的最短路径</span></span><br><span class="line"><span class="comment">//使用BFS可以求解非带权图的单源最短路径问题，因为广度优先搜索总是按照距离由近到远来遍历图中的每一个顶点</span></span><br><span class="line"><span class="comment">//BFS需要一个辅助队列Q，n个顶点均需入队一次，在最坏情况下，空间复杂度为O(|V|)</span></span><br><span class="line"><span class="comment">//采用邻接表存储方式时，每个顶点均需搜索一次（或入队一次），故时间复杂度为O(|V|)，在搜索任意一个顶点的邻接点时，每条边至少访问一次，故时间复杂度为O(|E|)，算法总的时间复杂度为O(|V|+|E|)</span></span><br><span class="line"><span class="comment">//采用邻接矩阵存储方式时，查找每个顶点的邻接点所需时间为O(|V|)，故算法总的时间复杂度为O(|V|^2)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS_MIN_Distance</span><span class="params">(Graph G,<span class="type">int</span> u)</span>&#123;</span><br><span class="line">    <span class="comment">//d[i]表示从u到i结点的最短路径</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++<span class="number">1</span>)&#123;</span><br><span class="line">        d[i]=∞;       <span class="comment">//初始化路径长度</span></span><br><span class="line">        path[i]=<span class="number">-1</span>;   <span class="comment">//最短路径从哪个顶点d过来</span></span><br><span class="line">    &#125;</span><br><span class="line">    d[u]=<span class="number">0</span>;</span><br><span class="line">    visited[u]=TRUE;</span><br><span class="line">    EnQueue(Q,u);</span><br><span class="line">    <span class="keyword">while</span>(!isEmpty(Q))&#123;          <span class="comment">//BFS算法主过程</span></span><br><span class="line">        DeQueue(Q,u);            <span class="comment">//队头元素u出队</span></span><br><span class="line">        <span class="keyword">for</span>(w=FirstNeighbor(G,u);w&gt;=<span class="number">0</span>;w=NextNeighbor(G,u,w))</span><br><span class="line">            <span class="keyword">if</span>(!visited[w])&#123;     <span class="comment">//w为u尚未访问的邻接顶点</span></span><br><span class="line">                d[w]=d[u]+<span class="number">1</span>;     <span class="comment">//路径长度加1</span></span><br><span class="line">                path[w]=u;       <span class="comment">//最短路径应从u到w</span></span><br><span class="line">                visited[w]=TRUE; <span class="comment">//设已访问标记</span></span><br><span class="line">                EnQueue(Q,w);    <span class="comment">//顶点w入队</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="深度优先搜索-DFS"><a href="#深度优先搜索-DFS" class="headerlink" title="深度优先搜索-DFS"></a>深度优先搜索-DFS</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DFS算法是一个递归算法，需要借助一个递归工作栈，故其空间复杂度为O(|V|)</span></span><br><span class="line"><span class="comment">//遍历图的过程实质上是对每个顶点查找其邻接点的过程，其耗费时间取决于所用的存储结构</span></span><br><span class="line"><span class="comment">//以邻接矩阵表示时，查找每个顶点的邻接点所需的时间为O(|V|)，故总的时间复杂度为O(|V|^2)</span></span><br><span class="line"><span class="comment">//以邻接表表示时，查找所有顶点的邻接点所需的时间为O(|E|)，访问顶点所需的时间为O(|V|),总的时间复杂度为O(|V|+|E|)</span></span><br><span class="line"><span class="type">bool</span> visited[MAX_VERTEX_NUM];     <span class="comment">//访问标记数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFSTraverse</span><span class="params">(Graph G)</span>&#123;        <span class="comment">//对图G进行深度优先遍历</span></span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vexnum;++v)</span><br><span class="line">        visited[v]=FALSE;         <span class="comment">//初始化已访问标记数组</span></span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vexnum;++v)</span><br><span class="line">        <span class="keyword">if</span>(!visited[v])</span><br><span class="line">            DFS(G,v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(Graph G,<span class="type">int</span> v)</span>&#123;          <span class="comment">//从顶点v出发，深度优先遍历图G</span></span><br><span class="line">    visit(v);                     <span class="comment">//访问顶点v</span></span><br><span class="line">    visited[v]=TRUE;              <span class="comment">//设已访问标记</span></span><br><span class="line">    <span class="keyword">for</span>(w=FirstNeighbor(G,v);w&gt;=<span class="number">0</span>;w=NextNeighbor(G,v,w))</span><br><span class="line">        <span class="keyword">if</span>(!visited[w])&#123;          <span class="comment">//w为v的尚未访问的邻接顶点</span></span><br><span class="line">            DFS(G,w);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//图的遍历算法可以用来判断图的连通性。</span></span><br><span class="line"><span class="comment">//对于无向图，调用BFS(G,i)或DFS(G,i)的次数等于该图的连通分量；对于有向图并非如此。</span></span><br></pre></td></tr></table></figure><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入排序</span></span><br><span class="line"><span class="comment">//算法思想：每次将一个待排序的记录按其关键字大小插入到前面已排好序的子序列中，直到全部记录插入完成</span></span><br><span class="line"><span class="comment">//直接插入排序</span></span><br><span class="line"><span class="comment">//空间复杂度：O(1)</span></span><br><span class="line"><span class="comment">//时间复杂度：主要来自于对比关键字、移动元素。若有n个元素，则需要n-1趟处理</span></span><br><span class="line"><span class="comment">//最好时间复杂度（全部有序）：O(n)</span></span><br><span class="line"><span class="comment">//共n-1趟处理，每一趟只需要对比关键字一次，不用移动元素</span></span><br><span class="line"><span class="comment">//最坏时间复杂度（全部逆序）：O(n^2)</span></span><br><span class="line"><span class="comment">//共n-1趟处理，每一趟需要对比关键字i+1次，移动元素i+2次</span></span><br><span class="line"><span class="comment">//平均时间复杂度：O(n^2)</span></span><br><span class="line"><span class="comment">//算法稳定性：稳定</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,temp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)            <span class="comment">//将各元素插入已排好序的序列中</span></span><br><span class="line">        <span class="keyword">if</span>(A[i]&lt;A[i<span class="number">-1</span>])&#123;        <span class="comment">//若A[i]关键字小于前驱</span></span><br><span class="line">            temp=A[i];          <span class="comment">//用temp暂存A[i]</span></span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span> &amp;&amp; A[j]&gt;temp;--j)    <span class="comment">//检查所有前面已排好序的元素</span></span><br><span class="line">                A[j+<span class="number">1</span>]=A[j];    <span class="comment">//所有大于temp的元素都向后挪位</span></span><br><span class="line">            A[j+<span class="number">1</span>]=temp;        <span class="comment">//复制到插入位置</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//优化--折半插入排序</span></span><br><span class="line"><span class="comment">//算法思想：先用折半查找找到应该插入的位置，再移动元素</span></span><br><span class="line"><span class="comment">//当low&gt;high时折半查找停止，应将[low,i-1]内的元素全部右移，并将A[0]复制到low所指位置</span></span><br><span class="line"><span class="comment">//当A[mid]==A[0]时，为了保证算法稳定性，应继续在mid所指位置右边寻找插入位置</span></span><br><span class="line"><span class="comment">//比起直接插入排序，比较关键字的次数减少了，但是移动元素的次数没变，整体来看时间复杂度依然是O(n^2)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,low,high,mid;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)&#123;       <span class="comment">//依次将A[2]-A[n]插入前面的已排序序列</span></span><br><span class="line">        A[<span class="number">0</span>]=A[i];           <span class="comment">//将A[i]暂存到A[0]</span></span><br><span class="line">        low=<span class="number">1</span>;               <span class="comment">//设置折半查找的范围</span></span><br><span class="line">        high=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)&#123;    <span class="comment">//折半查找（默认递增有序）</span></span><br><span class="line">            mid=(low+high)/<span class="number">2</span>;<span class="comment">//取中间点</span></span><br><span class="line">            <span class="keyword">if</span>(A[mid]&gt;A[<span class="number">0</span>])  <span class="comment">//查找左半子表</span></span><br><span class="line">                high=mid<span class="number">-1</span>;  </span><br><span class="line">            <span class="keyword">else</span>             <span class="comment">//查找右半子表</span></span><br><span class="line">                low=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=high;--j)</span><br><span class="line">            A[j+<span class="number">1</span>]=A[j];     <span class="comment">//统一后移元素，空出插入位置</span></span><br><span class="line">        A[high+<span class="number">1</span>]=A[<span class="number">0</span>];      <span class="comment">//插入操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="comment">//算法思想：先将待排序表分割成若干形如L[i,i+d,i+2d,...,i+kd]的特殊子表；对每个子表分别进行直接插入排序。缩小增量d，重复上述过程，直到d=1为止。</span></span><br><span class="line"><span class="comment">//空间复杂度：O(1)</span></span><br><span class="line"><span class="comment">//时间复杂度：优于直接插入排序</span></span><br><span class="line"><span class="comment">//稳定性：不稳定</span></span><br><span class="line"><span class="comment">//适用性：仅可用于顺序表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShellSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> d,i,j;</span><br><span class="line">    <span class="comment">//A[0]只是暂存单元，当j&lt;=0时，插入位置已到</span></span><br><span class="line">    <span class="keyword">for</span>(d=n/<span class="number">2</span>;d&gt;=<span class="number">1</span>;d=d/<span class="number">2</span>)     <span class="comment">//步长变化</span></span><br><span class="line">        <span class="keyword">for</span>(i=d+<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="keyword">if</span>(A[i]&lt;A[i-d])&#123;  <span class="comment">//需要将A[i]插入有序增量子表</span></span><br><span class="line">                A[<span class="number">0</span>]=A[i];    <span class="comment">//暂存在A[0]</span></span><br><span class="line">                <span class="keyword">for</span>(j=i-d;j&gt;<span class="number">0</span>&amp;&amp;A[<span class="number">0</span>]&lt;A[j];j-=d)</span><br><span class="line">                    A[j+d]=A[j];  <span class="comment">//记录后移，查找要插入的位置</span></span><br><span class="line">                A[j+d]=A[<span class="number">0</span>];      <span class="comment">//插入</span></span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="comment">//算法思想：从后往前（或从前往后）两两比较相邻元素的值，若为逆序，则交换它们，直到序列比较完，称这样过程为一趟冒泡排序，最多只需n-1趟排序</span></span><br><span class="line"><span class="comment">//每一趟排序都可以使一个元素移动到最终位置，已经确定最终位置的元素在之后的处理中无需再对比</span></span><br><span class="line"><span class="comment">//如果某一趟排序过程中未发生交换，则算法可提前结束</span></span><br><span class="line"><span class="comment">//空间复杂度：O(1)</span></span><br><span class="line"><span class="comment">//时间复杂度：</span></span><br><span class="line"><span class="comment">//最好情况（有序）：O(n)，比较次数=n-1，交换次数=0</span></span><br><span class="line"><span class="comment">//最坏情况（逆序）：O(n^2)，比较次数=(n-1)+(n-2)+...+1=n(n-1)/2=交换次数,</span></span><br><span class="line"><span class="comment">//最坏情况下要移动3n(n-1)/2（每次交换都需要移动元素三次）</span></span><br><span class="line"><span class="comment">//平均时间复杂度=O(n^2)</span></span><br><span class="line"><span class="comment">//稳定性：稳定（只有A[j-1]&gt;A[i]时才交换）</span></span><br><span class="line"><span class="comment">//适用性：顺序表、链表都可以</span></span><br><span class="line"><span class="comment">//在i所指位置之前的元素都已经有序了</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="type">bool</span> flag=<span class="literal">false</span>;          <span class="comment">//表示本趟冒泡是否发生交换的标志</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=n<span class="number">-1</span>;j&gt;i;j--)    <span class="comment">//一趟冒泡排序</span></span><br><span class="line">            <span class="keyword">if</span>(A[j<span class="number">-1</span>]&gt;A[j])&#123;      <span class="comment">//若为逆序</span></span><br><span class="line">                swap(A[j<span class="number">-1</span>],A[j]);<span class="comment">//交换</span></span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span>;               <span class="comment">//本趟遍历后没有发生交换，说明表已经有序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="comment">//算法思想：在待排序表L[1..n]中任取一个元素pivot作为枢轴（或基准，通常取首元素），通过一趟排序将待排序表划分成独立的两部分L[1...k-1]和L[k+1...n],使得L[1...k-1]中的所有元素小于pivot，L[k+1...n]中的所有元素大于等于pivot，则pivot放在了其最终位置L[k]上，这个过程称为一次划分，然后分别递归地对这两个子表重复上述过程，直至每部分内只有一个元素或空为止，即所有元素放在了其最终位置上</span></span><br><span class="line"><span class="comment">//快速排序是所有内部排序算法中平均性能最优的排序算法</span></span><br><span class="line"><span class="comment">//其算法表现主要取决于递归深度，若每次划分越均匀，则递归深度越低；划分越不均匀，递归深度越深</span></span><br><span class="line"><span class="comment">//n个结点的二叉树，最小高度=⌊log2n⌋+1，最大高度=n</span></span><br><span class="line"><span class="comment">//空间复杂度=O(递归层数)：最好（O(log2n)）；最坏（O(n)）</span></span><br><span class="line"><span class="comment">//时间复杂度=O(n*递归层数)</span></span><br><span class="line"><span class="comment">//最好时间复杂度（O(nlog2n)）-每次选的枢轴元素都能将序列划分成均匀地两部分；</span></span><br><span class="line"><span class="comment">//最坏时间复杂度（O(n^2)）-若序列原本就有序或者逆序，则时间、空间复杂度最高</span></span><br><span class="line"><span class="comment">//平均时间复杂度（O(nlog2n)）</span></span><br><span class="line"><span class="comment">//稳定性：不稳定</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">        <span class="type">int</span> pivotpos=Partition(A,low,high);  <span class="comment">//划分</span></span><br><span class="line">        QuickSort(A,low,pivotpos<span class="number">-1</span>);         <span class="comment">//划分左子表</span></span><br><span class="line">        QuickSort(A,pivotpos+<span class="number">1</span>，high);        <span class="comment">//划分右子表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用第一个元素将待排序序列划分成左右两个部分</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Partition</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot=A[low];       <span class="comment">//第一个元素作为枢轴</span></span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)&#123;        <span class="comment">//用low和high搜索枢轴的最终位置</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;A[high]&gt;=pivot) </span><br><span class="line">            --high;</span><br><span class="line">        A[low]=A[high];     <span class="comment">//比枢轴小的元素移动到左端</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;A[low]&lt;=pivot)</span><br><span class="line">            ++low;          <span class="comment">//比枢轴大的元素移动到右端</span></span><br><span class="line">        A[high]=A[low];</span><br><span class="line">    &#125;</span><br><span class="line">    A[low]=pivot;           <span class="comment">//枢轴元素存放到最终位置</span></span><br><span class="line">    <span class="keyword">return</span> low;             <span class="comment">//返回存放枢轴的最终位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//选择排序（简单选择排序、堆排序）</span></span><br><span class="line"><span class="comment">//算法思想：每一趟（如第i趟）在后面n-i+1(i=1,2,..,n-1)个待排序元素中选取关键字最小的元素，作为有序子序列的第i个元素，直到第n-1趟做完，待排序元素就剩下一个，就不需要再选。</span></span><br><span class="line"><span class="comment">//简单选择排序</span></span><br><span class="line"><span class="comment">//算法思想：每趟在待排序元素中选取关键字最小的元素加入有序子序列，第i趟排序即从L[i...n]中选取关键字最小的元素与L(i)交换，每一趟排序可以确定一个元素的最终位置，这样经过n-1趟排序就可以使得整个排序表有序</span></span><br><span class="line"><span class="comment">//必须进行n-1趟处理</span></span><br><span class="line"><span class="comment">//空间复杂度：O(1)</span></span><br><span class="line"><span class="comment">//时间复杂度：O(n^2)</span></span><br><span class="line"><span class="comment">//元素移动次数不会超过3(n-1)次，最好的情况是移动0次（初始有序）</span></span><br><span class="line"><span class="comment">//元素间比较的次数与序列初始状态无关，始终为n(n-1)/2</span></span><br><span class="line"><span class="comment">//稳定性：不稳定</span></span><br><span class="line"><span class="comment">//适用性：顺序表、链表都可以</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(EmlemType A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;      <span class="comment">//一共进行n-1趟</span></span><br><span class="line">        <span class="type">int</span> min=i;               <span class="comment">//记录最小元素位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)   <span class="comment">//在A[i..n-1]中选择最小元素</span></span><br><span class="line">            <span class="keyword">if</span>(A[j]&lt;A[min])      <span class="comment">//更新最小元素位置</span></span><br><span class="line">                min=j; </span><br><span class="line">        <span class="keyword">if</span>(min!=i)              </span><br><span class="line">            swap(A[i],A[min]);   <span class="comment">//封装的swap()共移动元素3次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="comment">//堆-顺序存储的完全二叉树</span></span><br><span class="line"><span class="comment">//结点i的左孩子是2i；右孩子是2i+1；父节点是⌊i/2⌋</span></span><br><span class="line"><span class="comment">//编号=&lt;n/2的结点都是分支结点</span></span><br><span class="line"><span class="comment">//大根堆（根&gt;=左、右）小根堆（根&lt;=左、右）</span></span><br><span class="line"><span class="comment">//空间复杂度：O(1)</span></span><br><span class="line"><span class="comment">//时间复杂度：建堆：O(n)+排序：O(nlog2n)=O(nlog2n)</span></span><br><span class="line"><span class="comment">//结论：一个结点，每下坠一层，最多只需对比关键字两次</span></span><br><span class="line"><span class="comment">//若树高为h，某结点在第i层，则将这个结点向下调整最多只需要下坠h-i层，关键字对比次数不超过2(h-i)</span></span><br><span class="line"><span class="comment">//n个结点的完全二叉树树高h=⌊log2n⌋+1</span></span><br><span class="line"><span class="comment">//建堆的过程，关键字对比次数不超过4n，建堆时间复杂度=O(n)</span></span><br><span class="line"><span class="comment">//堆排序总共需要n-1趟，每一趟交换后都需要将根结点下坠调整</span></span><br><span class="line"><span class="comment">//根结点最多下坠h-1层，每下坠一层，最多需要对比关键字2次，所以每一趟排序复杂度不超过O(h)=O(log2n)</span></span><br><span class="line"><span class="comment">//共n-1趟，总的时间复杂度=O(nlog2n)</span></span><br><span class="line"><span class="comment">//稳定性：不稳定</span></span><br><span class="line"><span class="comment">//基于大根堆的堆排序得到递增序列，基于小根堆的堆排序得到递减序列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//首先建堆，建堆的主要思想是从后调整所有的非终端结点，即结点数除以二向下取整，对于每个结点调用HeadAdjust算法，调整恢复堆的性质，通过这样来建立大根堆；然后第一个元素和最后一个元素交换破环堆，然后调整，如此n-1次（最后一个结点无需排序），每次都是先将堆顶元素和堆底元素交换，然后进行调整，交换一次就能获得一个最大（小）值，排好了一次序</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//建立大根堆</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BuildMaxHeap</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--)  <span class="comment">//从后往前调整所有非终端结点</span></span><br><span class="line">        HeadAdjust(A,i,len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆排序的完整逻辑</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> len)</span>&#123;</span><br><span class="line">    BuildMaxHeap(A,len);       <span class="comment">//初始建堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len;i&gt;<span class="number">1</span>;i--)&#123;    <span class="comment">//n-1趟的交换和建堆过程</span></span><br><span class="line">        swap(A[i],A[<span class="number">1</span>]);       <span class="comment">//堆顶元素和堆底元素交换</span></span><br><span class="line">        HeadAdjust(A,<span class="number">1</span>,i<span class="number">-1</span>);   <span class="comment">//把剩余的待排序元素整理成堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将以k为根的子树调整成大根堆</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeadAdjust</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> k,<span class="type">int</span> len)</span>&#123;</span><br><span class="line">    A[<span class="number">0</span>]=A[k];                  <span class="comment">//A[0]暂存子树的根结点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>*k;i&lt;=len;i*=<span class="number">2</span>)&#123; <span class="comment">//沿key较大的子结点向下筛选</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;len&amp;&amp;A[i]&lt;A[i+<span class="number">1</span>])  <span class="comment">//左孩子2i小于右孩子2i+1（左右孩子一样大，优先和左孩子交换）</span></span><br><span class="line">            i++;                <span class="comment">//取key较大的子结点的下标</span></span><br><span class="line">        <span class="keyword">if</span>(A[<span class="number">0</span>]&gt;=A[i])          <span class="comment">//筛选结束</span></span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        <span class="keyword">else</span>&#123;       </span><br><span class="line">            A[k]=A[i];          <span class="comment">//将A[i]调整到双亲结点上</span></span><br><span class="line">            k=i;                <span class="comment">//修改k值，以便继续向下筛选</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[k]=A[<span class="number">0</span>];                  <span class="comment">//被筛选结点的值放入最终位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="comment">//归并是将两个或两个以上的有序表合并成一个新的有序表</span></span><br><span class="line"><span class="comment">//2路归并排序：假设待排序表含有n个记录，则可将其视为n个有序的子表，每个子表长度为1，然后两两归并，得到⌈n/2⌉个长度为2或1的有序表；继续两两归并，如此重复直到合并成一个长度为n的有序表为止</span></span><br><span class="line"><span class="comment">//Merge()的功能是将前后相邻的两个有序表归并成一个有序表</span></span><br><span class="line"><span class="comment">//设两段有序表A[low...mid]、A[mid+1...high]存放在同一顺序表中的相邻位置，先将它们复制到辅助数组B中。每次从对应B中的两个段取出一个记录进行关键字的比较，把较小者放入A中。当数组B中有一段的下标超过其对应的表长（即该段的所有元素都已复制到A中）时，将另一段中的剩余部分直接复制到A中。</span></span><br><span class="line">ElemType *B=(ElemType *)<span class="built_in">malloc</span>((n+<span class="number">1</span>)*<span class="keyword">sizeof</span>(ElemType)); <span class="comment">//辅助数组B</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge</span><span class="params">(ElemType A[],<span class="type">int</span> low,<span class="type">int</span> mid,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="comment">//表A的两段A[low...mid]和A[mid+1...high]各自有序，把他们合成一个有序表</span></span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">for</span>(k=low;k&lt;=high;k++)</span><br><span class="line">        B[k]=A[k];          <span class="comment">//将A所有元素复制到B中</span></span><br><span class="line">    <span class="comment">//每次从B的两段取出一个记录进行关键字比较，较小的放入A中</span></span><br><span class="line">    <span class="comment">//限制条件：i、j不超过各自的段；k是A的下标；一轮比较出A的一个元素</span></span><br><span class="line">    <span class="keyword">for</span>(i=low,j=mid+<span class="number">1</span>,k=i;i&lt;=mid&amp;&amp;j&lt;=high;k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(B[i]&lt;=B[j])      <span class="comment">//比较B的左右两段中的元素</span></span><br><span class="line">            A[k]=B[i++];    <span class="comment">//将较小值复制到A中</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            A[k]=B[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以下两个while循环只会执行一个</span></span><br><span class="line">    <span class="keyword">while</span>(j&lt;=mid)           <span class="comment">//若第一个表未检测完，复制</span></span><br><span class="line">        A[k++]=B[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=high)          <span class="comment">//若第二个表未检测完，复制</span></span><br><span class="line">        A[k++]=B[j++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一趟归并排序会调用⌈n/2h⌉次算法merge()，将L[1...n]中前后相邻且长度为h的有序段进行两两归并，得到前后相邻、长度为2h的有序段，整个归并排序需要进行⌈log2n⌉趟</span></span><br><span class="line"><span class="comment">//递归形式的2路归并排序算法基于分治，分为分解和合并两个过程</span></span><br><span class="line"><span class="comment">//分解：将含有n个元素的待排序表分为各含n/2个元素的子表，采用2路归并排序算法对两个子表递归地进行排序</span></span><br><span class="line"><span class="comment">//合并：合并两个已排序的子表得到排序结果</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSort</span><span class="params">(Elemtype A[],<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(low+high)/<span class="number">2</span>;     <span class="comment">//从中间划分成两个子序列</span></span><br><span class="line">        MergeSort(A,low,mid);     <span class="comment">//对左侧子序列进行递归排序</span></span><br><span class="line">        MergeSort(A,mid+<span class="number">1</span>,high);  <span class="comment">//对右侧子序列进行递归排序</span></span><br><span class="line">        Merge(A,low,mid,high);    <span class="comment">//归并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2路归并的归并树在形态上是一棵倒立的二叉树</span></span><br><span class="line"><span class="comment">//二叉树的第h层最多有2^(h-1)个结点</span></span><br><span class="line"><span class="comment">//若树高为h，则应满足n&lt;=2^(h-1)，即h-1=⌈log2n⌉</span></span><br><span class="line"><span class="comment">//结论：n个元素进行2路归并排序，归并趟数等于⌈log2n⌉</span></span><br><span class="line"><span class="comment">//每趟归并时间复杂度为O(n),则算法时间复杂度为O(nlog2n)</span></span><br><span class="line"><span class="comment">//空间复杂度=O(n),来自于辅助数组B</span></span><br><span class="line"><span class="comment">//稳定性：稳定</span></span><br></pre></td></tr></table></figure><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基数排序</span></span><br><span class="line"><span class="comment">//基数排序不是基于比较的排序算法</span></span><br><span class="line"><span class="comment">//算法思想：将整个关键字拆分成d位，按照各个关键字位权重递增的次序（如：个，十，百），做d趟分配和收集</span></span><br><span class="line"><span class="comment">//若当前处理的关键字位可能取得r个值，则需要建立r个队列</span></span><br><span class="line"><span class="comment">//分配：顺序扫描各个元素，根据当前处理的关键字位，将元素插入相应队列，一趟分配耗时O(n)</span></span><br><span class="line"><span class="comment">//收集：把各个队列中的结点依次出队并链接，一趟收集耗时O(r)</span></span><br><span class="line"><span class="comment">//空间复杂度：O(r)[r个队列]</span></span><br><span class="line"><span class="comment">//时间复杂度：O(d(n+r))[做d趟分配和收集，一趟分配耗时O(n)，一趟收集耗时O(r)，所以时间复杂度为O(d(n+r))]</span></span><br><span class="line"><span class="comment">//稳定性：稳定</span></span><br><span class="line"><span class="comment">//擅长处理：</span></span><br><span class="line"><span class="comment">//1.数据元素关键字可方便拆分为d组，且d较小</span></span><br><span class="line"><span class="comment">//2.每组关键字取值范围不大，即r较小</span></span><br><span class="line"><span class="comment">//3.数据元素个数n较大</span></span><br></pre></td></tr></table></figure><h3 id="排序算法总结"><a href="#排序算法总结" class="headerlink" title="排序算法总结"></a>排序算法总结</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//平均时间复杂度（时间快）：快些归队（快速排序[O(nlog2n)]，希尔排序[O(n^(1/3))]，归并排序[O(nlog2n)]，堆排序[O(nlog2n)]）</span></span><br><span class="line"><span class="comment">//不稳定的算法：快些选一堆好友来聊天（快速排序，希尔排序，选择排序，堆排序）</span></span><br><span class="line"><span class="comment">//折半插入排序是在直接插入排序的基础上建立的，只是通过使用折半查找算法减少了数据对象的比较次数，但移动次数没有发生改变，所以时间复杂度为O(n^2)</span></span><br><span class="line"><span class="comment">//直接插入，直接比元素，找插入位置平均时间复杂度为O(n)</span></span><br><span class="line"><span class="comment">//折半插入，对半比元素，找插入位置平均时间复杂度为O(log2n)</span></span><br><span class="line"><span class="comment">//每次排序都能至少确定一个元素在其最终位置上的排序算法有：快速排序，选择排序，堆排序，冒泡排序（快速选择一堆帽子）</span></span><br><span class="line"><span class="comment">//元素的移动次数与关键字的初始序列无关的是：基数排序（基数排序不是基于比较的排序算法）</span></span><br><span class="line"><span class="comment">//元素的比较次数与关键字的初始序列无关的是：选择排序（简单选择排序，堆排序）、归并排序、折半插入排序</span></span><br><span class="line"><span class="comment">//算法时间复杂度与关键字初始序列无关的是：选择排序（简单选择排序O(n^2)、堆排序O(nlog2n)）、归并排序(2路O(nlog2n))、基数排序O(d(n+r))</span></span><br><span class="line"><span class="comment">//算法的排序趟数与关键字初始序列无关的是：插入排序（直接插入排序，折半插入排序，希尔排序）、选择排序（简单选择排序、堆排序）、归并排序、基数排序</span></span><br><span class="line"><span class="comment">//算法的排序趟数与关键字初始序列有关的是：冒泡排序、快速排序</span></span><br><span class="line"><span class="comment">//简单选择排序比较次数始终为n(n-1)/2，与关键字的初始序列无关，选择或交换次数为n-1趟（交换次数≠移动次数，待排序序列中确定了最小元素，再与第一个元素交换，因为交换次数与趟数一样）</span></span><br><span class="line"><span class="comment">//简单选择排序记录移动次数较少，当待排序列为正序时，移动次数最少，为0次，当为逆序时，移动次数最多，为3(n-1)次</span></span><br><span class="line"><span class="comment">//m路归并，每选出一个元素需要比较关键字m-1次</span></span><br><span class="line"><span class="comment">//快速排序：时间复杂度=O(n*递归层数) 最好：O(nlog2n) 最坏：O(n^2)</span></span><br><span class="line"><span class="comment">//空间复杂度=O(递归层数) 最好：O(log2n) 最坏：O(n)</span></span><br><span class="line"><span class="comment">//若n较小，可以采用直接插入排序或简单选择排序</span></span><br><span class="line"><span class="comment">//当记录本身信息量较大时，用简单选择排序较好（直接插入排序所需的记录移动次数较简单选择排序的多）</span></span><br><span class="line"><span class="comment">//若文件的初始状态已按关键字基本有序，则采用直接插入排序或冒泡排序（若此时采用快速排序，时间复杂度为O(n^2)）</span></span><br><span class="line"><span class="comment">//快速排序被认为是目前基于比较的内部排序方法中最好的方法，待排序的关键字随机分布时，快速排序的平均时间最短</span></span><br><span class="line"><span class="comment">//若n较大，则应该采用时间复杂度为O(nlog2n)的排序算法：快速排序、堆排序、归并排序</span></span><br><span class="line"><span class="comment">//要求排序稳定且时间复杂度为O(nlog2n)，则选用归并排序</span></span><br><span class="line"><span class="comment">//若n很大，记录的关键字位数较少且可以分解时，采用基数排序</span></span><br><span class="line"><span class="comment">//当记录本身信息量较大，为避免耗费大量时间移动记录，可用链表作为存储结构</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自我 debug：修复人格代码 bug</title>
      <link href="/FRank675.github.io/posts/2a399c28c129/"/>
      <url>/FRank675.github.io/posts/2a399c28c129/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\FRank675.github.io\css\APlayer.min.css"><script src="\FRank675.github.io\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\FRank675.github.io\js\Meting.min.js"></script><p>在实习的经历中，我的leader是个非常喜欢复盘、反思的人，向他学习，在这里反思自己的缺点，希望可以监督自己修改吧</p><h1 id="拖延症"><a href="#拖延症" class="headerlink" title="拖延症"></a>拖延症</h1><p><strong>具体表现：</strong>经常把事情拖延到ddl前才匆忙把事情做完，导致自己难受也使得事情做的不好不完善；每次都想着提前做完，但是总是拖延，没有给自己规定一个时间去完成，导致拖拖拉拉。</p><p><strong>解决办法：</strong>提前规划，比如说下周一要截至的任务，把它提前到这周六，提前完成任务，一方面给自己成就感，另一方面避免因为拖延而导致任务无法及时完成。</p><h1 id="意志力不够坚定"><a href="#意志力不够坚定" class="headerlink" title="意志力不够坚定"></a>意志力不够坚定</h1><p><strong>具体表现：</strong>在做一件事情的时候，遇到一点阻力就想放弃，阻力常常表现为不熟悉的领域、不确定的结论、不充足的时间，导致事情越来越糟糕。</p><p><strong>解决办法：</strong></p><h1 id="懒散"><a href="#懒散" class="headerlink" title="懒散"></a>懒散</h1><p><strong>具体表现：</strong>间歇性踌躇满志，持续性混吃等死。心里是对美好的未来有憧憬的，但是经常无法坚持，会间歇地努力几天，但是没办法一直坚持，容易思想懒散。</p>]]></content>
      
      
      <categories>
          
          <category> 个人 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反思 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hdw-dubbo微服务开发平台-搭建记录</title>
      <link href="/FRank675.github.io/posts/47cf844ae0b7/"/>
      <url>/FRank675.github.io/posts/47cf844ae0b7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="DUBBO系统搭建"><a href="#DUBBO系统搭建" class="headerlink" title="DUBBO系统搭建"></a>DUBBO系统搭建</h1><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><ul><li>hdw-dubbo微服务开发平台，具有统一授权、认证后台管理系统，其中包含具备用户管理、资源权限管理等多个模块，支持多业务系统并行开发，可以作为后端服务的开发脚手架。代码简洁，架构清晰，适合学习和直接项目中使用。</li><li>核心技术采用SpringBoot、Dubbo、Mybatis、Mybatis-plus、Druid、Redis、ActiveMQ、Quartz、JWT Token等主要框架和中间件。前端采用vue-element-ui组件。</li><li>前后端分离，通过token进行数据交互，可独立部署</li><li>灵活的权限控制，可控制到页面或按钮，满足绝大部分的权限需求</li><li>页面交互使用Vue2.x，极大的提高了开发效率</li><li>完善的代码生成机制，可在线生成entity、xml、dao、service、vue、sql代码，减少70%以上的开发任务</li><li>引入dubbo服务治理</li><li>引入quartz定时任务，可动态完成任务的添加、修改、删除、暂停、恢复及日志查看等功能</li><li>引入API模板，根据token作为登录令牌，极大的方便了APP接口开发</li><li>引入Hibernate Validator校验框架，轻松实现后端校验</li><li>引入swagger文档支持，方便编写API接口文档</li></ul><h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><table><thead><tr><th>平台</th><th>hdw-dubbo（后端）</th><th>hdw-dubbo-ui（前端）</th></tr></thead><tbody><tr><td>GitHub</td><td><a href="https://gitee.com/link?target=https://github.com/JacksonTu/hdw-dubbo">https://github.com/JacksonTu/hdw-dubbo</a></td><td><a href="https://gitee.com/link?target=https://github.com/JacksonTu/hdw-dubbo-ui">https://github.com/JacksonTu/hdw-dubbo-ui</a></td></tr><tr><td>Gitee</td><td><a href="https://gitee.com/tumao2/hdw-dubbo">https://gitee.com/tumao2/hdw-dubbo</a></td><td><a href="https://gitee.com/tumao2/hdw-dubbo-ui">https://gitee.com/tumao2/hdw-dubbo-ui</a></td></tr></tbody></table><h2 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h2><h3 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h3><ul><li>Java1.8 (v1.8.0_131+)</li><li>Nacos服务发现和注册中心(v1.4.2+)<a href="https://gitee.com/link?target=https://github.com/alibaba/nacos/releases/download/2.0.3/nacos-server-2.0.3.zip">下载地址</a></li><li>Redis (v3.2.100+)</li><li>ActiveMQ(v5.15.8+)<a href="https://gitee.com/link?target=http://activemq.apache.org/components/classic/download/">下载地址</a></li><li>RabbitMq (v3.7+)（需安装rabbitmq_delayed_message_exchange插件 <a href="https://gitee.com/link?target=https://www.rabbitmq.com/community-plugins.html">下载地址</a>）</li><li>Mysql (v5.7.26+)</li><li>Maven (v3+)</li><li>Nodejs (v10.16.0+)</li></ul><h3 id="后端配置"><a href="#后端配置" class="headerlink" title="后端配置"></a>后端配置</h3><h4 id="数据库配置"><a href="#数据库配置" class="headerlink" title="数据库配置"></a>数据库配置</h4><p>数据库sql文件：后端项目下的docs&#x2F;sql&#x2F;hdw_dubbo.sql</p><p>1.进入MySQL：mysql -u root -p (其中root是指我们的数据库用户名为root，后续可视具体情况修改)</p><p>然后输入密码Anxin@123即可进入数据库</p><p>2.进入数据库后创建数据库hdw_dubbo；</p><p>执行create database hdw_dubbo; （分号别漏了）</p><p>3.修改所有的涉及到Mysql的yml文件（可以全局搜索driver-class-name来定位），</p><p>修改为如下内容：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">jdbc:mysql://172.21.3.144:3306/hdw_dubbo?autoReconnect=true&amp;useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line"><span class="attr">username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">Anxin@123</span></span><br></pre></td></tr></table></figure><h4 id="Redis配置"><a href="#Redis配置" class="headerlink" title="Redis配置"></a>Redis配置</h4><p>修改yml文件中的redis配置，参考如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">redis:</span></span><br><span class="line">  <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">host:</span> <span class="number">172.21</span><span class="number">.6</span><span class="number">.217</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">gxltest123</span></span><br><span class="line">  <span class="attr">timeout:</span> <span class="string">3600ms</span></span><br><span class="line">  <span class="comment">#    cluster:</span></span><br><span class="line">  <span class="comment">#      max-redirects: 3</span></span><br><span class="line">  <span class="comment">#      nodes: 127.0.0.1:7000, 127.0.0.1:7001, 127.0.0.1:7002, 127.0.0.1:7003, 127.0.0.1:7004,127.0.0.1:7005</span></span><br><span class="line">  <span class="attr">lettuce:</span></span><br><span class="line">    <span class="attr">pool:</span></span><br><span class="line">      <span class="attr">max-active:</span> <span class="number">100</span></span><br><span class="line">      <span class="attr">max-idle:</span> <span class="number">100</span></span><br><span class="line">      <span class="attr">min-idle:</span> <span class="number">50</span></span><br><span class="line">      <span class="attr">max-wait:</span> <span class="string">6000ms</span></span><br><span class="line">    <span class="attr">shutdown-timeout:</span> <span class="string">100ms</span></span><br></pre></td></tr></table></figure><h4 id="Nacos配置"><a href="#Nacos配置" class="headerlink" title="Nacos配置"></a>Nacos配置</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cloud:</span></span><br><span class="line">  <span class="attr">nacos:</span></span><br><span class="line">    <span class="attr">discovery:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">172.21</span><span class="number">.2</span><span class="number">.198</span><span class="string">:8848</span></span><br></pre></td></tr></table></figure><h4 id="dubbo配置"><a href="#dubbo配置" class="headerlink" title="dubbo配置"></a>dubbo配置</h4><p>只要修改registry即可，主要是修改address：将其中的ip改完你的nacos地址</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">registry:</span></span><br><span class="line">  <span class="attr">id:</span> <span class="string">hdw-registry</span></span><br><span class="line">  <span class="attr">address:</span> <span class="string">spring-cloud://172.21.2.198</span></span><br><span class="line">  <span class="attr">file:</span> <span class="string">/output/cache/$&#123;dubbo.application.id&#125;.cache</span></span><br><span class="line">  <span class="attr">timeout:</span> <span class="number">5000</span></span><br><span class="line">  <span class="attr">session:</span> <span class="number">60000</span></span><br><span class="line">  <span class="attr">check:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>修改完这些配置后，初始化maven项目：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn clean</span><br><span class="line">mvn package</span><br></pre></td></tr></table></figure><p>得到的jar包可以在docker目录下看到</p><p>将项目传输到&#x2F;root&#x2F;gxl&#x2F;dubbo目录下（172.21.1.189）</p><p>依次执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nohup java -jar /root/gxl/dubbo/hdw-dubbo-master/docker/sever-base/hdw-server-base.jar &amp;</span><br><span class="line">nohup java -jar /root/gxl/dubbo/hdw-dubbo-master/docker/server-notice/hdw-server-notice.jar &amp;</span><br><span class="line">nohup java -jar /root/gxl/dubbo/hdw-dubbo-master/docker/web-base/hdw-web-base.jar &amp;</span><br></pre></td></tr></table></figure><p>需要注意必须依次执行，且必须保证前一个jar包执行完毕才能执行下一个</p><p>可以通过命令查看jar包执行情况：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tail -f nohup.out</span><br></pre></td></tr></table></figure><p>需要注意的是：部署该系统时需要打开外网！</p><p>以下是部署后端时可能遇到的问题以及尝试可行的解决办法：</p><p>报错：[com.alibaba.dubbo.config.AbstractConfig|]-[WARN] [DUBBO] Connection refused,</p><p><a href="https://github.com/alibaba/spring-cloud-alibaba/issues/1243">dubbo. registry.address:配置spring-cloud:&#x2F;&#x2F;localhost或者不配置启动会报错，但最终能注册成功 · Issue #1243 · alibaba&#x2F;spring-cloud-alibaba · GitHub</a></p><p><a href="https://blog.csdn.net/u014636209/article/details/88983118?spm=1001.2101.3001.6650.3&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-3-88983118-blog-103926113.235%5Ev28%5Epc_relevant_t0_download&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-3-88983118-blog-103926113.235%5Ev28%5Epc_relevant_t0_download&amp;utm_relevant_index=4">https://blog.csdn.net/u014636209/article/details/88983118?spm=1001.2101.3001.6650.3&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-3-88983118-blog-103926113.235%5Ev28%5Epc_relevant_t0_download&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-3-88983118-blog-103926113.235%5Ev28%5Epc_relevant_t0_download&amp;utm_relevant_index=4</a></p><h3 id="前端配置"><a href="#前端配置" class="headerlink" title="前端配置"></a>前端配置</h3><p>1.安装淘宝NPM镜像</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line">npm config set registry  https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>2.将locallhost换成本地IP地址，具体操作参考如下：</p><p><a href="https://blog.csdn.net/weixin_41620505/article/details/123229597">(115条消息) vue2 配置本地IP地址访问项目_can be overwritten by process.env.host_夢鑰的博客-CSDN博客</a></p><p>4.修改请求接口地址</p><p>简单操作，可以直接搜索localhost，将包括的接口里的localhost全部修改为172.21.1.189，即你要部署的服务器的ip地址</p><p>3.运行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cnpm install </span><br><span class="line">npm run dev</span><br><span class="line">npm run build  #打包</span><br></pre></td></tr></table></figure><p>打包后可以得到dist文件</p><p>将前端项目传输到&#x2F;root&#x2F;gxl&#x2F;dubbo路径下（172.21.1.189）</p><p>执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nohup npm start &amp;</span><br></pre></td></tr></table></figure><p>等待部署完成后即可</p><p>以下是部署前端时可能遇到的问题以及尝试可行的解决办法：</p><p>前端node-sass安装失败，请关注node-sass和node版本的对应关系</p><p><a href="https://blog.csdn.net/fwdwqdwq/article/details/123191380?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-4-123191380-blog-129423760.235%5Ev28%5Epc_relevant_t0_download&spm=1001.2101.3001.4242.3&utm_relevant_index=7">(115条消息) node node-sass sass-loader版本对应问题_查看nodesass版本_普通网友的博客-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 系统搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件能效平台-搭建记录</title>
      <link href="/FRank675.github.io/posts/e3ba0bc0895e/"/>
      <url>/FRank675.github.io/posts/e3ba0bc0895e/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="Software-Engineering-Productivity-Platform"><a href="#Software-Engineering-Productivity-Platform" class="headerlink" title="Software Engineering Productivity Platform"></a>Software Engineering Productivity Platform</h1><h1 id="软件能效平台"><a href="#软件能效平台" class="headerlink" title="软件能效平台"></a>软件能效平台</h1><h2 id="系统介绍"><a href="#系统介绍" class="headerlink" title="系统介绍"></a>系统介绍</h2><p>基于Vue2、Element UI、SpringBoot框架，用于软件研发流程管理支持以及其过程数据分析度量、质量保证技术的集成</p><h2 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h2><p>前端：<a href="https://github.com/purang-fintech/seppf.git">https://github.com/purang-fintech/seppf.git</a><br>后端：<a href="https://github.com/purang-fintech/seppb.git">https://github.com/purang-fintech/seppb.git</a></p><h2 id="配置教程"><a href="#配置教程" class="headerlink" title="配置教程"></a>配置教程</h2><h3 id="数据库配置"><a href="#数据库配置" class="headerlink" title="数据库配置"></a>数据库配置</h3><p>（服务器ip：172.21.3.144；MySQL登录账户密码：root Anxin@123）</p><p>1.进入MySQL：mysql -u root -p (其中root是指我们的数据库用户名为root，后续可视具体情况修改)</p><p>然后输入密码Anxin@123即可进入数据库</p><p>2.进入数据库后执行create database sepp; （分号别漏了）</p><p>3.修改spring.properties文件，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jdbc.url=jdbc:mysql:<span class="comment">//172.21.3.144:3306/sepp？useUnicode=true&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;autoReconnect=true&amp;useSSL=false jdbc.username=root jdbc.password=Anxin@123</span></span><br></pre></td></tr></table></figure><p>需要注意的是，由于原作者数据库使用的账户密码是加密后的，所以在后续调用时会进行解密，我们使用的是未加密的所以不需要解密这一步，因此需执行以下操作</p><p>修改src&#x2F;main&#x2F;java&#x2F;com&#x2F;pr&#x2F;sepp&#x2F;common&#x2F;config&#x2F;factory&#x2F;DefinitionPropertySourceFactory.java文件，</p><p>将buildDecryptProperties方法修改为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Properties <span class="title function_">buildDecryptProperties</span><span class="params">(InputStream inputStream)</span> <span class="keyword">throws</span> IOException &#123; <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>(); properties.load(inputStream); properties.setProperty(JDBC_UNAME_PROP, properties.getProperty(JDBC_UNAME_PROP)); properties.setProperty(JDBC_PWD_PROP,properties.getProperty(JDBC_PWD_PROP));                                                                                                       <span class="keyword">return</span> properties; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>4.数据库文件导入</p><p>将conf&#x2F;database&#x2F;whole目录下的两个sql文件sepp_ddl.sql和sepp_dml.sql文件传输到机器172.21.3.144 gxl目录下，cd ~&#x2F;gxl，执行mysql -u root -p，输入密码，然后执行以下命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use sepp；</span><br><span class="line"></span><br><span class="line">source sepp_ddl.sql;</span><br><span class="line"></span><br><span class="line">source sepp_dml.sql;</span><br></pre></td></tr></table></figure><p>至此则将数据库导入并建立好表</p><p>5.若数据库库版本较高（大于7），则需要以下操作：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select @@global.sql_mode</span><br><span class="line"></span><br><span class="line">set global sql_mode=&#x27;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#x27;; </span><br></pre></td></tr></table></figure><p>但该方法在重启Mysql服务后会失效，重启服务后会失效，需要重复进行该操作</p><h3 id="前端配置"><a href="#前端配置" class="headerlink" title="前端配置"></a>前端配置</h3><p>node版本：v12.22.10</p><p>npm版本：6.14.16</p><p>进入node官网 node.js官网 选择v12.22.10下载安装node，具体配置参考(102条消息) node.js和npm的安装与环境配置（2021最新版）安装npm小绵杨Yancy的博客-CSDN博客</p><p>安装后可以在控制台输入node -v以及npm -v查看是否安装成功</p><p>安装成功后执行npm install</p><p>将config&#x2F;dev.env.js中的ROOT_URL修改为你的后端接口，<a href="http://172.18.0.64:8082/sepp/">http://172.18.0.64:8082/sepp/</a></p><p>将config&#x2F;prod.env.js中的ROOT_URL修改为你的后端接口，<a href="http://172.18.0.64:8082/sepp/">http://172.18.0.64:8082/sepp/</a></p><p>将前端项目传输到172.21.1.189的&#x2F;root&#x2F;gxl&#x2F;seppf-master路径下</p><p>在&#x2F;root&#x2F;gxl&#x2F;seppf-master路径下执行</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">nohup npm start &amp;</span><br></pre></td></tr></table></figure><p>至此前端配置完成</p><h3 id="后端配置"><a href="#后端配置" class="headerlink" title="后端配置"></a>后端配置</h3><p>修改日志文件路径：</p><p>修改src&#x2F;main&#x2F;java&#x2F;com&#x2F;pr&#x2F;sepp&#x2F;common&#x2F;config&#x2F;factory&#x2F;DefinitionPropertySourceFactory.java的postProcessEnvironment方法默认路径，”&#x2F;opt&#x2F;sqcs_backend&#x2F;spring.properties”，没有的话需要自己创建目录</p><p>在quartz添加节点</p><p>修改pom.xml文件，ctr+F搜索quartz，在quartz的exclusions节点下添加如下代码：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zaxxer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>HikariCP-java7<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br></pre></td></tr></table></figure><p>执行mvn clean package，得到jar包sepp-1.0.jar</p><p>将后端项目传输到172.21.1.189的&#x2F;root&#x2F;gxl&#x2F;seppb-master路径下</p><p>在根目录下创建目录&#x2F;opt&#x2F;sqcs_backend，执行以下目录</p><p>cd &#x2F;</p><p>mkdir -r &#x2F;opt&#x2F;sqcs_backend</p><p>然后启动</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">nohup java -jar /root/gxl/seppb-master/target/sepp-<span class="number">1.0</span>.jar &amp;</span><br></pre></td></tr></table></figure><p>在谷歌浏览器中打开 <a href="http://http//172.21.1.189/:8080">http://http://172.21.1.189/:8080</a></p>]]></content>
      
      
      <categories>
          
          <category> 系统搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令——touch命令</title>
      <link href="/FRank675.github.io/posts/d98ea350b62e/"/>
      <url>/FRank675.github.io/posts/d98ea350b62e/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="Linux命令——touch命令"><a href="#Linux命令——touch命令" class="headerlink" title="Linux命令——touch命令"></a>Linux命令——touch命令</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>touch命令用于修改文件或者目录的时间属性，包括访问时间、状态更改时间和内容修改时间。</p><p>默认情况，若文件不存在，系统会建立一个新的文件。</p><h2 id="2-命令格式"><a href="#2-命令格式" class="headerlink" title="2.命令格式"></a>2.命令格式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">touch [<span class="variable constant_">OPTION</span>]... <span class="variable constant_">FILE</span>...</span><br></pre></td></tr></table></figure><h2 id="3-选项说明"><a href="#3-选项说明" class="headerlink" title="3.选项说明"></a>3.选项说明</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">-a：改变档案的访问时间。</span><br><span class="line">-c,--no-create：假如目的档案不存在，不会建立新的档案。</span><br><span class="line">-d, --date=<span class="variable constant_">STRING</span>：使用指定的时间修改文件时间属性，而非当前时间。</span><br><span class="line">-f：不使用，是为了与其他<span class="title class_">Unix</span>系统的相容性而保留。</span><br><span class="line">-h, --no-dereference：只改变符号链接的时间属性，而不是链接的文件。</span><br><span class="line">-m：改变档案的修改时间。</span><br><span class="line">-r,--reference=<span class="variable constant_">FILE</span>：使用参考档的时间记录，而不是当前时间。</span><br><span class="line">-t <span class="variable constant_">STAMP</span>：设定档案的时间记录，格式与date指令相同。</span><br><span class="line">--help 列出指令格式。</span><br><span class="line">--version 列出版本信息。</span><br></pre></td></tr></table></figure><h2 id="4-常用示例"><a href="#4-常用示例" class="headerlink" title="4.常用示例"></a>4.常用示例</h2><h3 id="（1）改变文件为当前系统时间。"><a href="#（1）改变文件为当前系统时间。" class="headerlink" title="（1）改变文件为当前系统时间。"></a>（1）改变文件为当前系统时间。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">touch filename</span><br></pre></td></tr></table></figure><h3 id="（2）如果目标文件不存在，则新建一个文件"><a href="#（2）如果目标文件不存在，则新建一个文件" class="headerlink" title="（2）如果目标文件不存在，则新建一个文件"></a>（2）如果目标文件不存在，则新建一个文件</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">touch filename</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令——sed命令</title>
      <link href="/FRank675.github.io/posts/86e40a8114e1/"/>
      <url>/FRank675.github.io/posts/86e40a8114e1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="Linux命令——sed命令"><a href="#Linux命令——sed命令" class="headerlink" title="Linux命令——sed命令"></a>Linux命令——sed命令</h1><h2 id="1-功能简介"><a href="#1-功能简介" class="headerlink" title="1.功能简介"></a>1.功能简介</h2><p>sed(Stream EDitor)是一种流文件编辑器，它一次处理一行内容。</p><p>处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。</p><p>接着处理下一行，直到文件末尾。文件内容并没有改变，除非使用-i选项。sed主要用来编辑一个或多个文件，简化对文件的反复操作或者用来编写转换程序等。</p><p>sed功能同awk类似，差别在于，sed简单，对列处理的功能要差一些，awk功能复杂，对列处理的功能比较强大。</p><h2 id="2-命令格式"><a href="#2-命令格式" class="headerlink" title="2.命令格式"></a>2.命令格式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sed [-nefr] [动作]</span><br></pre></td></tr></table></figure><h2 id="3-选项说明"><a href="#3-选项说明" class="headerlink" title="3.选项说明"></a>3.选项说明</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">选项：</span><br><span class="line">-n,--quiet,--silent：使用安静模式。sed的一般用法中，所有来自<span class="variable constant_">STDIN</span> 的数据一般都会被打印到终端上，如果加上-n后，则只有经过sed特殊处理的那一行(或者动作)才会被列出来。</span><br><span class="line">-e &lt;script&gt;,--expression=&lt;script&gt;：将脚本文件作为sed的命令来执行；</span><br><span class="line">-f &lt;script-file&gt;,--file=&lt;script-file&gt;：直接将sed的动作写在一个文件内，-f filename则可以运行filename 内的sed动作；</span><br><span class="line">-r,--regexp-extended：sed支持扩展正则表达式(默认是基础正则表达式)。</span><br><span class="line">-i ：直接修改读取的文件内容，而不是输出到终端。</span><br><span class="line">--help：显示帮助。</span><br><span class="line">--version：显示版本。</span><br><span class="line"></span><br><span class="line">动作说明：[n1[,n2]]<span class="keyword">function</span></span><br><span class="line">n1, n2 ：不见得会存在，一般代表『选择进行动作的行数』，举例来说，如果我的动作是需要在 <span class="number">10</span> 到 <span class="number">20</span> 行之间进行的，则『 <span class="number">10</span>,<span class="number">20</span>[动作行为] 』</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>：</span><br><span class="line">a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～</span><br><span class="line">c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！</span><br><span class="line">d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；</span><br><span class="line">i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；</span><br><span class="line">p ：列印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～</span><br><span class="line">s ：替换，通常这个s的动作可以搭配正规表示法！例如 <span class="number">1</span>,20s/old/<span class="keyword">new</span>/g。</span><br></pre></td></tr></table></figure><h2 id="4-典型示例"><a href="#4-典型示例" class="headerlink" title="4.典型示例"></a>4.典型示例</h2><h3 id="4-1删除行操作"><a href="#4-1删除行操作" class="headerlink" title="4.1删除行操作"></a>4.1删除行操作</h3><h4 id="（1）将-x2F-etc-x2F-passwd-的内容列出并且列印行号，同时，请将第-2-5-行删除。"><a href="#（1）将-x2F-etc-x2F-passwd-的内容列出并且列印行号，同时，请将第-2-5-行删除。" class="headerlink" title="（1）将 &#x2F;etc&#x2F;passwd 的内容列出并且列印行号，同时，请将第 2~5 行删除。"></a>（1）将 &#x2F;etc&#x2F;passwd 的内容列出并且列印行号，同时，请将第 2~5 行删除。</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[b3335@<span class="variable constant_">MIC</span> ~]$ nl -n ln /etc/passwd | sed <span class="string">&#x27;2,5d&#x27;</span></span><br><span class="line"><span class="number">1</span> <span class="attr">root</span>:<span class="attr">x</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="attr">root</span>:<span class="regexp">/root:/</span>bin/bash</span><br><span class="line"><span class="number">6</span> <span class="attr">sync</span>:<span class="attr">x</span>:<span class="number">5</span>:<span class="number">0</span>:<span class="attr">sync</span>:<span class="regexp">/sbin:/</span>bin/sync</span><br><span class="line"><span class="number">7</span> <span class="attr">shutdown</span>:<span class="attr">x</span>:<span class="number">6</span>:<span class="number">0</span>:<span class="attr">shutdown</span>:<span class="regexp">/sbin:/</span>sbin/shutdown</span><br><span class="line">.....(后面省略).....</span><br></pre></td></tr></table></figure><p>注意：原本应该是要下达 sed -e 才对，当只有一个动作的时候，没有 -e 也行，但是多于一个动作时必须要使用-e选项来指定动作。同时也要注意的是， sed 后面接的动作，请务必以两个单引号括住。</p><h4 id="（2）只要删除第-2-行。"><a href="#（2）只要删除第-2-行。" class="headerlink" title="（2）只要删除第 2 行。"></a>（2）只要删除第 2 行。</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">nl /etc/passwd | sed <span class="string">&#x27;2d&#x27;</span> </span><br></pre></td></tr></table></figure><h4 id="（3）要删除第-3-到最后一行"><a href="#（3）要删除第-3-到最后一行" class="headerlink" title="（3）要删除第 3 到最后一行"></a>（3）要删除第 3 到最后一行</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">nl /etc/passwd | sed <span class="string">&#x27;3,$d&#x27;</span> </span><br></pre></td></tr></table></figure><h3 id="4-2新增行操作"><a href="#4-2新增行操作" class="headerlink" title="4.2新增行操作"></a>4.2新增行操作</h3><h4 id="（1）在第二行后加上”I-like-drinking-tea”。"><a href="#（1）在第二行后加上”I-like-drinking-tea”。" class="headerlink" title="（1）在第二行后加上”I like drinking tea”。"></a>（1）在第二行后加上”I like drinking tea”。</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[b3335@<span class="variable constant_">MIC</span> ~]$ nl -n ln /etc/passwd | sed <span class="string">&#x27;2a I like drinking tea&#x27;</span></span><br><span class="line"><span class="number">1</span>   <span class="attr">root</span>:<span class="attr">x</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="attr">root</span>:<span class="regexp">/root:/</span>bin/bash</span><br><span class="line"><span class="number">2</span>   <span class="attr">bin</span>:<span class="attr">x</span>:<span class="number">1</span>:<span class="number">1</span>:<span class="attr">bin</span>:<span class="regexp">/bin:/</span>sbin/nologin</span><br><span class="line">I like drinking tea</span><br><span class="line"><span class="number">3</span>   <span class="attr">daemon</span>:<span class="attr">x</span>:<span class="number">2</span>:<span class="number">2</span>:<span class="attr">daemon</span>:<span class="regexp">/sbin:/</span>sbin/nologin</span><br><span class="line">.....(后面省略).....</span><br></pre></td></tr></table></figure><h4 id="（2）那如果是要在第二行前加入。"><a href="#（2）那如果是要在第二行前加入。" class="headerlink" title="（2）那如果是要在第二行前加入。"></a>（2）那如果是要在第二行前加入。</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">nl /etc/passwd | sed <span class="string">&#x27;2i drink tea&#x27;</span></span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">nl /etc/passwd | sed <span class="string">&#x27;1a drink tea&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="（3）在第二行后面加入两行，”I-like-drinking-tea”与”I-like-drinking-beer”。"><a href="#（3）在第二行后面加入两行，”I-like-drinking-tea”与”I-like-drinking-beer”。" class="headerlink" title="（3）在第二行后面加入两行，”I like drinking tea”与”I like drinking beer”。"></a>（3）在第二行后面加入两行，”I like drinking tea”与”I like drinking beer”。</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[b3335@<span class="variable constant_">MIC</span> ~]$ nl -n ln /etc/passwd | sed <span class="string">&#x27;2a I like drinking tea\nI like drinking beer&#x27;</span></span><br><span class="line"><span class="number">1</span>       <span class="attr">root</span>:<span class="attr">x</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="attr">root</span>:<span class="regexp">/root:/</span>bin/bash</span><br><span class="line"><span class="number">2</span>       <span class="attr">bin</span>:<span class="attr">x</span>:<span class="number">1</span>:<span class="number">1</span>:<span class="attr">bin</span>:<span class="regexp">/bin:/</span>sbin/nologin</span><br><span class="line">I like drinking tea</span><br><span class="line">I like drinking beer</span><br><span class="line"><span class="number">3</span>       <span class="attr">daemon</span>:<span class="attr">x</span>:<span class="number">2</span>:<span class="number">2</span>:<span class="attr">daemon</span>:<span class="regexp">/sbin:/</span>sbin/nologin</span><br><span class="line">…（后面省略）…</span><br></pre></td></tr></table></figure><p>或者每一行使用反斜杠\来分开，就可以在命令行中将一条命令分开多行输入，如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[b3335@<span class="variable constant_">MIC</span> ~]$ nl -n ln /etc/passwd | sed <span class="string">&#x27;2a I like drinking tea\</span></span><br><span class="line"><span class="string">&gt; I like drinking beer&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="4-3替换行操作"><a href="#4-3替换行操作" class="headerlink" title="4.3替换行操作"></a>4.3替换行操作</h3><h4 id="（1）将第2-5行的内容替换成为”No-2-5-number”。"><a href="#（1）将第2-5行的内容替换成为”No-2-5-number”。" class="headerlink" title="（1）将第2-5行的内容替换成为”No 2-5 number”。"></a>（1）将第2-5行的内容替换成为”No 2-5 number”。</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[b3335@<span class="variable constant_">MIC</span> ~]$ nl -nln /etc/passwd | sed <span class="string">&#x27;2,5c No 2-5 number&#x27;</span></span><br><span class="line"><span class="number">1</span>       <span class="attr">root</span>:<span class="attr">x</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="attr">root</span>:<span class="regexp">/root:/</span>bin/bash</span><br><span class="line"><span class="title class_">No</span> <span class="number">2</span>-<span class="number">5</span> number</span><br><span class="line"><span class="number">6</span>       <span class="attr">sync</span>:<span class="attr">x</span>:<span class="number">5</span>:<span class="number">0</span>:<span class="attr">sync</span>:<span class="regexp">/sbin:/</span>bin/sync</span><br><span class="line">.....(后面省略).....</span><br></pre></td></tr></table></figure><h3 id="4-4选择行打印"><a href="#4-4选择行打印" class="headerlink" title="4.4选择行打印"></a>4.4选择行打印</h3><h4 id="（1）仅列出-x2F-etc-x2F-passwd-文件内的第-5-7-行。"><a href="#（1）仅列出-x2F-etc-x2F-passwd-文件内的第-5-7-行。" class="headerlink" title="（1）仅列出 &#x2F;etc&#x2F;passwd 文件内的第 5-7 行。"></a>（1）仅列出 &#x2F;etc&#x2F;passwd 文件内的第 5-7 行。</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[root@www ~]# nl -nln /etc/passwd | sed -n <span class="string">&#x27;5,7p&#x27;</span></span><br><span class="line"><span class="number">5</span> <span class="attr">lp</span>:<span class="attr">x</span>:<span class="number">4</span>:<span class="number">7</span>:<span class="attr">lp</span>:<span class="regexp">/var/</span>spool/<span class="attr">lpd</span>:<span class="regexp">/sbin/</span>nologin</span><br><span class="line"><span class="number">6</span> <span class="attr">sync</span>:<span class="attr">x</span>:<span class="number">5</span>:<span class="number">0</span>:<span class="attr">sync</span>:<span class="regexp">/sbin:/</span>bin/sync</span><br><span class="line"><span class="number">7</span> <span class="attr">shutdown</span>:<span class="attr">x</span>:<span class="number">6</span>:<span class="number">0</span>:<span class="attr">shutdown</span>:<span class="regexp">/sbin:/</span>sbin/shutdown</span><br></pre></td></tr></table></figure><h3 id="4-5数据的查找并进行相关操作"><a href="#4-5数据的查找并进行相关操作" class="headerlink" title="4.5数据的查找并进行相关操作"></a>4.5数据的查找并进行相关操作</h3><h4 id="（1）数据的查找并显示"><a href="#（1）数据的查找并显示" class="headerlink" title="（1）数据的查找并显示"></a>（1）数据的查找并显示</h4><p>搜索 &#x2F;etc&#x2F;passwd有root关键字的行并输出。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[b3335@<span class="variable constant_">MIC</span> ~]$ nl /etc/passwd | sed -n <span class="string">&#x27;/root/p&#x27;</span></span><br><span class="line"><span class="number">1</span>   <span class="attr">root</span>:<span class="attr">x</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="attr">root</span>:<span class="regexp">/root:/</span>bin/bash</span><br><span class="line"><span class="number">11</span>  <span class="attr">operator</span>:<span class="attr">x</span>:<span class="number">11</span>:<span class="number">0</span>:<span class="attr">operator</span>:<span class="regexp">/root:/</span>sbin/nologin</span><br></pre></td></tr></table></figure><h4 id="（2）数据的查找并删除"><a href="#（2）数据的查找并删除" class="headerlink" title="（2）数据的查找并删除"></a>（2）数据的查找并删除</h4><p>删除&#x2F;etc&#x2F;passwd所有包含root的行，其他行输出。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[b3335@<span class="variable constant_">MIC</span> ~]$ nl /etc/passwd | sed  <span class="string">&#x27;/root/d&#x27;</span></span><br><span class="line"><span class="number">2</span>  <span class="attr">daemon</span>:<span class="attr">x</span>:<span class="number">1</span>:<span class="number">1</span>:<span class="attr">daemon</span>:<span class="regexp">/usr/</span><span class="attr">sbin</span>:<span class="regexp">/bin/</span>sh</span><br><span class="line"><span class="number">3</span>  <span class="attr">bin</span>:<span class="attr">x</span>:<span class="number">2</span>:<span class="number">2</span>:<span class="attr">bin</span>:<span class="regexp">/bin:/</span>bin/sh</span><br><span class="line">…（下面忽略）…</span><br></pre></td></tr></table></figure><p>如果想删除匹配的字符串，使用如下命令：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[b3335@<span class="variable constant_">MIC</span> ~]$ nl /etc/passwd | sed  <span class="string">&#x27;s/root//g&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="（3）数据的查找并替换"><a href="#（3）数据的查找并替换" class="headerlink" title="（3）数据的查找并替换"></a>（3）数据的查找并替换</h4><p>除了整行的处理模式之外， sed 还可以用行为单位进行部分数据的搜寻并取代。基本上 sed 的搜寻与替代的与 vi 相当的类似！他有点像这样：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/被取代的字串/新的字串/g&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="（4）数据的搜寻并执行命令"><a href="#（4）数据的搜寻并执行命令" class="headerlink" title="（4）数据的搜寻并执行命令"></a>（4）数据的搜寻并执行命令</h4><p>搜索&#x2F;etc&#x2F;passwd,找到root对应的行，执行后面花括号中的一组命令，每个命令之间用分号分隔，这里把bash替换为blueshell，再输出这行：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">nl /etc/passwd | sed -n <span class="string">&#x27;/root/&#123;s/bash/blueshell/;p&#125;&#x27;</span></span><br><span class="line"><span class="number">1</span>  <span class="attr">root</span>:<span class="attr">x</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="attr">root</span>:<span class="regexp">/root:/</span>bin/blueshell</span><br></pre></td></tr></table></figure><p>如果只替换&#x2F;etc&#x2F;passwd的第一个bash关键字为blueshell，就退出</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">nl /etc/passwd | sed -n <span class="string">&#x27;/bash/&#123;s/bash/blueshell/;p;q&#125;&#x27;</span>    </span><br><span class="line"><span class="number">1</span>  <span class="attr">root</span>:<span class="attr">x</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="attr">root</span>:<span class="regexp">/root:/</span>bin/blueshell</span><br></pre></td></tr></table></figure><h3 id="4-6多点编辑"><a href="#4-6多点编辑" class="headerlink" title="4.6多点编辑"></a>4.6多点编辑</h3><p>一条sed命令，删除&#x2F;etc&#x2F;passwd第三行到末尾的数据，并把bash替换为blueshell</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">nl /etc/passwd | sed -e <span class="string">&#x27;3,$d&#x27;</span> -e <span class="string">&#x27;s/bash/blueshell/&#x27;</span></span><br><span class="line"><span class="number">1</span>  <span class="attr">root</span>:<span class="attr">x</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="attr">root</span>:<span class="regexp">/root:/</span>bin/blueshell</span><br><span class="line"><span class="number">2</span>  <span class="attr">daemon</span>:<span class="attr">x</span>:<span class="number">1</span>:<span class="number">1</span>:<span class="attr">daemon</span>:<span class="regexp">/usr/</span><span class="attr">sbin</span>:<span class="regexp">/bin/</span>sh</span><br></pre></td></tr></table></figure><p>-e表示多点编辑，第一个编辑命令删除&#x2F;etc&#x2F;passwd第三行到末尾的数据，第二条命令搜索bash替换为blueshell。</p><h3 id="4-7直接修改文件"><a href="#4-7直接修改文件" class="headerlink" title="4.7直接修改文件"></a>4.7直接修改文件</h3><p>sed 可以直接修改文件的内容，不必使用管道命令或数据流重导向！ </p><p>不过，由於这个动作会直接修改到原始的文件，</p><p>所以请你千万不要随便拿系统配置来测试，使用时也要慎重。</p><p>我们使用下载的regular_express.txt 文件来测试看看吧！</p><p>利用 sed 将 regular_express.txt 内每一行结尾若为 . 则换成 !</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[root@www ~]# sed -i <span class="string">&#x27;s/\.$/!/g&#x27;</span> regular_express.<span class="property">txt</span></span><br></pre></td></tr></table></figure><p>利用 sed 直接在 regular_express.txt 最后一行加入”# This is a test”。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[root@www ~]# sed -i <span class="string">&#x27;$a # This is a test&#x27;</span> regular_express.<span class="property">txt</span></span><br></pre></td></tr></table></figure><p>由於 $ 代表的是最后一行，而 a 的动作是新增，因此该文件最后新增”# This is a test”。</p><p>sed 的-i选项可以直接修改文件内容，这功能非常有帮助！</p><p>举例来说，如果你有一个 100 万行的文件，你要在第 100 行加某些文字，此时使用 vim 可能会疯掉！因为文件太大了！那怎办？就利用 sed 啊！透过 sed 直接修改&#x2F;取代的功能，你甚至不需要使用 vim 去修订！</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令——scp命令</title>
      <link href="/FRank675.github.io/posts/3b4e095cdd12/"/>
      <url>/FRank675.github.io/posts/3b4e095cdd12/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="Linux命令——scp命令"><a href="#Linux命令——scp命令" class="headerlink" title="Linux命令——scp命令"></a>Linux命令——scp命令</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>scp（secure copy）命令是一个基于SSH安全的进行远程文件拷贝命令，用于在Linux下进行远程拷贝文件，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp支持对传输的数据进行加密。</p><h2 id="2-命令格式"><a href="#2-命令格式" class="headerlink" title="2.命令格式"></a>2.命令格式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">scp [-1246BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file] [-l limit] [-o ssh_option] [-P port] [-S program][[user@]<span class="attr">host1</span>:]file1 ... [[user@]<span class="attr">host2</span>:]file2</span><br></pre></td></tr></table></figure><h2 id="3-选项说明"><a href="#3-选项说明" class="headerlink" title="3.选项说明"></a>3.选项说明</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">-<span class="number">1</span>：使用ssh协议版本<span class="number">1</span>；</span><br><span class="line">-<span class="number">2</span>：使用ssh协议版本<span class="number">2</span>；</span><br><span class="line">-<span class="number">4</span>：使用ipv4；</span><br><span class="line">-<span class="number">6</span>：使用ipv6；</span><br><span class="line">-B：以批处理模式运行，阻止scp询问口令；</span><br><span class="line">-C：使用压缩，将-C标志传递给ssh，从而打开压缩功能；</span><br><span class="line">-c [cipher]：使用指定的秘钥对传输的文件进行加密；</span><br><span class="line">-F [ssh_config]：指定ssh配置文件；</span><br><span class="line">-i [identity_file]：从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh；</span><br><span class="line">-l [limit]：指定宽带限制；</span><br><span class="line">-o [ssh_option]：指定使用的ssh选项，可以使用ssh_config中使用的ssh选项；</span><br><span class="line">-P [port]：指定远程主机的端口号；</span><br><span class="line">-p：保留文件的最后修改时间，最后访问时间和权限模式；</span><br><span class="line">-q：<span class="title class_">Quiet</span> mode，不显示复制进度以及来自ssh的警告和诊断消息；</span><br><span class="line">-r：以递归方式复制整个目录;</span><br><span class="line">-S [program]：指定加密传输时所使用的程序。此程序必须能够理解ssh的选项；</span><br><span class="line">-v：使用冗余模式，使scp和ssh打印调试信息以及进度。</span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong>  </p><p>（1）scp返回0成功，&gt;0失败；  </p><p>（2）使用scp在不同主机之间进行文件传输，需要确保两台设备都开启了ssh远程登录服务，且两台设备能互相通信；  </p><p>（3）使用scp命令要确保使用的用户具有可读取远程服务器相应文件的权限，否则scp命令是无法起作用的。</p><h2 id="4-常用示例"><a href="#4-常用示例" class="headerlink" title="4.常用示例"></a>4.常用示例</h2><h3 id="（1）远程主机之间，使用scp拷贝多个文件。"><a href="#（1）远程主机之间，使用scp拷贝多个文件。" class="headerlink" title="（1）远程主机之间，使用scp拷贝多个文件。"></a>（1）远程主机之间，使用scp拷贝多个文件。</h3><p><strong>方法一：</strong>将多个文件放在同一个目录中，使用<code>scp -r</code> 来拷贝，参考如下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">scp -r uername@<span class="attr">sourceHostName</span>:sourcedir username@<span class="attr">destinationHostName</span>:destinationdir</span><br></pre></td></tr></table></figure><p><strong>方法二：</strong> 将多个文件或者目录使用tar打包后作为单个文件传输。</p><p><strong>方法三：</strong> scp支持同时拷贝多个文件的功能，示例如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">scp file1  file2 remote_username@<span class="attr">remote_ip</span>:remote_folder </span><br></pre></td></tr></table></figure><h3 id="（2）从本地复制文件到远程。"><a href="#（2）从本地复制文件到远程。" class="headerlink" title="（2）从本地复制文件到远程。"></a>（2）从本地复制文件到远程。</h3><p>命令格式：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">scp local_file  remote_username@<span class="attr">remote_ip</span>:remote_folder </span><br><span class="line">或者 </span><br><span class="line">scp local_file remote_username@<span class="attr">remote_ip</span>:remote_file </span><br><span class="line">或者 </span><br><span class="line">scp local_file <span class="attr">remote_ip</span>:remote_folder </span><br><span class="line">或者 </span><br><span class="line">scp local_file <span class="attr">remote_ip</span>:remote_file </span><br></pre></td></tr></table></figure><p>第1,2个指定了用户名，命令执行后需要再输入密码，第1个仅指定了远程的目录，文件名字不变，第2个指定了文件名；  </p><p>第3,4个没有指定用户名，命令执行后需要输入用户名和密码，第3个仅指定了远程的目录，文件名字不变，第4个指定了文件名；</p><p>应用实例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">scp /home/space/music/<span class="number">1.</span>mp3 root@www.<span class="property">runoob</span>.<span class="property">com</span>:<span class="regexp">/home/</span>root/others/music </span><br><span class="line">scp /home/space/music/<span class="number">1.</span>mp3 root@www.<span class="property">runoob</span>.<span class="property">com</span>:<span class="regexp">/home/</span>root/others/music/<span class="number">001</span>.<span class="property">mp3</span> </span><br><span class="line">scp /home/space/music/<span class="number">1.</span>mp3 www.<span class="property">runoob</span>.<span class="property">com</span>:<span class="regexp">/home/</span>root/others/music </span><br><span class="line">scp /home/space/music/<span class="number">1.</span>mp3 www.<span class="property">runoob</span>.<span class="property">com</span>:<span class="regexp">/home/</span>root/others/music/<span class="number">001</span>.<span class="property">mp3</span> </span><br></pre></td></tr></table></figure><h3 id="（3）使用scp复制目录。"><a href="#（3）使用scp复制目录。" class="headerlink" title="（3）使用scp复制目录。"></a>（3）使用scp复制目录。</h3><p>命令格式：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">scp -r local_folder remote_username@<span class="attr">remote_ip</span>:remote_folder </span><br><span class="line">或者 </span><br><span class="line">scp -r local_folder <span class="attr">remote_ip</span>:remote_folder</span><br></pre></td></tr></table></figure><p>第1个指定了用户名，命令执行后需要再输入密码；  </p><p>第2个没有指定用户名，命令执行后需要输入用户名和密码；</p><p>应用实例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">scp -r /home/space/music/ root@www.<span class="property">runoob</span>.<span class="property">com</span>:<span class="regexp">/home/</span>root/others/ </span><br><span class="line">scp -r /home/space/music/ www.<span class="property">runoob</span>.<span class="property">com</span>:<span class="regexp">/home/</span>root/others/ </span><br></pre></td></tr></table></figure><p>上面命令将本地 music 目录复制到远程 others 目录下。</p><h3 id="（4）从远程复制到本地。"><a href="#（4）从远程复制到本地。" class="headerlink" title="（4）从远程复制到本地。"></a>（4）从远程复制到本地。</h3><p>从远程复制到本地，只要将从本地复制到远程的命令的后2个参数调换顺序即可，如下实例 </p><p>应用实例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">scp root@www.<span class="property">runoob</span>.<span class="property">com</span>:<span class="regexp">/home/</span>root/others/music /home/space/music/<span class="number">1.</span>mp3 </span><br><span class="line">scp -r www.<span class="property">runoob</span>.<span class="property">com</span>:<span class="regexp">/home/</span>root/others/ <span class="regexp">/home/</span>space/music/</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>如果远程服务器防火墙有为scp命令设置了指定的端口，我们需要使用 -P 参数来设置命令的端口号，命令格式如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#scp 命令使用端口号 <span class="number">4588</span></span><br><span class="line">scp -P <span class="number">4588</span> remote@www.<span class="property">runoob</span>.<span class="property">com</span>:<span class="regexp">/usr/</span>local/sin.<span class="property">sh</span> /home/administrator</span><br></pre></td></tr></table></figure><h3 id="（5）使用expect和scp实现不同主机之间文件的自动传输。"><a href="#（5）使用expect和scp实现不同主机之间文件的自动传输。" class="headerlink" title="（5）使用expect和scp实现不同主机之间文件的自动传输。"></a>（5）使用expect和scp实现不同主机之间文件的自动传输。</h3><p>脚本如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#!<span class="regexp">/usr/</span>bin/expect</span><br><span class="line">set timeout <span class="number">5</span></span><br><span class="line">spawn scp dablelv@<span class="number">172.25</span><span class="number">.44</span><span class="number">.22</span>:<span class="regexp">/yourpath/y</span>ourfile root@<span class="number">10.130</span><span class="number">.89</span><span class="number">.104</span>:/destinationpath</span><br><span class="line">expect <span class="string">&quot;dablelv@172.25.44.22&#x27;s password:&quot;</span></span><br><span class="line">send <span class="string">&quot;123456\n&quot;</span></span><br><span class="line">expect <span class="string">&quot;root@10.130.89.104&#x27;s password:&quot;</span></span><br><span class="line">send <span class="string">&quot;123456\n&quot;</span></span><br><span class="line">interact eof</span><br></pre></td></tr></table></figure><p>脚本解释：  </p><p><strong>第一行</strong>：<code>#!/usr/bin/expect</code> 指明该脚本由expect来解析。这里的expect其实和linux下的bash、Windows下的cmd.exe是一类东西，都是可执行程序，也可用于脚本的解析器。expect的主要作用是解析自动交互的脚本，比如实现ssh的自动登录，无需手动输入密码等。</p><p><strong>第二行</strong>：<code>set timeout 5</code> 用于设置expect的expect命令的等待时间为5秒，如果expect等待的值在5秒内没有出现在标准输出，那么expect脚本继续执行。expect的默认timeout为10s。</p><p><strong>第三行</strong>：<code>spawn scp dablelv@172.25.44.22:/yourpath/yourfile</code>。spawn是expect的内置命令，不是Linux可执行程序，使用<code>which spawn</code> 是查不到spawn所在路径的。这个就好比cd是shell的内建命令，离开shell，就无法执行cd一样。 它主要的功能是给ssh运行进程加个壳，用来传递交互指令。 它主要的功能是给后面需要执行的命令加个壳，用来传递交互指令。</p><p><strong>第四行</strong>：<code>expect &quot;dablelv@172.25.44.22&#39;s password:&quot;</code> expect命令也是expect的内建命令，其作用就是等待标准输出出现指定的值，如果有则立即返回，向下执行；否则就一直等待，等待的最长时间由上面的<code>set timeout</code>来指定。</p><p><strong>第五行</strong>：<code>send &quot;123456\n&quot;</code>就是在expect等待到指定的值之后向标准输出发送的值，这里就是执行交互动作，与手工输入密码的动作等效。效果上跟用户手动在终端上输入123456之后敲一个回车一样。</p><p><strong>第六、七行</strong>实现的功能同第五六行，因为scp需要登录到两个主机实现文件的网络传输，所以这里是登录第二台主机需要输入的密码。</p><p><strong>第八行</strong>：<code>interact eof</code> 表示expect脚本执行结束。执行完成上述命令后，此时Expect会把控制权交给控制台，这个时候就变回手工操作。如果是使用ssh登录其它主机的话，需要保持在交互状态，那么此时需要<code>interact</code>，如果没有这一句登录完成后会立刻退出，而不是留在远程终端上。如果你只是登录过去执行一段命令就退出，可将其改为<code>expect eof</code>。</p><p>如果出现 “: no such file or directory 这样的错误，很可能是因为在本地Windows环境编辑，上传到Linux下执行因文件格式不同导致的，可使用vi或者vim在末行模式使用<code>:set ff</code>来查看文件格式，如果是dos格式的话，那么需要使用<code>:set ff=unix</code> 来改变文件格式。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令——ping命令</title>
      <link href="/FRank675.github.io/posts/c0d06b4cf0bc/"/>
      <url>/FRank675.github.io/posts/c0d06b4cf0bc/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\FRank675.github.io\css\APlayer.min.css"><script src="\FRank675.github.io\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\FRank675.github.io\js\Meting.min.js"></script><h1 id="Linux命令——ping命令"><a href="#Linux命令——ping命令" class="headerlink" title="Linux命令——ping命令"></a>Linux命令——ping命令</h1><h2 id="1-命令简介"><a href="#1-命令简介" class="headerlink" title="1.命令简介"></a>1.命令简介</h2><p>ping（Packet Internet Groper 命令是因特网包探索器，用于测试网络连通性，是常用的网络命令之一。</p><p>ping 命令用于向指定的网络主机发送特殊数据报 IMCP 回应请求报文（IMCP ECHO_REQUEST），多数网络设备收到该数据包后会回应 ICMP 回应回复报文 （ICMP Echo-Reply），以此来验证网络连接是否正常。</p><p>注意：</p><p>Linux 系统下的 ping 命令与 Windows 系统下的 ping 命令稍有不同。</p><p>Windows 下运行 ping 命令一般会发出 4 个请求就结束运行该命令；</p><p>而 Linux 下不会自动终止，此时需要我们按 Ctrl+C 终止或者使用 -c 参数为 ping 命令指定发送的请求数目。</p><h2 id="2-命令格式"><a href="#2-命令格式" class="headerlink" title="2.命令格式"></a>2.命令格式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ping</span><br><span class="line">ping [<span class="variable constant_">OPTIONS</span>] <span class="variable constant_">DESTINATION</span></span><br></pre></td></tr></table></figure><p>不跟参数单独执行 ping 命令将显示简短用法。其中参数为零到多个，目标主机可以是主机 IP 或者域名。</p><h2 id="3-选项说明"><a href="#3-选项说明" class="headerlink" title="3.选项说明"></a>3.选项说明</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">-<span class="number">4</span></span><br><span class="line">只使用 <span class="title class_">IPv4</span></span><br><span class="line">-<span class="number">6</span></span><br><span class="line">只使用 <span class="title class_">IPv6</span></span><br><span class="line">-A</span><br><span class="line">探测包发送间隔自适应往返时间，这样网络中存在的未应答的探测请求一般不会超过一个</span><br><span class="line">-a</span><br><span class="line">　　每次发送数据时发出鸣响（<span class="title class_">Audible</span>）</span><br><span class="line">-B</span><br><span class="line">不允许 ping 改变包头的源地址</span><br><span class="line">-b</span><br><span class="line">允许 ping 一个广播地址</span><br><span class="line">-c <span class="variable constant_">COUNT</span></span><br><span class="line">　　发送 count 个 <span class="variable constant_">ECHO_REQUEST</span> 数据包后结束 ping 程序</span><br><span class="line">-D</span><br><span class="line">在每行前打印时间戳</span><br><span class="line">-d</span><br><span class="line">　　使用 socket 的 <span class="variable constant_">SO_DEBUG</span> 选项。实际上，<span class="title class_">Linux</span> 内核不使用这个套接字选项</span><br><span class="line">-F <span class="variable constant_">FLOW_LABEL</span></span><br><span class="line">仅 <span class="title class_">IPv6</span> 有效。为请求包分配一个 <span class="number">20</span> 比特的 flow label。如果 <span class="variable constant_">FLOW_LABEL</span> 为 <span class="number">0</span>，内核会随机分配</span><br><span class="line">-f</span><br><span class="line">　　采用洪泛模式大量且快速地向目标发送数据包。如果发送间隔没有设置，则默认设置为 <span class="number">0</span>，并按照报文接受的速度和一百次每秒的速度来发送报文（以最快的为准）。只有超级用户能够将此选项和 -i <span class="number">0</span> 选项一起使用</span><br><span class="line">-h</span><br><span class="line">显示帮助信息</span><br><span class="line">-I <span class="variable constant_">INTERFACE</span></span><br><span class="line">　　使用指定的网络接口地址发送数据包</span><br><span class="line">-i <span class="variable constant_">INTERVAL</span></span><br><span class="line">　　每隔 <span class="variable constant_">INTERVAL</span> 秒发送一次数据包，默认一秒 ping 一次。只有超级用户可以将间隔设置为小于<span class="number">0.2</span> 秒的值</span><br><span class="line">-L</span><br><span class="line">抑制组播报文回送，只适用于 ping 的目标为一个组播地址</span><br><span class="line">-l <span class="variable constant_">PRELOAD</span></span><br><span class="line">在没有接受到回复报文之前能发送的最多报文。非超级用户最多只能设置为 <span class="number">3</span></span><br><span class="line">-M <span class="variable constant_">PMTUDISC_OPT</span></span><br><span class="line">选择 <span class="title class_">Path</span> <span class="variable constant_">MTU</span> <span class="title class_">Discovery</span> 策略模式。<span class="variable constant_">PMTUDISC_OPT</span> 取值可以为 <span class="keyword">do</span>（不允许分段，甚至不允许在本地分段）、want（找出 <span class="variable constant_">PMTU</span>，在如果包太大就在本地分段） 或 dont（不要设置 <span class="variable constant_">IP</span> 包首部中的 <span class="variable constant_">DF</span> 位，即允许分段）</span><br><span class="line">-m <span class="variable constant_">MARK</span></span><br><span class="line">使用标记来标记发送的数据包</span><br><span class="line">-n</span><br><span class="line">　　只输出主机 <span class="variable constant_">IP</span> 地址，不通过查询 <span class="variable constant_">DNS</span> 获知 <span class="variable constant_">IP</span> 地址对应的主机名，以节省时间</span><br><span class="line">-O</span><br><span class="line">在发送下一个数据包之前报告未完成的 <span class="variable constant_">ICMP</span> <span class="title class_">Echo</span> 请求</span><br><span class="line">-p <span class="variable constant_">PATTERN</span></span><br><span class="line">　　最多指定 <span class="number">16</span> 个字节去填充发送的数据包，这对于诊断网络中数据依赖问题很有用。例如，-p ff 会将所有的填充数据设置为 <span class="number">1</span></span><br><span class="line">-Q <span class="variable constant_">TOS</span></span><br><span class="line"> 用来设置服务质量（<span class="title class_">Quality</span> <span class="keyword">of</span> <span class="title class_">Service</span> ）。<span class="variable constant_">ICMP</span> 协议有一个 <span class="number">8</span> bits 的区分服务（<span class="title class_">Differentiated</span> <span class="title class_">Services</span>）。低两位用于分离数据，高 <span class="number">6</span> 位表示区分服务，一般有最小时延、最大吞吐量、最高可靠性、最小代价</span><br><span class="line">-q</span><br><span class="line">　　静态输出。仅程序启动和结束时显示摘要行</span><br><span class="line">-R</span><br><span class="line">　　记录路由过程</span><br><span class="line">-r</span><br><span class="line">　　忽略正常的路由表，而直接向主机发送数据包。如果目标主机不再直连的网络上，则返回异常</span><br><span class="line">-S <span class="variable constant_">SNDBUF</span></span><br><span class="line">设置套接字的发送缓冲区大小。如果没有设置，则被设定为不超过一个报文长度</span><br><span class="line">-s <span class="variable constant_">PACKETSIZE</span></span><br><span class="line">　　指定要发送的数据的字节数。默认是 <span class="number">56</span> 字节，与 <span class="number">8</span> 字节的 <span class="variable constant_">ICMP</span> 头部结合刚好是 <span class="number">64</span> 字节的 <span class="variable constant_">ICMP</span> 数据包</span><br><span class="line">-T <span class="variable constant_">TIMESTAMP_OPTION</span></span><br><span class="line">设置 <span class="variable constant_">IP</span> 报文的时间戳选项。选项可以是以下三种：</span><br><span class="line">（<span class="number">1</span>）-T tsonly 只记录时间戳；</span><br><span class="line">（<span class="number">2</span>）-T tsandaddr 收集时间戳和 <span class="variable constant_">IP</span> 地址；</span><br><span class="line">（<span class="number">3</span>）-T tsprespec [host1 [host2 [host3[host4]]]] 收集来自预定的网络地址的时间戳</span><br><span class="line">-t <span class="variable constant_">TTL</span></span><br><span class="line">　　设置 <span class="variable constant_">IP</span> 包的 <span class="variable constant_">TTL</span> 值</span><br><span class="line">-U</span><br><span class="line">打印完整的用户对用户延迟</span><br><span class="line">-V</span><br><span class="line">显示版本信息并退出</span><br><span class="line">-v</span><br><span class="line">　　详细模式输出</span><br><span class="line">-W <span class="variable constant_">TIMEOUT</span></span><br><span class="line">　　设置等待 <span class="variable constant_">ICMP</span> 响应的超时时间，单位秒</span><br><span class="line">-w <span class="variable constant_">DEADLINE</span></span><br><span class="line">　　ping 程序在 <span class="variable constant_">DEADLINE</span> 秒后退出，不管发送或接收多少数据包</span><br></pre></td></tr></table></figure><h2 id="4-常用示例"><a href="#4-常用示例" class="headerlink" title="4.常用示例"></a>4.常用示例</h2><h3 id="（1）显示-ping-的简要用法。"><a href="#（1）显示-ping-的简要用法。" class="headerlink" title="（1）显示 ping 的简要用法。"></a>（1）显示 ping 的简要用法。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ping</span><br><span class="line"><span class="title class_">Usage</span>: ping [-aAbBdDfhLnOqrRUvV] [-c count] [-i interval] [-I interface]</span><br><span class="line">            [-m mark] [-M pmtudisc_option] [-l preload] [-p pattern] [-Q tos]</span><br><span class="line">            [-s packetsize] [-S sndbuf] [-t ttl] [-T timestamp_option]</span><br><span class="line">            [-w deadline] [-W timeout] [hop1 ...] destination</span><br></pre></td></tr></table></figure><h3 id="（2）测试能否-ping-通-IP。"><a href="#（2）测试能否-ping-通-IP。" class="headerlink" title="（2）测试能否 ping 通 IP。"></a>（2）测试能否 ping 通 IP。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ping <span class="number">9.134</span><span class="number">.114</span><span class="number">.170</span></span><br><span class="line"><span class="variable constant_">PING</span> <span class="number">9.134</span><span class="number">.114</span><span class="number">.170</span> (<span class="number">9.134</span><span class="number">.114</span><span class="number">.170</span>) <span class="number">56</span>(<span class="number">84</span>) bytes <span class="keyword">of</span> data.</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">9.134</span><span class="number">.114</span><span class="number">.170</span>: icmp_seq=<span class="number">1</span> ttl=<span class="number">64</span> time=<span class="number">0.033</span> ms</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">9.134</span><span class="number">.114</span><span class="number">.170</span>: icmp_seq=<span class="number">2</span> ttl=<span class="number">64</span> time=<span class="number">0.040</span> ms</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>回包正常，表示网络链路通畅。</p><h3 id="（3）测试能否-ping-通域名。"><a href="#（3）测试能否-ping-通域名。" class="headerlink" title="（3）测试能否 ping 通域名。"></a>（3）测试能否 ping 通域名。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ping baidu.<span class="property">com</span></span><br><span class="line"><span class="variable constant_">PING</span> baidu.<span class="property">com</span> (<span class="number">220.181</span><span class="number">.38</span><span class="number">.148</span>) <span class="number">56</span>(<span class="number">84</span>) bytes <span class="keyword">of</span> data.</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">220.181</span><span class="number">.38</span><span class="number">.148</span>: icmp_seq=<span class="number">1</span> ttl=<span class="number">249</span> time=<span class="number">39.4</span> ms</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">220.181</span><span class="number">.38</span><span class="number">.148</span>: icmp_seq=<span class="number">2</span> ttl=<span class="number">249</span> time=<span class="number">39.3</span> ms</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>回包正常，表示网络链路通畅。</p><h3 id="（4）每隔-0-5-秒-ping-一次，一共-ping-3-次。"><a href="#（4）每隔-0-5-秒-ping-一次，一共-ping-3-次。" class="headerlink" title="（4）每隔 0.5 秒 ping 一次，一共 ping 3 次。"></a>（4）每隔 0.5 秒 ping 一次，一共 ping 3 次。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ping -i <span class="number">0.5</span> -c <span class="number">3</span> baidu.<span class="property">com</span></span><br><span class="line"><span class="variable constant_">PING</span> baidu.<span class="property">com</span> (<span class="number">220.181</span><span class="number">.38</span><span class="number">.148</span>) <span class="number">56</span>(<span class="number">84</span>) bytes <span class="keyword">of</span> data.</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">220.181</span><span class="number">.38</span><span class="number">.148</span>: icmp_seq=<span class="number">1</span> ttl=<span class="number">249</span> time=<span class="number">39.3</span> ms</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">220.181</span><span class="number">.38</span><span class="number">.148</span>: icmp_seq=<span class="number">2</span> ttl=<span class="number">249</span> time=<span class="number">39.3</span> ms</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">220.181</span><span class="number">.38</span><span class="number">.148</span>: icmp_seq=<span class="number">3</span> ttl=<span class="number">249</span> time=<span class="number">39.3</span> ms</span><br><span class="line"></span><br><span class="line">--- baidu.<span class="property">com</span> ping statistics ---</span><br><span class="line"><span class="number">3</span> packets transmitted, <span class="number">3</span> received, <span class="number">0</span>% packet loss, time 1001ms</span><br><span class="line">rtt min/avg/max/mdev = <span class="number">39.375</span>/<span class="number">39.390</span>/<span class="number">39.399</span>/<span class="number">0.010</span> ms</span><br></pre></td></tr></table></figure><p>下面简单地介绍一下 ping 产生的响应内容的含义：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">PING</span> baidu.<span class="property">com</span> (<span class="number">220.181</span><span class="number">.38</span><span class="number">.148</span>) <span class="number">56</span>(<span class="number">84</span>) bytes <span class="keyword">of</span> data.</span><br><span class="line">表示 ping 目标主机的域名和 <span class="variable constant_">IP</span>，以及不带包头的包大小和带包头的包大小，参考 -s 选项</span><br><span class="line"></span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">220.181</span><span class="number">.38</span><span class="number">.148</span>: icmp_seq=<span class="number">1</span> ttl=<span class="number">249</span> time=<span class="number">39.3</span> ms</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">220.181</span><span class="number">.38</span><span class="number">.148</span>: icmp_seq=<span class="number">2</span> ttl=<span class="number">249</span> time=<span class="number">39.3</span> ms</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">220.181</span><span class="number">.38</span><span class="number">.148</span>: icmp_seq=<span class="number">3</span> ttl=<span class="number">249</span> time=<span class="number">39.3</span> ms</span><br><span class="line">icmp_seq：ping 序列，从 <span class="number">1</span> 开始；如果数字不是按顺序递增也就意味着丢包了</span><br><span class="line">ttl：剩余的 ttl；见下文的 <span class="variable constant_">TTL</span> 解释</span><br><span class="line"><span class="attr">time</span>: 响应时间，数值越小，通信速度越快</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> packets transmitted, <span class="number">3</span> received, <span class="number">0</span>% packet loss, time 1001ms</span><br><span class="line">发出去的包数，返回的包数，丢包率，总耗费时间</span><br><span class="line"></span><br><span class="line">rtt min/avg/max/mdev = <span class="number">39.375</span>/<span class="number">39.390</span>/<span class="number">39.399</span>/<span class="number">0.010</span> ms</span><br><span class="line">最小/最大/平均响应时间和本机硬件耗费时间</span><br></pre></td></tr></table></figure><h3 id="（5）综合实例，每隔-0-5-秒-ping-一次，一共-ping-3-次，并且设置发送包的大小为-1024-和-TTL-值为-255。"><a href="#（5）综合实例，每隔-0-5-秒-ping-一次，一共-ping-3-次，并且设置发送包的大小为-1024-和-TTL-值为-255。" class="headerlink" title="（5）综合实例，每隔 0.5 秒 ping 一次，一共 ping 3 次，并且设置发送包的大小为 1024 和 TTL 值为 255。"></a>（5）综合实例，每隔 0.5 秒 ping 一次，一共 ping 3 次，并且设置发送包的大小为 1024 和 TTL 值为 255。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ping -i <span class="number">0.5</span> -c <span class="number">3</span> -s <span class="number">1024</span> -t <span class="number">255</span> baidu.<span class="property">com</span></span><br><span class="line"><span class="variable constant_">PING</span> baidu.<span class="property">com</span> (<span class="number">39.156</span><span class="number">.69</span><span class="number">.79</span>) <span class="number">1024</span>(<span class="number">1052</span>) bytes <span class="keyword">of</span> data.</span><br><span class="line"><span class="number">1032</span> bytes <span class="keyword">from</span> <span class="number">39.156</span><span class="number">.69</span><span class="number">.79</span>: icmp_seq=<span class="number">1</span> ttl=<span class="number">249</span> time=<span class="number">44.8</span> ms</span><br><span class="line"><span class="number">1032</span> bytes <span class="keyword">from</span> <span class="number">39.156</span><span class="number">.69</span><span class="number">.79</span>: icmp_seq=<span class="number">2</span> ttl=<span class="number">249</span> time=<span class="number">40.5</span> ms</span><br><span class="line"><span class="number">1032</span> bytes <span class="keyword">from</span> <span class="number">39.156</span><span class="number">.69</span><span class="number">.79</span>: icmp_seq=<span class="number">3</span> ttl=<span class="number">249</span> time=<span class="number">40.4</span> ms</span><br><span class="line"></span><br><span class="line">--- baidu.<span class="property">com</span> ping statistics ---</span><br><span class="line"><span class="number">3</span> packets transmitted, <span class="number">3</span> received, <span class="number">0</span>% packet loss, time 1001ms</span><br><span class="line">rtt min/avg/max/mdev = <span class="number">40.441</span>/<span class="number">41.927</span>/<span class="number">44.810</span>/<span class="number">2.045</span> ms</span><br></pre></td></tr></table></figure><h3 id="（6）综合实例，使用-i-指定发送数据包时间间隔，-c-指定一共发送多少个数据包，-I-指定源地址，-q-直接显示程序的启动和最后结果。"><a href="#（6）综合实例，使用-i-指定发送数据包时间间隔，-c-指定一共发送多少个数据包，-I-指定源地址，-q-直接显示程序的启动和最后结果。" class="headerlink" title="（6）综合实例，使用 -i 指定发送数据包时间间隔，-c 指定一共发送多少个数据包，-I 指定源地址，-q 直接显示程序的启动和最后结果。"></a>（6）综合实例，使用 -i 指定发送数据包时间间隔，-c 指定一共发送多少个数据包，-I 指定源地址，-q 直接显示程序的启动和最后结果。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ping -i <span class="number">0.2</span> -c <span class="number">3</span> -I <span class="number">9.134</span><span class="number">.114</span><span class="number">.170</span> baidu.<span class="property">com</span> -q</span><br><span class="line"><span class="variable constant_">PING</span> baidu.<span class="property">com</span> (<span class="number">39.156</span><span class="number">.69</span><span class="number">.79</span>) <span class="keyword">from</span> <span class="number">9.134</span><span class="number">.114</span><span class="number">.170</span> : <span class="number">56</span>(<span class="number">84</span>) bytes <span class="keyword">of</span> data.</span><br><span class="line"></span><br><span class="line">--- baidu.<span class="property">com</span> ping statistics ---</span><br><span class="line"><span class="number">3</span> packets transmitted, <span class="number">3</span> received, <span class="number">0</span>% packet loss, time 400ms</span><br><span class="line">rtt min/avg/max/mdev = <span class="number">40.476</span>/<span class="number">40.541</span>/<span class="number">40.588</span>/<span class="number">0.171</span> ms</span><br></pre></td></tr></table></figure><h3 id="（7）以最快的速度，使用最大的包进行-ping，可用于测试目标主机的承压能力。"><a href="#（7）以最快的速度，使用最大的包进行-ping，可用于测试目标主机的承压能力。" class="headerlink" title="（7）以最快的速度，使用最大的包进行 ping，可用于测试目标主机的承压能力。"></a>（7）以最快的速度，使用最大的包进行 ping，可用于测试目标主机的承压能力。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ping -f -s <span class="number">65507</span> baidu.<span class="property">com</span></span><br></pre></td></tr></table></figure><p>注意：此用法非常危险，65535（包头+内容）*100个包每秒&#x3D;6.25MB，每秒发送 6.25MB 的数据，相当于 50Mbps 的带宽，完全可能导致目标主机拒绝服务，请谨慎使用。</p><h3 id="（8）ping-不通的情况。"><a href="#（8）ping-不通的情况。" class="headerlink" title="（8）ping 不通的情况。"></a>（8）ping 不通的情况。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ping -c <span class="number">3</span> <span class="number">9.9</span><span class="number">.9</span><span class="number">.9</span></span><br><span class="line"><span class="variable constant_">PING</span> <span class="number">9.9</span><span class="number">.9</span><span class="number">.9</span> (<span class="number">9.9</span><span class="number">.9</span><span class="number">.9</span>) <span class="number">56</span>(<span class="number">84</span>) bytes <span class="keyword">of</span> data.</span><br><span class="line"></span><br><span class="line">--- <span class="number">9.9</span><span class="number">.9</span><span class="number">.9</span> ping statistics ---</span><br><span class="line"><span class="number">3</span> packets transmitted, <span class="number">0</span> received, <span class="number">100</span>% packet loss, time 1999ms</span><br></pre></td></tr></table></figure><h3 id="ping-不通目标主机的常见原因："><a href="#ping-不通目标主机的常见原因：" class="headerlink" title="ping 不通目标主机的常见原因："></a>ping 不通目标主机的常见原因：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">No</span> <span class="title class_">Answer</span>：原因可能是，对方主机没工作，双方网络配置不正确，路由问题等</span><br><span class="line"><span class="title class_">Request</span> <span class="title class_">Time</span> <span class="title class_">Out</span>：对方主机已关机，路由问题或对端防火墙设置禁止ping</span><br><span class="line"><span class="title class_">Unknown</span> <span class="title class_">Host</span> <span class="title class_">Name</span>：<span class="variable constant_">DNS</span>设置问题，或者对方主机不存在</span><br><span class="line"><span class="title class_">Destination</span> <span class="title class_">Net</span> <span class="title class_">Unreachable</span>：双方没有建立连接，或对方主机不存在</span><br><span class="line"><span class="title class_">Bad</span> <span class="variable constant_">IP</span> <span class="title class_">Address</span>：<span class="variable constant_">IP</span> 地址不存在或 <span class="variable constant_">IP</span> 不能被 <span class="variable constant_">DNS</span> 服务器解析</span><br><span class="line">transmit failed，error code：网卡驱动问题</span><br><span class="line">no rout to host：网卡工作不正常</span><br><span class="line"><span class="title class_">Ping</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> 如果ping不通，表明本地机 <span class="variable constant_">TCP</span>/<span class="variable constant_">IP</span> 协议不能正常工作</span><br></pre></td></tr></table></figure><h2 id="5-拓展知识"><a href="#5-拓展知识" class="headerlink" title="5.拓展知识"></a>5.拓展知识</h2><h3 id="5-1-TTL"><a href="#5-1-TTL" class="headerlink" title="5.1 TTL"></a>5.1 TTL</h3><p>当我们在使用 ping 命令时，返回结果里会带一个 TTL 值。</p><p>这个东西的含义其实就是Time To Live，指的是报文在网络中能够存活的限制。</p><p>以前这个限制方式是设定一个时间（Time To Live中的Time就是这样来的），当报文在网络中转发时，时间超过这个限制，最后一个收到报文的‘路由点’就会把它扔掉，而不继续转发。</p><p>后来把时间限制改为了跳数限制，就是当报文在网络中转发时，每经过一个‘路由点‘，就把预先设定的这个TTL数值减 1，直到最后 TTL&#x3D;1 时报文就被扔掉，不向下转发。</p><p>路由点：我这里是指完成路由功能的机器，因为并不是只有路由器才可以完成路由转发功能，比如主机可以配置路由转发。</p><p>所以，回包中的 TTL 表示目标主机返回的报文到达本机后，从它预设的 TTL 值减小到现在的值。</p><h3 id="5-2-开启和禁用-ping-响应"><a href="#5-2-开启和禁用-ping-响应" class="headerlink" title="5.2 开启和禁用 ping 响应"></a>5.2 开启和禁用 ping 响应</h3><p>有时为了保护主机，很多时候我们需要禁止 ICMP 协议，在这种情况下，终端再使用ping命令检测，服务器不会再做出任何响应。</p><h3 id="（1）临时开启-ping。"><a href="#（1）临时开启-ping。" class="headerlink" title="（1）临时开启 ping。"></a>（1）临时开启 ping。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">echo <span class="number">0</span> &gt; <span class="regexp">/proc/</span>sys/net/ipv4/icmp_echo_ignore_all</span><br></pre></td></tr></table></figure><h3 id="（2）临时禁用-ping。"><a href="#（2）临时禁用-ping。" class="headerlink" title="（2）临时禁用 ping。"></a>（2）临时禁用 ping。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">echo <span class="number">1</span> &gt; <span class="regexp">/proc/</span>sys/net/ipv4/icmp_echo_ignore_all </span><br></pre></td></tr></table></figure><h3 id="（3）永久禁用-ping。"><a href="#（3）永久禁用-ping。" class="headerlink" title="（3）永久禁用 ping。"></a>（3）永久禁用 ping。</h3><p>在配置文件 &#x2F;etc&#x2F;sysctl.conf 中增加如下一行。修改完成后执行sysctl -p使新配置生效</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">net.<span class="property">ipv4</span>.<span class="property">icmp_echo_ignore_all</span>=<span class="number">1</span>          # <span class="number">1</span> 表示禁止</span><br></pre></td></tr></table></figure><h3 id="（4）永久开启-ping。"><a href="#（4）永久开启-ping。" class="headerlink" title="（4）永久开启 ping。"></a>（4）永久开启 ping。</h3><p>在配置文件 &#x2F;etc&#x2F;sysctl.conf 中增加如下一行。修改完成后执行 sysctl -p 使新配置生效。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">net.<span class="property">ipv4</span>.<span class="property">icmp_echo_ignore_all</span>=<span class="number">0</span>          # <span class="number">0</span> 表示允许</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令——ls命令</title>
      <link href="/FRank675.github.io/posts/5399fdb078dd/"/>
      <url>/FRank675.github.io/posts/5399fdb078dd/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="Linux命令——ls命令"><a href="#Linux命令——ls命令" class="headerlink" title="Linux命令——ls命令"></a>Linux命令——ls命令</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>ls命令用来显示目录内容，在Linux中是使用率较高的命令。ls命令的输出信息可以进行彩色加亮显示，以分区不同类型的文件。</p><h2 id="2-命令格式"><a href="#2-命令格式" class="headerlink" title="2.命令格式"></a>2.命令格式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ls [<span class="variable constant_">OPTION</span>]... [<span class="variable constant_">FILE</span>]...</span><br></pre></td></tr></table></figure><h2 id="3-选项说明"><a href="#3-选项说明" class="headerlink" title="3.选项说明"></a>3.选项说明</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">-a,--all：显示所有档案及目录（ls内定将档案名或目录名称以“.”开头的文件视为影藏文件，默认不会列出）； </span><br><span class="line">-A,--almost-all：显示除影藏文件“.”和“..”以外的所有文件列表； </span><br><span class="line">--<span class="attr">author</span>:与-l选项结合使用，打印出每一个文件的作者；</span><br><span class="line">-b, --<span class="built_in">escape</span>：将文件中的不可输出的字符以反斜线“\”加字符编码的方式输出；</span><br><span class="line">--block-size=<span class="attr">SIZE</span>:使用指定的<span class="variable constant_">SIZE</span>作为统计文件大小的单位。<span class="variable constant_">SIZE</span>可以取如下字符串，或对应的数值: <span class="variable constant_">KB</span> <span class="number">1000</span>, K <span class="number">1024</span>, <span class="variable constant_">MB</span> <span class="number">1000</span>*<span class="number">1000</span>, M <span class="number">1024</span>*<span class="number">1024</span>,以及G, T, P, E, Z, Y等；</span><br><span class="line">-B, --ignore-backups：不要列出以~结尾的隐含条目，默认列出；</span><br><span class="line">-c：与“-l”选项连用时，展示ctime；与“-lt”选项连用时，输出按照文件状态改变时间排序，排序的依据是文件的索引节点中的ctime字段；</span><br><span class="line">-C：多列显示输出结果。这是默认选项； </span><br><span class="line">--color[=<span class="variable constant_">WHEN</span>]：使用不同的颜色高亮显示不同类型文件，<span class="variable constant_">WHEN</span>的默认取值为<span class="string">&#x27;always&#x27;</span>，也可以是<span class="string">&#x27;never&#x27;</span>或<span class="string">&#x27;auto&#x27;</span>；</span><br><span class="line">-d, --<span class="attr">directory</span>:仅显示目录名，而不显示目录下的内容列表。显示符号链接文件本身，而不显示其所指向的目录或文件； </span><br><span class="line">-D, --dired：以<span class="title class_">Emacs</span>的dired模式输出；</span><br><span class="line">-f：此参数的效果和同时指定“aU”参数相同，并关闭“-ls --color”参数效果； </span><br><span class="line">-F, --classify：在每个输出项后追加文件的类型标识符，具体含义：“*”表示具有可执行权限的普通文件，“/”表示目录，“@”表示符号链接，“|”表示命令管道<span class="variable constant_">FIFO</span>，“=”表示sockets套接字。当文件为普通文件时，不输出任何标识符； </span><br><span class="line">--file-type：与“-F”选项的功能相同，但是不显示“*”； </span><br><span class="line">--format=<span class="variable constant_">WORD</span>：<span class="variable constant_">WORD</span>可取值为across，等价于-x选项。取值为commas,等价于-m。取值为horizontal，等价于-x。取值为long，等价于-l。取值为single-column，等价于-<span class="number">1</span>。取值为verbose，等价于-l。取值为vertical，等价于-C；</span><br><span class="line">--full-time：列出完整的日期与时间；</span><br><span class="line">-g：类似于-l,但不列出所属者；</span><br><span class="line">--group-directories-first：目录排在文件之前列出；</span><br><span class="line">-G, --no-group：在长格式(-l)输出时，不输出组名；</span><br><span class="line">-h, --human-readable：以可读方式显示文件大小；</span><br><span class="line">--si：以<span class="number">1000</span>代替<span class="number">1024</span>计算文件大小；</span><br><span class="line">-H, --dereference-command-line：使用命令列中的符号链接指示的真正目的地；</span><br><span class="line">--dereference-command-line-symlink-to-dir：遵循命令行中列出的符号链接；</span><br><span class="line">--hide=<span class="variable constant_">PATTERN</span>：不列出符合<span class="variable constant_">PATTERN</span>模型的隐藏文件；</span><br><span class="line">--indicator-style=<span class="variable constant_">WORD</span>：追加指示符<span class="variable constant_">WORD</span>到每一个文件或目录名称后，none默认 slash (-p), file-type (--file-type), classify (-F)；</span><br><span class="line">-i, --inode：显示文件索引节点号（inode）。一个索引节点代表一个文件； </span><br><span class="line">-I, --ignore=<span class="variable constant_">PATTERN</span>：不列出匹配<span class="variable constant_">PATTERN</span>的文件或目录名；</span><br><span class="line">-k：以<span class="variable constant_">KB</span>（千字节）为单位显示文件大小，类似于--block-size=1K；</span><br><span class="line">-<span class="number">1</span>：数字<span class="number">1</span>，与“-C”选项功能相反，所有输出信息用单列格式输出，不输出为多列；</span><br><span class="line">-l：以长格式显示目录下的内容列表。输出的信息从左到右依次包括文件名，文件类型、权限模式、硬连接数、所有者、组、文件大小和文件的最后修改时间等； </span><br><span class="line">-L,--dereference：如果遇到性质为符号链接的文件或目录，直接列出该链接所指向的原始文件或目录； </span><br><span class="line">-m：用“,”号区隔每个文件和目录的名称； </span><br><span class="line">-n：以用户识别码和群组识别码替代其名称； </span><br><span class="line">-N,--<span class="attr">literal</span>: 直接列出文件和目录名称，包括控制字符；</span><br><span class="line">-<span class="attr">o</span>: 此参数的效果类似于<span class="string">&quot;-l&quot;</span>，但不列出用户组信息；</span><br><span class="line">-p, --indicator-style=<span class="attr">slash</span>:追加斜杠/指示符到目录名后；</span><br><span class="line">-q, --hide-control-<span class="attr">chars</span>:用<span class="string">&quot;?&quot;</span>号取代控制字符，列出文件和目录名称；</span><br><span class="line">--show-control-<span class="attr">chars</span>:显示文件和目录名称中的控制字符；</span><br><span class="line">-Q, --quote-<span class="attr">name</span>:把文件和目录名称以双引号“”标示起来；</span><br><span class="line">--quoting-style=<span class="attr">WORD</span>:使用指定的引号模式来标识档案名称，<span class="variable constant_">WORD</span>的取值有：literal, locale, shell, shell-always, c, <span class="built_in">escape</span>；</span><br><span class="line">-r, --<span class="attr">reverse</span>:以文件名反序排列并输出目录内容；</span><br><span class="line">-R, --<span class="attr">recursive</span>:递归处理，将指定目录下的所有文件及子目录一并处理； </span><br><span class="line">-s,--size：显示文件和目录的大小，以区块为单位； </span><br><span class="line">-S：以文件大小进行排序；</span><br><span class="line">--sort=<span class="variable constant_">WORD</span>：以指定的内容进行排序，而非默认的档案名称，<span class="variable constant_">WORD</span>可取值：none（不排序，等于-U）；extension（以条目名的最后一个扩展名排序，等于-X）；<span class="title function_">size</span>(以用条目大小排序，等于-S）;<span class="title function_">time</span>(以条目内容最后被修改时间排序，等于-t);<span class="title function_">version</span>(以条目版本进行排序，等于-v);</span><br><span class="line">--time=<span class="variable constant_">WORD</span>：当使用-t或--sort=time来按照时间排序时，<span class="variable constant_">WORD</span>可取值为atime、access、<span class="title function_">use</span>(表示使用访问时间排序)；或者ctime、status（状态改变时间排序），来取代默认以内容修改时间排序；</span><br><span class="line">--time-style=<span class="variable constant_">STYLE</span>：使用-l选项时，显示时间使用指定的样式风格<span class="variable constant_">STYLE</span>，可取值为full-iso,long-iso,iso,locale，还有+<span class="variable constant_">FORMAT</span>,<span class="variable constant_">FORMAT</span>，这两项设置格式可以参考date命令的设置方法；</span><br><span class="line">-t：用文件和目录的内容修改时间排序； </span><br><span class="line">-T, --tabsize=<span class="variable constant_">COLS</span>：设置每一列之间的<span class="title class_">Tab</span>间隔符代表的宽度为<span class="variable constant_">COLS</span>，默认为<span class="number">8</span>个空格；</span><br><span class="line">-u：与-lt同用，表示使用访问时间排序，与-l同用，显示访问时间而非内容修改时间；</span><br><span class="line">-U：列出文件和目录名称时不予排序；</span><br><span class="line">-v：文件和目录的名称列表以版本进行排序；</span><br><span class="line">-w,--width=<span class="variable constant_">COLS</span>：设置每列的最大字符数为<span class="variable constant_">COLS</span>；</span><br><span class="line">-x：以从左到右，由上至下的横列方式显示文件和目录名称；</span><br><span class="line">-X：以文件和目录的最后一个扩展名排序；</span><br><span class="line">--help：显示帮助信息；</span><br><span class="line">--<span class="attr">version</span>:显示版本信息；</span><br></pre></td></tr></table></figure><h2 id="4-常用示例"><a href="#4-常用示例" class="headerlink" title="4.常用示例"></a>4.常用示例</h2><h3 id="（1）ls命令按照修改日期递减排序"><a href="#（1）ls命令按照修改日期递减排序" class="headerlink" title="（1）ls命令按照修改日期递减排序"></a>（1）ls命令按照修改日期递减排序</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ls -t</span><br></pre></td></tr></table></figure><p>如果想按照修改日期递增的话使用<code>ls -rt</code> 就行了。</p><h3 id="（2）ls命令按照文件大小递减排序。"><a href="#（2）ls命令按照文件大小递减排序。" class="headerlink" title="（2）ls命令按照文件大小递减排序。"></a>（2）ls命令按照文件大小递减排序。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#递减排序</span><br><span class="line">ls -hS</span><br><span class="line"></span><br><span class="line">#递增排序</span><br><span class="line">ls -hrS</span><br></pre></td></tr></table></figure><h3 id="（3）显示隐藏文件，包括当前目录和父级目录。"><a href="#（3）显示隐藏文件，包括当前目录和父级目录。" class="headerlink" title="（3）显示隐藏文件，包括当前目录和父级目录。"></a>（3）显示隐藏文件，包括当前目录和父级目录。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[dablelv@<span class="title class_">TENCENT64</span> ~]$ ll -a</span><br><span class="line">total <span class="number">148</span></span><br><span class="line">drwxr-x---  <span class="number">8</span> dablelv dablelv  <span class="number">4096</span> <span class="title class_">Nov</span> <span class="number">23</span> <span class="number">23</span>:<span class="number">56</span> .</span><br><span class="line">drwxr-xr-x <span class="number">22</span> root    root     <span class="number">4096</span> <span class="title class_">Jun</span>  <span class="number">7</span> <span class="number">15</span>:<span class="number">15</span> ..</span><br><span class="line">-rw-------  <span class="number">1</span> dablelv dablelv <span class="number">71812</span> <span class="title class_">Nov</span> <span class="number">24</span> <span class="number">00</span>:<span class="number">38</span> .<span class="property">bash_history</span></span><br><span class="line">-rw-r--r--  <span class="number">1</span> dablelv dablelv  <span class="number">2153</span> <span class="title class_">May</span>  <span class="number">2</span>  <span class="number">2017</span> .<span class="property">bash_profile</span></span><br><span class="line">-rw-------  <span class="number">1</span> dablelv dablelv   <span class="number">595</span> <span class="title class_">Nov</span> <span class="number">24</span> <span class="number">16</span>:<span class="number">57</span> .<span class="property">lesshst</span></span><br><span class="line">drwx------  <span class="number">2</span> dablelv dablelv  <span class="number">4096</span> <span class="title class_">Jul</span> <span class="number">23</span> <span class="number">20</span>:<span class="number">42</span> .<span class="property">ssh</span></span><br></pre></td></tr></table></figure><p>ll实际是<code>ls -l</code>的别成，使用alias命令可以查看相关命令。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[dablelv@<span class="title class_">TENCENT64</span> ~]$ alias</span><br><span class="line">alias l.=<span class="string">&#x27;ls -d .* --color=auto&#x27;</span></span><br><span class="line">alias ll=<span class="string">&#x27;ls -l --color=auto&#x27;</span></span><br><span class="line">alias ls=<span class="string">&#x27;ls --color=auto&#x27;</span></span><br><span class="line">alias vi=<span class="string">&#x27;vim&#x27;</span></span><br><span class="line">alias which=<span class="string">&#x27;alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="（4）以指定的文件大小类型展示。"><a href="#（4）以指定的文件大小类型展示。" class="headerlink" title="（4）以指定的文件大小类型展示。"></a>（4）以指定的文件大小类型展示。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[dablelv@<span class="title class_">TENCENT64</span> ~]$ ll --block-size=K</span><br><span class="line">total 24K</span><br><span class="line">drwxrwxr-x <span class="number">10</span> dablelv dablelv 4K <span class="title class_">Nov</span> <span class="number">21</span> <span class="number">15</span>:<span class="number">08</span> code_root</span><br><span class="line">-rwxrwxr-x  <span class="number">1</span> dablelv dablelv 1K <span class="title class_">Nov</span> <span class="number">21</span> <span class="number">00</span>:<span class="number">18</span> dable.<span class="property">php</span></span><br><span class="line">-rw-rw-r--  <span class="number">1</span> dablelv dablelv 1K <span class="title class_">Nov</span> <span class="number">21</span> <span class="number">00</span>:<span class="number">18</span> dablelala.<span class="property">php</span></span><br><span class="line">-rw-rw-r--  <span class="number">1</span> dablelv dablelv 0K <span class="title class_">Nov</span> <span class="number">23</span> <span class="number">23</span>:<span class="number">56</span> dablelv~</span><br><span class="line">-rw-rw-r--  <span class="number">1</span> dablelv dablelv 1K <span class="title class_">Nov</span> <span class="number">21</span> <span class="number">00</span>:<span class="number">40</span> dablenewnew</span><br><span class="line">drwxrwxrwx  <span class="number">2</span> dablelv dablelv 4K <span class="title class_">Nov</span> <span class="number">21</span> <span class="number">00</span>:<span class="number">29</span> <span class="keyword">new</span></span><br><span class="line">drwxrwxr-x  <span class="number">6</span> dablelv dablelv 4K <span class="title class_">Nov</span> <span class="number">21</span> <span class="number">00</span>:<span class="number">24</span> test</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令——lsof命令</title>
      <link href="/FRank675.github.io/posts/4d9fc314d761/"/>
      <url>/FRank675.github.io/posts/4d9fc314d761/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="Linux命令——lsof命令"><a href="#Linux命令——lsof命令" class="headerlink" title="Linux命令——lsof命令"></a>Linux命令——lsof命令</h1><h2 id="1-命令简介"><a href="#1-命令简介" class="headerlink" title="1.命令简介"></a>1.命令简介</h2><p>​lsof（list open files）用于查看进程打开的文件，是十分方便的系统监测工具。</p><p>​因为 lsof 命令需要访问核心内存和各种系统文件，所以需要 root 权限才可执行。</p><p>在 Linux 系统中，一切皆文件。</p><p>​通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。所以 lsof 不仅可以查看进程打开的普通文件、目录，还可以查看进程监听的端口等 socket 相关的信息。</p><p>​进程打开的每一个文件，系统在后台都会为之分配一个文件描述符，无论这个文件的本质如何，该文件描述符为应用程序与基础操作系统之间的交互提供了通用接口。</p><p>​因为应用程序打开文件的描述符列表提供了大量关于这个应用程序本身的信息，因此通过 lsof 工具能够查看这个列表，对系统监测以及排错很有帮助。</p><p>lsof 查看的打开文件可以是：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">普通文件</span><br><span class="line">目录</span><br><span class="line">字符或块设备文件</span><br><span class="line">共享库</span><br><span class="line">管道、命名管道</span><br><span class="line">符号链接</span><br><span class="line">网络文件（如 <span class="variable constant_">NFS</span> file、网络 socket，<span class="title class_">Unix</span> 域名 socket）</span><br><span class="line">其它类型的文件，等等</span><br></pre></td></tr></table></figure><h2 id="2-命令格式"><a href="#2-命令格式" class="headerlink" title="2.命令格式"></a>2.命令格式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lsof [<span class="variable constant_">OPTIONS</span>] [--] [<span class="variable constant_">NAMES</span>]</span><br></pre></td></tr></table></figure><p>​在没有任何选项的情况下，lsof 列出所有属于活动进程的打开文件。</p><h2 id="3-选项说明"><a href="#3-选项说明" class="headerlink" title="3.选项说明"></a>3.选项说明</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">-?, -h </span><br><span class="line">显示帮助信息</span><br><span class="line">-a</span><br><span class="line">参数被视为逻辑与 <span class="variable constant_">AND</span>，会影响全部的参数</span><br><span class="line">-A A</span><br><span class="line">在配置了 <span class="variable constant_">AFS</span> 分布式网络文件系统的系统上可用，其 <span class="variable constant_">AFS</span> 内核代码是通过动态模块实现的。通过 A 指定备用名称列表文件，在该文件中可以找到动态模块的内核地址</span><br><span class="line">-b</span><br><span class="line">避免 lsof 因调用可能阻塞的内核函数而产生阻塞，比如 <span class="title function_">lstat</span>(<span class="number">2</span>)、<span class="title function_">readlink</span>(<span class="number">2</span>) 和 <span class="title function_">stat</span>(<span class="number">2</span>) 等内核函数</span><br><span class="line">-c C</span><br><span class="line">显示出以字符或字符串 C 开头的命令程序开启的文件，如 lsof -c init。如果 C 以斜杠 / 开头和结尾，则斜杠之间的字符被解释为正则表达式。该选项可多次指定</span><br><span class="line">+c W</span><br><span class="line">指定 <span class="variable constant_">COMMAND</span> 列的宽度，单位字符。默认为 <span class="number">9</span></span><br><span class="line">-C</span><br><span class="line">禁用从内核的名称缓存中报告任何路径名</span><br><span class="line">-D D</span><br><span class="line">指导 lsof 使用设备缓存文件。该选项的使用有时受到限制。-D 必须后面跟着一个函数字母，函数字母后面可以有一个路径名称。lsof 识别以下功能字母：</span><br><span class="line">?报告设备缓存文件路径</span><br><span class="line">b构建设备缓存文件</span><br><span class="line">i忽略设备缓存文件</span><br><span class="line">r读取设备缓存文件</span><br><span class="line">u读取并更新设备缓存文件</span><br><span class="line">+D D</span><br><span class="line">递归搜索目录 D。如显示在 /usr/local 及其子目录下被程序开启的文件：lsof +D /usr/local</span><br><span class="line">+d D</span><br><span class="line"> 非递归搜索目录 D。如显示在 /usr/local 下被程序开启的文件：lsof +d /usr/local</span><br><span class="line">-d <span class="variable constant_">FD</span></span><br><span class="line">指定文件描述符列表，可以采用逗号分隔，也可以指定范围。比如 <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> 或 <span class="number">1</span>-<span class="number">3</span>。如果前面包含尖号，表示排除。如显示 <span class="variable constant_">FD</span> 为 <span class="number">4</span> 的进程：lsof -d <span class="number">4</span></span><br><span class="line">+|-e S</span><br><span class="line">豁免（exempt）路径名称为 S 的文件系统不受可能阻塞的内核函数调用的影响。+e 选项豁免 <span class="title function_">stat</span>(<span class="number">2</span>)、<span class="title function_">lstat</span>(<span class="number">2</span>) 和大多数 <span class="title function_">readlink</span>(<span class="number">2</span>) 内核函数调用。-e 选项只能豁免 <span class="title function_">stat</span>(<span class="number">2</span>) 和 <span class="title function_">lstat</span>(<span class="number">2</span>) 内核函数调用</span><br><span class="line">+|-E</span><br><span class="line">+E 指定使用端点信息显示 <span class="title class_">Linux</span> 管道、<span class="title class_">Linux</span> <span class="variable constant_">UNIX</span> 套接字和 <span class="title class_">Linux</span> 伪终端文件，并显示端点的文件。-E 则不显示端点的文件</span><br><span class="line">-F <span class="variable constant_">LIST</span></span><br><span class="line">指定字符列表 <span class="variable constant_">LIST</span>，选择输出给另一程序处理的字段，各字段对应的字符见下文</span><br><span class="line">+|-f [cfgGn]</span><br><span class="line">f 本身澄清了路径名参数的解释方式。当后面跟着 c、f、g、G 或 n 时，它指定要启用（+）或抑制（-）内核文件结构信息。</span><br><span class="line">c 文件结构使用计数（not <span class="title class_">Linux</span>）</span><br><span class="line">f 文件结构地址（not <span class="title class_">Linux</span>）</span><br><span class="line">g 文件标志缩写（<span class="title class_">Linux</span> <span class="number">2.6</span><span class="number">.22</span> 及更高版本）</span><br><span class="line">G 十六进制文件标志（<span class="title class_">Linux</span> <span class="number">2.6</span><span class="number">.22</span> 及更高版本）</span><br><span class="line">n 文件结构节点地址（not <span class="title class_">Linux</span>）</span><br><span class="line">-g [<span class="variable constant_">PGID</span>]</span><br><span class="line">选择或排除属于指定进程组的进程打开的文件。 进程组 <span class="variable constant_">ID</span> 使用逗号分隔，如果 <span class="variable constant_">PGID</span> 前面包含尖号，表示排除。若没有指定 <span class="variable constant_">PGID</span>，则显示全部。如显示 <span class="variable constant_">PGID</span> 为 <span class="number">6</span> 和 <span class="number">7</span> 的进程：lsof -g6,<span class="number">7</span></span><br><span class="line">-i [I]</span><br><span class="line">选择其 <span class="title class_">Internet</span> 地址与 -i 中指定的地址匹配的文件，若没有相关地址被指定，则监听全部。</span><br><span class="line">用法： lsof -i [<span class="number">46</span>][protocol][@hostname|hostaddr][:serivce|port]</span><br><span class="line">说明：<span class="number">4</span> <span class="number">6</span> 分别表示 <span class="title class_">IPv4</span> 和 <span class="title class_">IPv6</span>   </span><br><span class="line">    protocol： <span class="variable constant_">TCP</span> or <span class="variable constant_">UDP</span>   </span><br><span class="line">    hostname：主机名</span><br><span class="line">    hostaddr：<span class="title class_">IPv4</span> 或 <span class="title class_">IPv6</span> 地址</span><br><span class="line">    service：主机提供的服务的名称，即 /etc/services 中的 service name</span><br><span class="line">    port：端口号</span><br><span class="line">-K</span><br><span class="line">在支持任务（线程）报告方式的系统上输出进程的任务（线程）列表</span><br><span class="line">-k K</span><br><span class="line">指定内核名称列表文件，代替 /vmunix、/mach 等</span><br><span class="line">-l</span><br><span class="line">禁止将 user <span class="variable constant_">ID</span> 转换为登录的名称，默认是登录名称</span><br><span class="line">+|-L [L]</span><br><span class="line">+ 或 - 表示开启或关闭显示文件连接数，如果只有单纯的 +L，后面没有任何数字，则表示显示全部，如果后面有数字，只有文件连接数少于该数字的会被列出</span><br><span class="line">+|-m M</span><br><span class="line">-m 指定一个内核内存文件 M ，代替 /dev/kmem 或 /dev/mem。+m 将装载补充文件写入标准输出文件</span><br><span class="line">+|-M</span><br><span class="line">启用或禁用报告本地 <span class="variable constant_">TCP</span>、<span class="variable constant_">UDP</span> 和 <span class="variable constant_">UDPLITE</span> 端口的端口映射器注册</span><br><span class="line">-n</span><br><span class="line">不将 <span class="variable constant_">IP</span> 地址转换为主机名</span><br><span class="line">-N</span><br><span class="line">显示 <span class="variable constant_">NFS</span> 文件</span><br><span class="line">-o</span><br><span class="line">始终显示文件偏移量。它导致 <span class="variable constant_">SIZE</span>/<span class="variable constant_">OFF</span> 输出列标题更改为 <span class="variable constant_">OFFSET</span></span><br><span class="line">-o O</span><br><span class="line">指定在文件偏移量的 0t 之后要打印的小数位数</span><br><span class="line">-O</span><br><span class="line">指示 lsof 避免被某些内核操作阻塞。即在分叉的子进程中执行它们。虽然使用此选项将减少 lsof 启动开销，但也可能导致 lsof 在内核不响应函数时挂起。谨慎使用此选项</span><br><span class="line">-P</span><br><span class="line">禁止将网络文件的端口号转换为端口名</span><br><span class="line">-p S</span><br><span class="line">排除或选择进程的文件列表，进程 <span class="variable constant_">ID</span> 列表使用逗号分隔，如 <span class="number">123</span> 或 <span class="number">123</span>,^<span class="number">456</span>。尖号表示排除指定 <span class="variable constant_">PID</span></span><br><span class="line">-R</span><br><span class="line">使用列 <span class="variable constant_">PPID</span> 列出父进程的 <span class="variable constant_">PID</span></span><br><span class="line">+|-r [T[mFMT]]</span><br><span class="line"> 控制 lsof 不断重复执行，间隔 T 秒，默认为 15s。-r 永远不断地执行，直到收到中断讯号（ctrl+ c），+r 一直执行，直到没有文件被显示。可选的 mFMT 参数指定标记线的格式，格式 <span class="variable constant_">FMT</span> 遵循 C 语言标准库函数 <span class="title function_">strftime</span>(<span class="number">3</span>) 的规范</span><br><span class="line">-S [T]</span><br><span class="line">指定内核函数 <span class="title function_">lstat</span>(<span class="number">2</span>)、<span class="title function_">readlink</span>(<span class="number">2</span>) 和 <span class="title function_">stat</span>(<span class="number">2</span>) 的可选超时秒值，否则可能会死锁。t 的最小值是 <span class="number">2</span>；默认值是 <span class="number">15</span></span><br><span class="line">-s [<span class="attr">P</span>:S]</span><br><span class="line">列出文件的大小，若该文件没有大小，则留下空白。它导致 <span class="variable constant_">SIZE</span>/<span class="variable constant_">OFF</span> 输出列标题更改为 <span class="variable constant_">SIZE</span>。P 表示协议名称 <span class="variable constant_">TCP</span>  or  <span class="variable constant_">UDP</span>，S 表示逗号分隔的协议状态</span><br><span class="line">-T [T]</span><br><span class="line">-T 没有参数则禁用 <span class="variable constant_">TCP</span>/<span class="variable constant_">TPI</span> 信息报告。跟如下参数，则显示指定 <span class="variable constant_">TCP</span>/<span class="variable constant_">TPI</span> 信息：</span><br><span class="line">f 选择报告套接字选项，状态和值，以及 <span class="variable constant_">TCP</span>标志和值</span><br><span class="line">q 选择队列长度</span><br><span class="line">s 选择连接状态</span><br><span class="line">w 选择窗口大小</span><br><span class="line">-t</span><br><span class="line">生成只有进程标识符而没有标题的简洁输出，这样输出可以通过管道传递给 <span class="title function_">kill</span>(<span class="number">1</span>) 杀死</span><br><span class="line">-U</span><br><span class="line">选择 <span class="variable constant_">UNIX</span> 域套接字文件的列表</span><br><span class="line">-u <span class="variable constant_">USERS</span></span><br><span class="line">选择登录名或用户 <span class="variable constant_">ID</span> 位于逗号分隔集 <span class="variable constant_">USERS</span> 中的用户的文件列表。如 root 或 <span class="number">548</span>,root”，如果用户名或用户 <span class="variable constant_">ID</span> 前有尖号 ^，表示排除</span><br><span class="line">-V</span><br><span class="line">指示被要求列出但找不到的项</span><br><span class="line">-v</span><br><span class="line">    显示版本信息</span><br><span class="line">+|-w</span><br><span class="line">   启用（＋）或禁用（－）警告消息</span><br><span class="line">-X</span><br><span class="line"><span class="title class_">Linux</span> 下跳过所有打开的 <span class="variable constant_">TCP</span>、<span class="variable constant_">UDP</span> 和 <span class="variable constant_">UDPLITE</span> <span class="title class_">IPv4</span> 和 <span class="title class_">IPv6</span> 文件的信息报告</span><br><span class="line">-x [fl]</span><br><span class="line">一般与选项 +d 和 +D 选项，指示搜索时是否跨文件系统和符号链接。-x 不跟任何参数时，表示跨文件系统和符号链接</span><br><span class="line">-Z [Z]</span><br><span class="line">指定如何处理 <span class="title class_">SELinux</span> 安全上下文。当在运行的 <span class="title class_">Linux</span> 内核中禁用<span class="title class_">SELinux</span>时，Z 字段将被抑制输出。-Z 选项不跟参数，如 -Z -，安全上下文将列在 <span class="variable constant_">SECURITY</span>-<span class="variable constant_">CONTEXT</span> 列中输出</span><br><span class="line">--</span><br><span class="line">双减号表示选项结束</span><br><span class="line"><span class="variable constant_">NAMES</span></span><br><span class="line">列出指定文件，符号链接在使用前将被解析</span><br></pre></td></tr></table></figure><h2 id="4-输出字段说明"><a href="#4-输出字段说明" class="headerlink" title="4.输出字段说明"></a>4.输出字段说明</h2><p>​当指定了 -F 选项时，lsof 将生成适合由另一个程序（如 awk 或 Perl 脚本或 C 程序）处理的输出。</p><p>​下面是 lsof 可输出的字段。单个字符表示字段标识符。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a文件访问模式</span><br><span class="line">c进程命令名</span><br><span class="line">C文件结构共享计数</span><br><span class="line">d文件的设备字符码</span><br><span class="line">D文件的主要/次要设备号</span><br><span class="line">F文件结构地址</span><br><span class="line">f文件描述符</span><br><span class="line">G文件标志</span><br><span class="line">g进程组 <span class="variable constant_">ID</span></span><br><span class="line">i文件 inode 编号</span><br><span class="line">K任务 <span class="variable constant_">ID</span></span><br><span class="line">k链接计数</span><br><span class="line">L进程登录名</span><br><span class="line">m重复输出之间的标记</span><br><span class="line">N节点标识符</span><br><span class="line">n文件名、注释、<span class="title class_">Internet</span> 地址</span><br><span class="line">o文件偏移量（十进制）</span><br><span class="line">P协议名称</span><br><span class="line">p进程 <span class="variable constant_">ID</span></span><br><span class="line">R父进程 <span class="variable constant_">ID</span></span><br><span class="line">r原始设备号</span><br><span class="line">S文件的流标识</span><br><span class="line">s文件大小（十进制）</span><br><span class="line">T<span class="variable constant_">TCP</span>/<span class="variable constant_">TPI</span> 信息</span><br><span class="line">t文件类型</span><br><span class="line">u进程用户 <span class="variable constant_">ID</span></span><br><span class="line">Z<span class="title class_">SELinux</span> 安全上下文（禁用 <span class="title class_">SELinux</span> 时禁用）</span><br><span class="line">z<span class="title class_">Solaris</span> <span class="number">10</span> 及更高版本的区域名</span><br><span class="line"><span class="number">0</span>使用<span class="variable constant_">NUL</span>字段结束符字符代替<span class="variable constant_">NL</span></span><br><span class="line"><span class="number">1</span>-<span class="number">9</span>系统特定的字段标识符</span><br></pre></td></tr></table></figure><p>​可以使用命令 <code>lsof -F?</code> 查看上面字段的说明信息。</p><h2 id="5-常用示例"><a href="#5-常用示例" class="headerlink" title="5.常用示例"></a>5.常用示例</h2><h3 id="（1）无任何参数，列出所有属于活动进程的打开文件。"><a href="#（1）无任何参数，列出所有属于活动进程的打开文件。" class="headerlink" title="（1）无任何参数，列出所有属于活动进程的打开文件。"></a>（1）无任何参数，列出所有属于活动进程的打开文件。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lsof | head</span><br><span class="line"><span class="variable constant_">COMMAND</span>     <span class="variable constant_">PID</span>   <span class="variable constant_">TID</span> <span class="variable constant_">USER</span>   <span class="variable constant_">FD</span>      <span class="variable constant_">TYPE</span>             <span class="variable constant_">DEVICE</span> <span class="variable constant_">SIZE</span>/<span class="variable constant_">OFF</span>       <span class="variable constant_">NODE</span> <span class="variable constant_">NAME</span></span><br><span class="line">systemd       <span class="number">1</span>       root  cwd       <span class="variable constant_">DIR</span>              <span class="number">252</span>,<span class="number">1</span>     <span class="number">4096</span>          <span class="number">2</span> /</span><br><span class="line">systemd       <span class="number">1</span>       root  rtd       <span class="variable constant_">DIR</span>              <span class="number">252</span>,<span class="number">1</span>     <span class="number">4096</span>          <span class="number">2</span> /</span><br><span class="line">systemd       <span class="number">1</span>       root  txt       <span class="variable constant_">REG</span>              <span class="number">252</span>,<span class="number">1</span>  <span class="number">1616248</span>      <span class="number">47908</span> /usr/lib/systemd/systemd</span><br><span class="line">systemd       <span class="number">1</span>       root  mem       <span class="variable constant_">REG</span>              <span class="number">252</span>,<span class="number">1</span>    <span class="number">20032</span>      <span class="number">25897</span> /usr/lib64/libuuid.<span class="property">so</span><span class="number">.1</span><span class="number">.3</span><span class="number">.0</span></span><br><span class="line">systemd       <span class="number">1</span>       root  mem       <span class="variable constant_">REG</span>              <span class="number">252</span>,<span class="number">1</span>   <span class="number">252704</span>      <span class="number">25043</span> /usr/lib64/libblkid.<span class="property">so</span><span class="number">.1</span><span class="number">.1</span><span class="number">.0</span></span><br><span class="line">systemd       <span class="number">1</span>       root  mem       <span class="variable constant_">REG</span>              <span class="number">252</span>,<span class="number">1</span>    <span class="number">90632</span>      <span class="number">25988</span> /usr/lib64/libz.<span class="property">so</span><span class="number">.1</span><span class="number">.2</span><span class="number">.7</span></span><br><span class="line">systemd       <span class="number">1</span>       root  mem       <span class="variable constant_">REG</span>              <span class="number">252</span>,<span class="number">1</span>   <span class="number">153192</span>      <span class="number">25496</span> /usr/lib64/liblzma.<span class="property">so</span><span class="number">.5</span><span class="number">.0</span><span class="number">.99</span></span><br><span class="line">systemd       <span class="number">1</span>       root  mem       <span class="variable constant_">REG</span>              <span class="number">252</span>,<span class="number">1</span>    <span class="number">23968</span>      <span class="number">25065</span> /usr/lib64/libcap-ng.<span class="property">so</span><span class="number">.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">systemd       <span class="number">1</span>       root  mem       <span class="variable constant_">REG</span>              <span class="number">252</span>,<span class="number">1</span>    <span class="number">19888</span>      <span class="number">25018</span> /usr/lib64/libattr.<span class="property">so</span><span class="number">.1</span><span class="number">.1</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><p>​lsof 输出各列信息的意义如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">COMMAND</span>：进程的名称</span><br><span class="line"><span class="variable constant_">PID</span>：进程标识符</span><br><span class="line"><span class="variable constant_">TID</span>：任务 <span class="variable constant_">ID</span>。<span class="title class_">Linux</span> 下 <span class="variable constant_">TID</span> 为空表示该行为进程</span><br><span class="line"><span class="variable constant_">USER</span>：进程所有者</span><br><span class="line"><span class="variable constant_">FD</span>：文件描述符。主要有：</span><br><span class="line">cwd：应用程序当前工作目录，这是该应用程序启动的目录，除非它本身对这个目录进行更改</span><br><span class="line">txt：该类型的文件是程序代码，如应用程序二进制文件本身或共享库，如上列表中显示的 /sbin/init 程序</span><br><span class="line">lnn：库引用（<span class="variable constant_">AIX</span>）</span><br><span class="line">err：<span class="variable constant_">FD</span> 信息错误</span><br><span class="line">jld：监狱目录（<span class="title class_">FreeBSD</span>）</span><br><span class="line">ltx：共享库文本（代码和数据）</span><br><span class="line">mxx：十六进制内存映射类型号 xx</span><br><span class="line">m86：<span class="variable constant_">DOS</span>合并映射文件</span><br><span class="line">mem：内存映射文件</span><br><span class="line">mmap：内存映射设备</span><br><span class="line">pd：父目录</span><br><span class="line">rtd：根目录</span><br><span class="line">tr：内核跟踪文件（<span class="title class_">OpenBSD</span>）</span><br><span class="line">v86：<span class="variable constant_">VP</span>/ix 映射文件</span><br><span class="line"><span class="number">0</span>：标准输出</span><br><span class="line"><span class="number">1</span>：标准输入</span><br><span class="line"><span class="number">2</span>：标准错误</span><br><span class="line"></span><br><span class="line">文件描述符后一般还跟着文件状态模式：</span><br><span class="line">r：只读模式</span><br><span class="line">w：写入模式</span><br><span class="line">u：读写模式</span><br><span class="line">空格：文件的状态模式为 unknow，且没有锁定</span><br><span class="line">-：文件的状态模式为 unknow，且被锁定</span><br><span class="line"></span><br><span class="line">同时在文件状态模式后面，还跟着相关的锁：</span><br><span class="line">N：对于未知类型的 <span class="title class_">Solaris</span> <span class="variable constant_">NFS</span> 锁</span><br><span class="line">r：文件部分的读锁</span><br><span class="line">R：整个文件的读锁</span><br><span class="line">w：文件的部分写锁</span><br><span class="line">W：整个文件的写锁</span><br><span class="line">u：任何长度的读写锁</span><br><span class="line">U：用于未知类型的锁</span><br><span class="line">x：用于部分文件上的 <span class="variable constant_">SCO</span> <span class="title class_">OpenServer</span> <span class="title class_">Xenix</span> 锁</span><br><span class="line">X：用于整个文件上的 <span class="variable constant_">SCO</span> <span class="title class_">OpenServer</span> <span class="title class_">Xenix</span> 锁</span><br><span class="line">space：无锁</span><br><span class="line"></span><br><span class="line"><span class="variable constant_">TYPE</span>：文件类型。常见的文件类型有：</span><br><span class="line"><span class="variable constant_">REG</span>：普通文件</span><br><span class="line"><span class="variable constant_">DIR</span>：表示目录</span><br><span class="line"><span class="variable constant_">CHR</span>：表示字符类型</span><br><span class="line"><span class="variable constant_">BLK</span>：块设备类型</span><br><span class="line"><span class="variable constant_">UNIX</span>：<span class="variable constant_">UNIX</span> 域套接字</span><br><span class="line"><span class="variable constant_">FIFO</span>：先进先出队列</span><br><span class="line"><span class="title class_">IPv4</span>：<span class="title class_">IPv4</span> 套接字</span><br><span class="line"><span class="variable constant_">DEVICE</span>：磁盘名称</span><br><span class="line"><span class="variable constant_">SIZE</span>：文件的大小或文件偏移量（以字节为单位）</span><br><span class="line"><span class="variable constant_">NODE</span>：索引节点</span><br><span class="line"><span class="variable constant_">NAME</span>：打开文件的确切名称</span><br></pre></td></tr></table></figure><h3 id="（2）查看谁正在使用某个文件，也就是说查找某个文件相关的进程。"><a href="#（2）查看谁正在使用某个文件，也就是说查找某个文件相关的进程。" class="headerlink" title="（2）查看谁正在使用某个文件，也就是说查找某个文件相关的进程。"></a>（2）查看谁正在使用某个文件，也就是说查找某个文件相关的进程。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lsof /bin/bash</span><br><span class="line"><span class="variable constant_">COMMAND</span>     <span class="variable constant_">PID</span> <span class="variable constant_">USER</span>  <span class="variable constant_">FD</span>   <span class="variable constant_">TYPE</span> <span class="variable constant_">DEVICE</span> <span class="variable constant_">SIZE</span>/<span class="variable constant_">OFF</span>  <span class="variable constant_">NODE</span> <span class="variable constant_">NAME</span></span><br><span class="line">watchdog.  <span class="number">7639</span> root txt    <span class="variable constant_">REG</span>  <span class="number">252</span>,<span class="number">1</span>   <span class="number">922760</span> <span class="number">45210</span> /usr/bin/bash</span><br><span class="line">bash       <span class="number">8591</span> root txt    <span class="variable constant_">REG</span>  <span class="number">252</span>,<span class="number">1</span>   <span class="number">922760</span> <span class="number">45210</span> /usr/bin/bash</span><br><span class="line">bash       <span class="number">9694</span> root txt    <span class="variable constant_">REG</span>  <span class="number">252</span>,<span class="number">1</span>   <span class="number">922760</span> <span class="number">45210</span> /usr/bin/bash</span><br><span class="line">bash      <span class="number">20151</span> root txt    <span class="variable constant_">REG</span>  <span class="number">252</span>,<span class="number">1</span>   <span class="number">922760</span> <span class="number">45210</span> /usr/bin/bash</span><br></pre></td></tr></table></figure><h3 id="（3）递归查看某个目录下所有被打开的文件信息。"><a href="#（3）递归查看某个目录下所有被打开的文件信息。" class="headerlink" title="（3）递归查看某个目录下所有被打开的文件信息。"></a>（3）递归查看某个目录下所有被打开的文件信息。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lsof +D ./test</span><br><span class="line"><span class="variable constant_">COMMAND</span>  <span class="variable constant_">PID</span> <span class="variable constant_">USER</span>   <span class="variable constant_">FD</span>   <span class="variable constant_">TYPE</span> <span class="variable constant_">DEVICE</span> <span class="variable constant_">SIZE</span>/<span class="variable constant_">OFF</span>   <span class="variable constant_">NODE</span> <span class="variable constant_">NAME</span></span><br><span class="line">bash    <span class="number">8518</span> root  cwd    <span class="variable constant_">DIR</span>  <span class="number">252</span>,<span class="number">1</span>     <span class="number">4096</span> <span class="number">799036</span> ./test/shell</span><br></pre></td></tr></table></figure><h3 id="（4）列出某个用户打开的文件信息。"><a href="#（4）列出某个用户打开的文件信息。" class="headerlink" title="（4）列出某个用户打开的文件信息。"></a>（4）列出某个用户打开的文件信息。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lsof -u root</span><br></pre></td></tr></table></figure><h3 id="（5）列出某个进程所打开的文件信息。"><a href="#（5）列出某个进程所打开的文件信息。" class="headerlink" title="（5）列出某个进程所打开的文件信息。"></a>（5）列出某个进程所打开的文件信息。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lsof -c sshd</span><br></pre></td></tr></table></figure><p>-c 选项将会列出所有以 sshd 开头的进程所打开的文件。其实也可以通过命令<code>lsof | grep sshd</code>来查看，但是第一种方法更加简洁。</p><h3 id="（6）列出多个进程打开的文件信息。"><a href="#（6）列出多个进程打开的文件信息。" class="headerlink" title="（6）列出多个进程打开的文件信息。"></a>（6）列出多个进程打开的文件信息。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lsof -c mysql -c apache</span><br></pre></td></tr></table></figure><h3 id="（7）列出某个用户以及某个进程所打开的文件信息。"><a href="#（7）列出某个用户以及某个进程所打开的文件信息。" class="headerlink" title="（7）列出某个用户以及某个进程所打开的文件信息。"></a>（7）列出某个用户以及某个进程所打开的文件信息。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lsof -u test -c mysql </span><br></pre></td></tr></table></figure><p>注意，-u 与 -c 选项之间是或的关系。可以使用 -</p><h3 id="（8）列出除了某个用户外的所有被打开的文件信息。"><a href="#（8）列出除了某个用户外的所有被打开的文件信息。" class="headerlink" title="（8）列出除了某个用户外的所有被打开的文件信息。"></a>（8）列出除了某个用户外的所有被打开的文件信息。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lsof -u ^root</span><br></pre></td></tr></table></figure><p>尖号 ^ 在用户名之前，表示排除在外，即不显示 root 用户所打开的文件信息。</p><h3 id="（9）通过某个进程号显示该进程打开的文件。"><a href="#（9）通过某个进程号显示该进程打开的文件。" class="headerlink" title="（9）通过某个进程号显示该进程打开的文件。"></a>（9）通过某个进程号显示该进程打开的文件。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lsof -p <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="（10）列出多个进程号对应的文件信息。"><a href="#（10）列出多个进程号对应的文件信息。" class="headerlink" title="（10）列出多个进程号对应的文件信息。"></a>（10）列出多个进程号对应的文件信息。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lsof -p <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="（11）列出除了某个进程号，其他进程号所打开的文件信息。"><a href="#（11）列出除了某个进程号，其他进程号所打开的文件信息。" class="headerlink" title="（11）列出除了某个进程号，其他进程号所打开的文件信息。"></a>（11）列出除了某个进程号，其他进程号所打开的文件信息。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lsof -p ^<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="（12）列出所有的网络连接。"><a href="#（12）列出所有的网络连接。" class="headerlink" title="（12）列出所有的网络连接。"></a>（12）列出所有的网络连接。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lsof -i</span><br></pre></td></tr></table></figure><h3 id="（13）列出所有的-TCP-网络连接信息。"><a href="#（13）列出所有的-TCP-网络连接信息。" class="headerlink" title="（13）列出所有的 TCP 网络连接信息。"></a>（13）列出所有的 TCP 网络连接信息。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lsof -i tcp</span><br></pre></td></tr></table></figure><h3 id="（14）列出所有-UDP-网络连接信息。"><a href="#（14）列出所有-UDP-网络连接信息。" class="headerlink" title="（14）列出所有 UDP 网络连接信息。"></a>（14）列出所有 UDP 网络连接信息。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lsof -i udp</span><br></pre></td></tr></table></figure><h3 id="（15）列出谁在使用某个端口。"><a href="#（15）列出谁在使用某个端口。" class="headerlink" title="（15）列出谁在使用某个端口。"></a>（15）列出谁在使用某个端口。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lsof -i :<span class="number">3306</span></span><br></pre></td></tr></table></figure><h3 id="（16）列出谁在使用某个特定的-UDP-或-TCP-端口。"><a href="#（16）列出谁在使用某个特定的-UDP-或-TCP-端口。" class="headerlink" title="（16）列出谁在使用某个特定的 UDP 或 TCP 端口。"></a>（16）列出谁在使用某个特定的 UDP 或 TCP 端口。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lsof -i <span class="attr">udp</span>:<span class="number">55</span></span><br><span class="line">lsof -i <span class="attr">tcp</span>:<span class="number">80</span></span><br></pre></td></tr></table></figure><h3 id="（17）列出某个用户的所有活跃的网络端口。"><a href="#（17）列出某个用户的所有活跃的网络端口。" class="headerlink" title="（17）列出某个用户的所有活跃的网络端口。"></a>（17）列出某个用户的所有活跃的网络端口。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lsof -a -u test -i</span><br></pre></td></tr></table></figure><h3 id="（18）列出所有网络文件系统。"><a href="#（18）列出所有网络文件系统。" class="headerlink" title="（18）列出所有网络文件系统。"></a>（18）列出所有网络文件系统。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lsof -N</span><br></pre></td></tr></table></figure><h3 id="（19）选择-UNIX-域套接字文件的列表。"><a href="#（19）选择-UNIX-域套接字文件的列表。" class="headerlink" title="（19）选择 UNIX 域套接字文件的列表。"></a>（19）选择 UNIX 域套接字文件的列表。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lsof -U</span><br></pre></td></tr></table></figure><h3 id="（20）查看某个用户组所打开的文件信息。"><a href="#（20）查看某个用户组所打开的文件信息。" class="headerlink" title="（20）查看某个用户组所打开的文件信息。"></a>（20）查看某个用户组所打开的文件信息。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lsof -g <span class="number">5555</span></span><br></pre></td></tr></table></figure><h3 id="（21）根据指定文件描述符的文件信息。"><a href="#（21）根据指定文件描述符的文件信息。" class="headerlink" title="（21）根据指定文件描述符的文件信息。"></a>（21）根据指定文件描述符的文件信息。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lsof -d txt</span><br><span class="line">lsof -d <span class="number">1</span></span><br><span class="line">lsof -d <span class="number">2</span></span><br></pre></td></tr></table></figure><p>0 表示标准输入，1 表示标准输出，2 表示标准错误，从而可知：所以大多数应用程序所打开的文件的 FD 都是从 3 开始。</p><h3 id="（22）查看指定文件描述符范围的文件信息。"><a href="#（22）查看指定文件描述符范围的文件信息。" class="headerlink" title="（22）查看指定文件描述符范围的文件信息。"></a>（22）查看指定文件描述符范围的文件信息。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lsof -d <span class="number">2</span>-<span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="（23列出-COMMAND-列中包含字符串-sshd-且文件描符的类型为-txt-的文件信息。"><a href="#（23列出-COMMAND-列中包含字符串-sshd-且文件描符的类型为-txt-的文件信息。" class="headerlink" title="（23列出 COMMAND 列中包含字符串 sshd 且文件描符的类型为 txt 的文件信息。"></a>（23列出 COMMAND 列中包含字符串 sshd 且文件描符的类型为 txt 的文件信息。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lsof -c sshd -a -d txt</span><br><span class="line"><span class="variable constant_">COMMAND</span>   <span class="variable constant_">PID</span> <span class="variable constant_">USER</span>  <span class="variable constant_">FD</span>   <span class="variable constant_">TYPE</span> <span class="variable constant_">DEVICE</span> <span class="variable constant_">SIZE</span>/<span class="variable constant_">OFF</span>  <span class="variable constant_">NODE</span> <span class="variable constant_">NAME</span></span><br><span class="line">sshd     <span class="number">8254</span> root txt    <span class="variable constant_">REG</span>  <span class="number">252</span>,<span class="number">1</span>   <span class="number">819608</span> <span class="number">27632</span> /usr/sbin/sshd</span><br><span class="line">sshd    <span class="number">20149</span> root txt    <span class="variable constant_">REG</span>  <span class="number">252</span>,<span class="number">1</span>   <span class="number">819608</span> <span class="number">27632</span> /usr/sbin/sshd</span><br></pre></td></tr></table></figure><h3 id="（24）列出被进程号为-1234-的进程所打开的所有-IPV4-网络文件。"><a href="#（24）列出被进程号为-1234-的进程所打开的所有-IPV4-网络文件。" class="headerlink" title="（24）列出被进程号为 1234 的进程所打开的所有 IPV4 网络文件。"></a>（24）列出被进程号为 1234 的进程所打开的所有 IPV4 网络文件。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lsof -p <span class="number">1234</span> -a -i <span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="（25）列出目前连接主机-peida-linux-上端口为：20，21，22，25-相关的所有文件信息，且每隔-3-秒不断地执行-lsof-指令。"><a href="#（25）列出目前连接主机-peida-linux-上端口为：20，21，22，25-相关的所有文件信息，且每隔-3-秒不断地执行-lsof-指令。" class="headerlink" title="（25）列出目前连接主机 peida.linux 上端口为：20，21，22，25 相关的所有文件信息，且每隔 3 秒不断地执行 lsof 指令。"></a>（25）列出目前连接主机 peida.linux 上端口为：20，21，22，25 相关的所有文件信息，且每隔 3 秒不断地执行 lsof 指令。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lsof -i @peida.<span class="property">linux</span>:<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">25</span> -r <span class="number">3</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令——ifconfig命令</title>
      <link href="/FRank675.github.io/posts/39c694be31b5/"/>
      <url>/FRank675.github.io/posts/39c694be31b5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="Linux命令——ifconfig命令"><a href="#Linux命令——ifconfig命令" class="headerlink" title="Linux命令——ifconfig命令"></a>Linux命令——ifconfig命令</h1><h2 id="1-命令简介"><a href="#1-命令简介" class="headerlink" title="1.命令简介"></a>1.命令简介</h2><p>ifconfig（configure a network interface）命令是系统管理员命令，用于查看和配置网络接口。</p><h2 id="2-命令格式"><a href="#2-命令格式" class="headerlink" title="2.命令格式"></a>2.命令格式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ifconfig [-v] [-a] [-s] [<span class="variable constant_">INTERFACE</span>]</span><br><span class="line">ifconfig [-v] <span class="variable constant_">INTERFACE</span> [aftype] <span class="variable constant_">OPTIONS</span> | <span class="variable constant_">ADDRESS</span> ...</span><br></pre></td></tr></table></figure><p>不跟任何选项和参数单独执行 ifconfig 命令将显示当前活动接口的状态。</p><p>如果给定一个接口参数，则它仅显示给定接口的状态。</p><p>如果只给一个选项 -a，它将显示所有接口的状态，包括那些关闭的接口。其他情况，用于配置一个接口。</p><h2 id="3-选项说明"><a href="#3-选项说明" class="headerlink" title="3.选项说明"></a>3.选项说明</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">-a</span><br><span class="line">显示所有接口的状态，包括那些关闭的接口</span><br><span class="line">-s</span><br><span class="line">显示接口简短状态列表，类似于 netstat -i</span><br><span class="line">-v</span><br><span class="line">冗余模式，遇到错误将报告错误信息</span><br><span class="line"><span class="variable constant_">INTERFACE</span></span><br><span class="line">接口的名称。这通常是一个驱动程序名，后面跟着一个单元号，例如用于第一个以太网接口的 eth0</span><br><span class="line">up</span><br><span class="line">此标志将导致激活接口。如果将地址分配给接口，则会隐式激活接口</span><br><span class="line">down</span><br><span class="line">此标志用于关闭接口的驱动程序</span><br><span class="line">[-]arp</span><br><span class="line">启用或关闭接口使用 <span class="variable constant_">ARP</span> 协议</span><br><span class="line">[-]promisc</span><br><span class="line">启用或禁用接口的混杂模式。如果选中，网络上的所有数据包都将由接口接收</span><br><span class="line">[-]allmulti</span><br><span class="line">启用或禁用所有多播模式。如果选中，则接口将接收网络上的所有多播数据包</span><br><span class="line">mtu N</span><br><span class="line">设置接口的最大传输单元</span><br><span class="line">dstaddr <span class="variable constant_">ADDR</span></span><br><span class="line">为点对点链路（如 <span class="variable constant_">PPP</span>）设置远程 <span class="variable constant_">IP</span> 地址。关键字 dstaddr 现在已经过时了，使用 pointopoint 关键字代替</span><br><span class="line">netmask <span class="variable constant_">ADDR</span></span><br><span class="line">设置接口的 <span class="variable constant_">IP</span> 网络掩码。此值默认为通常的 A、B 或 C 类网络掩码（从接口 <span class="variable constant_">IP</span> 地址派生），但可以设置为任何值</span><br><span class="line">add <span class="variable constant_">ADDR</span>/<span class="variable constant_">PREFIX_LEN</span></span><br><span class="line">向接口添加 <span class="title class_">IPv6</span> 地址</span><br><span class="line">del <span class="variable constant_">ADDR</span>/<span class="variable constant_">PREFIX_LEN</span></span><br><span class="line">从接口中删除 <span class="title class_">IPv6</span> 地址</span><br><span class="line">tunnel ::aa.<span class="property">bb</span>.<span class="property">cc</span>.<span class="property">dd</span></span><br><span class="line">创建一个新的<span class="title function_">SIT</span>(<span class="title class_">IPv6</span>-<span class="keyword">in</span>-<span class="title class_">IPv4</span>)设备，通过隧道到达给定的目的地</span><br><span class="line">irq <span class="variable constant_">ADDR</span></span><br><span class="line">设置此设备使用的中断行。并非所有设备都可以动态更改其 <span class="variable constant_">IRQ</span> 设置</span><br><span class="line">io_addr <span class="variable constant_">ADDR</span></span><br><span class="line">为该设备设置 I/O 空间中的起始地址</span><br><span class="line">mem_start <span class="variable constant_">ADDR</span></span><br><span class="line">设置此设备使用的共享内存的起始地址。只有少数几个设备需要这个</span><br><span class="line">media <span class="variable constant_">TYPE</span></span><br><span class="line">设置设备要使用的物理端口或介质类型。典型的类型值有10base2（细以太网）、10baseT（双绞线 10Mbps 以太网）、<span class="variable constant_">AUI</span>（外部收发器）等。特殊的媒体类型可以使用 auto 来告诉驱动程序进行自动感知。注意，并非所有设备都可以更改此设置</span><br><span class="line">[-]broadcast [<span class="variable constant_">ADDR</span>]</span><br><span class="line">如果给定地址参数，则为该接口设置协议广播地址。否则设置（或清除）接口的 <span class="variable constant_">IFF_BROADCAST</span>标志</span><br><span class="line">[-]pointopoint [<span class="variable constant_">ADDR</span>]</span><br><span class="line">这个关键字启用了接口的点对点模式，这意味着它是两台机器之间的直接连接，没有其他人监听它。如果给了地址参数，就像过时的 dstaddr 关键字一样，设置另一端的协议地址。否则设置或清除接口的 <span class="variable constant_">IFF_POINTOPOINT</span> 标志</span><br><span class="line">hw <span class="variable constant_">CLASS</span> <span class="variable constant_">ADDR</span></span><br><span class="line">如果设备驱动程序支持此操作，则设置此接口的物理地址。<span class="variable constant_">CLASS</span> 为硬件类型名称，<span class="variable constant_">ADDR</span> 为物理地址。目前支持的硬件类包括 ether (<span class="title class_">Ethernet</span>)、ax25 (<span class="variable constant_">AMPR</span> <span class="variable constant_">AX</span><span class="number">.25</span>)、<span class="title class_">ARCnet</span> 和 netrom (<span class="variable constant_">AMPR</span> <span class="variable constant_">NET</span>/<span class="variable constant_">ROM</span>)</span><br><span class="line">multicast</span><br><span class="line">在接口上设置多播标志。一般不需要显示设置，因为驱动程序本身会设置正确的标志</span><br><span class="line"><span class="variable constant_">ADDRESS</span></span><br><span class="line">接口的 <span class="variable constant_">IP</span> 地址</span><br><span class="line">txqueuelen <span class="variable constant_">LENGTH</span></span><br><span class="line">设置设备的传输队列的长度。对于具有高延迟（调制解调器链路，<span class="variable constant_">ISDN</span>）的较慢设备，将其设置为小值是有用的，以防止快速批量传输过多地干扰诸如 telnet 之类的交互通信</span><br></pre></td></tr></table></figure><h2 id="4-常用示例"><a href="#4-常用示例" class="headerlink" title="4.常用示例"></a>4.常用示例</h2><h3 id="（1）查看处于激活状态的网络接口信息。"><a href="#（1）查看处于激活状态的网络接口信息。" class="headerlink" title="（1）查看处于激活状态的网络接口信息。"></a>（1）查看处于激活状态的网络接口信息。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ifconfig</span><br><span class="line">eth0      <span class="title class_">Link</span> <span class="attr">encap</span>:<span class="title class_">Ethernet</span>  <span class="title class_">HWaddr</span> <span class="number">00</span>:<span class="number">16</span>:3<span class="attr">E</span>:<span class="number">00</span>:1<span class="attr">E</span>:<span class="number">51</span>  </span><br><span class="line">          inet <span class="attr">addr</span>:<span class="number">10.160</span><span class="number">.7</span><span class="number">.81</span>  <span class="title class_">Bcast</span>:<span class="number">10.160</span><span class="number">.15</span><span class="number">.255</span>  <span class="title class_">Mask</span>:<span class="number">255.255</span><span class="number">.240</span><span class="number">.0</span></span><br><span class="line">          <span class="variable constant_">UP</span> <span class="variable constant_">BROADCAST</span> <span class="variable constant_">RUNNING</span> <span class="variable constant_">MULTICAST</span>  <span class="attr">MTU</span>:<span class="number">1500</span>  <span class="title class_">Metric</span>:<span class="number">1</span></span><br><span class="line">          <span class="variable constant_">RX</span> <span class="attr">packets</span>:<span class="number">61430830</span> <span class="attr">errors</span>:<span class="number">0</span> <span class="attr">dropped</span>:<span class="number">0</span> <span class="attr">overruns</span>:<span class="number">0</span> <span class="attr">frame</span>:<span class="number">0</span></span><br><span class="line">          <span class="variable constant_">TX</span> <span class="attr">packets</span>:<span class="number">88534</span> <span class="attr">errors</span>:<span class="number">0</span> <span class="attr">dropped</span>:<span class="number">0</span> <span class="attr">overruns</span>:<span class="number">0</span> <span class="attr">carrier</span>:<span class="number">0</span></span><br><span class="line">          <span class="attr">collisions</span>:<span class="number">0</span> <span class="attr">txqueuelen</span>:<span class="number">1000</span></span><br><span class="line">          <span class="variable constant_">RX</span> <span class="attr">bytes</span>:<span class="number">3607197869</span> (<span class="number">3.3</span> <span class="title class_">GiB</span>)  <span class="variable constant_">TX</span> <span class="attr">bytes</span>:<span class="number">6115042</span> (<span class="number">5.8</span> <span class="title class_">MiB</span>)</span><br><span class="line"></span><br><span class="line">lo        <span class="title class_">Link</span> <span class="attr">encap</span>:<span class="title class_">Local</span> <span class="title class_">Loopback</span>  </span><br><span class="line">          inet <span class="attr">addr</span>:<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>  <span class="title class_">Mask</span>:<span class="number">255.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">          <span class="variable constant_">UP</span> <span class="variable constant_">LOOPBACK</span> <span class="variable constant_">RUNNING</span>  <span class="attr">MTU</span>:<span class="number">16436</span>  <span class="title class_">Metric</span>:<span class="number">1</span></span><br><span class="line">          <span class="variable constant_">RX</span> <span class="attr">packets</span>:<span class="number">56103</span> <span class="attr">errors</span>:<span class="number">0</span> <span class="attr">dropped</span>:<span class="number">0</span> <span class="attr">overruns</span>:<span class="number">0</span> <span class="attr">frame</span>:<span class="number">0</span></span><br><span class="line">          <span class="variable constant_">TX</span> <span class="attr">packets</span>:<span class="number">56103</span> <span class="attr">errors</span>:<span class="number">0</span> <span class="attr">dropped</span>:<span class="number">0</span> <span class="attr">overruns</span>:<span class="number">0</span> <span class="attr">carrier</span>:<span class="number">0</span></span><br><span class="line">          <span class="attr">collisions</span>:<span class="number">0</span> <span class="attr">txqueuelen</span>:<span class="number">0</span></span><br><span class="line">          <span class="variable constant_">RX</span> <span class="attr">bytes</span>:<span class="number">5079451</span> (<span class="number">4.8</span> <span class="title class_">MiB</span>)  <span class="variable constant_">TX</span> <span class="attr">bytes</span>:<span class="number">5079451</span> (<span class="number">4.8</span> <span class="title class_">MiB</span>)</span><br></pre></td></tr></table></figure><p>eth0 表示第一块网卡。</p><p>第一行 Link encap:Ethernet 表示连接类型为以太网，HWaddr 00:16:3E:00:1E:51 为网卡的物理地址；</p><p>第二行 inet addr:10.160.7.81 为网卡的 IPv4 地址，Bcast:10.160.15.255 为广播地址，Mask:255.255.240.0 为子网掩码； </p><p>第三行 UP（代表网卡开启状态），BROADCAST（支持广播），RUNNING（代表网卡的网线被接上），MULTICAST（支持组播），MTU:1500（最大传输单元 1500 字节），Metric:1 表示网卡路由数据包优先级，数值越低，优先级越高； </p><p>第四、五行：接收、发送数据包情况统计； </p><p>第七行：接收、发送数据字节数统计信息。</p><p>lo 是表示主机的回环地址，这个一般是用来测试一个网络程序，只能在本机上访问，局域网或外网的主机无法访问该地址。</p><h3 id="（2）查看所有网络接口信息，不论其是否激活。"><a href="#（2）查看所有网络接口信息，不论其是否激活。" class="headerlink" title="（2）查看所有网络接口信息，不论其是否激活。"></a>（2）查看所有网络接口信息，不论其是否激活。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ifconfig -a</span><br></pre></td></tr></table></figure><h3 id="（3）查看指定网络接口信息。"><a href="#（3）查看指定网络接口信息。" class="headerlink" title="（3）查看指定网络接口信息。"></a>（3）查看指定网络接口信息。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ifconfig eth0</span><br></pre></td></tr></table></figure><h3 id="（4）启动和关闭指定网卡。"><a href="#（4）启动和关闭指定网卡。" class="headerlink" title="（4）启动和关闭指定网卡。"></a>（4）启动和关闭指定网卡。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 启动网卡</span><br><span class="line">ifconfig eth0 up</span><br><span class="line"># 关闭网卡</span><br><span class="line">ifconfig eth0 down</span><br></pre></td></tr></table></figure><h3 id="（5）修改-MAC-地址。"><a href="#（5）修改-MAC-地址。" class="headerlink" title="（5）修改 MAC 地址。"></a>（5）修改 MAC 地址。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ifconfig eth0 down</span><br><span class="line">ifconfig eth0 hw ether <span class="number">00</span>:<span class="attr">AA</span>:<span class="attr">BB</span>:<span class="attr">CC</span>:<span class="attr">DD</span>:<span class="variable constant_">EE</span></span><br><span class="line">ifconfig eth0 up</span><br></pre></td></tr></table></figure><h3 id="（6）配置-IP-地址。"><a href="#（6）配置-IP-地址。" class="headerlink" title="（6）配置 IP 地址。"></a>（6）配置 IP 地址。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 给 eth0 网卡配置 <span class="variable constant_">IP</span> 地址</span><br><span class="line">ifconfig eth0 <span class="number">192.168</span><span class="number">.1</span><span class="number">.56</span></span><br><span class="line"></span><br><span class="line"># 给 eth0 网卡配置 <span class="variable constant_">IP</span> 地址并加上子网掩码</span><br><span class="line">ifconfig eth0 <span class="number">192.168</span><span class="number">.1</span><span class="number">.56</span> netmask <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span> </span><br><span class="line"></span><br><span class="line"># 给 eth0 网卡配置 <span class="variable constant_">IP</span> 地址，加上子网掩码，加上广播地址</span><br><span class="line">ifconfig eth0 <span class="number">192.168</span><span class="number">.1</span><span class="number">.56</span> netmask <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span> broadcast <span class="number">192.168</span><span class="number">.1</span><span class="number">.255</span></span><br></pre></td></tr></table></figure><h3 id="（7）启用和关闭-ARP-协议。"><a href="#（7）启用和关闭-ARP-协议。" class="headerlink" title="（7）启用和关闭 ARP 协议。"></a>（7）启用和关闭 ARP 协议。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 开启网卡 eth0 的 arp 协议</span><br><span class="line">ifconfig eth0 arp</span><br><span class="line"># 关闭网卡 eth0 的 arp 协议</span><br><span class="line">ifconfig eth0 -arp</span><br></pre></td></tr></table></figure><h3 id="（8）设置最大传输单元。"><a href="#（8）设置最大传输单元。" class="headerlink" title="（8）设置最大传输单元。"></a>（8）设置最大传输单元。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 设置能通过的最大数据包大小为 <span class="number">1500</span> bytes</span><br><span class="line">ifconfig eth0 mtu <span class="number">1500</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令——df命令</title>
      <link href="/FRank675.github.io/posts/210b0729d496/"/>
      <url>/FRank675.github.io/posts/210b0729d496/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="Linux命令——df命令"><a href="#Linux命令——df命令" class="headerlink" title="Linux命令——df命令"></a>Linux命令——df命令</h1><h2 id="1-功能"><a href="#1-功能" class="headerlink" title="1.功能"></a>1.功能</h2><p>用于查看Linux文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，以及剩余空间等信息。</p><h2 id="2-格式"><a href="#2-格式" class="headerlink" title="2.格式"></a>2.格式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">df [选项] [参数]</span><br></pre></td></tr></table></figure><h2 id="3-选项说明"><a href="#3-选项说明" class="headerlink" title="3.选项说明"></a>3.选项说明</h2><table><thead><tr><th align="left">选项</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">-a,–all</td><td align="left">显示所有的虚拟文件系统</td></tr><tr><td align="left">-B,–block-size&#x3D;SIZE</td><td align="left">使用指定的块大小</td></tr><tr><td align="left">-h,–human-readable</td><td align="left">以易读的方式显示磁盘空间已用与未用的大小</td></tr><tr><td align="left">–direct</td><td align="left">显示文件的统计信息，而不是挂载点</td></tr><tr><td align="left">–total</td><td align="left">显示所有文件系统总的使用情况</td></tr><tr><td align="left">-H,–si</td><td align="left">使用1000而非1024作为换算单位</td></tr><tr><td align="left">-i,–inodes</td><td align="left">显示索引节点inode信息，而非磁盘块的使用情况</td></tr><tr><td align="left">-k,–local</td><td align="left">同–block-size&#x3D;1K，即将块大小设置为1KB</td></tr><tr><td align="left">-t &lt;文件系统类型&gt;,–type&#x3D;TYPE</td><td align="left">显示指定的文件系统</td></tr><tr><td align="left">-T,–print-type</td><td align="left">显示文件系统类型</td></tr><tr><td align="left">-x &lt;文件系统类型&gt;,–exclude-type&#x3D;TYPE</td><td align="left">显示指定的文件系统之外的文件系统</td></tr><tr><td align="left">–no-sync</td><td align="left">不进行磁盘同步，默认选项</td></tr><tr><td align="left">-P</td><td align="left">输出格式为POSIX</td></tr><tr><td align="left">–help</td><td align="left">显示帮助信息</td></tr><tr><td align="left">–version</td><td align="left">显示版本信息</td></tr></tbody></table><h2 id="4-参数说明"><a href="#4-参数说明" class="headerlink" title="4.参数说明"></a>4.参数说明</h2><table><thead><tr><th align="left">参数</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">文件名称</td><td align="left">指定对应的磁盘分区或者外围设备</td></tr></tbody></table><h2 id="5-示例"><a href="#5-示例" class="headerlink" title="5.示例"></a>5.示例</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">df -hT</span><br><span class="line"><span class="title class_">Filesystem</span>    <span class="title class_">Type</span>    <span class="title class_">Size</span>  <span class="title class_">Used</span> <span class="title class_">Avail</span> <span class="title class_">Use</span>% <span class="title class_">Mounted</span> on</span><br><span class="line">/dev/mapper/vg_mic-lv_root</span><br><span class="line">              ext4     50G   16G   32G  <span class="number">33</span>% /</span><br><span class="line">tmpfs        tmpfs     16G     <span class="number">0</span>   16G   <span class="number">0</span>% <span class="regexp">/dev/</span>shm</span><br><span class="line">/dev/sda1     ext4    485M   38M  422M   <span class="number">9</span>% /boot</span><br><span class="line">/dev/mapper/vg_mic-lv_home</span><br><span class="line">              ext4    210G  197G  <span class="number">2.</span>7G  <span class="number">99</span>% /home</span><br></pre></td></tr></table></figure><p>上面的示例输出信息表示的意思分别是：  </p><p><strong>第一列</strong>：filesystem代表文件系统在哪个分区，所以列出设备名称。其中<code>/dev/mapper/vg_mic-lv_root</code>这行的意思是，你有一个VG (volume group，卷组)叫作vg_mic, vg_mic里面有一个LV(logical volume，逻辑卷)叫作lv_root。其实这个<code>/dev/mapper/vg_mic-lv_root</code>是一个连接文件，连接到&#x2F;dev&#x2F;dm-0的，可以用<code>ll /dev/mapper/vg_mic-lv_root</code>查看。实际上，可以将<code>vg_mic-lv_root</code>看作一个分区来对待就可以了。如果想查看实际的物理分区，可以使用命令pvdisplay[1,2]^{[1,2]}。</p><p><strong>第二列</strong>：Type代表文件系统类型。比如第三行的tmpfs是一种基于内存的文件系统，类似于ramdisk。tmpfs可以使用RAM，也可以使用swap分区来存储文件，提高文件的读写读写速度。再如第三行的&#x2F;dev&#x2F;sda1分区的文件系统是ext4。</p><p><strong>第三列</strong>：Size 代表分区的大小。</p><p><strong>第四列</strong>：Used表示已经使用的大小。</p><p><strong>第五列</strong>：Avail表示可用的大小。</p><p><strong>第六列</strong>：Use%表示以百分比显示已经使用的比例。</p><p><strong>第七列</strong>：Mounted on表示磁盘分区挂载的目录，即挂载点。</p><p>这里列一下Linux系统中磁盘与其它外设的命名规则，以及磁盘分区的命名规则。</p><p>常见的设备与其在Linux中的文件名如下表：</p><table><thead><tr><th align="left">设备</th><th align="left">文件名</th></tr></thead><tbody><tr><td align="left">IDE硬盘</td><td align="left">&#x2F;dev&#x2F;hd[a-d]</td></tr><tr><td align="left">SCSI&#x2F;SATA&#x2F;USB硬盘与U盘</td><td align="left">&#x2F;dev&#x2F;sd[a-p]</td></tr><tr><td align="left">软驱</td><td align="left">&#x2F;dev&#x2F;fd[0-1]</td></tr><tr><td align="left">打印机</td><td align="left">25针：&#x2F;dev&#x2F;lp[]0-2USB:&#x2F;dev&#x2F;usb&#x2F;lp[0-15]</td></tr><tr><td align="left">鼠标</td><td align="left">USB：&#x2F;dev&#x2F;usb&#x2F;mouse[0-15]ps2:&#x2F;dev&#x2F;psaux</td></tr><tr><td align="left">当前CD ROM&#x2F;DVD ROM</td><td align="left">cdrom</td></tr><tr><td align="left">当前鼠标</td><td align="left">&#x2F;dev&#x2F;mouse</td></tr><tr><td align="left">磁带机</td><td align="left">IDE：&#x2F;dev&#x2F;ht0SCSI:&#x2F;dev&#x2F;st0</td></tr></tbody></table><p>需要注意的是，每个磁盘驱动器的磁盘分区（partition）不同时，磁盘文件名还会改变。此外，磁带机的文件名，在某些不同的linux发行版本中可能不一样。</p><p>IDE磁盘，一般可以接4个，磁盘名称分别是hda，hdb，hdc和hdd。以hda为例，如果分为四个分区，则四个分区的名称分别为hda1，hda2，hda3和hda4，其他三个磁盘的分区名称以此类推。</p><p>一个IDE磁盘、SATA磁盘和SCSI 磁盘主分区与扩展分区加在一起最多4个，扩展分区最多只有一个，扩展分区中再开辟逻辑分区。</p><p>IDE磁盘最多可以分63个分区，59个逻辑分区。  SATA硬盘最多15个分区，11个逻辑分区。  SCSI硬盘最多16个分区，12个逻辑分区。</p><p>SATA硬盘的分区名称与IDE磁盘的分区名称类似，以第一块SATA磁盘sda为例，那么各个分区的名称分别是sda1，sda2，sda3…，以此类推。可见，IDE磁盘与SATA磁盘的分区号均是从1开始的[3]^{[3]}。</p><p>SCSI硬盘的分区名称与SATA硬盘分区名称相同。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令——crontab命令</title>
      <link href="/FRank675.github.io/posts/f77050876da6/"/>
      <url>/FRank675.github.io/posts/f77050876da6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="Linux命令——crontab命令"><a href="#Linux命令——crontab命令" class="headerlink" title="Linux命令——crontab命令"></a>Linux命令——crontab命令</h1><h2 id="1-命令简介"><a href="#1-命令简介" class="headerlink" title="1.命令简介"></a>1.命令简介</h2><p>contab（cron table） 命令被用管理用户的需要周期性执行的任务，与 Windows 下的计划任务类似，当安装完操作系统后，默认会安装此服务工具，并且会自动启动 crond 进程，crond 进程每分钟会检查是否有要执行的任务，如果有则执行该任务。</p><p>Linux 下的任务调度分为两类，系统任务调度和用户任务调度。</p><p><strong>系统任务调度</strong>：系统周期性所要执行的工作，比如写缓存数据到硬盘、日志清理等。&#x2F;etc&#x2F;crontab 文件是系统任务调度的配置文件。</p><p><strong>用户任务调度</strong>：用户定期要执行的工作，比如用户<a href="https://cloud.tencent.com/solution/backup?from=10680">数据备份</a>、定时邮件提醒等。用户可以使用 crontab 工具来定制自己的计划任务。所有用户定义的 crontab 文件都被保存在 &#x2F;var&#x2F;spool&#x2F;cron 目录中，其文件名与用户名一致。</p><p>系统管理员可以通过&#x2F;etc&#x2F;cron.deny 和 &#x2F;etc&#x2F;cron.allow 这两个文件来禁止或允许用户拥有自己的 crontab 文件。</p><h2 id="2-命令格式"><a href="#2-命令格式" class="headerlink" title="2.命令格式"></a>2.命令格式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">crontab [-u <span class="variable constant_">USER</span>] <span class="variable constant_">FILE</span></span><br><span class="line">crontab [-u <span class="variable constant_">USER</span>] [-l | -r | -e] [-i] [-s]</span><br><span class="line">crontab -n [ <span class="variable constant_">HOSTNAME</span> ]</span><br><span class="line">crontab -c</span><br></pre></td></tr></table></figure><h2 id="3-选项说明"><a href="#3-选项说明" class="headerlink" title="3.选项说明"></a>3.选项说明</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">-u</span><br><span class="line">指定要设置定时任务的用户名</span><br><span class="line">-l</span><br><span class="line">列出当前的定时任务</span><br><span class="line">-r</span><br><span class="line">删除定时任务</span><br><span class="line">-e</span><br><span class="line">编辑用户的定时任务。任务保存在 /<span class="keyword">var</span>/spool/cron 目录下与用户名同名的文件中</span><br><span class="line">-i</span><br><span class="line">在删除定时任务前询问用户是否确定删除</span><br><span class="line">-s</span><br><span class="line">在进行编辑/替换之前，将当前的 <span class="title class_">SELinux</span> 安全上下文字符串作为 <span class="variable constant_">MLS_LEVEL</span> 附加到 crontab 文件</span><br><span class="line">-n [<span class="variable constant_">HOSTNAME</span>]</span><br><span class="line">此选项只有当 <span class="title function_">cron</span>(<span class="number">8</span>) 使用 -c 选项启动以支持集群环境时才使用，用于指定集群中哪个主机执行定时 crontab 文件中的定时任务。如果省略了主机名，则使用 <span class="title function_">gethostname</span>(<span class="number">2</span>) 返回的本地主机名</span><br><span class="line">-c</span><br><span class="line">此选项只有当 <span class="title function_">cron</span>(<span class="number">8</span>) 使用 -c 选项启动以支持集群环境时才使用，用于查询集群中当前哪个主机执行定时 crontab 文件中的定时任务</span><br></pre></td></tr></table></figure><h2 id="4-用户配置文件"><a href="#4-用户配置文件" class="headerlink" title="4.用户配置文件"></a>4.用户配置文件</h2><p>crontab 文件保存了用户的定时任务，以特定格式保存在 &#x2F;var&#x2F;spool&#x2F;cron 目录下与用户名同名的文件中。</p><p>例如如果是 root 用户，那么添加任务时，会在该路径下有一个 root 文件。</p><p>Linux 的 cron 服务会每隔一分钟去读取一次 &#x2F;var&#x2F;spool&#x2F;cron 目录下面所有的内容。</p><p>crontab 文件每一行代表一项任务，每项任务分为六个字段，前五个字段是时间字段，第六个字段是要执行的命令，格式如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">minute hour day month week command</span><br></pre></td></tr></table></figure><p>minute 分钟，取值范围 0 到 59； </p><p>hour 小时，取值范围 0 到 23； </p><p>day 日期，取值范围 1 到 31； </p><p>month 月份，取值范围 1 到 12，或 jan,feb,mar,apr…； </p><p>week 星期，取值范围 0 到 7，或 sun,mon,tue,wed,thu,fri,sat。</p><p>注意 0 和 7 均代表星期日； </p><p>command 要执行的命令，可以是系统命令，也可以是自己编写的脚本文件；</p><p>在以上各个时间字段中，还可以使用以下特殊字符：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">* 表示所有可能的值，例如 minute 是 *，表示每分钟都执行命令</span><br><span class="line">, 可以用逗号隔开的值指定一个列表，例如，<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span></span><br><span class="line">- 可以用整数之间的横杠表示一个范围，例如 <span class="number">2</span>-<span class="number">6</span> 表示 <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> </span><br><span class="line">/ 可以用斜杠指定时间的间隔频率，例如 minute 为 */<span class="number">2</span> 表示每两分钟执行一次命令</span><br></pre></td></tr></table></figure><p>注意，crontab 文件注释符号为 #。</p><h2 id="5-系统配置文件"><a href="#5-系统配置文件" class="headerlink" title="5.系统配置文件"></a>5.系统配置文件</h2><p>除了用户的 crontab 文件，与定时任务相关的系统配置文件有：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/etc/crontab系统定时任务配置文件</span><br><span class="line">/etc/cron.<span class="property">d</span>自动定期需要做的任务</span><br><span class="line">/etc/cron.<span class="property">hourly</span>每小时执行一次的任务</span><br><span class="line">/etc/cron.<span class="property">daily</span>每天执行一次的任务</span><br><span class="line">/etc/cron.<span class="property">weekly</span>每周执行一次的任务</span><br><span class="line">/etc/cron.<span class="property">monthly</span>每月执行一次的任务</span><br><span class="line">/etc/cron.<span class="property">allow</span>    该文件中所列用户允许执行定时任务</span><br><span class="line">/etc/cron.<span class="property">deny</span>    该文件中所列用户不允许执行定时任务</span><br><span class="line">/<span class="keyword">var</span>/log/croncrontab 的日志文件</span><br></pre></td></tr></table></figure><p>Linux 的 cron 服务会每隔一分钟去读取一次 &#x2F;etc&#x2F;crontab 文件和 &#x2F;etc&#x2F;cron.d 目录下面所有的内容。</p><p>&#x2F;etc&#x2F;cron.hourly、&#x2F;etc&#x2F;cron.daily、&#x2F;etc&#x2F;cron.weekly 和 &#x2F;etc&#x2F;cron.monthly 下的任务也会间接按照相应的周期被调用。</p><h2 id="6-常用示例"><a href="#6-常用示例" class="headerlink" title="6.常用示例"></a>6.常用示例</h2><h3 id="（1）添加定时任务。"><a href="#（1）添加定时任务。" class="headerlink" title="（1）添加定时任务。"></a>（1）添加定时任务。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br><span class="line">* * * * * command# 每分钟执行一次 command</span><br><span class="line"><span class="number">3</span>,<span class="number">15</span> * * * * command# 每小时的第 <span class="number">3</span> 和第 <span class="number">15</span> 分钟执行</span><br><span class="line"><span class="number">3</span>,<span class="number">15</span> <span class="number">8</span>-<span class="number">11</span> * * * command# 上午 <span class="number">8</span> 点到 <span class="number">11</span>点每小时第 <span class="number">3</span> 和第 <span class="number">15</span> 分钟执行</span><br><span class="line"><span class="number">3</span>,<span class="number">15</span> <span class="number">8</span>-<span class="number">11</span> * * <span class="number">1</span> command# 每个星期一的上午 <span class="number">8</span> 点到 <span class="number">11</span> 点的第 <span class="number">3</span> 和第 <span class="number">15</span> 分钟执行</span><br><span class="line"><span class="number">3</span>,<span class="number">15</span> <span class="number">8</span>-<span class="number">11</span> <span class="number">1</span> * * command# 每个月一号上午 <span class="number">8</span> 点到 <span class="number">11</span> 点的第 <span class="number">3</span> 和第 <span class="number">15</span> 分钟执行</span><br><span class="line"><span class="number">3</span>,<span class="number">15</span> <span class="number">8</span>-<span class="number">11</span> <span class="number">1</span> <span class="number">1</span> * command# 每年一月一号上午 <span class="number">8</span> 点到 <span class="number">11</span> 点的第 <span class="number">3</span> 和第 <span class="number">15</span> 分钟执行</span><br><span class="line"><span class="number">0</span> *<span class="regexp">/2 * * * /</span>sbin/service httpd restart# 每隔两个小时在第 <span class="number">0</span> 分时候重启一次 httpd</span><br></pre></td></tr></table></figure><h3 id="（2）查看定时任务。"><a href="#（2）查看定时任务。" class="headerlink" title="（2）查看定时任务。"></a>（2）查看定时任务。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">crontab -l</span><br></pre></td></tr></table></figure><h3 id="（3）删除定时任务"><a href="#（3）删除定时任务" class="headerlink" title="（3）删除定时任务"></a>（3）删除定时任务</h3><p>即清除 &#x2F;var&#x2F;spool&#x2F;cron 目录下 crontab 文件。危险动作，请注意备份。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">crontab -r</span><br></pre></td></tr></table></figure><h3 id="（4）将指定的-crontab-文件还原到-x2F-var-x2F-spool-x2F-cron-目录下。"><a href="#（4）将指定的-crontab-文件还原到-x2F-var-x2F-spool-x2F-cron-目录下。" class="headerlink" title="（4）将指定的 crontab 文件还原到 &#x2F;var&#x2F;spool&#x2F;cron 目录下。"></a>（4）将指定的 crontab 文件还原到 &#x2F;var&#x2F;spool&#x2F;cron 目录下。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">crontab <span class="variable constant_">FILE</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令——cd命令</title>
      <link href="/FRank675.github.io/posts/337d2d2224c8/"/>
      <url>/FRank675.github.io/posts/337d2d2224c8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="Linux命令——cd命令"><a href="#Linux命令——cd命令" class="headerlink" title="Linux命令——cd命令"></a>Linux命令——cd命令</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>cd命令是shell的内建命令（bash builtin），用来切换工作目录至指定的目录dirname。</p><p> 其中dirname可以是绝对路径或相对路径。</p><p>若目录名称省略，则变换至使用者的home directory（也就是刚login时所在的目录）。</p><p>另外，~也表示为home directory的意思，.则是表示目前所在的目录，..则表示目前目录位置的上一层目录。</p><h2 id="2-命令格式"><a href="#2-命令格式" class="headerlink" title="2.命令格式"></a>2.命令格式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cd [-L|-P] [dir]</span><br></pre></td></tr></table></figure><h2 id="3-命令选项"><a href="#3-命令选项" class="headerlink" title="3.命令选项"></a>3.命令选项</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">-p：如果要切换到的目标目录是一个符号连接，直接切换到符号连接指向的目标目录。</span><br><span class="line">-L：如果要切换的目标目录是一个符号的连接，直接切换到字符连接名代表的目录，而非符号连接所指向的目标目录。</span><br><span class="line">-：当仅使用一个横杠 - 时，当前工作目录将被切换到环境变量<span class="string">&quot;OLDPWD&quot;</span>所表示的目录。</span><br></pre></td></tr></table></figure><h2 id="4-常用示例"><a href="#4-常用示例" class="headerlink" title="4.常用示例"></a>4.常用示例</h2><h3 id="（1）回到上一层目录："><a href="#（1）回到上一层目录：" class="headerlink" title="（1）回到上一层目录："></a>（1）回到上一层目录：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cd ..</span><br></pre></td></tr></table></figure><h3 id="（2）回到根目录："><a href="#（2）回到根目录：" class="headerlink" title="（2）回到根目录："></a>（2）回到根目录：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cd /</span><br></pre></td></tr></table></figure><h3 id="（3）回到上次使用的目录："><a href="#（3）回到上次使用的目录：" class="headerlink" title="（3）回到上次使用的目录："></a>（3）回到上次使用的目录：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cd –</span><br></pre></td></tr></table></figure><h3 id="（4）回到用户家目录："><a href="#（4）回到用户家目录：" class="headerlink" title="（4）回到用户家目录："></a>（4）回到用户家目录：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cd ~</span><br><span class="line">#或</span><br><span class="line">cd -- </span><br></pre></td></tr></table></figure><p><strong>注意：</strong>  </p><p>（1）登录Linux主机后，命令行最左侧<code>[lvlv@echidna ~/code]$</code>中，~表示在当前用户的家目录，$表示是普通用户权限，#则表示超级用户权限。echidna表示当前主机的名称，lvlv则表示当前登录的用户名称。查看当前主机名称用hostname命令。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令——cat命令</title>
      <link href="/FRank675.github.io/posts/44cb01cbd9f6/"/>
      <url>/FRank675.github.io/posts/44cb01cbd9f6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="Linux命令——cat命令"><a href="#Linux命令——cat命令" class="headerlink" title="Linux命令——cat命令"></a>Linux命令——cat命令</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>cat 命令用于连接文件或者标准输入的内容，并打印到标准输出设备上。</p><h2 id="2-命令格式"><a href="#2-命令格式" class="headerlink" title="2.命令格式"></a>2.命令格式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cat [<span class="variable constant_">OPTION</span>]... [<span class="variable constant_">FILE</span>]...</span><br></pre></td></tr></table></figure><h2 id="3-选项说明"><a href="#3-选项说明" class="headerlink" title="3.选项说明"></a>3.选项说明</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">-：从标准输入获取内容。</span><br><span class="line">-A, --show-all：等价于-vET，显示文件内所有不可打印的字符。</span><br><span class="line">-b, --number-nonblank：和 -n 相似，只不过对于空白行不编号。</span><br><span class="line">-e : 等价于 -vE。</span><br><span class="line">-E, --show-ends：在每行结束处显示 $。</span><br><span class="line">-n, --number：由 <span class="number">1</span> 开始对所有输出的行数编号。</span><br><span class="line">-s, --squeeze-blank：当遇到有连续两行以上的空白行，就代换为一行的空白行。</span><br><span class="line">-t：等价于<span class="string">&quot;-vT&quot;</span>选项。</span><br><span class="line">-T, --show-tabs： 将 <span class="variable constant_">TAB</span> 字符显示为 ^I。</span><br><span class="line">-v, --show-nonprinting：使用 ^ 和 M- 符号，除了 <span class="variable constant_">LFD</span> 和 <span class="variable constant_">TAB</span> 之外。</span><br><span class="line">--help：显示帮助信息。</span><br><span class="line">--version：显示版本信息。</span><br></pre></td></tr></table></figure><h2 id="4-常用示例"><a href="#4-常用示例" class="headerlink" title="4.常用示例"></a>4.常用示例</h2><h3 id="（1）将几个文件合并为一个文件。"><a href="#（1）将几个文件合并为一个文件。" class="headerlink" title="（1）将几个文件合并为一个文件。"></a>（1）将几个文件合并为一个文件。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$ cat file1 file2 &gt; file</span><br></pre></td></tr></table></figure><h3 id="（2）查看文件。"><a href="#（2）查看文件。" class="headerlink" title="（2）查看文件。"></a>（2）查看文件。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$ cat  file</span><br></pre></td></tr></table></figure><h3 id="（3）从键盘创建一个文件。"><a href="#（3）从键盘创建一个文件。" class="headerlink" title="（3）从键盘创建一个文件。"></a>（3）从键盘创建一个文件。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$ cat &gt; filename<span class="string">`</span></span><br></pre></td></tr></table></figure><h3 id="（4）把-textfile1-的文档内容加上行号后输入-textfile2-这个文档里。"><a href="#（4）把-textfile1-的文档内容加上行号后输入-textfile2-这个文档里。" class="headerlink" title="（4）把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里。"></a>（4）把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$ cat -n textfile1 &gt; textfile2</span><br></pre></td></tr></table></figure><h3 id="（5）将文件file1和标准输入内容，纵向连接后重定向至文件file2。"><a href="#（5）将文件file1和标准输入内容，纵向连接后重定向至文件file2。" class="headerlink" title="（5）将文件file1和标准输入内容，纵向连接后重定向至文件file2。"></a>（5）将文件file1和标准输入内容，纵向连接后重定向至文件file2。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$ cat file1 - &gt; file2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令——awk命令</title>
      <link href="/FRank675.github.io/posts/658af63f600d/"/>
      <url>/FRank675.github.io/posts/658af63f600d/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="Linux命令——awk命令"><a href="#Linux命令——awk命令" class="headerlink" title="Linux命令——awk命令"></a>Linux命令——awk命令</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>AWK是一个优良的文本处理工具，Linux及Unix环境中现有的功能最强大的数据处理引擎之一。</p><p>数据可以来自标准输入(stdin)、一个或多个文件，或其它命令的输出。</p><p>它支持用户自定义函数和动态正则表达式等先进功能，是linux&#x2F;unix下的一个强大编程工具。</p><p>它在命令行中使用，但更多是作为脚本来使用。</p><p>awk有很多内建的功能，比如数组、函数等，这是它和C语言的相同之处，灵活性是awk最大的优势。</p><p>简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。</p><p>awk有3个不同版本: awk、nawk和gawk，未作特别说明，一般指gawk，gawk 是 AWK 的 GNU 版本。</p><p>awk其名称得自于它的创始人 Alfred Aho 、Peter Weinberger 和 Brian Kernighan 姓氏的首个字母。</p><p>实际上AWK的确拥有自己的语言： AWK程序设计语言 ， 三位创建者已将它正式定义为“样式扫描和处理语言”。</p><p>它允许您创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成<a href="https://cloud.tencent.com/product/bi?from=10680">报表</a>，还有无数其他的功能。</p><h2 id="2-命令格式"><a href="#2-命令格式" class="headerlink" title="2.命令格式"></a>2.命令格式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">awk [options] <span class="string">&#x27;pattern + &#123;action&#125;&#x27;</span> [filenames...]</span><br></pre></td></tr></table></figure><p>尽管操作可能会很复杂，但语法总是这样。awk通常用来格式化文本文件中的信息，是以文件的一行为处理单位，每接收文件的一行，然后执行相应的命令，来处理文本。其中pattern表示AWK在数据中查找的内容，而action是在找到匹配内容时所执行的一系列命令。花括号{}不需要在程序中始终出现，但它们用于根据特定的模式对一系列指令进行分组。pattern表示的正则表达式，用斜杠括起来，action 对匹配的行进行处理。</p><p><strong>注意：</strong>  </p><p>（1）pattern缺省为1，action缺省为{print}。  </p><p>（2）pattern + {action}可以同时存在多个，每个pattern之间的关系是或，只要当前行匹配pattern，则执行pattern后大括号中的commands。</p><h2 id="3-常用命令选项"><a href="#3-常用命令选项" class="headerlink" title="3.常用命令选项"></a>3.常用命令选项</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">-F fs,--field-separator fs：使用字符串fs作为域分隔符。可以同时指定多个域分隔符，此时需要使用一对中括号括起来。例如使用-和|可写作 -F <span class="string">&#x27;[-|]&#x27;</span>。如果用[]作为分隔符，可写作-F <span class="string">&#x27;[][]&#x27;</span>。不指定分隔符，默认为空格和<span class="title class_">Tab</span>。需要注意，awk命令使用-F<span class="string">&#x27; &#x27;</span>显示指定空格时，tab也会被作为分隔符。</span><br><span class="line">-v [<span class="keyword">var</span>]=[val],--assign [<span class="keyword">var</span>]=[val]：定义一个awk变量并赋值，可以将外部变量传递给awk；</span><br><span class="line">-f [program-file],--file [program-file]：从指定的awk脚本文件program-file读取awk指令；</span><br><span class="line">-m[f/r] <span class="attr">val</span>:对val值设置内在限制，-mf选项限制分配给val的最大块数目；-mr选项限制记录的最大数目。这两个功能是<span class="title class_">Bell</span>实验室版awk的扩展功能，在标准awk中不适用;</span><br><span class="line">-O,--optimize：在程序的内部表示上启用优化。目前，这只包括简单的常量折叠。gawk的维护者系统随着时间推移，增加额外的优化；</span><br><span class="line">-W compat,-W traditional,--compat,--traditional：是awk运行在兼容模式下，gawk的任何扩展都不会被识别；</span><br><span class="line">-W copyleft,--copyleft,-W copyright,--copyright：打印简短的版权信息；</span><br><span class="line">-W dump-variables[=file],--dump-variables[=file]：将awk的全局变量排序后打印到指定的文件file中，如果没有指定file，则在当前目录默认生成一个awkvars.<span class="property">out</span>；</span><br><span class="line">-W exec [file],--exec [file]:功能类似于命令选项-f，但脚本文件需要以#!开头；另外命令行的变量将不再生效；</span><br><span class="line">-W gen-po,--gen-<span class="attr">po</span>:解析awk程序，产生.<span class="property">po</span>格式的文件到标准输出，来标明程序中每一个可本地化的字符串位置（自己翻译的可能不准确）；</span><br><span class="line">-W help,-W usage,--help,--<span class="attr">usage</span>:打印全部awk选项和每个选项的简短说明;</span><br><span class="line">-W lint[=value],--lint[=value]:打印有关在其它版本awk中，出现可疑的或不可移植结构的警告。该选项提供了一个可选的参数fatal，即将警告视为致命的错误；</span><br><span class="line">-W lint-old,--lint-<span class="attr">old</span>:打印关于不能向传统unix平台移植的结构的警告；</span><br><span class="line">-W non-decimal-data,--non-decimal-data：识别输入数据中的八进制和十六进制数；</span><br><span class="line">-W posix,--posix：打开兼容模式，会出现以下限制：</span><br><span class="line">    不识别\x;</span><br><span class="line">    当域分隔fs是一个空格时，只有空格和tab能作为域分隔符，换行符将不能作为一个域分隔符；</span><br><span class="line">    在?和:之后，不能继续当前行；</span><br><span class="line">    函数关键字func将不能被识别；</span><br><span class="line">    操作符**和**=不能代替^和^=；</span><br><span class="line">    fflush函数无效。</span><br><span class="line">-W profile[=prof_file],--profile[=prof_file]：输出性能分析报告至指定的文件prof_file,如果prof_file缺省，默认输出到awkprof.<span class="property">out</span>；</span><br><span class="line">-W re-interval,--re-interval：允许间隔正则表达式的使用，参考(grep中的<span class="title class_">Posix</span>字符类)，如括号表达式[[:<span class="attr">alpha</span>:]]；</span><br><span class="line">-W source program-text,--source program-<span class="attr">text</span>:使用program-text作为源代码，可与-f命令混用；</span><br><span class="line">-W use-lc-numeric,--use-lc-<span class="attr">numeric</span>:是awk使用本地小数点解析输入的数据（自己翻译的可能不准确）；</span><br><span class="line">-W version,--<span class="attr">version</span>:打印awk版本信息；</span><br><span class="line">--:标识命令选项结束。（自己翻译的可能不准确）</span><br></pre></td></tr></table></figure><h2 id="4-调用awk方式"><a href="#4-调用awk方式" class="headerlink" title="4.调用awk方式"></a>4.调用awk方式</h2><p>有三种方式调用awk。</p><h3 id="（1）命令行方式。"><a href="#（1）命令行方式。" class="headerlink" title="（1）命令行方式。"></a>（1）命令行方式。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">awk [-F  field-separator]  <span class="string">&#x27;pattern + &#123;action&#125;&#x27;</span>  input-<span class="title function_">file</span>(s)</span><br></pre></td></tr></table></figure><p>其中，commands 是真正awk命令，[-F域分隔符]是可选的。 input-file(s) 是待处理的文件。  在awk中，文件的每一行中，由域分隔符分开的每一项称为一个域。通常，在不指名-F域分隔符的情况下，默认的域分隔符是空格。</p><h3 id="（2）shell脚本方式。"><a href="#（2）shell脚本方式。" class="headerlink" title="（2）shell脚本方式。"></a>（2）shell脚本方式。</h3><p>  将所有的awk命令插入一个文件，脚本中在首行注明使用awk命令来解析执行，相当于将shell脚本首行的：<code>#!/bin/sh</code>换成：<code>#!/bin/awk</code>，最后通过键入脚本名称来调用。</p><h3 id="（3）将所有的awk命令插入到一个单独文件，然后使用-f选项调用。"><a href="#（3）将所有的awk命令插入到一个单独文件，然后使用-f选项调用。" class="headerlink" title="（3）将所有的awk命令插入到一个单独文件，然后使用-f选项调用。"></a>（3）将所有的awk命令插入到一个单独文件，然后使用-f选项调用。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">awk -f awk-script-file input-<span class="title function_">file</span>(s)</span><br></pre></td></tr></table></figure><p>其中，-f选项加载awk-script-file中的awk脚本，input-file(s)跟上面的是一样的。</p><h2 id="5-awk内置变量"><a href="#5-awk内置变量" class="headerlink" title="5.awk内置变量"></a>5.awk内置变量</h2><p>awk有许多内置变量用来设置环境信息，这些变量可以被改变，下面给出常见的内置变量说明。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$n             当前记录的第n个字段，n从<span class="number">1</span>开始，字段间由<span class="variable constant_">FS</span>分隔</span><br><span class="line">$<span class="number">0</span>             当前完成的记录（当前处理行）</span><br><span class="line"><span class="variable constant_">ARGC</span>            命令行参数个数</span><br><span class="line"><span class="variable constant_">ARGIND</span>          命令行中当前处理文件的位置(从<span class="number">0</span>开始算)</span><br><span class="line"><span class="variable constant_">ARGV</span>            命令行参数数组</span><br><span class="line"><span class="variable constant_">CONVFMT</span>         数字转换格式，默认值为%.6g</span><br><span class="line"><span class="variable constant_">ENVIRON</span>         支持队列中系统环境变量的使用</span><br><span class="line"><span class="variable constant_">ERRNO</span>           最后一个系统错误的描述</span><br><span class="line"><span class="variable constant_">FIELDWIDTHS</span>     字段宽度列表(用空格键分隔)</span><br><span class="line"><span class="variable constant_">FILENAME</span>        awk浏览的文件名</span><br><span class="line"><span class="variable constant_">FNR</span>             当前被处理文件的记录数</span><br><span class="line"><span class="variable constant_">FS</span>              设置输入域分隔符，等价于命令行-F选项</span><br><span class="line"><span class="variable constant_">IGNORECASE</span>      如果为真，则进行忽略大小写的匹配</span><br><span class="line"><span class="variable constant_">LINT</span>            动态控制--lint选项是否生效，为<span class="literal">false</span>不生效，为<span class="literal">true</span>则生效；</span><br><span class="line"><span class="variable constant_">NF</span>              浏览记录的域的个数</span><br><span class="line"><span class="variable constant_">NR</span>              已读的记录数</span><br><span class="line"><span class="variable constant_">OFMT</span>            数字的输出格式，默认值是%.6g</span><br><span class="line"><span class="variable constant_">OFS</span>             输出域分隔符</span><br><span class="line"><span class="variable constant_">ORS</span>             输出记录分隔符             </span><br><span class="line"><span class="variable constant_">RS</span>              <span class="title class_">The</span> input record separator，输入记录的分隔符，默认为换行符</span><br><span class="line"><span class="variable constant_">RT</span>              <span class="title class_">The</span> record terminator，输入记录的结束符      </span><br><span class="line"><span class="variable constant_">RSTART</span>          由match函数所匹配的字符串的第一个位置</span><br><span class="line"><span class="variable constant_">RLENGTH</span>         由match函数所匹配的字符串的长度</span><br><span class="line"><span class="variable constant_">SUBSEP</span>          数组下标分隔符(默认值是\<span class="number">034</span>)</span><br><span class="line"><span class="variable constant_">TEXTDOMAIN</span>      awk程序所使用的文本所处的地域</span><br></pre></td></tr></table></figure><h2 id="6-awk编程示例"><a href="#6-awk编程示例" class="headerlink" title="6.awk编程示例"></a>6.awk编程示例</h2><h3 id="6-1基础打印输出"><a href="#6-1基础打印输出" class="headerlink" title="6.1基础打印输出"></a>6.1基础打印输出</h3><p>（1）假设last -n 5的输出如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[root@www ~]# last -n <span class="number">5</span> &lt;==仅取出前五行</span><br><span class="line">root     pts/<span class="number">1</span>   <span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span>  <span class="title class_">Tue</span> <span class="title class_">Feb</span> <span class="number">10</span> <span class="number">11</span>:<span class="number">21</span>   still logged <span class="keyword">in</span></span><br><span class="line">root     pts/<span class="number">1</span>   <span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span>  <span class="title class_">Tue</span> <span class="title class_">Feb</span> <span class="number">10</span> <span class="number">00</span>:<span class="number">46</span> - <span class="number">02</span>:<span class="number">28</span>  (<span class="number">01</span>:<span class="number">41</span>)</span><br><span class="line">root     pts/<span class="number">1</span>   <span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span>  <span class="title class_">Mon</span> <span class="title class_">Feb</span>  <span class="number">9</span> <span class="number">11</span>:<span class="number">41</span> - <span class="number">18</span>:<span class="number">30</span>  (<span class="number">06</span>:<span class="number">48</span>)</span><br><span class="line">dmtsai   pts/<span class="number">1</span>   <span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span>  <span class="title class_">Mon</span> <span class="title class_">Feb</span>  <span class="number">9</span> <span class="number">11</span>:<span class="number">41</span> - <span class="number">11</span>:<span class="number">41</span>  (<span class="number">00</span>:<span class="number">00</span>)</span><br><span class="line">root     tty1                   <span class="title class_">Fri</span> <span class="title class_">Sep</span>  <span class="number">5</span> <span class="number">14</span>:<span class="number">09</span> - <span class="number">14</span>:<span class="number">10</span>  (<span class="number">00</span>:<span class="number">01</span>)</span><br></pre></td></tr></table></figure><p>如果只是显示最近登录的5个帐号:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#last -n <span class="number">5</span> | awk  <span class="string">&#x27;&#123;print $1&#125;&#x27;</span></span><br><span class="line">root</span><br><span class="line">root</span><br><span class="line">root</span><br><span class="line">dmtsai</span><br><span class="line">root</span><br></pre></td></tr></table></figure><p>awk工作流程是这样的：</p><p>读入有’\n’换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域，0则表示所有域,0则表示所有域,0则表示所有域,1表示第一个域,n表示第n个域。</p><p>默认域分隔符是”空白键”或”[tab]键”,所以n表示第n个域。默认域分隔符是”空白键”或”[tab]键”,所以n表示第n个域。</p><p>默认域分隔符是”空白键” 或 “[tab]键”,所以1表示登录用户，$3表示登录用户ip,以此类推。</p><p>（2）如果想显示&#x2F;etc&#x2F;passwd配置文件中的账户以及账户对应的shell,而账户与shell之间以tab键分割。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#cat /etc/passwd |awk  -F <span class="string">&#x27;:&#x27;</span>  <span class="string">&#x27;&#123;print $1&quot;\t&quot;$7&#125;&#x27;</span></span><br><span class="line">root    /bin/bash</span><br><span class="line">daemon  /bin/sh</span><br><span class="line">bin     /bin/sh</span><br><span class="line">sys     /bin/sh</span><br></pre></td></tr></table></figure><p>注意，这里使用了-F指定域分隔符为’:’。</p><p>（3）如果只是显示&#x2F;etc&#x2F;passwd的账户和账户对应的shell,而账户与shell之间以逗号分割,而且在所有行添加列名name,shell,在最后一行添加”blue,&#x2F;bin&#x2F;nosh”。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cat /etc/passwd |awk  -F <span class="string">&#x27;:&#x27;</span>  <span class="string">&#x27;BEGIN &#123;print &quot;name,shell&quot;&#125;  &#123;print $1&quot;,&quot;$7&#125; END &#123;print &quot;blue,/bin/nosh&quot;&#125;&#x27;</span></span><br><span class="line">name,shell</span><br><span class="line">root,<span class="regexp">/bin/</span>bash</span><br><span class="line">daemon,<span class="regexp">/bin/</span>sh</span><br><span class="line">bin,<span class="regexp">/bin/</span>sh</span><br><span class="line">sys,<span class="regexp">/bin/</span>sh</span><br><span class="line">....</span><br><span class="line">blue,<span class="regexp">/bin/</span>nosh</span><br></pre></td></tr></table></figure><p>awk工作流程是这样的：先执行BEGING，然后读取文件，读入有&#x2F;n换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域，0则表示所有域,0则表示所有域,0则表示所有域,1表示第一个域,$n表示第n个域,随后开始执行模式所对应的动作action。接着开始读入第二条记录······直到所有的记录都读完，最后执行END操作。</p><p>（4）搜索&#x2F;etc&#x2F;passwd有root关键字的所有行。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#awk -<span class="attr">F</span>: <span class="string">&#x27;/root/&#x27;</span> /etc/passwd</span><br><span class="line"><span class="attr">root</span>:<span class="attr">x</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="attr">root</span>:<span class="regexp">/root:/</span>bin/bash</span><br></pre></td></tr></table></figure><p>上面三种是awk的action的使用示例，而这种是pattern的使用示例，匹配了pattern(这里是root)的行才会执行action(没有指定action，默认输出每行的内容)。</p><p>搜索支持正则表达式，例如找root开头的。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">awk -<span class="attr">F</span>: <span class="string">&#x27;/^root/&#x27;</span> /etc/passwd</span><br></pre></td></tr></table></figure><p>（5）搜索&#x2F;etc&#x2F;passwd有root关键字的所有行，并显示对应的shell。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># awk -<span class="attr">F</span>: <span class="string">&#x27;/root/&#123;print $7&#125;&#x27;</span> /etc/passwd             </span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure><p>这里是awk的pattern+action示例用法，同时指明了action是{print $7}。</p><p>（6）打印&#x2F;etc&#x2F;passwd第三行的第一列和第二列。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">awk -<span class="attr">F</span>: <span class="string">&#x27;NR==3&#123;print $1,$2;&#125;&#x27;</span> /etc/passwd</span><br><span class="line"></span><br><span class="line">#输出结果：</span><br><span class="line">daemon x</span><br></pre></td></tr></table></figure><h3 id="6-2-awk在每一列后添加字符串后输出"><a href="#6-2-awk在每一列后添加字符串后输出" class="headerlink" title="6.2.awk在每一列后添加字符串后输出"></a>6.2.awk在每一列后添加字符串后输出</h3><p>设定变量内容：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a=<span class="string">&quot;/test.html /dir1 /abc.txt&quot;</span></span><br></pre></td></tr></table></figure><p>希望得到</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">echo $a</span><br><span class="line">--exclude=<span class="regexp">/test.html --exclude=/</span>dir1 --exclude=/abc.<span class="property">txt</span></span><br></pre></td></tr></table></figure><p>如何用awk实现。</p><p>解决办法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">echo $a|awk <span class="string">&#x27;&#123;for(i=1;i&lt;=NF-1;++i)&#123;printf &quot;-execute=%s &quot;,$i&#125;&#125;&#123;print &quot;--exclude=&quot;$NF&quot;&quot;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">#或者</span><br><span class="line">echo $a|awk <span class="string">&#x27;&#123;for(i=1;i&lt;=NF;i++)&#123;printf &quot;--exclude=&quot;$i&quot; &quot;&#125;&#123;print &quot;&quot;&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>后者是网友给出的答案，和我上面的写法是差不多的，只是对printf在使用形式上有所差别而已。第二种方法print “”是用于换行，print每次输出后默认进行换行。</p><h3 id="6-3shell编程使用awk浮点运算保留两位小数"><a href="#6-3shell编程使用awk浮点运算保留两位小数" class="headerlink" title="6.3shell编程使用awk浮点运算保留两位小数"></a>6.3shell编程使用awk浮点运算保留两位小数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a=<span class="number">3</span></span><br><span class="line">b=<span class="number">10</span></span><br><span class="line">c=$(awk <span class="string">&#x27;BEGIN&#123;printf &quot;%.2f&quot;,&#x27;</span>$a<span class="string">&#x27;*100/&#x27;</span>$b<span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">echo <span class="attr">c</span>:$c%</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">c=$(awk -v n=$a -v m=$b <span class="string">&#x27;BEGIN&#123;printf &quot;%.2f&quot;,n*100/m&#125;&#x27;</span>)</span><br><span class="line">echo <span class="attr">c</span>:$c%</span><br></pre></td></tr></table></figure><p>-v表示定义awk的变量！v是variable的首字母。输出：c：30.00%。</p><h3 id="6-4awk访问shell变量"><a href="#6-4awk访问shell变量" class="headerlink" title="6.4awk访问shell变量"></a>6.4awk访问shell变量</h3><p>awk默认是无法访问shell变量的，我所知道的有三种方法。  方法一：awk -v 选项让awk 里使用shell变量。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">var0=dablelv0</span><br><span class="line">var1=dablelv1</span><br><span class="line">awk -v tmpVar0=$var0 -v tmpVar1=$var1 <span class="string">&#x27;BEGIN&#123;print tmpVar0&quot; &quot;tmpVar1&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>输出：</strong> dablelv0 dablelv1  <strong>注意：</strong> BEGIN必须大写，awk的{action}必须要使用单引号括起来。</p><p>方法二：<code>&#39;&quot;$var&quot;&#39;</code>  这种写法是老外常用的写法。如:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>=<span class="string">&quot;test&quot;</span> </span><br><span class="line">awk <span class="string">&#x27;BEGIN&#123;print &quot;&#x27;</span>$var<span class="string">&#x27;&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>这种写法其实际是双括号变为单括号的常量,传递给了awk。</p><p>如果var中含空格，为了shell不把空格作为分格符，应该如下使用：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>=<span class="string">&quot;this is a test&quot;</span> </span><br><span class="line">awk <span class="string">&#x27;BEGIN&#123;print &quot;&#x27;</span><span class="string">&quot;$var&quot;</span><span class="string">&#x27;&quot;&#125;&#x27;</span> </span><br></pre></td></tr></table></figure><p>方法三：export 变量，将变量设置为临时会话环境变量，仅在当前shell会话中有效。在awk中使用<code>ENVIRON[&quot;var&quot;]</code>形式访问变量。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>=<span class="string">&quot;this is a test&quot;</span></span><br><span class="line"><span class="keyword">export</span> $var #或者 <span class="keyword">export</span> <span class="keyword">var</span></span><br><span class="line"></span><br><span class="line">#或者</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span>=<span class="string">&quot;this is a test&quot;</span></span><br><span class="line"></span><br><span class="line">awk <span class="string">&#x27;BEGIN&#123;print ENVIRON[&quot;var&quot;]&#125;&#x27;</span> </span><br></pre></td></tr></table></figure><h3 id="6-5awk执行shell命令"><a href="#6-5awk执行shell命令" class="headerlink" title="6.5awk执行shell命令"></a>6.5awk执行shell命令</h3><p>awk执行shell命令有两种方法。  方法一：使用awk的system()函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">var</span>=dablelv</span><br><span class="line">awk <span class="string">&#x27;BEGIN&#123;system(&quot;echo $var&quot;)&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>输出：</strong>dablelv  </p><p><strong>注意：</strong>一定要使用export将变量设置为临时环境变量，因为awk的system()实际上是新建了一个shell进程来执行给定的shell命令，否则无法访问父进程的变量。</p><p>方法二：使用<code>使用print cmd | &quot;/bin/bash&quot;</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>=<span class="string">&quot;this is a test&quot;</span></span><br><span class="line">awk <span class="string">&#x27;BEGIN&#123;print &quot;echo &quot;&quot;&#x27;</span><span class="string">&quot;$var&quot;</span><span class="string">&#x27;&quot;|&quot;sh&quot;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">#或者</span><br><span class="line"><span class="keyword">var</span>=<span class="string">&quot;this is a test&quot;</span></span><br><span class="line">awk -v varTmp=<span class="string">&quot;$var&quot;</span> <span class="string">&#x27;BEGIN&#123;print &quot;echo &quot;varTmp|&quot;sh&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>输出：this is a test  </p><p><strong>注意：</strong>  </p><p>（1）指定bash的时候需要双引号括起来；  </p><p>（2）方法二与方法一的区别在于方法二是将变量在awk解析后再通过管道传给shell，所以无需将变量设置为临时环境变量，因为shell接收到的变量已经是变量的值。</p><h2 id="7-awk常见问题"><a href="#7-awk常见问题" class="headerlink" title="7.awk常见问题"></a>7.awk常见问题</h2><p>（1）awk以空格为分隔符Tab也被作为域分隔符。现在只以空格为分隔符，需要使用中括号的方式。不使用中括号，则仍然会将Tab作为分隔符。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#错误的写法</span><br><span class="line">awk -F<span class="string">&#x27; &#x27;</span> <span class="string">&#x27;&#123;print $1;&#125;&#x27;</span> test.<span class="property">txt</span></span><br><span class="line"></span><br><span class="line">#正确的写法</span><br><span class="line">awk -F<span class="string">&#x27;[ ]&#x27;</span> <span class="string">&#x27;&#123;print $1;&#125;&#x27;</span> test.<span class="property">txt</span> </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令汇总</title>
      <link href="/FRank675.github.io/posts/3a39ed211cab/"/>
      <url>/FRank675.github.io/posts/3a39ed211cab/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\FRank675.github.io\css\APlayer.min.css"><script src="\FRank675.github.io\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\FRank675.github.io\js\Meting.min.js"></script><h1 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h1><p><strong>系统信息</strong><br>arch 显示机器的处理器架构<br>uname -m 显示机器的处理器架构<br><strong>uname -r 显示正在使用的内核版本</strong><br>dmidecode -q 显示硬件系统部件 - (SMBIOS &#x2F; DMI)<br>hdparm -i &#x2F;dev&#x2F;hda 罗列一个磁盘的架构特性<br>hdparm -tT &#x2F;dev&#x2F;sda 在磁盘上执行测试性读取操作<br><strong>cat &#x2F;proc&#x2F;cpuinfo 显示CPU info的信息</strong><br>cat &#x2F;proc&#x2F;interrupts 显示中断<br>cat &#x2F;proc&#x2F;meminfo 校验内存使用<br>cat &#x2F;proc&#x2F;swaps 显示哪些swap被使用<br>cat &#x2F;proc&#x2F;version 显示内核的版本<br>cat &#x2F;proc&#x2F;net&#x2F;dev 显示网络适配器及统计<br>cat &#x2F;proc&#x2F;mounts 显示已加载的文件系统<br>lspci -tv 罗列 PCI 设备<br>lsusb -tv 显示 USB 设备<br><strong>date 显示系统日期</strong><br>cal 2007 显示2007年的日历表<br>date 041217002007.00 设置日期和时间 - 月日时分年.秒<br>clock -w 将时间修改保存到 BIOS </p><p><strong>关机 (系统的关机、重启以及登出 )</strong><br>shutdown -h now 关闭系统<br>init 0 关闭系统<br>telinit 0 关闭系统<br>shutdown -h hours:minutes &amp; 按预定时间关闭系统<br>shutdown -c 取消按预定时间关闭系统<br>shutdown -r now 重启<br><strong>reboot 重启</strong><br>logout 注销 </p><p><strong>文件和目录</strong><br>cd &#x2F;home 进入 ‘&#x2F; home’ 目录’<br><strong>cd .. 返回上一级目录</strong><br><strong>cd ..&#x2F;.. 返回上两级目录</strong><br>cd 进入个人的主目录<br>cd ~user1 进入个人的主目录<br><strong>cd - 返回上次所在的目录</strong><br><strong>pwd 显示工作路径</strong><br><strong>ls 查看目录中的文件</strong><br>ls -F 查看目录中的文件<br>ls -l 显示文件和目录的详细资料<br><strong>ls -a 显示隐藏文件</strong><br>ls <em>[0-9]</em> 显示包含数字的文件名和目录名<br>tree 显示文件和目录由根目录开始的树形结构<br>lstree 显示文件和目录由根目录开始的树形结构<br><strong>mkdir dir1 创建一个叫做 ‘dir1’ 的目录’</strong><br><strong>mkdir dir1 dir2 同时创建两个目录</strong><br><strong>mkdir -p &#x2F;tmp&#x2F;dir1&#x2F;dir2 创建一个目录树</strong><br><strong>rm -f file1 删除一个叫做 ‘file1’ 的文件’</strong><br>rmdir dir1 删除一个叫做 ‘dir1’ 的目录’<br><strong>rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容</strong><br>rm -rf dir1 dir2 同时删除两个目录及它们的内容<br><strong>mv dir1 new_dir 重命名&#x2F;移动 一个目录</strong><br><strong>cp file1 file2 复制一个文件</strong><br><em><em>cp dir&#x2F;</em> . 复制一个目录下的所有文件到当前工作目录</em>*<br>cp -a &#x2F;tmp&#x2F;dir1 . 复制一个目录到当前工作目录<br>cp -a dir1 dir2 复制一个目录 </p><p>cp -r dir1 dir2 复制一个目录及子目录<br>ln -s file1 lnk1 创建一个指向文件或目录的软链接<br>ln file1 lnk1 创建一个指向文件或目录的物理链接<br>touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm)<br>file file1 outputs the mime type of the file as text<br>iconv -l 列出已知的编码<br>iconv -f fromEncoding -t toEncoding inputFile &gt; outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding.<br>find . -maxdepth 1 -name *.jpg -print -exec convert “{}” -resize 80x60 “thumbs&#x2F;{}” ; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick) </p><p><strong>文件搜索</strong><br><strong><u>find &#x2F; -name file1 从 ‘&#x2F;‘ 开始进入根文件系统搜索文件和目录</strong></u><br>find &#x2F; -user user1 搜索属于用户 ‘user1’ 的文件和目录<br><strong>find &#x2F;home&#x2F;user1 -name *.bin 在目录 ‘&#x2F; home&#x2F;user1’ 中搜索带有’.bin’ 结尾的文件</strong><br>find &#x2F;usr&#x2F;bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件<br>find &#x2F;usr&#x2F;bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件<br>find &#x2F; -name *.rpm -exec chmod 755 ‘{}’ ; 搜索以 ‘.rpm’ 结尾的文件并定义其权限<br>find &#x2F; -xdev -name *.rpm 搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备<br>locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令<br>whereis halt 显示一个二进制文件、源码或man的位置<br><strong>which halt 显示一个二进制文件或可执行文件的完整路径</strong> </p><p><strong>挂载一个文件系统</strong><br>mount &#x2F;dev&#x2F;hda2 &#x2F;mnt&#x2F;hda2 挂载一个叫做hda2的盘 - 确定目录 ‘&#x2F; mnt&#x2F;hda2’ 已经存在<br>umount &#x2F;dev&#x2F;hda2 卸载一个叫做hda2的盘 - 先从挂载点 ‘&#x2F; mnt&#x2F;hda2’ 退出<br>fuser -km &#x2F;mnt&#x2F;hda2 当设备繁忙时强制卸载<br>umount -n &#x2F;mnt&#x2F;hda2 运行卸载操作而不写入 &#x2F;etc&#x2F;mtab 文件- 当文件为只读或当磁盘写满时非常有用<br>mount &#x2F;dev&#x2F;fd0 &#x2F;mnt&#x2F;floppy 挂载一个软盘<br>mount &#x2F;dev&#x2F;cdrom &#x2F;mnt&#x2F;cdrom 挂载一个cdrom或dvdrom<br>mount &#x2F;dev&#x2F;hdc &#x2F;mnt&#x2F;cdrecorder 挂载一个cdrw或dvdrom<br>mount &#x2F;dev&#x2F;hdb &#x2F;mnt&#x2F;cdrecorder 挂载一个cdrw或dvdrom<br>mount -o loop file.iso &#x2F;mnt&#x2F;cdrom 挂载一个文件或ISO镜像文件<br>mount -t vfat &#x2F;dev&#x2F;hda5 &#x2F;mnt&#x2F;hda5 挂载一个Windows FAT32文件系统<br>mount &#x2F;dev&#x2F;sda1 &#x2F;mnt&#x2F;usbdisk 挂载一个usb 捷盘或闪存设备<br>mount -t smbfs -o username&#x3D;user,password&#x3D;pass &#x2F;&#x2F;WinClient&#x2F;share &#x2F;mnt&#x2F;share 挂载一个windows网络共享 </p><p><strong>磁盘空间</strong><br><strong>df -h 显示已经挂载的分区列表</strong><br>ls -lSr |more 以尺寸大小排列文件和目录<br>du -sh dir1 估算目录 ‘dir1’ 已经使用的磁盘空间’<br>du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小<br>rpm -q -a –qf ‘%10{SIZE}t%{NAME}n’ | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)<br>dpkg-query -W -f&#x3D;’${Installed-Size;10}t${Package}n’ | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (<a href="https://so.csdn.net/so/search?q=ubuntu&spm=1001.2101.3001.7020">ubuntu</a>, debian类系统) </p><p><strong>用户和群组</strong><br>groupadd group_name 创建一个新用户组<br>groupdel group_name 删除一个用户组<br>groupmod -n new_group_name old_group_name 重命名一个用户组<br>useradd -c “Name Surname “ -g admin -d &#x2F;home&#x2F;user1 -s &#x2F;bin&#x2F;bash user1 创建一个属于 “admin” 用户组的用户<br>useradd user1 创建一个新用户<br>userdel -r user1 删除一个用户 ( ‘-r’ 排除主目录)<br>usermod -c “User FTP” -g system -d &#x2F;ftp&#x2F;user1 -s &#x2F;bin&#x2F;nologin user1 修改用户属性<br>passwd 修改口令<br>passwd user1 修改一个用户的口令 (只允许root执行)<br>chage -E 2005-12-31 user1 设置用户口令的失效期限<br>pwck 检查 ‘&#x2F;etc&#x2F;passwd’ 的文件格式和语法修正以及存在的用户<br>grpck 检查 ‘&#x2F;etc&#x2F;passwd’ 的文件格式和语法修正以及存在的群组<br>newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组 </p><p><strong>文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消</strong><br><strong>ls -lh 显示权限</strong><br>ls &#x2F;tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示<br>chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限<br>chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限<br>chown user1 file1 改变一个文件的所有人属性<br>chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性<br>chgrp group1 file1 改变文件的群组<br>chown user1:group1 file1 改变一个文件的所有人和群组属性<br>find &#x2F; -perm -u+s 罗列一个系统中所有使用了SUID控制的文件<br>chmod u+s &#x2F;bin&#x2F;file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限<br>chmod u-s &#x2F;bin&#x2F;file1 禁用一个二进制文件的 SUID位<br>chmod g+s &#x2F;home&#x2F;public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的<br>chmod g-s &#x2F;home&#x2F;public 禁用一个目录的 SGID 位<br>chmod o+t &#x2F;home&#x2F;public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件<br>chmod o-t &#x2F;home&#x2F;public 禁用一个目录的 STIKY 位 </p><p><strong>文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消</strong><br>chattr +a file1 只允许以追加方式读写文件<br>chattr +c file1 允许这个文件能被内核自动压缩&#x2F;解压<br>chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件<br>chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接<br>chattr +s file1 允许一个文件被安全地删除<br>chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘<br>chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件<br>lsattr 显示特殊的属性 </p><p><strong>打包和压缩文件</strong><br>bunzip2 file1.bz2 解压一个叫做 ‘file1.bz2’的文件<br>bzip2 file1 压缩一个叫做 ‘file1’ 的文件<br>gunzip file1.gz 解压一个叫做 ‘file1.gz’的文件<br>gzip file1 压缩一个叫做 ‘file1’的文件<br>gzip -9 file1 最大程度压缩<br>rar a file1.rar test_file 创建一个叫做 ‘file1.rar’ 的包<br>rar a file1.rar file1 file2 dir1 同时压缩 ‘file1’, ‘file2’ 以及目录 ‘dir1’<br>rar x file1.rar 解压rar包<br>unrar x file1.rar 解压rar包<br>tar -cvf archive.tar file1 创建一个非压缩的 tarball<br>tar -cvf archive.tar file1 file2 dir1 创建一个包含了 ‘file1’, ‘file2’ 以及 ‘dir1’的档案文件<br>tar -tf archive.tar 显示一个包中的内容<br>tar -xvf archive.tar 释放一个包<br><strong>tar -xvf archive.tar -C &#x2F;tmp 将压缩包释放到 &#x2F;tmp目录下</strong><br>tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包<br>tar -jxvf archive.tar.bz2 解压一个bzip2格式的压缩包<br>tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包<br>tar -zxvf archive.tar.gz 解压一个gzip格式的压缩包<br>zip file1.zip file1 创建一个zip格式的压缩包<br>zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包<br>unzip file1.zip 解压一个zip格式压缩包 </p><p><strong>RPM 包 - （Fedora, Redhat及类似系统）</strong><br>rpm -ivh package.rpm 安装一个rpm包<br>rpm -ivh –nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告<br>rpm -U package.rpm 更新一个rpm包但不改变其配置文件<br>rpm -F package.rpm 更新一个确定已经安装的rpm包<br>rpm -e package_name.rpm 删除一个rpm包<br>rpm -qa 显示系统中所有已经安装的rpm包<br>rpm -qa | grep httpd 显示所有名称中包含 “httpd” 字样的rpm包<br>rpm -qi package_name 获取一个已安装包的特殊信息<br>rpm -qg “System Environment&#x2F;Daemons” 显示一个组件的rpm包<br>rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表<br>rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表<br>rpm -q package_name –whatrequires 显示与一个rpm包存在依赖关系的列表<br>rpm -q package_name –whatprovides 显示一个rpm包所占的体积<br>rpm -q package_name –scripts 显示在安装&#x2F;删除期间所执行的脚本l<br>rpm -q package_name –changelog 显示一个rpm包的修改历史<br>rpm -qf &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf 确认所给的文件由哪个rpm包所提供<br>rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表<br>rpm –import &#x2F;media&#x2F;cdrom&#x2F;RPM-GPG-KEY 导入公钥数字证书<br>rpm –checksig package.rpm 确认一个rpm包的完整性<br>rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性<br>rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间<br>rpm -Va 检查系统中所有已安装的rpm包- 小心使用<br>rpm -Vp package.rpm 确认一个rpm包还未安装<br>rpm2cpio package.rpm | cpio –extract –make-directories <em>bin</em> 从一个rpm包运行可执行文件<br>rpm -ivh &#x2F;usr&#x2F;src&#x2F;redhat&#x2F;RPMS&#x2F;<code>arch</code>&#x2F;package.rpm 从一个rpm源码安装一个构建好的包<br>rpmbuild –rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包 </p><p><strong>YUM 软件包升级器 - （Fedora, RedHat及类似系统）</strong><br>yum install package_name 下载并安装一个rpm包<br>yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系<br>yum update package_name.rpm 更新当前系统中所有安装的rpm包<br>yum update package_name 更新一个rpm包<br>yum remove package_name 删除一个rpm包<br>yum list 列出当前系统中安装的所有包<br>yum search package_name 在rpm仓库中搜寻软件包<br>yum clean packages 清理rpm缓存删除下载的包<br>yum clean headers 删除所有头文件<br>yum clean all 删除所有缓存的包和头文件 </p><p><strong>DEB 包 (Debian, Ubuntu 以及类似系统)</strong><br>dpkg -i package.deb 安装&#x2F;更新一个 deb 包<br>dpkg -r package_name 从系统删除一个 deb 包<br>dpkg -l 显示系统中所有已经安装的 deb 包<br>dpkg -l | grep httpd 显示所有名称中包含 “httpd” 字样的deb包<br>dpkg -s package_name 获得已经安装在系统中一个特殊包的信息<br>dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表<br>dpkg –contents package.deb 显示尚未安装的一个包所提供的文件列表<br>dpkg -S &#x2F;bin&#x2F;ping 确认所给的文件由哪个deb包提供 </p><p><strong>APT 软件工具 (Debian, Ubuntu 以及类似系统)</strong><br>apt-get install package_name 安装&#x2F;更新一个 deb 包<br>apt-cdrom install package_name 从光盘安装&#x2F;更新一个 deb 包<br>apt-get update 升级列表中的软件包<br>apt-get upgrade 升级所有已安装的软件<br>apt-get remove package_name 从系统删除一个deb包<br>apt-get check 确认依赖的软件仓库正确<br>apt-get clean 从下载的软件包中清理缓存<br>apt-cache search searched-package 返回包含所要搜索字符串的软件包名称 </p><p><strong>查看文件内容</strong><br><strong>cat file1 从第一个字节开始正向查看文件的内容</strong><br>tac file1 从最后一行开始反向查看一个文件的内容<br>more file1 查看一个长文件的内容<br>less file1 类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作<br>head -2 file1 查看一个文件的前两行<br>tail -2 file1 查看一个文件的最后两行<br>tail -f &#x2F;var&#x2F;log&#x2F;messages 实时查看被添加到一个文件中的内容 </p><p><strong>文本处理</strong><br>cat file1 file2 … | command &lt;&gt; file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUT<br>cat file1 | command( sed, grep, awk, grep, etc…) &gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中<br>cat file1 | command( sed, grep, awk, grep, etc…) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中<br>grep Aug &#x2F;var&#x2F;log&#x2F;messages 在文件 ‘&#x2F;var&#x2F;log&#x2F;messages’中查找关键词”Aug”<br>grep ^Aug &#x2F;var&#x2F;log&#x2F;messages 在文件 ‘&#x2F;var&#x2F;log&#x2F;messages’中查找以”Aug”开始的词汇<br>grep [0-9] &#x2F;var&#x2F;log&#x2F;messages 选择 ‘&#x2F;var&#x2F;log&#x2F;messages’ 文件中所有包含数字的行<br>grep Aug -R &#x2F;var&#x2F;log&#x2F;* 在目录 ‘&#x2F;var&#x2F;log’ 及随后的目录中搜索字符串”Aug”<br>sed ‘s&#x2F;stringa1&#x2F;stringa2&#x2F;g’ example.txt 将example.txt文件中的 “string1” 替换成 “string2”<br>sed ‘&#x2F;^$&#x2F;d’ example.txt 从example.txt文件中删除所有空白行<br>sed ‘&#x2F; *#&#x2F;d; &#x2F;^$&#x2F;d’ example.txt 从example.txt文件中删除所有注释和空白行<br>echo ‘esempio’ | tr ‘[:lower:]’ ‘[:upper:]’ 合并上下单元格内容<br>sed -e ‘1d’ result.txt 从文件example.txt 中排除第一行<br>sed -n ‘&#x2F;stringa1&#x2F;p’ 查看只包含词汇 “string1”的行<br>sed -e ‘s&#x2F; <em>$&#x2F;&#x2F;‘ example.txt 删除每一行最后的空白字符<br>sed -e ‘s&#x2F;stringa1&#x2F;&#x2F;g’ example.txt 从文档中只删除词汇 “string1” 并保留剩余全部<br>sed -n ‘1,5p;5q’ example.txt 查看从第一行到第5行内容<br>sed -n ‘5p;5q’ example.txt 查看第5行<br>sed -e ‘s&#x2F;00</em>&#x2F;0&#x2F;g’ example.txt 用单个零替换多个零<br>cat -n file1 标示文件的行数<br>cat example.txt | awk ‘NR%2&#x3D;&#x3D;1’ 删除example.txt文件中的所有偶数行<br>echo a b c | awk ‘{print $1}’ 查看一行第一栏<br>echo a b c | awk ‘{print $1,$3}’ 查看一行的第一和第三栏<br>paste file1 file2 合并两个文件或两栏的内容<br>paste -d ‘+’ file1 file2 合并两个文件或两栏的内容，中间用”+”区分<br>sort file1 file2 排序两个文件的内容<br>sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份)<br>sort file1 file2 | uniq -u 删除交集，留下其他的行<br>sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件)<br>comm -1 file1 file2 比较两个文件的内容只删除 ‘file1’ 所包含的内容<br>comm -2 file1 file2 比较两个文件的内容只删除 ‘file2’ 所包含的内容<br>comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分 </p><p><strong>字符设置和文件格式转换</strong><br>dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIX<br>unix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOS<br>recode ..HTML &lt; page.txt &gt; page.html 将一个文本文件转换成html<br>recode -l | more 显示所有允许的转换格式 </p><p><strong>文件系统分析</strong><br>badblocks -v &#x2F;dev&#x2F;hda1 检查磁盘hda1上的坏磁块<br>fsck &#x2F;dev&#x2F;hda1 修复&#x2F;检查hda1磁盘上linux文件系统的完整性<br>fsck.ext2 &#x2F;dev&#x2F;hda1 修复&#x2F;检查hda1磁盘上ext2文件系统的完整性<br>e2fsck &#x2F;dev&#x2F;hda1 修复&#x2F;检查hda1磁盘上ext2文件系统的完整性<br>e2fsck -j &#x2F;dev&#x2F;hda1 修复&#x2F;检查hda1磁盘上ext3文件系统的完整性<br>fsck.ext3 &#x2F;dev&#x2F;hda1 修复&#x2F;检查hda1磁盘上ext3文件系统的完整性<br>fsck.vfat &#x2F;dev&#x2F;hda1 修复&#x2F;检查hda1磁盘上fat文件系统的完整性<br>fsck.msdos &#x2F;dev&#x2F;hda1 修复&#x2F;检查hda1磁盘上dos文件系统的完整性<br>dosfsck &#x2F;dev&#x2F;hda1 修复&#x2F;检查hda1磁盘上dos文件系统的完整性 </p><p><strong>初始化一个文件系统</strong><br>mkfs &#x2F;dev&#x2F;hda1 在hda1分区创建一个文件系统<br>mke2fs &#x2F;dev&#x2F;hda1 在hda1分区创建一个linux ext2的文件系统<br>mke2fs -j &#x2F;dev&#x2F;hda1 在hda1分区创建一个linux ext3(日志型)的文件系统<br>mkfs -t vfat 32 -F &#x2F;dev&#x2F;hda1 创建一个 FAT32 文件系统<br>fdformat -n &#x2F;dev&#x2F;fd0 格式化一个软盘<br>mkswap &#x2F;dev&#x2F;hda3 创建一个swap文件系统 </p><p><strong>SWAP文件系统</strong><br>mkswap &#x2F;dev&#x2F;hda3 创建一个swap文件系统<br>swapon &#x2F;dev&#x2F;hda3 启用一个新的swap文件系统<br>swapon &#x2F;dev&#x2F;hda2 &#x2F;dev&#x2F;hdb3 启用两个swap分区 </p><p><strong>备份</strong><br>dump -0aj -f &#x2F;tmp&#x2F;home0.bak &#x2F;home 制作一个 ‘&#x2F;home’ 目录的完整备份<br>dump -1aj -f &#x2F;tmp&#x2F;home0.bak &#x2F;home 制作一个 ‘&#x2F;home’ 目录的交互式备份<br>restore -if &#x2F;tmp&#x2F;home0.bak 还原一个交互式备份<br>rsync -rogpav –delete &#x2F;home &#x2F;tmp 同步两边的目录<br>rsync -rogpav -e ssh –delete &#x2F;home ip_address:&#x2F;tmp 通过SSH通道rsync<br>rsync -az -e ssh –delete ip_addr:&#x2F;home&#x2F;public &#x2F;home&#x2F;local 通过ssh和压缩将一个远程目录同步到本地目录<br>rsync -az -e ssh –delete &#x2F;home&#x2F;local ip_addr:&#x2F;home&#x2F;public 通过ssh和压缩将本地目录同步到远程目录<br>dd bs&#x3D;1M if&#x3D;&#x2F;dev&#x2F;hda | gzip | ssh user@ip_addr ‘dd of&#x3D;hda.gz’ 通过ssh在远程主机上执行一次备份本地磁盘的操作<br>dd if&#x3D;&#x2F;dev&#x2F;sda of&#x3D;&#x2F;tmp&#x2F;file1 备份磁盘内容到一个文件<br>tar -Puf backup.tar &#x2F;home&#x2F;user 执行一次对 ‘&#x2F;home&#x2F;user’ 目录的交互式备份操作<br>( cd &#x2F;tmp&#x2F;local&#x2F; &amp;&amp; tar c . ) | ssh -C user@ip_addr ‘cd &#x2F;home&#x2F;share&#x2F; &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个目录内容<br>( tar c &#x2F;home ) | ssh -C user@ip_addr ‘cd &#x2F;home&#x2F;backup-home &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个本地目录<br>tar cf - . | (cd &#x2F;tmp&#x2F;backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接<br>find &#x2F;home&#x2F;user1 -name ‘<em>.txt’ | xargs cp -av –target-directory&#x3D;&#x2F;home&#x2F;backup&#x2F; –parents 从一个目录查找并复制所有以 ‘.txt’ 结尾的文件到另一个目录<br>find &#x2F;var&#x2F;log -name ‘</em>.log’ | tar cv –files-from&#x3D;- | bzip2 &gt; log.tar.bz2 查找所有以 ‘.log’ 结尾的文件并做成一个bzip包<br>dd if&#x3D;&#x2F;dev&#x2F;hda of&#x3D;&#x2F;dev&#x2F;fd0 bs&#x3D;512 count&#x3D;1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作<br>dd if&#x3D;&#x2F;dev&#x2F;fd0 of&#x3D;&#x2F;dev&#x2F;hda bs&#x3D;512 count&#x3D;1 从已经保存到软盘的备份中恢复MBR内容 </p><p><strong>光盘</strong><br>cdrecord -v gracetime&#x3D;2 dev&#x3D;&#x2F;dev&#x2F;cdrom -eject blank&#x3D;fast -force 清空一个可复写的光盘内容<br>mkisofs &#x2F;dev&#x2F;cdrom &gt; cd.iso 在磁盘上创建一个光盘的iso镜像文件<br>mkisofs &#x2F;dev&#x2F;cdrom | gzip &gt; cd_iso.gz 在磁盘上创建一个压缩了的光盘iso镜像文件<br>mkisofs -J -allow-leading-dots -R -V “Label CD” -iso-level 4 -o .&#x2F;cd.iso data_cd 创建一个目录的iso镜像文件<br>cdrecord -v dev&#x3D;&#x2F;dev&#x2F;cdrom cd.iso 刻录一个ISO镜像文件<br>gzip -dc cd_iso.gz | cdrecord dev&#x3D;&#x2F;dev&#x2F;cdrom - 刻录一个压缩了的ISO镜像文件<br>mount -o loop cd.iso &#x2F;mnt&#x2F;iso 挂载一个ISO镜像文件<br>cd-paranoia -B 从一个CD光盘转录音轨到 wav 文件中<br>cd-paranoia – “-3” 从一个CD光盘转录音轨到 wav 文件中（参数-3）<br>cdrecord –scanbus 扫描总线以识别scsi通道<br>dd if&#x3D;&#x2F;dev&#x2F;hdc | md5sum 校验一个设备的md5sum编码，例如一张 CD </p><p><strong>网络 - （以太网和WIFI无线</strong>）<br>ifconfig eth0 显示一个以太网卡的配置<br>ifup eth0 启用一个 ‘eth0’ 网络设备<br>ifdown eth0 禁用一个 ‘eth0’ 网络设备<br>ifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址<br>ifconfig eth0 promisc 设置 ‘eth0’ 成混杂模式以嗅探数据包 (sniffing)<br>dhclient eth0 以dhcp模式启用 ‘eth0’<br>route -n show routing table<br>route add -net 0&#x2F;0 gw IP_Gateway configura default gateway<br>route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 configure static route to reach network ‘192.168.0.0&#x2F;16’<br>route del 0&#x2F;0 gw IP_gateway remove static route<br>echo “1” &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward activate ip routing<br>hostname show hostname of system<br>host <a href="http://www.example.com/">www.example.com</a> lookup hostname to resolve name to ip address and viceversa<br>nslookup <a href="http://www.example.com/">www.example.com</a> lookup hostname to resolve name to ip address and viceversa<br>ip link show show link status of all interfaces<br>mii-tool eth0 show link status of ‘eth0’<br>ethtool eth0 show statistics of network card ‘eth0’<br>netstat -tup show all active network connections and their PID<br>netstat -tupl show all network services listening on the system and their PID<br>tcpdump tcp port 80 show all HTTP traffic<br>iwlist scan show wireless networks<br>iwconfig eth1 show configuration of a wireless network card<br>hostname show hostname<br>host <a href="http://www.example.com/">www.example.com</a> lookup hostname to resolve name to ip address and viceversa<br>nslookup <a href="http://www.example.com/">www.example.com</a> lookup hostname to resolve name to ip address and viceversa<br>whois <a href="http://www.example.com/">www.example.com</a> lookup on Whois database </p><p><strong>JPS工具</strong></p><p>jps(Java Virtual Machine Process Status Tool)是JDK 1.5提供的一个显示当前所有java进程pid的命令，简单实用，非常适合在linux&#x2F;unix平台上简单察看当前java进程的一些简单情况。</p><p>  我想很多人都是用过unix系统里的ps命令，这个命令主要是用来显示当前系统的进程情况，有哪些进程，及其 id。 jps 也是一样，它的作用是显示当前系统的java进程情况，及其id号。我们可以通过它来查看我们到底启动了几个java进程（因为每一个java程序都会独占一个java虚拟机实例），和他们的进程号（为下面几个程序做准备），并可通过opt来查看这些进程的详细启动参数。</p><p>   <strong>使用方法：在当前命令行下打 jps(需要JAVA_HOME，没有的话，到改程序的目录下打) 。</strong></p><p><strong>jps存放在JAVA_HOME&#x2F;bin&#x2F;jps，使用时为了方便请将JAVA_HOME&#x2F;bin&#x2F;加入到Path.</strong></p><p>$&gt; <strong>jps</strong><br>23991 Jps<br>23789 BossMain<br>23651 Resin</p><p>比较常用的参数：</p><p><strong>-q 只显示pid，不显示class名称,jar文件名和传递给main 方法的参数</strong><br>$&gt; <strong>jps -q</strong><br>28680<br>23789<br>23651</p><p><strong>-m 输出传递给main 方法的参数，在嵌入式jvm上可能是null</strong></p><p>$&gt; <strong>jps -m</strong><br>28715 Jps -m<br>23789 BossMain<br>23651 Resin -socketwait 32768 -stdout &#x2F;data&#x2F;aoxj&#x2F;resin&#x2F;log&#x2F;stdout.log -stderr &#x2F;data&#x2F;aoxj&#x2F;resin&#x2F;log&#x2F;stderr.log</p><p><strong>-l 输出应用程序main class的完整package名 或者 应用程序的jar文件完整路径名</strong></p><p>$&gt; <strong>jps -l</strong><br>28729 sun.tools.jps.Jps<br>23789 com.asiainfo.aimc.bossbi.BossMain<br>23651 com.caucho.server.resin.Resin</p><p><strong>-v 输出传递给JVM的参数</strong></p><p>$&gt; <strong>jps -v</strong><br>23789 BossMain<br>28802 Jps -Denv.class.path&#x3D;&#x2F;data&#x2F;aoxj&#x2F;bossbi&#x2F;twsecurity&#x2F;java&#x2F;trustwork140.jar:&#x2F;data&#x2F;aoxj&#x2F;bossbi&#x2F;twsecurity&#x2F;java&#x2F;:&#x2F;data&#x2F;aoxj&#x2F;bossbi&#x2F;twsecurity&#x2F;java&#x2F;twcmcc.jar:&#x2F;data&#x2F;aoxj&#x2F;jdk15&#x2F;lib&#x2F;rt.jar:&#x2F;data&#x2F;aoxj&#x2F;jd</p><p>k15&#x2F;lib&#x2F;tools.jar -Dapplication.home&#x3D;&#x2F;data&#x2F;aoxj&#x2F;jdk15 -Xms8m<br>23651 Resin -Xss1m -Dresin.home&#x3D;&#x2F;data&#x2F;aoxj&#x2F;resin -Dserver.root&#x3D;&#x2F;data&#x2F;aoxj&#x2F;resin -Djava.util.logging.manager&#x3D;com.caucho.log.LogManagerImpl -</p><p>Djavax.management.builder.initial&#x3D;com.caucho.jmx.MBeanServerBuilderImpl</p><p><strong>sudo jps看到的进程数量最全</strong></p><p><strong>jps 192.168.0.77</strong></p><p><strong>列出远程服务器192.168.0.77机器所有的jvm实例，采用rmi协议，默认连接端口为1099</strong></p><p><strong>（前提是远程服务器提供jstatd服务）</strong></p><p><strong>注：jps命令有个地方很不好，似乎只能显示当前用户的java进程，要显示其他用户的还是只能用unix&#x2F;linux的ps命令。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python常用操作</title>
      <link href="/FRank675.github.io/posts/40889dd62d68/"/>
      <url>/FRank675.github.io/posts/40889dd62d68/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="Python-总结"><a href="#Python-总结" class="headerlink" title="Python 总结"></a>Python 总结</h1><p>[TOC]</p><h2 id="将两个list转换为dictionary"><a href="#将两个list转换为dictionary" class="headerlink" title="将两个list转换为dictionary"></a>将两个list转换为dictionary</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将两个list转换为dictionary</span></span><br><span class="line">list_1 = [<span class="string">&#x27;karl&#x27;</span>, <span class="string">&#x27;lay&#x27;</span>, <span class="string">&#x27;martin&#x27;</span>]</span><br><span class="line">list_2 = [<span class="number">111</span>, <span class="number">222</span>, <span class="number">333</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 1 ： zip()</span></span><br><span class="line">dict_1 = <span class="built_in">dict</span>(<span class="built_in">zip</span>(list_1, list_2))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 2 : dictionary comprehension</span></span><br><span class="line">dict_2 = &#123;key: value <span class="keyword">for</span> key, value <span class="keyword">in</span> <span class="built_in">zip</span>(list_1, list_2)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 3 : Using a For loop (Not Recommended)</span></span><br><span class="line">tuples = <span class="built_in">zip</span>(list_1, list_2)</span><br><span class="line">dict_3 = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> tuples:</span><br><span class="line">    <span class="keyword">if</span> key <span class="keyword">in</span> dict_3:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        dict_3[key] = value</span><br><span class="line"><span class="built_in">print</span>(dict_1, dict_2, dict_3, sep= <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; Output</span></span><br><span class="line"><span class="string">&#123;&#x27;karl&#x27;: 111, &#x27;lay&#x27;: 222, &#x27;martin&#x27;: 333&#125;</span></span><br><span class="line"><span class="string">&#123;&#x27;karl&#x27;: 111, &#x27;lay&#x27;: 222, &#x27;martin&#x27;: 333&#125;</span></span><br><span class="line"><span class="string">&#123;&#x27;karl&#x27;: 111, &#x27;lay&#x27;: 222, &#x27;martin&#x27;: 333&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="对字符串列表进行排序"><a href="#对字符串列表进行排序" class="headerlink" title="对字符串列表进行排序"></a>对字符串列表进行排序</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对字符串列表进行排序</span></span><br><span class="line">list1 = [<span class="string">&quot;Karl&quot;</span>,<span class="string">&quot;Larry&quot;</span>,<span class="string">&quot;Ana&quot;</span>,<span class="string">&quot;Zack&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># sort是在原位重新排列列表，而sorted ()是产生一个新的列表。 </span></span><br><span class="line"><span class="comment"># sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 1: sort()</span></span><br><span class="line">list1.sort()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 2: sorted()</span></span><br><span class="line">sorted_list = <span class="built_in">sorted</span>(list1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 3: Brute Force Method</span></span><br><span class="line">size = <span class="built_in">len</span>(list1)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">    <span class="keyword">if</span> list1[i] &lt; list1[j]:</span><br><span class="line">       temp = list1[i]</span><br><span class="line">       list1[i] = list1[j]</span><br><span class="line">       list1[j] = temp</span><br><span class="line">       </span><br><span class="line"><span class="built_in">print</span>(list1)</span><br><span class="line"><span class="string">&quot;&quot;&quot; Output</span></span><br><span class="line"><span class="string">[&#x27;Ana&#x27;, &#x27;Karl&#x27;, &#x27;Larry&#x27;, &#x27;Zack&#x27;]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="List-Comprehension-with-if-and-else"><a href="#List-Comprehension-with-if-and-else" class="headerlink" title="List Comprehension with if and else"></a>List Comprehension with if and else</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## List Comprehension with if and else</span></span><br><span class="line"></span><br><span class="line">list_1 = [<span class="string">&quot;Divided By 5&quot;</span> <span class="keyword">if</span> i%<span class="number">5</span> == <span class="number">0</span> <span class="keyword">else</span> i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">20</span>)]</span><br><span class="line">list_2 = [<span class="string">&quot;FizzBuzz&quot;</span> <span class="keyword">if</span> i%<span class="number">3</span> == <span class="number">0</span> <span class="keyword">and</span> i%<span class="number">5</span> == <span class="number">0</span> <span class="keyword">else</span> <span class="string">&#x27;Fuzz&#x27;</span> <span class="keyword">if</span> i%<span class="number">3</span> == <span class="number">0</span> <span class="keyword">else</span> <span class="string">&#x27;Buzz&#x27;</span> <span class="keyword">if</span> i%<span class="number">5</span> == <span class="number">0</span> <span class="keyword">else</span> i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">20</span>)]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(list_1, list_2, sep=<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot; Output</span></span><br><span class="line"><span class="string">[1, 2, 3, 4, &#x27;Divided By 5&#x27;, 6, 7, 8, 9, &#x27;Divided By 5&#x27;, 11, 12, 13, 14, &#x27;Divided By 5&#x27;, 16, 17, 18, 19]</span></span><br><span class="line"><span class="string">[1, 2, &#x27;Fuzz&#x27;, 4, &#x27;Buzz&#x27;, &#x27;Fuzz&#x27;, 7, 8, &#x27;Fuzz&#x27;, &#x27;Buzz&#x27;, 11, &#x27;Fuzz&#x27;, 13, 14, &#x27;FizzBuzz&#x27;, 16, 17, &#x27;Fuzz&#x27;, 19]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="添加来自两个列表的元素"><a href="#添加来自两个列表的元素" class="headerlink" title="添加来自两个列表的元素"></a>添加来自两个列表的元素</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加来自两个列表的元素</span></span><br><span class="line"></span><br><span class="line">maths = [<span class="number">59</span>, <span class="number">64</span>, <span class="number">75</span>, <span class="number">86</span>]</span><br><span class="line">physics = [<span class="number">78</span>, <span class="number">98</span>, <span class="number">56</span>, <span class="number">56</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Brute Force Method</span></span><br><span class="line">list1 = [</span><br><span class="line">  maths[<span class="number">0</span>]+physics[<span class="number">0</span>],</span><br><span class="line">  maths[<span class="number">1</span>]+physics[<span class="number">1</span>],</span><br><span class="line">  maths[<span class="number">2</span>]+physics[<span class="number">2</span>],</span><br><span class="line">  maths[<span class="number">3</span>]+physics[<span class="number">3</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># List Comprehension</span></span><br><span class="line">list1 = [x + y <span class="keyword">for</span> x,y <span class="keyword">in</span> <span class="built_in">zip</span>(maths,physics)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Using Maps</span></span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line">all_devices = <span class="built_in">list</span>(<span class="built_in">map</span>(operator.add, maths, physics))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Using Numpy Library</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">list1 = np.add(maths,physics)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(list1)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;Output</span></span><br><span class="line"><span class="string">[137 162 131 142]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="对dictionary列表进行排序"><a href="#对dictionary列表进行排序" class="headerlink" title="对dictionary列表进行排序"></a>对dictionary列表进行排序</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = [</span><br><span class="line">    &#123;<span class="string">&quot;Name&quot;</span>:<span class="string">&quot;Karl&quot;</span>,</span><br><span class="line">     <span class="string">&quot;Age&quot;</span>:<span class="number">25</span>&#125;,</span><br><span class="line">     &#123;<span class="string">&quot;Name&quot;</span>:<span class="string">&quot;Lary&quot;</span>,</span><br><span class="line">     <span class="string">&quot;Age&quot;</span>:<span class="number">39</span>&#125;,</span><br><span class="line">     &#123;<span class="string">&quot;Name&quot;</span>:<span class="string">&quot;Nina&quot;</span>,</span><br><span class="line">     <span class="string">&quot;Age&quot;</span>:<span class="number">35</span>&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">## Using sort()</span></span><br><span class="line">dict1.sort(key=<span class="keyword">lambda</span> item: item.get(<span class="string">&quot;Age&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># List sorting using itemgetter</span></span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line">f = itemgetter(<span class="string">&#x27;Name&#x27;</span>)</span><br><span class="line">dict1.sort(key=f)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Iterable sorted function</span></span><br><span class="line">dict1 = <span class="built_in">sorted</span>(dict1, key=<span class="keyword">lambda</span> item: item.get(<span class="string">&quot;Age&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dict1)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;Output</span></span><br><span class="line"><span class="string">[&#123;&#x27;Age&#x27;: 25, &#x27;Name&#x27;: &#x27;Karl&#x27;&#125;,</span></span><br><span class="line"><span class="string"> &#123;&#x27;Age&#x27;: 35, &#x27;Name&#x27;: &#x27;Nina&#x27;&#125;,</span></span><br><span class="line"><span class="string"> &#123;&#x27;Age&#x27;: 39, &#x27;Name&#x27;: &#x27;Lary&#x27;&#125;]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="检查字符串中的子字符串"><a href="#检查字符串中的子字符串" class="headerlink" title="检查字符串中的子字符串"></a>检查字符串中的子字符串</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">addresses = [</span><br><span class="line">  <span class="string">&quot;12/45 Elm street&quot;</span>,</span><br><span class="line">  <span class="string">&#x27;34/56 Clark street&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;56,77 maple street&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;17/45 Elm street&#x27;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">street = <span class="string">&#x27;Elm street&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> addresses:</span><br><span class="line">  <span class="keyword">if</span> street <span class="keyword">in</span> i:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;output</span></span><br><span class="line"><span class="string">12/45 Elm street</span></span><br><span class="line"><span class="string">17/45 Elm street</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="字符串格式"><a href="#字符串格式" class="headerlink" title="字符串格式"></a>字符串格式</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;Abhay&quot;</span></span><br><span class="line">age = <span class="number">21</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># METHOD 1: Concatenation</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My name is &quot;</span> + name + <span class="string">&quot;, and I am &quot;</span> + <span class="built_in">str</span>(age) + <span class="string">&quot; years old.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># METHOD 2: F-strings (Python 3+)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;My name is <span class="subst">&#123;name&#125;</span>, and I am <span class="subst">&#123;age&#125;</span> years old&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># METHOD 3: Join</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join([<span class="string">&quot;My name is &quot;</span>, name, <span class="string">&quot;, and I am &quot;</span>, <span class="built_in">str</span>(age), <span class="string">&quot; years old&quot;</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># METHOD 4: modulus operator</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My name is %s, and I am %d years old.&quot;</span> % (name, age))</span><br><span class="line"></span><br><span class="line"><span class="comment"># METHOD 5: format(Python 2 and 3)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My name is &#123;&#125;, and I am &#123;&#125; years old&quot;</span>.<span class="built_in">format</span>(name, age))</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; Output</span></span><br><span class="line"><span class="string">My name is Abhay, and I am 21 years old.</span></span><br><span class="line"><span class="string">My name is Abhay, and I am 21 years old</span></span><br><span class="line"><span class="string">My name is Abhay, and I am 21 years old</span></span><br><span class="line"><span class="string">My name is Abhay, and I am 21 years old.</span></span><br><span class="line"><span class="string">My name is Abhay, and I am 21 years old</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="列表中最常见的元素"><a href="#列表中最常见的元素" class="headerlink" title="列表中最常见的元素"></a>列表中最常见的元素</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列表中最常见的元素</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">most_frequent</span>(<span class="params">nums</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">set</span>(nums), key = nums.count)</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">most_frequent_num = most_frequent(<span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(most_frequent_num)</span><br><span class="line"><span class="string">&quot;&quot;&quot; Output</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="在没有if-else情况下计算"><a href="#在没有if-else情况下计算" class="headerlink" title="在没有if-else情况下计算"></a>在没有if-else情况下计算</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import operator</span><br><span class="line">action = &#123;</span><br><span class="line">  &quot;+&quot; : operator.add,</span><br><span class="line">  &quot;-&quot; : operator.sub,</span><br><span class="line">  &quot;/&quot; : operator.truediv,</span><br><span class="line">  &quot;*&quot; : operator.mul,</span><br><span class="line">  &quot;**&quot; : pow</span><br><span class="line">&#125;</span><br><span class="line">print(action[&#x27;*&#x27;](5, 5))    # 25</span><br></pre></td></tr></table></figure><h2 id="Chained-Function调用"><a href="#Chained-Function调用" class="headerlink" title="Chained Function调用"></a>Chained Function调用</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在python中，你可以在同一行代码调用多个函数。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a,b</span>):</span><br><span class="line">  <span class="keyword">return</span> a+b</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub</span>(<span class="params">a,b</span>):</span><br><span class="line">  <span class="keyword">return</span> a-b</span><br><span class="line"></span><br><span class="line">a,b = <span class="number">9</span>,<span class="number">6</span></span><br><span class="line"><span class="built_in">print</span>((sub <span class="keyword">if</span> a &gt; b <span class="keyword">else</span> add)(a, b))</span><br></pre></td></tr></table></figure><h2 id="交换数值"><a href="#交换数值" class="headerlink" title="交换数值"></a>交换数值</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a,b = <span class="number">5</span>,<span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 1</span></span><br><span class="line">b,a = a,b</span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">swap</span>(<span class="params">a,b</span>):</span><br><span class="line">  <span class="keyword">return</span> b,a</span><br><span class="line"></span><br><span class="line">swap(a,b)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a,b)</span><br><span class="line"><span class="string">&quot;&quot;&quot; Output</span></span><br><span class="line"><span class="string">7 5</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="查找重复项"><a href="#查找重复项" class="headerlink" title="查找重复项"></a>查找重复项</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">has_duplicates</span>(<span class="params">lst</span>):</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">not</span> <span class="built_in">len</span>(lst) == <span class="built_in">len</span>(<span class="built_in">set</span>(lst))</span><br><span class="line"></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">y = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(has_duplicates(x))    <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(has_duplicates(y))    <span class="comment"># True</span></span><br></pre></td></tr></table></figure><h2 id="在给定范围内，算所有数的平方"><a href="#在给定范围内，算所有数的平方" class="headerlink" title="在给定范围内，算所有数的平方"></a>在给定范围内，算所有数的平方</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># METHOD 1</span></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> repeat</span><br><span class="line">n = <span class="number">5</span></span><br><span class="line">squares = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">pow</span>, <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>), repeat(<span class="number">2</span>)))</span><br><span class="line"><span class="built_in">print</span>(squares)</span><br><span class="line"></span><br><span class="line"><span class="comment"># METHOD 2</span></span><br><span class="line">n = <span class="number">6</span></span><br><span class="line">squares = [i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>)]</span><br><span class="line"><span class="built_in">print</span>(squares)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;Output</span></span><br><span class="line"><span class="string">  [1, 4, 9, 16, 25]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="合并两个字典"><a href="#合并两个字典" class="headerlink" title="合并两个字典"></a>合并两个字典</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">basic_information = &#123;<span class="string">&quot;name&quot;</span>:[<span class="string">&#x27;karl&#x27;</span>,<span class="string">&#x27;Lary&#x27;</span>],<span class="string">&quot;mobile&quot;</span>:[<span class="string">&quot;0134567894&quot;</span>,<span class="string">&quot;0123456789&quot;</span>]&#125;</span><br><span class="line">academic_information = &#123;<span class="string">&quot;grade&quot;</span>:[<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>]&#125;</span><br><span class="line"></span><br><span class="line">details = <span class="built_in">dict</span>() <span class="comment">## Combines Dict</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Dictionary Comprehension Method</span></span><br><span class="line">details = &#123;key: value <span class="keyword">for</span> data <span class="keyword">in</span> (basic_information, academic_information) <span class="keyword">for</span> key,value <span class="keyword">in</span> data.items()&#125;</span><br><span class="line"><span class="built_in">print</span>(details)</span><br><span class="line"></span><br><span class="line"><span class="comment">## Dictionary unpacking</span></span><br><span class="line">details = &#123;**basic_information ,**academic_information&#125;</span><br><span class="line"><span class="built_in">print</span>(details)</span><br><span class="line"></span><br><span class="line"><span class="comment">## Copy and Update Method</span></span><br><span class="line">details = basic_information.copy()</span><br><span class="line">details.update(academic_information)</span><br><span class="line"><span class="built_in">print</span>(details)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/FRank675.github.io/posts/72b1ae2f9336/"/>
      <url>/FRank675.github.io/posts/72b1ae2f9336/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\FRank675.github.io\css\APlayer.min.css"><script src="\FRank675.github.io\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\FRank675.github.io\js\Meting.min.js"></script><h2 id="1、TCP"><a href="#1、TCP" class="headerlink" title="1、TCP"></a>1、TCP</h2><h3 id="（1）介绍一下OSI七层模型和TCP五层模型？"><a href="#（1）介绍一下OSI七层模型和TCP五层模型？" class="headerlink" title="（1）介绍一下OSI七层模型和TCP五层模型？"></a>（1）介绍一下OSI七层模型和TCP五层模型？</h3><p>OSI七层模型从上到下依次为：</p><p>应用层：为应用程序提供网络服务；</p><p>表示层：数据格式转换、数据压缩和数据加密；</p><p>会话层：建立、断开和维护通信链接；</p><p>传输层：为上层协议提供端到端的可靠传输；</p><p>网络层：寻址和路由；</p><p>数据链路层：定义通过通信媒介互连的设备之间传输的规范；</p><p>物理层：利用物理传输介质为数据链路层提供物理连接。</p><p>TCP五层模型相比OSI七层模型，将OSI的应用层、表示层和会话层合为一层：应用层，其他不变。</p><h3 id="（2）什么是面向有连接型和面向无连接型？"><a href="#（2）什么是面向有连接型和面向无连接型？" class="headerlink" title="（2）什么是面向有连接型和面向无连接型？"></a>（2）什么是面向有连接型和面向无连接型？</h3><ul><li>面向有连接型传输包括会话建立、传输数据和会话断开，此外还包括保证传输可靠性的各种措施，比如超时重传、流量控制等，常见的面向有连接传输有TCP；</li><li>面向无连接型传输仅提供基本的传输数据的功能，即使接收端不存在，发送端也能发送数据包，常见的面向无连接传输有UDP、IP。</li></ul><h3 id="（3）什么是UDP和TCP？UDP和TCP的区别是什么？"><a href="#（3）什么是UDP和TCP？UDP和TCP的区别是什么？" class="headerlink" title="（3）什么是UDP和TCP？UDP和TCP的区别是什么？"></a>（3）什么是UDP和TCP？UDP和TCP的区别是什么？</h3><p>UDP和TCP都是传输层的协议，用来建立可靠的通信传输链接的。</p><p>UDP仅提供了最基本的数据传输功能，至于传输时连接的建立和断开、传输可靠性的保证这些UDP统统不关心，而是把这些问题抛给了UDP上层的应用层程序去处理，自己仅提供传输层协议的最基本功能。</p><p>TCP作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，会在传输开始前建立连接，传输结束后断开连接，此外，TCP还采取了多种措施保障传输的可靠性。</p><p><strong>TCP和UDP的区别如下：</strong></p><ul><li>TCP是面向有连接型，UDP是面向无连接型；</li><li>TCP是一对一传输，UDP支持一对一、一对多、多对一和多对多的交互通信；</li><li>TCP是面向字节流的，即把应用层传来的报文看成字节流，将字节流拆分成大小不等的数据块，并添加TCP首部；UDP是面向报文的，对应用层传下来的报文不拆分也不合并，仅添加UDP首部；</li><li>TCP支持传输可靠性的多种措施，包括保证包的传输顺序、重发机制、流量控制和拥塞控制；UDP仅提供最基本的数据传输能力。</li></ul><h3 id="（4）TCP对应的应用层协议有哪些？UDP对应的应用层协议有哪些？"><a href="#（4）TCP对应的应用层协议有哪些？UDP对应的应用层协议有哪些？" class="headerlink" title="（4）TCP对应的应用层协议有哪些？UDP对应的应用层协议有哪些？"></a>（4）TCP对应的应用层协议有哪些？UDP对应的应用层协议有哪些？</h3><p>TCP对应的典型的应用层协议：</p><ul><li>FTP：文件传输协议；</li><li>SSH：远程登录协议；</li><li>HTTP：web服务器传输超文本到本地浏览器的超文本传输协议。</li></ul><p>UDP对应的典型的应用层协议：</p><ul><li>DNS：域名解析协议；</li><li>TFTP：简单文件传输协议；</li><li>SNMP：简单网络管理协议。</li></ul><h3 id="（5）介绍一下TCP三次握手？为什么不是两次？为什么不是四次？"><a href="#（5）介绍一下TCP三次握手？为什么不是两次？为什么不是四次？" class="headerlink" title="（5）介绍一下TCP三次握手？为什么不是两次？为什么不是四次？"></a>（5）介绍一下TCP三次握手？为什么不是两次？为什么不是四次？</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>物理层、数据链路层在物理层面上架设好了通信链路，网络层确定了通信双方的地址，那下一步就是传输层建立逻辑层面上的通信连接，将从应用层获得的报文数据从源端发送给接受端。TCP的三次握手就是在发送数据前通过“三次握手”的方式建立起这个通信连接，<strong>建立这个连接的目的是让源端和目的端确认一下双方的发送报文能力和接收报文能力是正常的，实际上就是通过三次握手这个操作将下面的表填完整：</strong></p><p><img src="https://pic1.zhimg.com/80/v2-3a6613efd413f9e5ae1c5e124e0a0fa8_720w.webp" alt="img"></p><p>图1.1 三次握手要填充的表格</p><p>下面具体介绍三次握手的过程，并在每次握手时填充这个表格，当表格填满后，意味着源端和目的端已确认完毕双方的发送报文能力和接收报文能力是正常的，三次握手结束，通信双方的连接已成功建立。</p><h5 id="TCP报文首部"><a href="#TCP报文首部" class="headerlink" title="TCP报文首部"></a>TCP报文首部</h5><p>在介绍三次握手前先介绍一下TCP报文的首部，报文首部可以理解为报文的元数据，里面存放着与这次报文相关的其他信息，图我就不摆了，介绍一下跟三次握手相关的报文首部字段。</p><p>（1）序号seq</p><p>对字节流的编号。例如第一个字节的序号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。注意第一份报文段的序号是随机生成的，后面的报文段序号是根据上一个报文段序号及报文长度生成的。</p><p>（2）确认号ack</p><p>期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</p><p>（3）SYN</p><p>控制位的一种，用于建立连接，该位设为 1，表示希望建立连接，并对第一份报文的序号进行随机初始化。</p><p>（4）ACK</p><p>控制位的一种，确认应答的字段有效，TCP规定除了最初建立连接时的 SYN 包以外该位必须设为 1。</p><p>（5）FIN</p><p>控制位的一种，当FIN&#x3D;1，表明此报文的发送方的数据已经发送完毕，要求关闭连接。</p><h5 id="三次握手具体过程"><a href="#三次握手具体过程" class="headerlink" title="三次握手具体过程"></a>三次握手具体过程</h5><p>TCP三次握手的过程如图所示</p><p><img src="https://pic3.zhimg.com/80/v2-770e5584cb5752e0295432be789b86d2_720w.webp" alt="img"></p><p>TCP三次握手过程</p><p>（1）第一次握手</p><p>Client端将SYN置为1，表示希望与Server端建立连接；序号seq初始化为J，并将该数据包发送给Server端，Client进入SYN_SENT状态，等待Server确认。</p><p>（2）第二次握手</p><p>Server端检查报文发现SYN为1，知道了Client端想建立连接；Server端将SYN置为1，表示Server端也希望与Clinet端建立连接；Server端将ACK置为1，表示收到了Client端建立连接的请求；Server端将seq初始化为K；Server端将ack置为J+1，这里ack&#x3D;seq + 1，还有疑问（如果控制位占1字节，为什么第三次握手时有ACK&#x3D;1、SYN&#x3D;1，ack为什么不是+2？如果+1只是告诉服务端收到了消息，那ACK控制位就已经达到目的了，为什么还要多次一举再加一个ack?）。第二次握手包括服务端确认客户端发来的报文和服务端向客户端发送报文两个过程。</p><p>第二次握手时表格填充结果如下：</p><p><img src="https://pic1.zhimg.com/80/v2-e697bf5e5130739686f11ddf5d43a5dc_720w.webp" alt="img"></p><p>第二次握手表格填充</p><p>（3）第三次握手</p><p>Client收到报文后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack&#x3D;K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。第三次握手包括客户端确认服务端发来的报文，客户端向服务端发送报文和服务端确认客户端发来的报文三个过程。</p><p>第三次握手客户端确认信息后填充表格如下:</p><p><img src="https://pic3.zhimg.com/80/v2-fb9327440993a84efc06eb827b25ebe2_720w.webp" alt="img"></p><p>第三次握手客户端确认信息表格填充</p><p>第三次握手服务端确认信息后填充表格如下：</p><p><img src="https://pic1.zhimg.com/80/v2-d868aad5715376de187ea48ec781b520_720w.webp" alt="img"></p><p>​                                                              第三次握手服务端确认信息表格填充</p><p>至此，表格填充完毕，三次握手也结束，连接成功建立。有些面试官会问为什么不是2次握手？</p><p><strong>因为2次握手表格填充不完，源端和目的端无法确认双方的收发能力；为什么不是4次握手？3次握手表格就填充完毕了，不需要再多一次握手了。</strong></p><h3 id="（6）介绍一下TCP四次挥手？为什么不是三次？为什么不是五次？"><a href="#（6）介绍一下TCP四次挥手？为什么不是三次？为什么不是五次？" class="headerlink" title="（6）介绍一下TCP四次挥手？为什么不是三次？为什么不是五次？"></a>（6）介绍一下TCP四次挥手？为什么不是三次？为什么不是五次？</h3><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>三次握手是建立TCP连接，四次挥手是断开TCP连接，即客户端和服务端总共要收发4个包才能确定断开连接。</p><h4 id="四次挥手的具体过程"><a href="#四次挥手的具体过程" class="headerlink" title="四次挥手的具体过程"></a>四次挥手的具体过程</h4><p>四次挥手的过程如图所示：</p><p><img src="/FRank675.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/v2-439585f9ae8c89bfb5a96f100fb99ed5_720w.webp" alt="img"></p><p>TCP四次挥手过程图</p><p>（1）第一次挥手</p><p>假设客户端主动发起断开请求，客户端向服务端发送报文，报文首部包括FIN&#x3D;1，这个控制位代表客户端想要断开连接；序列号seq&#x3D;u，这时客户端进入FIN-WAIT-1（终止等待1）状态，停止发送数据，并等待服务端的确认。</p><p>（2）第二次挥手</p><p>服务端收到客户端的报文后发出确认报文，控制位ACK&#x3D;1；确认号ack&#x3D;u+1；序列号seq&#x3D;v；然后服务端就进入CLOSE-WAIT（关闭等待）状态。TCP服务端会告知上层的应用进程来自客户端的连接即将关闭，让应用程序做好相应的准备。此时客户端已经没有数据向服务端发送了，但服务端向客户端发送数据，客户端依然能接收。</p><p>（3）第三次挥手</p><p>客户端收到服务器确认报文后，进入FIN-WAIT-2状态。此时服务器再次发送报文，报文首部控制位FIN&#x3D;1，表示服务端向客户端发送断开连接请求；确认标志ACK&#x3D;1；确认序号ack&#x3D;u+1；序号seq&#x3D;w，然后服务器进入LAST-ACK（最后确认态），等待客户端确认。</p><p>（4）第四次挥手</p><p>客户端收到了服务端的断开连接的报文后，必须发出确认报文，标志位ACK&#x3D;1；确认号ack&#x3D;w+1;序号seq&#x3D;u+1；之后客户端就进入了TIME-WAIT（时间等待）状态。注意此时客户端的TCP连接还没有释放，必须经过2*MSL（最长报文段寿命）的时间后，客户端才进入CLOSED状态关闭连接。而服务端只要收到了客户端发送的确认报文后就会进入CLOSED状态关闭服务端连接。当客户端和服务端都进入了CLOSED状态后，客户端和服务端之间的连接才完全断开。</p><h3 id="2-2-为什么会有TIME-WAIT状态？"><a href="#2-2-为什么会有TIME-WAIT状态？" class="headerlink" title="2.2 为什么会有TIME_WAIT状态？"></a>2.2 为什么会有TIME_WAIT状态？</h3><p>上面介绍第四次挥手的过程中，客户端在发送完给服务端的回执报文后没有立刻进入CLOSED状态，而是进入TIME-WAIT状态，然后等待2*MSL（最长报文段寿命）的时间后才进入CLOSED状态，这是为什么？原因有以下两点：</p><ul><li>客户端发送给服务端回执后，有可能这个回执报文在传输途中丢失等原因，服务端并没有收到，此时服务端会再次向客户端发送FIN&#x3D;1的断开请求报文，如果客户端没有等待2*MSL时间而直接进入了CLOSED状态，客户端就会收不到服务端再次发送的断开连接的请求报文，导致服务端无法进入CLOSED状态；</li><li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li></ul><p>注：MSL是Maximum Segment Lifetime英文的缩写，中文可以译为“报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p><h3 id="2-3-为什么是四次挥手而不是三次或者五次？"><a href="#2-3-为什么是四次挥手而不是三次或者五次？" class="headerlink" title="2.3 为什么是四次挥手而不是三次或者五次？"></a>2.3 为什么是四次挥手而不是三次或者五次？</h3><p>第二次挥手和第三次挥手都是服务端向客户端发送报文，第二次挥手是服务端收到了客户端的断开请求，通知客户端俺收到了，此时客户端没有数据向服务端发送了，但不代表服务端也没有数据向客户端发送，因为服务端要把剩余还没有发送的报文发送完毕再断开连接；第三次挥手是服务端数据全部发送完毕，向客户端发送断开请求报文（FIN&#x3D;1）。</p><p>如果是三次挥手，即把服务端向客户端发送报文的第二次挥手和第三次挥手合为一次，会造成服务端发送了回执后立刻又发送断开请求，造成服务端有数据没有全部发送至客户端，因此必须将第二次挥手和第三次挥手分开；五次挥手则完全没必要，多此一举。</p><h3 id="（7）在四次挥手中，为什么客户端进入TIME-WAIT状态等待2-MSL时间，而不是直接进入CLOSED状态？"><a href="#（7）在四次挥手中，为什么客户端进入TIME-WAIT状态等待2-MSL时间，而不是直接进入CLOSED状态？" class="headerlink" title="（7）在四次挥手中，为什么客户端进入TIME_WAIT状态等待2*MSL时间，而不是直接进入CLOSED状态？"></a>（7）在四次挥手中，为什么客户端进入TIME_WAIT状态等待2*MSL时间，而不是直接进入CLOSED状态？</h3><p>客户端在发送完给服务端的回执报文后没有立刻进入CLOSED状态，而是进入TIME-WAIT状态，然后等待2*MSL（最长报文段寿命）的时间后才进入CLOSED状态，这是为什么？原因有以下两点：</p><ul><li>客户端发送给服务端回执后，有可能这个回执报文在传输途中丢失等原因，服务端并没有收到，此时服务端会再次向客户端发送FIN&#x3D;1的断开请求报文，如果客户端没有等待2*MSL时间而直接进入了CLOSED状态，客户端就会收不到服务端再次发送的断开连接的请求报文，导致服务端无法进入CLOSED状态；</li><li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li></ul><p>注：MSL是Maximum Segment Lifetime英文的缩写，中文可以译为“报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p><h3 id="（8）说一下ARQ协议？"><a href="#（8）说一下ARQ协议？" class="headerlink" title="（8）说一下ARQ协议？"></a>（8）说一下ARQ协议？</h3><p>ARQ协议，即自动重传请求（Automatic Repeat-reQuest），意思是如果发送方在发送后一段时间之内没有收到确认回执，它通常会重新发送。ARQ协议包括停止等待ARQ协议和连续ARQ协议。</p><p>（1）停止等待ARQ协议</p><p>停止等待ARQ协议是指，在停止等待中如果接收端没有收到发送端发来的分组，接收端就不会给发送端发送确认回执，此时发送端会重新发送之前的报文分组。发送端会维护一个超时计时器，超时时间会设置的比数据在传输往返过程的时间要长一些。</p><p>（2）连续ARQ协议</p><p>连续ARQ协议是指，发送端维护一个“窗口”，“窗口”内可以有多个分组，窗口的大小就是窗口中分组的个数，凡是位于“窗口”内的分组可以连续发送出去而不必等待接收端返回的确认回执，对按序到达的最后一个分组，接收端会向发送端发送确认回执，如果有分组没有正确到达，会返回最后一个正确达到的分组序号，该序号后面的分组会重新发送给接收端。</p><p>举个例子，窗口大小为4，发送时第1、2、4号分组均成功发送，3号分组发送失败，接收端会给发送端发送2号分组的确认回执，然后发送端会把2号分组之后的数据（3号分组和4号分组）重新再发送一遍，即使4号分组是发送成功的。</p><p>在连续ARQ协议中，发送端会维护一块发送端的数据缓存，“窗口”里的分组都会在这个缓存中，当需要重新发送“窗口”中的分组报文时，便会从缓存里读取分组并发送。</p><p>连续 ARQ 协议可提高信道利用率。</p><h3 id="（9）说一下TCP的流量控制？"><a href="#（9）说一下TCP的流量控制？" class="headerlink" title="（9）说一下TCP的流量控制？"></a>（9）说一下TCP的流量控制？</h3><p>流量控制是为了控制发送端发送数据的速率，保证接收端能将本应接收的所有报文分组接收成功，否则会触发自动重传机制造成网络流量的浪费。</p><p>流量控制的具体操作是：接收端会通知发送端自己能接收的数据大小，于是发送端会发送不超过这个数据量的数据，这个大小被称为“窗口”的大小，在TCP首部中专门有一个字段表示“窗口”的大小，该值越大代表网络的吞吐量越高。</p><h3 id="（10）说一下TCP的拥塞控制？"><a href="#（10）说一下TCP的拥塞控制？" class="headerlink" title="（10）说一下TCP的拥塞控制？"></a>（10）说一下TCP的拥塞控制？</h3><p>计算机网络都处在一个共享的环境，在通信开始时如果立即把大量数据注入到网络，可能会引起网络阻塞，甚至带来网络瘫痪。TCP为了防止该问题的出现，采用了拥塞控制的策略，常见的拥塞控制策略有慢启动、拥塞避免、快重传与快恢复，这里以慢启动为例做简单介绍。</p><p>在通信开始时，定义一个“拥塞窗口”，窗口大小为1，意思是开始时只发送一个分组，之后每收到一个确认回执（ACK），拥塞窗口的大小就加1（即逐渐增大窗口大小），发送端在发送数据时，将拥塞窗口的大小与接收端流量控制窗口的大小作比较，取二者中较小的值，然后实际发送的数据量比这个最小值还要小。</p><h3 id="（11）什么是TCP粘包？"><a href="#（11）什么是TCP粘包？" class="headerlink" title="（11）什么是TCP粘包？"></a>（11）什么是TCP粘包？</h3><p>如果客户端连续不断的向服务端发送数据包时，服务端接收的数据会出现两个数据包粘在一起的情况。</p><p>\1. TCP 是基于字节流的，虽然应用层和 TCP 传输层之间的数据交互是大小不等的数据块，但是 TCP 把这些数据块仅仅看成一连串无结构的字节流，没有边界；</p><p>\2. 从 TCP 的帧结构也可以看出，在 TCP 的首部没有表示数据长度的字段。</p><p>基于上面两点，在使用 TCP 传输数据时，才有粘包或者拆包现象发生的可能。一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。</p><h3 id="（12）粘包是如何产生的？"><a href="#（12）粘包是如何产生的？" class="headerlink" title="（12）粘包是如何产生的？"></a>（12）粘包是如何产生的？</h3><p>（1）发送方产生粘包</p><p>采用 TCP 协议传输数据的客户端与服务器经常是保持一个长连接的状态（一次连接发一次数据不存在粘包），双方在连接不断开的情况下，可以一直传输数据。但当发送的数据包过于的小时，那么 TCP 协议默认的会启用 Nagle 算法，将这些较小的数据包进行合并发送（缓冲区数据发送是一个堆压的过程）；这个合并过程就是在发送缓冲区中进行的，也就是说数据发送出来它已经是粘包的状态了。</p><p>一句话：要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包。</p><p>（2）接收方产生粘包</p><p>接收方采用 TCP 协议接收数据时的过程是这样的：数据到接收方，从网络模型的下方传递至传输层，传输层的 TCP 协议处理是将其放置接收缓冲区，然后由应用层来主动获取（C 语言用 recv、read 等函数）；这时会出现一个问题，就是我们在程序中调用的读取数据函数不能及时的把缓冲区中的数据拿出来，而下一个数据又到来并有一部分放入的缓冲区末尾，等我们读取数据时就是一个粘包。（放数据的速度 &gt; 应用层拿数据速度）。</p><p>一句话：接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。</p><h3 id="（13）如何避免粘包？"><a href="#（13）如何避免粘包？" class="headerlink" title="（13）如何避免粘包？"></a>（13）如何避免粘包？</h3><p>有以下两个措施：</p><ul><li>在每个包的末尾加上特殊字符，用以区分连续的两个包；</li><li>在报文首部添加包的长度。</li></ul><h1 id="2、http"><a href="#2、http" class="headerlink" title="2、http"></a>2、http</h1><h3 id="（1）什么是http协议？http和https的区别？"><a href="#（1）什么是http协议？http和https的区别？" class="headerlink" title="（1）什么是http协议？http和https的区别？"></a>（1）什么是http协议？http和https的区别？</h3><p>http协议是应用层的协议，中文名称是超文本传输协议，是客户端和服务端相互通信时将信息以http报文的形式传输。</p><p>https可以简单的理解为：https &#x3D; http + 加密 + 认证 + 完整性保护。</p><p>http协议的缺点:</p><ol><li>通信使用明文，内容可能被窃听。</li><li>通信双方的身份无法得到认证，身份可能遭遇伪装。</li><li>无法验证报文的完整性。</li></ol><p>针对以上问题，https的改进措施:</p><ol><li>加密。https协议通过SSL或者TLS协议将报文内容进行加密，client端进行加密，server端进行解密。</li><li>认证。通过值得信赖的第三方机构颁布证书，即可确认通信双方的身份。客户端持有证书即可完成客户端身份的确认，客户端通信前会查看服务端的证书。</li><li>完整性保护。可以通过MD5等散列码进行通信内容的校验。</li></ol><h3 id="（2）为什么说http协议是无状态协议？怎么解决Http协议无状态协议"><a href="#（2）为什么说http协议是无状态协议？怎么解决Http协议无状态协议" class="headerlink" title="（2）为什么说http协议是无状态协议？怎么解决Http协议无状态协议?"></a>（2）为什么说http协议是无状态协议？怎么解决Http协议无状态协议?</h3><p>http协议是一种无状态协议，协议自身不对请求和响应之间的通信状态进行保存，即对发送过来的请求和响应都不做持久化处理，把http协议设计的如此简单是为了更快地处理大量事务。</p><p>为了解决http协议不能保存通信状态的问题，引入了Cookie状态管理。Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。Cookie会根据从服务端发送的响应报文的一个叫Set-Cookie的首部字段，通知客户端保存Cookie。当下次客户端再往该服务端发送请求时，客户端会自动在请求报文中加入Cookie值发送出去，服务端发现客户端发来的Cookie后，会检查是哪一个客户端发来的连接请求，对比服务器上的记录，最后得到之前的状态信息。</p><h3 id="（3）URI和URL的区别"><a href="#（3）URI和URL的区别" class="headerlink" title="（3）URI和URL的区别?"></a>（3）URI和URL的区别?</h3><p>URI: Uniform Resource Identifier，统一资源标识符，用来唯一标识互联网中的一份资源。</p><p>URL: Uniform Resource Locator，统一资源定位符，我们访问网站的网址就是URL。</p><p>URL是URI的子集。</p><p>URI的目的就是唯一标识互联网中的一份资源，具体可以用资源名称、资源地址等，但是资源地址是目前使用最广泛的，因此URL就容易和URI混淆。URI相当于抽象类，URL就是这个抽象类的具体实现类。</p><h3 id="（4）常见的http动词有哪些？"><a href="#（4）常见的http动词有哪些？" class="headerlink" title="（4）常见的http动词有哪些？"></a>（4）常见的http动词有哪些？</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">GET: 从服务器获取资源</span><br><span class="line">POST: 在服务器新建资源</span><br><span class="line">PUT: 在服务器更新资源</span><br><span class="line">DELETE: 在服务器删除资源</span><br><span class="line">HEAD: 获取资源的元数据</span><br><span class="line">OPTIONAL: 查询对指定的资源支持的方法</span><br></pre></td></tr></table></figure><h3 id="（5）put和post的区别？"><a href="#（5）put和post的区别？" class="headerlink" title="（5）put和post的区别？"></a>（5）put和post的区别？</h3><p>put是幂等的，post不是。</p><p>幂等是数学的一个用语，对于单个输入或者无输入的运算方法，如果每次都是同样的结果，则称其是幂等的。也就是说，如果一个网络重复执行多次，产生的效果是一样的，那就是幂等（idempotent）。</p><p>post在发请求的时候，服务器会每次都创建一个文件，而put发请求的时候，是更新文件而不是创建文件，因此put是幂等的。</p><h3 id="（6）http请求报文和响应报文的组成？"><a href="#（6）http请求报文和响应报文的组成？" class="headerlink" title="（6）http请求报文和响应报文的组成？"></a>（6）http请求报文和响应报文的组成？</h3><p>http协议全称是HyperTest Transfer Protocol，超文本传输协议。</p><p>http报文说白了就是client和server通信时依据http协议，将传输的信息以文本的形式呈现，这个文本就是http报文。http报文分为请求报文和消息报文，这两类报文有着相同的结构组成，如图：</p><p><img src="https://pic2.zhimg.com/80/v2-c33de43cb8ec51af31ba034ec2b05d91_720w.webp" alt="img"></p><p>http报文组成</p><p>网上有很多如何在浏览器上查看http报文的，我这里举个例子，方便理解。</p><p><strong>http请求报文：</strong></p><p><img src="/FRank675.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/v2-5363573a7ecc660173ae165251709346_720w.webp" alt="img"></p><p>http请求报文</p><p><strong>http响应报文：</strong></p><p><img src="/FRank675.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/v2-236226d376885574b63151bb072bccdd_720w.webp" alt="img"></p><p>http响应报文</p><p>图中没有显示空行和报文主体。</p><p>下面大致讲一下这四部分：</p><p><strong>请求行&#x2F;响应行</strong></p><p>请求行由http动词，请求uri和http版本组成，主要是反应这次请求要对什么资源做什么操作</p><p>响应行由http返回码，原因短语和http版本组成，呈现的服务端对这次请求的处理结果，我们通过响应行的信息能知道这次请求是否成功，bug出在client端还是server端，原因是什么。</p><p><strong>首部字段</strong></p><p>首部字段又叫头域（header），相当于http报文的元数据，记录了这次http报文的具体描述信息，比如时间、服务端域名等。</p><p><strong>空行</strong></p><p>用来区分首部字段和报文主体。</p><p><strong>报文主体</strong></p><p>报文主体并不是每个报文都有的，要看具体的报文是要做什么，比如列举桶的返回报文里，报文主体会把桶列表以xml格式返回，但是列举桶的请求报文主体什么都不包含。报文主体返回的格式一般是xml或者json格式。</p><h3 id="（7）常见的http返回码有哪些？"><a href="#（7）常见的http返回码有哪些？" class="headerlink" title="（7）常见的http返回码有哪些？"></a>（7）常见的http返回码有哪些？</h3><ul><li>200：请求被正常处理</li><li>204：请求被受理但没有资源可以返回</li><li>206：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。</li><li>301：永久性重定向</li><li>302：临时重定向</li><li>303：与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上</li><li>304：发送附带条件的请求时，条件不满足时返回，与重定向无关</li><li>307：临时重定向，与302类似，只是强制要求使用POST方法</li><li>400：请求报文语法有误，服务器无法识别</li><li>401：请求需要认证</li><li>403：请求的对应资源禁止被访问</li><li>404：服务器无法找到对应资源</li><li>500：服务器内部错误</li><li>503：服务器正忙</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日常小确幸记录</title>
      <link href="/FRank675.github.io/posts/1e3575b0dcca/"/>
      <url>/FRank675.github.io/posts/1e3575b0dcca/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="2023-1-23"><a href="#2023-1-23" class="headerlink" title="2023.1.23"></a>2023.1.23</h2><p>今天刷题看到了一些有趣的评论^_^</p><p><img src="/%E6%97%A5%E5%B8%B8%E7%82%B9%E6%BB%B4.assets/1674463375977.png" alt="1674463375977"></p><p><img src="/%E6%97%A5%E5%B8%B8%E7%82%B9%E6%BB%B4.assets/1674463442949.png" alt="1674463442949"></p><p>然后一年后有人评论</p><p><img src="/%E6%97%A5%E5%B8%B8%E7%82%B9%E6%BB%B4.assets/1674463413620.png" alt="1674463413620"></p><p>然后我好像得研究一下网站的图床咋搞</p>]]></content>
      
      
      <categories>
          
          <category> 小确幸 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题记录</title>
      <link href="/FRank675.github.io/posts/8cc09a6c47db/"/>
      <url>/FRank675.github.io/posts/8cc09a6c47db/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="主要记录LEETCODE刷题的感想和总结"><a href="#主要记录LEETCODE刷题的感想和总结" class="headerlink" title="主要记录LEETCODE刷题的感想和总结~"></a>主要记录LEETCODE刷题的感想和总结~</h1><h2 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a><a href="https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">剑指 Offer 09. 用两个栈实现队列</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -<span class="number">1</span> )</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line">输入：</span><br><span class="line">[<span class="string">&quot;CQueue&quot;</span>,<span class="string">&quot;appendTail&quot;</span>,<span class="string">&quot;deleteHead&quot;</span>,<span class="string">&quot;deleteHead&quot;</span>,<span class="string">&quot;deleteHead&quot;</span>]</span><br><span class="line">[[],[<span class="number">3</span>],[],[],[]]</span><br><span class="line">输出：[null,null,<span class="number">3</span>,-<span class="number">1</span>,-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[<span class="string">&quot;CQueue&quot;</span>,<span class="string">&quot;deleteHead&quot;</span>,<span class="string">&quot;appendTail&quot;</span>,<span class="string">&quot;appendTail&quot;</span>,<span class="string">&quot;deleteHead&quot;</span>,<span class="string">&quot;deleteHead&quot;</span>]</span><br><span class="line">[[],[],[<span class="number">5</span>],[<span class="number">2</span>],[],[]]</span><br><span class="line">输出：[null,-<span class="number">1</span>,null,null,<span class="number">5</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">###思路分析：使用双栈实现队列，队列要求先进先出，所以一个栈用于进，另一个栈倒置用于出，在python中可以使用append()方法添加元素，使用pop()弹出元素</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CQueue</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment">#初始化双栈</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.stack1 = []</span><br><span class="line">        self.stack2 = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#添加元素，在第一个栈中添加元素</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">appendTail</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type value: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.stack1.append(value)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除最先进去的元素</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteHead</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment">#当第二个栈不为空，则可以直接弹出</span></span><br><span class="line">        <span class="comment">#否则需要将第一个栈中的元素弹入第二个栈</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.stack2) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(self.stack1) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            <span class="comment">#将第一个栈中的元素全部弹出装入第二个栈中</span></span><br><span class="line">            <span class="comment">#达到的效果就是第一个栈最先进去的元素在第二个栈的顶部</span></span><br><span class="line">            <span class="keyword">while</span> self.stack1:</span><br><span class="line">                self.stack2.append(self.stack1.pop())</span><br><span class="line">        <span class="comment">#第二个栈顶端的元素就是队列删除的最先进去的元素</span></span><br><span class="line">        <span class="keyword">return</span> self.stack2.pop()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = CQueue()</span></span><br><span class="line"><span class="comment"># obj.appendTail(value)</span></span><br><span class="line"><span class="comment"># param_2 = obj.deleteHead()</span></span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-30-包含min函数的栈"><a href="#剑指-Offer-30-包含min函数的栈" class="headerlink" title="剑指 Offer 30. 包含min函数的栈"></a><a href="https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/">剑指 Offer 30. 包含min函数的栈</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 <span class="built_in">min</span> 函数在该栈中，调用 <span class="built_in">min</span>、push 及 pop 的时间复杂度都是 O(<span class="number">1</span>)。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-<span class="number">2</span>);</span><br><span class="line">minStack.push(<span class="number">0</span>);</span><br><span class="line">minStack.push(-<span class="number">3</span>);</span><br><span class="line">minStack.<span class="built_in">min</span>();   --&gt; 返回 -<span class="number">3.</span></span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 <span class="number">0.</span></span><br><span class="line">minStack.<span class="built_in">min</span>();   --&gt; 返回 -<span class="number">2.</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">各函数的调用总次数不超过 <span class="number">20000</span> 次</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment">#初始化两个栈，一个栈正常存储，另一个栈存储最小值</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.minStack = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x</span>):<span class="number">2</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment">#第一个栈正常存储</span></span><br><span class="line">        self.stack.append(x)</span><br><span class="line">        <span class="comment">#第二个栈比较是否出现更小的值，如果出现，添加到最小栈</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.minStack <span class="keyword">or</span> x &lt;= self.minStack[-<span class="number">1</span>]:</span><br><span class="line">            self.minStack.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment">#第一个栈正常弹出，第二个栈比较是否弹出最小值，如果是，第二个栈也弹出</span></span><br><span class="line">        <span class="keyword">if</span> self.stack.pop() == self.minStack[-<span class="number">1</span>]:</span><br><span class="line">            self.minStack.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">min</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment">#最小值即最小栈最后一个值</span></span><br><span class="line">        <span class="keyword">return</span> self.minStack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MinStack()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.min()</span></span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-06-从尾到头打印链表"><a href="#剑指-Offer-06-从尾到头打印链表" class="headerlink" title="剑指 Offer 06. 从尾到头打印链表"></a><a href="https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">剑指 Offer 06. 从尾到头打印链表</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line">输入：head = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line"> </span><br><span class="line">限制：</span><br><span class="line"><span class="number">0</span> &lt;= 链表长度 &lt;= <span class="number">10000</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 递归法</span></span><br><span class="line"><span class="comment"># [1,2,3,4,5]</span></span><br><span class="line"><span class="comment"># [2,3,4,5]</span></span><br><span class="line"><span class="comment"># [3,4,5]</span></span><br><span class="line"><span class="comment"># [4,5]</span></span><br><span class="line"><span class="comment"># [5]</span></span><br><span class="line"><span class="comment"># []</span></span><br><span class="line"><span class="comment"># [5,4,3,2,1]</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reversePrint</span>(<span class="params">self, head</span>):</span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> self.reversePrint(head.<span class="built_in">next</span>) + [head.val]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 普通做法</span></span><br><span class="line"><span class="comment"># 遍历链表使用一个list存储链表</span></span><br><span class="line"><span class="comment"># 反转链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reversePrint</span>(<span class="params">self, head</span>):</span><br><span class="line">        resList = []</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            resList.append(head.val)</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> resList[::-<span class="number">1</span>]</span><br><span class="line"><span class="comment"># list的[]中有三个参数，用冒号分割</span></span><br><span class="line"><span class="comment"># list[param1:param2:param3]</span></span><br><span class="line"><span class="comment"># param1，相当于start_index，可以为空，默认是0</span></span><br><span class="line"><span class="comment"># param2，相当于end_index，可以为空，默认是list.size</span></span><br><span class="line"><span class="comment"># param3，步长，默认为1。步长为-1时，返回倒序原序列</span></span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-24-反转链表"><a href="#剑指-Offer-24-反转链表" class="headerlink" title="剑指 Offer 24. 反转链表"></a><a href="https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/">剑指 Offer 24. 反转链表</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL</span><br><span class="line">输出: <span class="number">5</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;NULL</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line"><span class="number">0</span> &lt;= 节点个数 &lt;= <span class="number">5000</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义指针 pre，cur 分别指向 null 和头节点。</span></span><br><span class="line"><span class="comment">#遍历链表，将 cur.next 临时保存到 t 中，然后改变指针 cur 指向的节点的指向，将其指向 pre 指针指向的节点，即 cur.next = pre。然后 pre 指针指向 cur，cur 指针往前走。</span></span><br><span class="line"><span class="comment">#当遍历结束后，返回 pre 指针即可。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        pre, cur = <span class="literal">None</span>, head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            t = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = t</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">请实现一个函数，把字符串 s 中的每个空格替换成<span class="string">&quot;%20&quot;</span>。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line">输入：s = <span class="string">&quot;We are happy.&quot;</span></span><br><span class="line">输出：<span class="string">&quot;We%20are%20happy.&quot;</span></span><br><span class="line"> </span><br><span class="line">限制：</span><br><span class="line"><span class="number">0</span> &lt;= s 的长度 &lt;= <span class="number">10000</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">replaceSpace</span>(<span class="params">self, s</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> s.replace(<span class="string">&quot; &quot;</span>,<span class="string">&quot;%20&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python replace()方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 描述</span></span><br><span class="line"><span class="comment"># Python replace() 方法把字符串中的 old（旧字符串） 替换成 new(新字符串)，如果指定第三个参数max，则替换不超过 max 次。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># replace()方法语法：</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span>.replace(old, new[, <span class="built_in">max</span>])</span><br><span class="line"><span class="comment"># 参数</span></span><br><span class="line"><span class="comment"># old -- 将被替换的子字符串。</span></span><br><span class="line"><span class="comment"># new -- 新字符串，用于替换old子字符串。</span></span><br><span class="line"><span class="comment"># max -- 可选字符串, 替换不超过 max 次</span></span><br><span class="line"><span class="comment"># 返回值</span></span><br><span class="line"><span class="comment"># 返回字符串中的 old（旧字符串） 替换成 new(新字符串)后生成的新字符串，如果指定第三个参数max，则替换不超过 max 次。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例</span></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;this is string example....wow!!! this is really string&quot;</span>;</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span>.replace(<span class="string">&quot;is&quot;</span>, <span class="string">&quot;was&quot;</span>);</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span>.replace(<span class="string">&quot;is&quot;</span>, <span class="string">&quot;was&quot;</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment"># 以上实例输出结果如下：</span></span><br><span class="line">thwas was string example....wow!!! thwas was really string</span><br><span class="line">thwas was string example....wow!!! thwas <span class="keyword">is</span> really string</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-58-II-左旋转字符串"><a href="#剑指-Offer-58-II-左旋转字符串" class="headerlink" title="剑指 Offer 58 - II. 左旋转字符串"></a><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">剑指 Offer 58 - II. 左旋转字符串</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串<span class="string">&quot;abcdefg&quot;</span>和数字<span class="number">2</span>，该函数将返回左旋转两位得到的结果<span class="string">&quot;cdefgab&quot;</span>。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line">输入: s = <span class="string">&quot;abcdefg&quot;</span>, k = <span class="number">2</span></span><br><span class="line">输出: <span class="string">&quot;cdefgab&quot;</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line">输入: s = <span class="string">&quot;lrloseumgh&quot;</span>, k = <span class="number">6</span></span><br><span class="line">输出: <span class="string">&quot;umghlrlose&quot;</span></span><br><span class="line"> </span><br><span class="line">限制：</span><br><span class="line"><span class="number">1</span> &lt;= k &lt; s.length &lt;= <span class="number">10000</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseLeftWords</span>(<span class="params">self, s, n</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> s[n:]+s[<span class="number">0</span>:n]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Python字符串运算符</span></span><br><span class="line"></span><br><span class="line">下表实例变量 a 值为字符串 <span class="string">&quot;Hello&quot;</span>，b 变量值为 <span class="string">&quot;Python&quot;</span>：</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">操作符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">+</td><td align="left">字符串连接</td><td align="left">&gt;&gt;&gt;a + b ‘HelloPython’</td></tr><tr><td align="left">*</td><td align="left">重复输出字符串</td><td align="left">&gt;&gt;&gt;a * 2 ‘HelloHello’</td></tr><tr><td align="left">[]</td><td align="left">通过索引获取字符串中字符</td><td align="left">&gt;&gt;&gt;a[1] ‘e’</td></tr><tr><td align="left">[ : ]</td><td align="left">截取字符串中的一部分</td><td align="left">&gt;&gt;&gt;a[1:4] ‘ell’</td></tr><tr><td align="left">in</td><td align="left">成员运算符 - 如果字符串中包含给定的字符返回 True</td><td align="left">&gt;&gt;&gt;”H” in a True</td></tr><tr><td align="left">not in</td><td align="left">成员运算符 - 如果字符串中不包含给定的字符返回 True</td><td align="left">&gt;&gt;&gt;”M” not in a True</td></tr><tr><td align="left">r&#x2F;R</td><td align="left">原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母”r”（可以大小写）以外，与普通字符串有着几乎完全相同的语法。</td><td align="left">&gt;&gt;&gt;print r’\n’ \n &gt;&gt;&gt; print R’\n’ \n</td></tr><tr><td align="left">%</td><td align="left">格式字符串</td><td align="left"></td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Python 的字符串内建函数</span></span><br><span class="line"></span><br><span class="line">字符串方法是从 Python1<span class="number">.6</span> 到 <span class="number">2.0</span> 慢慢加进来的 —— 它们也被加到了Jython 中。</span><br><span class="line"></span><br><span class="line">这些方法实现了 string 模块的大部分方法，如下表所示列出了目前字符串内建支持的方法，所有的方法都包含了对 Unicode 的支持，有一些甚至是专门用于 Unicode 的。</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">方法</th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left">string.capitalize()</td><td align="left">把字符串的第一个字符大写</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-center.html">string.center(width)</a></td><td align="left">返回一个原字符串居中,并使用空格填充至长度 width 的新字符串</td></tr><tr><td align="left">string.count(str, beg&#x3D;0, end&#x3D;len(string))</td><td align="left">返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-decode.html">string.decode(encoding&#x3D;’UTF-8’, errors&#x3D;’strict’)</a></td><td align="left">以 encoding 指定的编码格式解码 string，如果出错默认报一个 ValueError 的 异 常 ， 除非 errors 指 定 的 是 ‘ignore’ 或 者’replace’</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-encode.html">string.encode(encoding&#x3D;’UTF-8’, errors&#x3D;’strict’)</a></td><td align="left">以 encoding 指定的编码格式编码 string，如果出错默认报一个ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’</td></tr><tr><td align="left"><strong><a href="https://www.runoob.com/python/att-string-endswith.html">string.endswith(obj, beg&#x3D;0, end&#x3D;len(string))</a></strong></td><td align="left">检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False.</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-expandtabs.html">string.expandtabs(tabsize&#x3D;8)</a></td><td align="left">把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8。</td></tr><tr><td align="left"><strong><a href="https://www.runoob.com/python/att-string-find.html">string.find(str, beg&#x3D;0, end&#x3D;len(string))</a></strong></td><td align="left">检测 str 是否包含在 string 中，如果 beg 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回-1</td></tr><tr><td align="left"><strong><a href="https://www.runoob.com/python/att-string-format.html">string.format()</a></strong></td><td align="left">格式化字符串</td></tr><tr><td align="left"><strong><a href="https://www.runoob.com/python/att-string-index.html">string.index(str, beg&#x3D;0, end&#x3D;len(string))</a></strong></td><td align="left">跟find()方法一样，只不过如果str不在 string中会报一个异常.</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-isalnum.html">string.isalnum()</a></td><td align="left">如果 string 至少有一个字符并且所有字符都是字母或数字则返回 True,否则返回 False</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-isalpha.html">string.isalpha()</a></td><td align="left">如果 string 至少有一个字符并且所有字符都是字母则返回 True,否则返回 False</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-isdecimal.html">string.isdecimal()</a></td><td align="left">如果 string 只包含十进制数字则返回 True 否则返回 False.</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-isdigit.html">string.isdigit()</a></td><td align="left">如果 string 只包含数字则返回 True 否则返回 False.</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-islower.html">string.islower()</a></td><td align="left">如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-isnumeric.html">string.isnumeric()</a></td><td align="left">如果 string 中只包含数字字符，则返回 True，否则返回 False</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-isspace.html">string.isspace()</a></td><td align="left">如果 string 中只包含空格，则返回 True，否则返回 False.</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-istitle.html">string.istitle()</a></td><td align="left">如果 string 是标题化的(见 title())则返回 True，否则返回 False</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-isupper.html">string.isupper()</a></td><td align="left">如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False</td></tr><tr><td align="left"><strong><a href="https://www.runoob.com/python/att-string-join.html">string.join(seq)</a></strong></td><td align="left">以 string 作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-ljust.html">string.ljust(width)</a></td><td align="left">返回一个原字符串左对齐,并使用空格填充至长度 width 的新字符串</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-lower.html">string.lower()</a></td><td align="left">转换 string 中所有大写字符为小写.</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-lstrip.html">string.lstrip()</a></td><td align="left">截掉 string 左边的空格</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-maketrans.html">string.maketrans(intab, outtab)</a></td><td align="left">maketrans() 方法用于创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-max.html">max(str)</a></td><td align="left">返回字符串 <em>str</em> 中最大的字母。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-min.html">min(str)</a></td><td align="left">返回字符串 <em>str</em> 中最小的字母。</td></tr><tr><td align="left"><strong><a href="https://www.runoob.com/python/att-string-partition.html">string.partition(str)</a></strong></td><td align="left">有点像 find()和 split()的结合体,从 str 出现的第一个位置起,把 字 符 串 string 分 成 一 个 3 元 素 的 元 组 (string_pre_str,str,string_post_str),如果 string 中不包含str 则 string_pre_str &#x3D;&#x3D; string.</td></tr><tr><td align="left"><strong><a href="https://www.runoob.com/python/att-string-replace.html">string.replace(str1, str2, num&#x3D;string.count(str1))</a></strong></td><td align="left">把 string 中的 str1 替换成 str2,如果 num 指定，则替换不超过 num 次.</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-rfind.html">string.rfind(str, beg&#x3D;0,end&#x3D;len(string) )</a></td><td align="left">类似于 find() 函数，返回字符串最后一次出现的位置，如果没有匹配项则返回 -1。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-rindex.html">string.rindex( str, beg&#x3D;0,end&#x3D;len(string))</a></td><td align="left">类似于 index()，不过是返回最后一个匹配到的子字符串的索引号。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-rjust.html">string.rjust(width)</a></td><td align="left">返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-rpartition.html">string.rpartition(str)</a></td><td align="left">类似于 partition()函数,不过是从右边开始查找</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-rstrip.html">string.rstrip()</a></td><td align="left">删除 string 字符串末尾的空格.</td></tr><tr><td align="left"><strong><a href="https://www.runoob.com/python/att-string-split.html">string.split(str&#x3D;””, num&#x3D;string.count(str))</a></strong></td><td align="left">以 str 为分隔符切片 string，如果 num 有指定值，则仅分隔 <strong>num+1</strong> 个子字符串</td></tr><tr><td align="left">[string.splitlines(<a href="https://www.runoob.com/python/att-string-splitlines.html">keepends])</a></td><td align="left">按照行(‘\r’, ‘\r\n’, ‘\n’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-startswith.html">string.startswith(obj, beg&#x3D;0,end&#x3D;len(string))</a></td><td align="left">检查字符串是否是以 obj 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查.</td></tr><tr><td align="left">[string.strip(obj])</td><td align="left">在 string 上执行 lstrip()和 rstrip()</td></tr><tr><td align="left">string.swapcase()</td><td align="left">翻转 string 中的大小写</td></tr><tr><td align="left">string.title()</td><td align="left">返回”标题化”的 string,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle())</td></tr><tr><td align="left"><strong><a href="https://www.runoob.com/python/att-string-translate.html">string.translate(str, del&#x3D;””)</a></strong></td><td align="left">根据 str 给出的表(包含 256 个字符)转换 string 的字符,要过滤掉的字符放到 del 参数中</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-upper.html">string.upper()</a></td><td align="left">转换 string 中的小写字母为大写</td></tr><tr><td align="left">string.zfill(width)</td><td align="left">返回长度为 width 的字符串，原字符串 string 右对齐，前面填充0</td></tr></tbody></table><h2 id="剑指-Offer-03-数组中重复的数字"><a href="#剑指-Offer-03-数组中重复的数字" class="headerlink" title="剑指 Offer 03. 数组中重复的数字"></a><a href="https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">剑指 Offer 03. 数组中重复的数字</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">找出数组中重复的数字。</span><br><span class="line"></span><br><span class="line">在一个长度为 n 的数组 nums 里的所有数字都在 <span class="number">0</span>～n-<span class="number">1</span> 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line">输入：</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>]</span><br><span class="line">输出：<span class="number">2</span> 或 <span class="number">3</span> </span><br><span class="line"> </span><br><span class="line">限制：</span><br><span class="line"><span class="number">2</span> &lt;= n &lt;= <span class="number">100000</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 排序</span></span><br><span class="line"><span class="comment"># 先排序，将相同的数字聚集到一起。</span></span><br><span class="line"><span class="comment"># 再遍历，当位于 i 与 i + 1 的数字相等时，返回该数字。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findRepeatNumber</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        sorted_nums = <span class="built_in">sorted</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> sorted_nums[i] == sorted_nums[i+<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> sorted_nums[i]   </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 哈希表</span></span><br><span class="line"><span class="comment"># 记录数字在数组中的数量，当数量为 2 时，返回即可。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findRepeatNumber</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        sorted_nums = <span class="built_in">sorted</span>(nums)</span><br><span class="line">        hash_map = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> i, number <span class="keyword">in</span> <span class="built_in">enumerate</span>(sorted_nums):</span><br><span class="line">            <span class="keyword">if</span> number <span class="keyword">in</span> hash_map:</span><br><span class="line">                <span class="keyword">return</span> number</span><br><span class="line">            hash_map[number] = i</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Python <span class="built_in">enumerate</span>() 函数</span><br><span class="line"></span><br><span class="line">描述</span><br><span class="line"><span class="built_in">enumerate</span>() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 <span class="keyword">for</span> 循环当中。</span><br><span class="line"></span><br><span class="line">语法</span><br><span class="line">以下是 <span class="built_in">enumerate</span>() 方法的语法:</span><br><span class="line"></span><br><span class="line"><span class="built_in">enumerate</span>(sequence, [start=<span class="number">0</span>])</span><br><span class="line">参数</span><br><span class="line">sequence -- 一个序列、迭代器或其他支持迭代对象。</span><br><span class="line">start -- 下标起始位置的值。</span><br><span class="line">返回值</span><br><span class="line">返回 <span class="built_in">enumerate</span>(枚举) 对象。</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line">以下展示了使用 <span class="built_in">enumerate</span>() 方法的实例：</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>seasons = [<span class="string">&#x27;Spring&#x27;</span>, <span class="string">&#x27;Summer&#x27;</span>, <span class="string">&#x27;Fall&#x27;</span>, <span class="string">&#x27;Winter&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">enumerate</span>(seasons))</span><br><span class="line">[(<span class="number">0</span>, <span class="string">&#x27;Spring&#x27;</span>), (<span class="number">1</span>, <span class="string">&#x27;Summer&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;Fall&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;Winter&#x27;</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">enumerate</span>(seasons, start=<span class="number">1</span>))       <span class="comment"># 下标从 1 开始</span></span><br><span class="line">[(<span class="number">1</span>, <span class="string">&#x27;Spring&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;Summer&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;Fall&#x27;</span>), (<span class="number">4</span>, <span class="string">&#x27;Winter&#x27;</span>)]</span><br><span class="line"></span><br><span class="line">普通的 <span class="keyword">for</span> 循环</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>i = <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>seq = [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> element <span class="keyword">in</span> seq:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span> i, seq[i]</span><br><span class="line"><span class="meta">... </span>    i += <span class="number">1</span></span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> one</span><br><span class="line"><span class="number">1</span> two</span><br><span class="line"><span class="number">2</span> three</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> 循环使用 <span class="built_in">enumerate</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>seq = [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, element <span class="keyword">in</span> <span class="built_in">enumerate</span>(seq):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span> i, element</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> one</span><br><span class="line"><span class="number">1</span> two</span><br><span class="line"><span class="number">2</span> three</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Python <span class="built_in">sorted</span>() 函数</span><br><span class="line"></span><br><span class="line">描述</span><br><span class="line"><span class="built_in">sorted</span>() 函数对所有可迭代的对象进行排序操作。</span><br><span class="line"></span><br><span class="line">sort 与 <span class="built_in">sorted</span> 区别：</span><br><span class="line">sort 是应用在 <span class="built_in">list</span> 上的方法，<span class="built_in">sorted</span> 可以对所有可迭代的对象进行排序操作。</span><br><span class="line"><span class="built_in">list</span> 的 sort 方法返回的是对已经存在的列表进行操作，无返回值，而内建函数 <span class="built_in">sorted</span> 方法返回的是一个新的 <span class="built_in">list</span>，而不是在原来的基础上进行的操作，原列表不发生变化。</span><br><span class="line"></span><br><span class="line"><span class="built_in">sorted</span> 语法：</span><br><span class="line"><span class="built_in">sorted</span>(iterable, cmp=<span class="literal">None</span>, key=<span class="literal">None</span>, reverse=<span class="literal">False</span>)</span><br><span class="line">参数说明：</span><br><span class="line"></span><br><span class="line">iterable -- 可迭代对象。</span><br><span class="line">cmp -- 比较的函数，这个具有两个参数，参数的值都是从可迭代对象中取出，此函数必须遵守的规则为，大于则返回<span class="number">1</span>，小于则返回-<span class="number">1</span>，等于则返回<span class="number">0</span>。</span><br><span class="line">key -- 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。</span><br><span class="line">reverse -- 排序规则，reverse = <span class="literal">True</span> 降序 ， reverse = <span class="literal">False</span> 升序（默认）。</span><br><span class="line"></span><br><span class="line">返回值</span><br><span class="line">返回重新排序的列表。</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-53-I-在排序数组中查找数字-I"><a href="#剑指-Offer-53-I-在排序数组中查找数字-I" class="headerlink" title="剑指 Offer 53 - I. 在排序数组中查找数字 I"></a><a href="https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">剑指 Offer 53 - I. 在排序数组中查找数字 I</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">统计一个数字在排序数组中出现的次数。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: nums = [<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">10</span>], target = <span class="number">8</span></span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: nums = [<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">10</span>], target = <span class="number">6</span></span><br><span class="line">输出: <span class="number">0</span></span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line"><span class="number">0</span> &lt;= nums.length &lt;= <span class="number">105</span></span><br><span class="line">-<span class="number">109</span> &lt;= nums[i] &lt;= <span class="number">109</span></span><br><span class="line">nums 是一个非递减数组</span><br><span class="line">-<span class="number">109</span> &lt;= target &lt;= <span class="number">109</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-53-II-0～n-1中缺失的数字"><a href="#剑指-Offer-53-II-0～n-1中缺失的数字" class="headerlink" title="剑指 Offer 53 - II. 0～n-1中缺失的数字"></a><a href="https://leetcode.cn/problems/que-shi-de-shu-zi-lcof/">剑指 Offer 53 - II. 0～n-1中缺失的数字</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">一个长度为n-<span class="number">1</span>的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围<span class="number">0</span>～n-<span class="number">1</span>之内。在范围<span class="number">0</span>～n-<span class="number">1</span>内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line">输出: <span class="number">8</span></span><br><span class="line"> </span><br><span class="line">限制：</span><br><span class="line"><span class="number">1</span> &lt;= 数组长度 &lt;= <span class="number">10000</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python</title>
      <link href="/FRank675.github.io/posts/290bdd6d9133/"/>
      <url>/FRank675.github.io/posts/290bdd6d9133/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><p>变量是存储在内存中的值，这就意味着在创建变量时会在内存中开辟一个空间。</p><p>基于变量的数据类型，解释器会分配指定内存，并决定什么数据可以被存储在内存中。</p><p>因此，变量可以指定不同的数据类型，这些变量可以存储整数，小数或字符。</p><h3 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h3><p>Python 中的变量赋值不需要类型声明。</p><p>每个变量在内存中创建，都包括变量的标识，名称和数据这些信息。</p><p>每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。</p><p>等号 <strong>&#x3D;</strong> 用来给变量赋值。</p><p>等号 <strong>&#x3D;</strong> 运算符左边是一个变量名，等号 <strong>&#x3D;</strong> 运算符右边是存储在变量中的值。例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line">counter = <span class="number">100</span> <span class="comment"># 赋值整型变量</span></span><br><span class="line">miles = <span class="number">1000.0</span> <span class="comment"># 浮点型</span></span><br><span class="line">name = <span class="string">&quot;John&quot;</span> <span class="comment"># 字符串</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> counter</span><br><span class="line"><span class="built_in">print</span> miles</span><br><span class="line"><span class="built_in">print</span> name</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100</span><br><span class="line">1000.0</span><br><span class="line">John</span><br></pre></td></tr></table></figure><h3 id="多个变量赋值"><a href="#多个变量赋值" class="headerlink" title="多个变量赋值"></a>多个变量赋值</h3><p>Python允许你同时为多个变量赋值。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = b = c = 1</span><br></pre></td></tr></table></figure><p>以上实例，创建一个整型对象，值为1，三个变量被分配到相同的内存空间上。</p><p>您也可以为多个对象指定多个变量。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a, b, c = 1, 2, &quot;john&quot;</span><br></pre></td></tr></table></figure><p>以上实例，两个整型对象 1 和 2 分别分配给变量 a 和 b，字符串对象 “john” 分配给变量 c。</p><h3 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h3><p>Python 定义了一些标准类型，用于存储各种类型的数据。</p><p>Python有五个标准的数据类型：</p><ul><li>Numbers（数字）</li><li>String（字符串）</li><li>List（列表）</li><li>Tuple（元组）</li><li>Dictionary（字典）</li></ul><h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><p>数字数据类型用于存储数值。</p><p>他们是不可改变的数据类型，这意味着改变数字数据类型会分配一个新的对象。</p><p>当你指定一个值时，Number 对象就会被创建：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var1 = 1</span><br><span class="line">var2 = 10</span><br></pre></td></tr></table></figure><p>您也可以使用del语句删除一些对象的引用。</p><p>del语句的语法是：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">del var1[,var2[,var3[....,varN]]]</span><br></pre></td></tr></table></figure><p>您可以通过使用del语句删除单个或多个对象的引用。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">del var</span><br><span class="line">del var_a, var_b</span><br></pre></td></tr></table></figure><p>Python支持四种不同的数字类型：</p><ul><li>int（有符号整型）</li><li>long（长整型，也可以代表八进制和十六进制）</li><li>float（浮点型）</li><li>complex（复数）</li></ul><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串或串(String)是由数字、字母、下划线组成的一串字符。</p><p>一般记为 :</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s = &quot;a1a2···an&quot;   # n&gt;=0</span><br></pre></td></tr></table></figure><p>它是编程语言中表示文本的数据类型。</p><p>python的字串列表有2种取值顺序:</p><ul><li>从左到右索引默认0开始的，最大范围是字符串长度少1</li><li>从右到左索引默认-1开始的，最大范围是字符串开头</li></ul><p><img src="/Python.assets/python-string-slice.png" alt="img"></p><p>如果你要实现从字符串中获取一段子字符串的话，可以使用 <strong>[头下标:尾下标]</strong> 来截取相应的字符串，其中下标是从 0 开始算起，可以是正数或负数，下标可以为空表示取到头或尾。</p><p><strong>[头下标:尾下标]</strong> 获取的子字符串包含头下标的字符，但不包含尾下标的字符。</p><p>比如:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; s = &#x27;abcdef&#x27;</span><br><span class="line">&gt;&gt;&gt; s[1:5]</span><br><span class="line">&#x27;bcde&#x27;</span><br></pre></td></tr></table></figure><p>当使用以冒号分隔的字符串，python 返回一个新的对象，结果包含了以这对偏移标识的连续的内容，左边的开始是包含了下边界。</p><p>上面的结果包含了 <strong>s[1]</strong> 的值 b，而取到的最大范围不包括<strong>尾下标</strong>，就是 <strong>s[5]</strong> 的值 f。</p><p><img src="https://www.runoob.com/wp-content/uploads/2013/11/o99aU.png" alt="img"></p><p>加号（+）是字符串连接运算符，星号（*）是重复操作。如下实例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span>           <span class="comment"># 输出完整字符串</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span>[<span class="number">0</span>]        <span class="comment"># 输出字符串中的第一个字符</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span>[<span class="number">2</span>:<span class="number">5</span>]      <span class="comment"># 输出字符串中第三个至第六个之间的字符串</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span>[<span class="number">2</span>:]       <span class="comment"># 输出从第三个字符开始的字符串</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span> * <span class="number">2</span>       <span class="comment"># 输出字符串两次</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span> + <span class="string">&quot;TEST&quot;</span>  <span class="comment"># 输出连接的字符串</span></span><br></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello World!</span><br><span class="line">H</span><br><span class="line">llo</span><br><span class="line">llo World!</span><br><span class="line">Hello World!Hello World!</span><br><span class="line">Hello World!TEST</span><br></pre></td></tr></table></figure><p>Python 列表截取可以接收第三个参数，参数作用是截取的步长，以下实例在索引 1 到索引 4 的位置并设置为步长为 2（间隔一个位置）来截取字符串：</p><p><img src="/Python.assets/python_list_slice_2.png" alt="img"></p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>List（列表） 是 Python 中使用最频繁的数据类型。</p><p>列表可以完成大多数集合类的数据结构实现。它支持字符，数字，字符串甚至可以包含列表（即嵌套）。</p><p>列表用 <strong>[ ]</strong> 标识，是 python 最通用的复合数据类型。</p><p>列表中值的切割也可以用到变量 <strong>[头下标:尾下标]</strong> ，就可以截取相应的列表，从左到右索引默认 0 开始，从右到左索引默认 -1 开始，下标可以为空表示取到头或尾。</p><p><img src="/Python.assets/list_slicing1_new1.png" alt="img"></p><p>加号 <strong>+</strong> 是列表连接运算符，星号 ***** 是重复操作。如下实例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">list</span> = [ <span class="string">&#x27;runoob&#x27;</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">&#x27;john&#x27;</span>, <span class="number">70.2</span> ]</span><br><span class="line">tinylist = [<span class="number">123</span>, <span class="string">&#x27;john&#x27;</span>]</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> <span class="built_in">list</span>               <span class="comment"># 输出完整列表</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">list</span>[<span class="number">0</span>]            <span class="comment"># 输出列表的第一个元素</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">list</span>[<span class="number">1</span>:<span class="number">3</span>]          <span class="comment"># 输出第二个至第三个元素 </span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">list</span>[<span class="number">2</span>:]           <span class="comment"># 输出从第三个开始至列表末尾的所有元素</span></span><br><span class="line"><span class="built_in">print</span> tinylist * <span class="number">2</span>       <span class="comment"># 输出列表两次</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">list</span> + tinylist    <span class="comment"># 打印组合的列表</span></span><br></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;runoob&#x27;, 786, 2.23, &#x27;john&#x27;, 70.2]</span><br><span class="line">runoob</span><br><span class="line">[786, 2.23]</span><br><span class="line">[2.23, &#x27;john&#x27;, 70.2]</span><br><span class="line">[123, &#x27;john&#x27;, 123, &#x27;john&#x27;]</span><br><span class="line">[&#x27;runoob&#x27;, 786, 2.23, &#x27;john&#x27;, 70.2, 123, &#x27;john&#x27;]</span><br></pre></td></tr></table></figure><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>元组是另一个数据类型，类似于 List（列表）。</p><p>元组用 <strong>()</strong> 标识。内部元素用逗号隔开。但是元组不能二次赋值，相当于只读列表。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">tuple</span> = ( <span class="string">&#x27;runoob&#x27;</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">&#x27;john&#x27;</span>, <span class="number">70.2</span> )</span><br><span class="line">tinytuple = (<span class="number">123</span>, <span class="string">&#x27;john&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> <span class="built_in">tuple</span>               <span class="comment"># 输出完整元组</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">tuple</span>[<span class="number">0</span>]            <span class="comment"># 输出元组的第一个元素</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">tuple</span>[<span class="number">1</span>:<span class="number">3</span>]          <span class="comment"># 输出第二个至第四个（不包含）的元素 </span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">tuple</span>[<span class="number">2</span>:]           <span class="comment"># 输出从第三个开始至列表末尾的所有元素</span></span><br><span class="line"><span class="built_in">print</span> tinytuple * <span class="number">2</span>       <span class="comment"># 输出元组两次</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">tuple</span> + tinytuple   <span class="comment"># 打印组合的元组</span></span><br></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(&#x27;runoob&#x27;, 786, 2.23, &#x27;john&#x27;, 70.2)</span><br><span class="line">runoob</span><br><span class="line">(786, 2.23)</span><br><span class="line">(2.23, &#x27;john&#x27;, 70.2)</span><br><span class="line">(123, &#x27;john&#x27;, 123, &#x27;john&#x27;)</span><br><span class="line">(&#x27;runoob&#x27;, 786, 2.23, &#x27;john&#x27;, 70.2, 123, &#x27;john&#x27;)</span><br></pre></td></tr></table></figure><p>以下对元组的操作是无效的，因为元组不允许更新，而列表是允许更新的：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">tuple</span> = ( <span class="string">&#x27;runoob&#x27;</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">&#x27;john&#x27;</span>, <span class="number">70.2</span> )</span><br><span class="line"><span class="built_in">list</span> = [ <span class="string">&#x27;runoob&#x27;</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">&#x27;john&#x27;</span>, <span class="number">70.2</span> ]</span><br><span class="line"><span class="built_in">tuple</span>[<span class="number">2</span>] = <span class="number">1000</span>    <span class="comment"># 元组中是非法应用</span></span><br><span class="line"><span class="built_in">list</span>[<span class="number">2</span>] = <span class="number">1000</span>     <span class="comment"># 列表中是合法应用</span></span><br></pre></td></tr></table></figure><p>元组是不允许更新的，所以以上代码执行错误，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;test.py&quot;, line 6, in &lt;module&gt;</span><br><span class="line">    tuple[2] = 1000    # 元组中是非法应用</span><br><span class="line">TypeError: &#x27;tuple&#x27; object does not support item assignment</span><br></pre></td></tr></table></figure><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>字典(dictionary)是除列表以外python之中最灵活的内置数据结构类型。列表是有序的对象集合，字典是无序的对象集合。</p><p>两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。</p><p>字典用”{ }”标识。字典由索引(key)和它对应的值value组成。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">dict</span> = &#123;&#125;</span><br><span class="line"><span class="built_in">dict</span>[<span class="string">&#x27;one&#x27;</span>] = <span class="string">&quot;This is one&quot;</span></span><br><span class="line"><span class="built_in">dict</span>[<span class="number">2</span>] = <span class="string">&quot;This is two&quot;</span></span><br><span class="line"> </span><br><span class="line">tinydict = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;runoob&#x27;</span>,<span class="string">&#x27;code&#x27;</span>:<span class="number">6734</span>, <span class="string">&#x27;dept&#x27;</span>: <span class="string">&#x27;sales&#x27;</span>&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> <span class="built_in">dict</span>[<span class="string">&#x27;one&#x27;</span>]          <span class="comment"># 输出键为&#x27;one&#x27; 的值</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">dict</span>[<span class="number">2</span>]              <span class="comment"># 输出键为 2 的值</span></span><br><span class="line"><span class="built_in">print</span> tinydict             <span class="comment"># 输出完整的字典</span></span><br><span class="line"><span class="built_in">print</span> tinydict.keys()      <span class="comment"># 输出所有键</span></span><br><span class="line"><span class="built_in">print</span> tinydict.values()    <span class="comment"># 输出所有值</span></span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This is one</span><br><span class="line">This is two</span><br><span class="line">&#123;&#x27;dept&#x27;: &#x27;sales&#x27;, &#x27;code&#x27;: 6734, &#x27;name&#x27;: &#x27;runoob&#x27;&#125;</span><br><span class="line">[&#x27;dept&#x27;, &#x27;code&#x27;, &#x27;name&#x27;]</span><br><span class="line">[&#x27;sales&#x27;, 6734, &#x27;runoob&#x27;]</span><br></pre></td></tr></table></figure><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><p>有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。</p><p>以下几个内置的函数可以执行数据类型之间的转换。这些函数返回一个新的对象，表示转换的值。</p><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">[int(x [,base])</td><td align="left">将x转换为一个整数</td></tr><tr><td align="left">[long(x [,base] )</td><td align="left">将x转换为一个长整数</td></tr><tr><td align="left">[float(x)]</td><td align="left">将x转换到一个浮点数</td></tr><tr><td align="left">[complex(real [,imag])]</td><td align="left">创建一个复数</td></tr><tr><td align="left">[str(x)]</td><td align="left">将对象 x 转换为字符串</td></tr><tr><td align="left">[repr(x)]</td><td align="left">将对象 x 转换为表达式字符串</td></tr><tr><td align="left">[eval(str)]</td><td align="left">用来计算在字符串中的有效Python表达式,并返回一个对象</td></tr><tr><td align="left">[tuple(s)]</td><td align="left">将序列 s 转换为一个元组</td></tr><tr><td align="left">[list(s)]</td><td align="left">将序列 s 转换为一个列表</td></tr><tr><td align="left">[set(s)]</td><td align="left">转换为可变集合</td></tr><tr><td align="left">[dict(d)]</td><td align="left">创建一个字典。d 必须是一个序列 (key,value)元组。</td></tr><tr><td align="left">[frozenset(s)]</td><td align="left">转换为不可变集合</td></tr><tr><td align="left">[chr(x)]</td><td align="left">将一个整数转换为一个字符</td></tr><tr><td align="left">[unichr(x)]</td><td align="left">将一个整数转换为Unicode字符</td></tr><tr><td align="left">[ord(x)]</td><td align="left">将一个字符转换为它的整数值</td></tr><tr><td align="left">[hex(x)]</td><td align="left">将一个整数转换为一个十六进制字符串</td></tr><tr><td align="left">[oct(x)]</td><td align="left">将一个整数转换为一个八进制字符串</td></tr></tbody></table><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">&#x3D;</td><td align="left">简单的赋值运算符</td><td align="left">c &#x3D; a + b 将 a + b 的运算结果赋值为 c</td></tr><tr><td align="left">+&#x3D;</td><td align="left">加法赋值运算符</td><td align="left">c +&#x3D; a 等效于 c &#x3D; c + a</td></tr><tr><td align="left">-&#x3D;</td><td align="left">减法赋值运算符</td><td align="left">c -&#x3D; a 等效于 c &#x3D; c - a</td></tr><tr><td align="left">*&#x3D;</td><td align="left">乘法赋值运算符</td><td align="left">c *&#x3D; a 等效于 c &#x3D; c * a</td></tr><tr><td align="left">&#x2F;&#x3D;</td><td align="left">除法赋值运算符</td><td align="left">c &#x2F;&#x3D; a 等效于 c &#x3D; c &#x2F; a</td></tr><tr><td align="left">%&#x3D;</td><td align="left">取模赋值运算符</td><td align="left">c %&#x3D; a 等效于 c &#x3D; c % a</td></tr><tr><td align="left">**&#x3D;</td><td align="left">幂赋值运算符</td><td align="left">c **&#x3D; a 等效于 c &#x3D; c ** a</td></tr><tr><td align="left">&#x2F;&#x2F;&#x3D;</td><td align="left">取整除赋值运算符</td><td align="left">c &#x2F;&#x2F;&#x3D; a 等效于 c &#x3D; c &#x2F;&#x2F; a</td></tr></tbody></table><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20:</p><table><thead><tr><th align="left">运算符</th><th align="left">逻辑表达式</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">and</td><td align="left">x and y</td><td align="left">布尔”与” - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。</td><td align="left">(a and b) 返回 20。</td></tr><tr><td align="left">or</td><td align="left">x or y</td><td align="left">布尔”或” - 如果 x 是非 0，它返回 x 的计算值，否则它返回 y 的计算值。</td><td align="left">(a or b) 返回 10。</td></tr><tr><td align="left">not</td><td align="left">not x</td><td align="left">布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。</td><td align="left">not(a and b) 返回 False</td></tr></tbody></table><h3 id="成员运算符"><a href="#成员运算符" class="headerlink" title="成员运算符"></a>成员运算符</h3><p>除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">in</td><td align="left">如果在指定的序列中找到值返回 True，否则返回 False。</td><td align="left">x 在 y 序列中 , 如果 x 在 y 序列中返回 True。</td></tr><tr><td align="left">not in</td><td align="left">如果在指定的序列中没有找到值返回 True，否则返回 False。</td><td align="left">x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。</td></tr></tbody></table><p>以下实例演示了Python所有成员运算符的操作：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">20</span></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ( a <span class="keyword">in</span> <span class="built_in">list</span> ):</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;1 - 变量 a 在给定的列表中 list 中&quot;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;1 - 变量 a 不在给定的列表中 list 中&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ( b <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">list</span> ):</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;2 - 变量 b 不在给定的列表中 list 中&quot;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;2 - 变量 b 在给定的列表中 list 中&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 修改变量 a 的值</span></span><br><span class="line">a = <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> ( a <span class="keyword">in</span> <span class="built_in">list</span> ):</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;3 - 变量 a 在给定的列表中 list 中&quot;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;3 - 变量 a 不在给定的列表中 list 中&quot;</span></span><br></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 - 变量 a 不在给定的列表中 list 中</span><br><span class="line">2 - 变量 b 不在给定的列表中 list 中</span><br><span class="line">3 - 变量 a 在给定的列表中 list 中</span><br></pre></td></tr></table></figure><h3 id="身份运算符"><a href="#身份运算符" class="headerlink" title="身份运算符"></a>身份运算符</h3><p>身份运算符用于比较两个对象的存储单元</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">is</td><td align="left">is 是判断两个标识符是不是引用自一个对象</td><td align="left"><strong>x is y</strong>, 类似 <strong>id(x) &#x3D;&#x3D; id(y)</strong> , 如果引用的是同一个对象则返回 True，否则返回 False</td></tr><tr><td align="left">is not</td><td align="left">is not 是判断两个标识符是不是引用自不同对象</td><td align="left"><strong>x is not y</strong> ， 类似 **id(a) !&#x3D; id(b)**。如果引用的不是同一个对象则返回结果 True，否则返回 False。</td></tr></tbody></table><p><strong>注：</strong> id()函数用于获取对象内存地址。</p><p>以下实例演示了Python所有身份运算符的操作：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line">a = <span class="number">20</span></span><br><span class="line">b = <span class="number">20</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ( a <span class="keyword">is</span> b ):</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;1 - a 和 b 有相同的标识&quot;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;1 - a 和 b 没有相同的标识&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ( a <span class="keyword">is</span> <span class="keyword">not</span> b ):</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;2 - a 和 b 没有相同的标识&quot;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;2 - a 和 b 有相同的标识&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 修改变量 b 的值</span></span><br><span class="line">b = <span class="number">30</span></span><br><span class="line"><span class="keyword">if</span> ( a <span class="keyword">is</span> b ):</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;3 - a 和 b 有相同的标识&quot;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;3 - a 和 b 没有相同的标识&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ( a <span class="keyword">is</span> <span class="keyword">not</span> b ):</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;4 - a 和 b 没有相同的标识&quot;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;4 - a 和 b 有相同的标识&quot;</span></span><br></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 - a 和 b 有相同的标识</span><br><span class="line">2 - a 和 b 有相同的标识</span><br><span class="line">3 - a 和 b 没有相同的标识</span><br><span class="line">4 - a 和 b 没有相同的标识</span><br></pre></td></tr></table></figure><blockquote><p>is 与 &#x3D;&#x3D; 区别：</p><p>is 用于判断两个变量引用对象是否为同一个(同一块内存空间)， &#x3D;&#x3D; 用于判断引用变量的值是否相等。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b <span class="keyword">is</span> a </span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b == a</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a[:]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b <span class="keyword">is</span> a</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b == a</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure></blockquote><hr><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><p>以下表格列出了从最高到最低优先级的所有运算符：</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">**</td><td align="left">指数 (最高优先级)</td></tr><tr><td align="left">~ + -</td><td align="left">按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)</td></tr><tr><td align="left">* &#x2F; % &#x2F;&#x2F;</td><td align="left">乘，除，取模和取整除</td></tr><tr><td align="left">+ -</td><td align="left">加法减法</td></tr><tr><td align="left">&gt;&gt; &lt;&lt;</td><td align="left">右移，左移运算符</td></tr><tr><td align="left">&amp;</td><td align="left">位 ‘AND’</td></tr><tr><td align="left">^ |</td><td align="left">位运算符</td></tr><tr><td align="left">&lt;&#x3D; &lt; &gt; &gt;&#x3D;</td><td align="left">比较运算符</td></tr><tr><td align="left">&lt;&gt; &#x3D;&#x3D; !&#x3D;</td><td align="left">等于运算符</td></tr><tr><td align="left">&#x3D; %&#x3D; &#x2F;&#x3D; &#x2F;&#x2F;&#x3D; -&#x3D; +&#x3D; *&#x3D; **&#x3D;</td><td align="left">赋值运算符</td></tr><tr><td align="left">is is not</td><td align="left">身份运算符</td></tr><tr><td align="left">in not in</td><td align="left">成员运算符</td></tr><tr><td align="left">not and or</td><td align="left">逻辑运算符</td></tr></tbody></table><p>以下实例演示了Python所有运算符优先级的操作：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line">a = <span class="number">20</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line">c = <span class="number">15</span></span><br><span class="line">d = <span class="number">5</span></span><br><span class="line">e = <span class="number">0</span></span><br><span class="line"> </span><br><span class="line">e = (a + b) * c / d       <span class="comment">#( 30 * 15 ) / 5</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;(a + b) * c / d 运算结果为：&quot;</span>,  e</span><br><span class="line"> </span><br><span class="line">e = ((a + b) * c) / d     <span class="comment"># (30 * 15 ) / 5</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;((a + b) * c) / d 运算结果为：&quot;</span>,  e</span><br><span class="line"> </span><br><span class="line">e = (a + b) * (c / d);    <span class="comment"># (30) * (15/5)</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;(a + b) * (c / d) 运算结果为：&quot;</span>,  e</span><br><span class="line"> </span><br><span class="line">e = a + (b * c) / d;      <span class="comment">#  20 + (150/5)</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;a + (b * c) / d 运算结果为：&quot;</span>,  e</span><br></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(a + b) * c / d 运算结果为： 90</span><br><span class="line">((a + b) * c) / d 运算结果为： 90</span><br><span class="line">(a + b) * (c / d) 运算结果为： 90</span><br><span class="line">a + (b * c) / d 运算结果为： 50</span><br></pre></td></tr></table></figure><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p>Python条件语句是通过一条或多条语句的执行结果（True或者False）来决定执行的代码块。</p><p>Python程序语言指定任何非0和非空（null）值为true，0 或者 null为false。</p><p>Python 编程中 if 语句用于控制程序的执行，基本形式为：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 判断条件：</span><br><span class="line">    执行语句……</span><br><span class="line"><span class="keyword">else</span>：</span><br><span class="line">    执行语句……</span><br></pre></td></tr></table></figure><p>其中”判断条件”成立时（非零），则执行后面的语句，而执行内容可以多行，以缩进来区分表示同一范围。</p><p>else 为可选语句，当需要在条件不成立时执行内容则可以执行相关语句。</p><p>if 语句的判断条件可以用&gt;（大于）、&lt;(小于)、&#x3D;&#x3D;（等于）、&gt;&#x3D;（大于等于）、&lt;&#x3D;（小于等于）来表示其关系。</p><p>当判断条件为多个值时，可以使用以下形式：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 判断条件<span class="number">1</span>:</span><br><span class="line">    执行语句<span class="number">1</span>……</span><br><span class="line"><span class="keyword">elif</span> 判断条件<span class="number">2</span>:</span><br><span class="line">    执行语句<span class="number">2</span>……</span><br><span class="line"><span class="keyword">elif</span> 判断条件<span class="number">3</span>:</span><br><span class="line">    执行语句<span class="number">3</span>……</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    执行语句<span class="number">4</span>……</span><br></pre></td></tr></table></figure><p>由于 python 并不支持 switch 语句，所以多个条件判断，只能用 elif 来实现，如果判断需要多个条件需同时判断时，可以使用 or （或），表示两个条件有一个成立时判断条件成功；使用 and （与）时，表示只有两个条件同时成立的情况下，判断条件才成功。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 例3：if语句多个条件</span></span><br><span class="line"> </span><br><span class="line">num = <span class="number">9</span></span><br><span class="line"><span class="keyword">if</span> num &gt;= <span class="number">0</span> <span class="keyword">and</span> num &lt;= <span class="number">10</span>:    <span class="comment"># 判断值是否在0~10之间</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="comment"># 输出结果: hello</span></span><br><span class="line"> </span><br><span class="line">num = <span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> num &lt; <span class="number">0</span> <span class="keyword">or</span> num &gt; <span class="number">10</span>:    <span class="comment"># 判断值是否在小于0或大于10</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;undefine&#x27;</span></span><br><span class="line"><span class="comment"># 输出结果: undefine</span></span><br><span class="line"> </span><br><span class="line">num = <span class="number">8</span></span><br><span class="line"><span class="comment"># 判断值是否在0~5或者10~15之间</span></span><br><span class="line"><span class="keyword">if</span> (num &gt;= <span class="number">0</span> <span class="keyword">and</span> num &lt;= <span class="number">5</span>) <span class="keyword">or</span> (num &gt;= <span class="number">10</span> <span class="keyword">and</span> num &lt;= <span class="number">15</span>):    </span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;undefine&#x27;</span></span><br><span class="line"><span class="comment"># 输出结果: undefine</span></span><br></pre></td></tr></table></figure><p>当if有多个条件时可使用括号来区分判断的先后顺序，括号中的判断优先执行，此外 and 和 or 的优先级低于&gt;（大于）、&lt;（小于）等判断符号，即大于和小于在没有括号的情况下会比与或要优先判断。</p><hr><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>Python 提供了 for 循环和 while 循环（在 Python 中没有 do..while 循环）:</p><table><thead><tr><th align="left">循环类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">while 循环</td><td align="left">在给定的判断条件为 true 时执行循环体，否则退出循环体。</td></tr><tr><td align="left">for 循环</td><td align="left">重复执行语句</td></tr><tr><td align="left">嵌套循环</td><td align="left">你可以在while循环体中嵌套for循环</td></tr></tbody></table><h3 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h3><p>循环控制语句可以更改语句执行的顺序。Python支持以下循环控制语句：</p><table><thead><tr><th align="left">控制语句</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">break 语句</td><td align="left">在语句块执行过程中终止循环，并且跳出整个循环</td></tr><tr><td align="left">continue 语句</td><td align="left">在语句块执行过程中终止当前循环，跳出该次循环，执行下一次循环。</td></tr><tr><td align="left">pass 语句</td><td align="left">pass是空语句，是为了保持程序结构的完整性。</td></tr></tbody></table><hr><h2 id="While循环语句"><a href="#While循环语句" class="headerlink" title="While循环语句"></a>While循环语句</h2><p>Python 编程中 while 语句用于循环执行程序，即在某条件下，循环执行某段程序，以处理需要重复处理的相同任务。其基本形式为：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 判断条件(condition)：</span><br><span class="line">    执行语句(statements)……</span><br></pre></td></tr></table></figure><p>执行语句可以是单个语句或语句块。判断条件可以是任何表达式，任何非零、或非空（null）的值均为true。</p><p>当判断条件假 false 时，循环结束。</p><p>while 语句时还有另外两个重要的命令 continue，break 来跳过循环，continue 用于跳过该次循环，break 则是用于退出循环，此外”判断条件”还可以是个常值，表示循环必定成立，具体用法如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># continue 和 break 用法</span></span><br><span class="line"> </span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">10</span>:   </span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> i%<span class="number">2</span> &gt; <span class="number">0</span>:     <span class="comment"># 非双数时跳过输出</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="built_in">print</span> i         <span class="comment"># 输出双数2、4、6、8、10</span></span><br><span class="line"> </span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:            <span class="comment"># 循环条件为1必定成立</span></span><br><span class="line">    <span class="built_in">print</span> i         <span class="comment"># 输出1~10</span></span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">10</span>:     <span class="comment"># 当i大于10时跳出循环</span></span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h2 id="循环使用-else-语句"><a href="#循环使用-else-语句" class="headerlink" title="循环使用 else 语句"></a>循环使用 else 语句</h2><p>在 python 中，while … else 在循环条件为 false 时执行 else 语句块：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"> </span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> count &lt; <span class="number">5</span>:</span><br><span class="line">   <span class="built_in">print</span> count, <span class="string">&quot; is  less than 5&quot;</span></span><br><span class="line">   count = count + <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> count, <span class="string">&quot; is not less than 5&quot;</span></span><br></pre></td></tr></table></figure><p>以上实例输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 is less than 5</span><br><span class="line">1 is less than 5</span><br><span class="line">2 is less than 5</span><br><span class="line">3 is less than 5</span><br><span class="line">4 is less than 5</span><br><span class="line">5 is not less than 5</span><br></pre></td></tr></table></figure><hr><h2 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h2><p>如果条件判断语句永远为 true，循环将会无限的执行下去</p><hr><h2 id="for循环语句"><a href="#for循环语句" class="headerlink" title="for循环语句"></a>for循环语句</h2><hr><h2 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a>循环嵌套</h2><hr><h2 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h2><hr><h2 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h2><hr><h2 id="pass语句"><a href="#pass语句" class="headerlink" title="pass语句"></a>pass语句</h2><hr><h2 id="Number（数字）"><a href="#Number（数字）" class="headerlink" title="Number（数字）"></a>Number（数字）</h2><hr><h2 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串"></a>字符串</h2><hr><h2 id="列表（List）"><a href="#列表（List）" class="headerlink" title="列表（List）"></a>列表（List）</h2><hr><h2 id="元组-1"><a href="#元组-1" class="headerlink" title="元组"></a>元组</h2><h2 id="字典（Dictionary）"><a href="#字典（Dictionary）" class="headerlink" title="字典（Dictionary）"></a>字典（Dictionary）</h2><h2 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h2><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><h2 id="文件I-x2F-O"><a href="#文件I-x2F-O" class="headerlink" title="文件I&#x2F;O"></a>文件I&#x2F;O</h2><h2 id="File方法"><a href="#File方法" class="headerlink" title="File方法"></a>File方法</h2><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h2 id="OS文件-x2F-目录方法"><a href="#OS文件-x2F-目录方法" class="headerlink" title="OS文件&#x2F;目录方法"></a>OS文件&#x2F;目录方法</h2><h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Git的那些事</title>
      <link href="/FRank675.github.io/posts/6a845e5ee4d5/"/>
      <url>/FRank675.github.io/posts/6a845e5ee4d5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\FRank675.github.io\css\APlayer.min.css"><script src="\FRank675.github.io\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\FRank675.github.io\js\Meting.min.js"></script><h2 id="Git取得项目的仓库"><a href="#Git取得项目的仓库" class="headerlink" title="Git取得项目的仓库"></a>Git取得项目的仓库</h2><h3 id="在工作目录中初始化新仓库"><a href="#在工作目录中初始化新仓库" class="headerlink" title="在工作目录中初始化新仓库"></a>在工作目录中初始化新仓库</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*在项目所在目录进行初始化，初始化后会得到一个名为.git的目录，存放所有Git需要的数据和资源*/</span></span><br><span class="line"></span><br><span class="line">$ git init</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交：*/</span></span><br><span class="line"></span><br><span class="line">$ git add *.c</span><br><span class="line"></span><br><span class="line">$ git add README</span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">&#x27;initial project version&#x27;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*这样我们就得到了一个实际维护着若干文件的Git仓库*/</span>    </span><br></pre></td></tr></table></figure><h3 id="从现有仓库克隆"><a href="#从现有仓库克隆" class="headerlink" title="从现有仓库克隆"></a>从现有仓库克隆</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*如果想对某个开源项目出一份力，可以先把该项目的 Git 仓库复制一份出来，这就需要用到git clone 命令。*/</span></span><br><span class="line"><span class="comment">/*克隆仓库的命令格式为 git clone [url]。*/</span></span><br><span class="line"><span class="comment">/*比如，要克隆 Ruby 语言的 Git 代码仓库 Grit，可以用下面的命令：*/</span></span><br><span class="line"></span><br><span class="line">$ git clone git:<span class="comment">//github.com/schacon/grit.git</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*这会在当前目录下创建一个名为grit的目录，其中包含一个 .git 的目录，用于保存下载下来的所有版本记录，然后从中取出最新版本的文件拷贝。*/</span></span><br><span class="line"><span class="comment">/*如果进入这个新建的 grit 目录，你会看到项目中的所有文件已经在里边了，准备好后续的开发和使用。*/</span></span><br><span class="line"><span class="comment">/*如果希望在克隆的时候，自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：*/</span></span><br><span class="line"></span><br><span class="line">$ git clone git:<span class="comment">//github.com/schacon/grit.git mygrit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*唯一的差别就是，现在新建的目录成了mygrit，其他的都和上边的一样。*/</span></span><br></pre></td></tr></table></figure><h2 id="Git记录每次更新到仓库"><a href="#Git记录每次更新到仓库" class="headerlink" title="Git记录每次更新到仓库"></a>Git记录每次更新到仓库</h2><p>有了一个真实项目的 Git 仓库，并从这个仓库中取出了所有文件的工作拷贝。接下来，对这些文件作些修改，在完成了一个阶段的目标之后，提交本次更新到仓库。</p><p>工作目录下面的所有文件有这两种状态：已跟踪或未跟踪。</p><p>已跟踪的文件是指本来就被纳入版本控制管理的文件，在上次快照中有它们的记录，工作一段时间后，它们的状态可能是未更新，已修改或者已放入暂存区。</p><p>而所有其他文件都属于未跟踪文件。它们既没有上次更新时的快照，也不在当前的暂存区域。初次克隆某个仓库时，工作目录中的所有文件都属于已跟踪文件，且状态为未修改。</p><p>在编辑过某些文件之后，Git 将这些文件标为已修改。我们逐步把这些修改过的文件放到暂存区域，直到最后一次性提交所有这些暂存起来的文件，如此重复。</p><h2 id="Git查看提交历史"><a href="#Git查看提交历史" class="headerlink" title="Git查看提交历史"></a>Git查看提交历史</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*在提交了若干更新之后，又或者克隆了某个项目，想回顾下提交历史，可以使用 `git log` 命令查看。*/</span></span><br><span class="line"></span><br><span class="line">$ git log</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*默认不用任何参数的话，git log 会按提交时间列出所有的更新，最近的更新排在最上面。*/</span></span><br><span class="line"><span class="comment">/*每次更新都有一个 SHA-1 校验和、作者的名字和电子邮件地址、提交时间，最后缩进一个段落显示提交说明。*/</span></span><br><span class="line"><span class="comment">/*常用 -p 选项展开显示每次提交的内容差异，用 -2 则仅显示最近的两次更新：*/</span></span><br><span class="line">    </span><br><span class="line">$ git log -p -<span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下表还列出了一些其他常用的选项及其释义。</p><table><thead><tr><th align="left">选项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-p</td><td align="left">按补丁格式显示每个更新之间的差异。</td></tr><tr><td align="left">–word-diff</td><td align="left">按 word diff 格式显示差异。</td></tr><tr><td align="left">–stat</td><td align="left">显示每次更新的文件修改统计信息。</td></tr><tr><td align="left">–shortstat</td><td align="left">只显示 –stat 中最后的行数修改添加移除统计。</td></tr><tr><td align="left">–name-only</td><td align="left">仅在提交信息后显示已修改的文件清单。</td></tr><tr><td align="left">–name-status</td><td align="left">显示新增、修改、删除的文件清单。</td></tr><tr><td align="left">–abbrev-commit</td><td align="left">仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。</td></tr><tr><td align="left">–relative-date</td><td align="left">使用较短的相对时间显示（比如，“2 weeks ago”）。</td></tr><tr><td align="left">–graph</td><td align="left">显示 ASCII 图形表示的分支合并历史。</td></tr><tr><td align="left">–pretty</td><td align="left">使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。</td></tr><tr><td align="left">–oneline</td><td align="left">–pretty&#x3D;oneline –abbrev-commit 的简化用法。</td></tr></tbody></table><p>限制输出长度</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*下面的命令列出所有最近两周内的提交：*/</span></span><br><span class="line"></span><br><span class="line">$ git log --since=<span class="number">2.</span>weeks</span><br><span class="line"></span><br><span class="line"><span class="comment">/*可以给出各种时间格式，比如说具体的某一天（“2008-01-15”），或者是多久以前（“2 years 1 day 3 minutes ago”）。*/</span></span><br><span class="line"><span class="comment">/*另一个真正实用的git log选项是路径(path)，如果只关心某些文件或者目录的历史提交，可以在 git log 选项的最后指定它们的路径。因为是放在最后位置上的选项，所以用两个短划线（--）隔开之前的选项和后面限定的路径名。*/</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">选项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-(n)</td><td align="left">仅显示最近的 n 条提交</td></tr><tr><td align="left">–since, –after</td><td align="left">仅显示指定时间之后的提交。</td></tr><tr><td align="left">–until, –before</td><td align="left">仅显示指定时间之前的提交。</td></tr><tr><td align="left">–author</td><td align="left">仅显示指定作者相关的提交。</td></tr><tr><td align="left">–committer</td><td align="left">仅显示指定提交者相关的提交。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*如果要查看 Git 仓库中，2008 年 10 月期间，Junio Hamano 提交的但未合并的测试脚本（位于项目的 t/ 目录下的文件），可以用下面的查询命令：*/</span></span><br><span class="line"></span><br><span class="line">$ git log --pretty=<span class="string">&quot;%h - %s&quot;</span> --author=gitster --since=<span class="string">&quot;2008-10-01&quot;</span> \ --before=<span class="string">&quot;2008-11-01&quot;</span> --no-merges -- t/</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Git撤销操作"><a href="#Git撤销操作" class="headerlink" title="Git撤销操作"></a>Git撤销操作</h2><h3 id="修改最后一次提交"><a href="#修改最后一次提交" class="headerlink" title="修改最后一次提交"></a>修改最后一次提交</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*提交完了才发现漏掉了几个文件没有加，或者提交信息写错了。想要撤消刚才的提交操作，可以使用 --amend 选项重新提交*/</span></span><br><span class="line"></span><br><span class="line">$ git commit --amend</span><br><span class="line"></span><br><span class="line"><span class="comment">/*此命令将使用当前的暂存区域快照提交。*/</span></span><br><span class="line"><span class="comment">/*如果刚才提交完没有作任何改动，直接运行此命令的话，相当于有机会重新编辑提交说明，但将要提交的文件快照和之前的一样。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*启动文本编辑器后，会看到上次提交时的说明，编辑它确认没问题后保存退出，就会使用新的提交说明覆盖刚才失误的提交。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果刚才提交时忘了暂存某些修改，可以先补上暂存操作，然后再运行 --amend 提交：*/</span></span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">&#x27;initial commit&#x27;</span></span><br><span class="line">    </span><br><span class="line">$ git add forgotten_file</span><br><span class="line">    </span><br><span class="line">$ git commit --amend</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*上面的三条命令最终只是产生一个提交，第二个提交命令修正了第一个的提交内容。*/</span></span><br></pre></td></tr></table></figure><h3 id="取消已经暂存的文件"><a href="#取消已经暂存的文件" class="headerlink" title="取消已经暂存的文件"></a>取消已经暂存的文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*有两个修改过的文件，想要分开提交，但不小心用 git add . 全加到了暂存区域。该如何撤消暂存其中的一个文件呢？*/</span></span><br><span class="line"></span><br><span class="line">$ git reset HEAD benchmarks.rb</span><br><span class="line"></span><br><span class="line"><span class="comment">/*现在 benchmarks.rb 文件又回到了之前已修改未暂存的状态。*/</span></span><br></pre></td></tr></table></figure><h3 id="取消对文件的修改"><a href="#取消对文件的修改" class="headerlink" title="取消对文件的修改"></a>取消对文件的修改</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*该如何取消修改，回到之前的状态（也就是修改之前的版本）*/</span></span><br><span class="line"></span><br><span class="line">$ git checkout -- benchmarks.rb</span><br><span class="line"></span><br><span class="line"><span class="comment">/*在用这条命令前，请务必确定真的不再需要保留刚才的修改。*/</span></span><br></pre></td></tr></table></figure><h2 id="Git远程仓库的使用"><a href="#Git远程仓库的使用" class="headerlink" title="Git远程仓库的使用"></a>Git远程仓库的使用</h2><p>远程仓库是指托管在网络上的项目仓库，可能会有好多个，其中有些你只能读，另外有些可以写。</p><p>同他人协作开发某个项目时，需要管理这些远程仓库，以便推送或拉取数据，分享各自的工作进展。 </p><p>管理远程仓库的工作，包括添加远程库，移除废弃的远程库，管理各式远程库分支，定义是否跟踪这些分支，等等。 </p><h3 id="查看当前的远程库"><a href="#查看当前的远程库" class="headerlink" title="查看当前的远程库"></a>查看当前的远程库</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*要查看当前配置有哪些远程仓库，可以用 git remote 命令，它会列出每个远程库的简短名字。*/</span></span><br><span class="line"><span class="comment">/*在克隆完某个项目后，至少可以看到一个名为origin 的远程库，Git 默认使用这个名字来标识你所克隆的原始仓库：*/</span></span><br><span class="line"></span><br><span class="line">$ git clone git:<span class="comment">//github.com/schacon/ticgit.git</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*Cloning into &#x27;ticgit&#x27;...</span></span><br><span class="line"><span class="comment">remote: Reusing existing pack: 1857, done.</span></span><br><span class="line"><span class="comment">remote: Total 1857 (delta 0), reused 0 (delta 0)</span></span><br><span class="line"><span class="comment">Receiving objects: 100% (1857/1857), 374.35 KiB | 193.00 KiB/s, done.</span></span><br><span class="line"><span class="comment">Resolving deltas: 100% (772/772), done.</span></span><br><span class="line"><span class="comment">Checking connectivity... done.*/</span></span><br><span class="line"></span><br><span class="line">$ cd ticgit</span><br><span class="line">    </span><br><span class="line">$ git remote</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*origin*/</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*也可以加上 -v 选项（译注：此为 --verbose 的简写，取首字母），显示对应的克隆地址：*/</span></span><br><span class="line"></span><br><span class="line">$ git remote -v</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*origin  git://github.com/schacon/ticgit.git (fetch)</span></span><br><span class="line"><span class="comment">origin  git://github.com/schacon/ticgit.git (push)*/</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*如果有多个远程仓库，此命令将全部列出。比如在我的 Grit 项目中，可以看到：*/</span></span><br><span class="line"></span><br><span class="line">$ cd grit</span><br><span class="line">$ git remote -v</span><br><span class="line">bakkdoor  git:<span class="comment">//github.com/bakkdoor/grit.git</span></span><br><span class="line">cho45     git:<span class="comment">//github.com/cho45/grit.git</span></span><br><span class="line">defunkt   git:<span class="comment">//github.com/defunkt/grit.git</span></span><br><span class="line">koke      git:<span class="comment">//github.com/koke/grit.git</span></span><br><span class="line">origin    git<span class="meta">@github</span>.com:mojombo/grit.git</span><br><span class="line"><span class="comment">/*这样一来，我就可以非常轻松地从这些用户的仓库中，拉取他们的提交到本地。*/</span></span><br><span class="line"><span class="comment">/*需要注意，上面列出的地址只有 origin 用的是 SSH URL 链接，所以也只有这个仓库能推送数据上去。*/</span></span><br></pre></td></tr></table></figure><h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用，运行git remote add [shortname] [url]：*/</span></span><br><span class="line"></span><br><span class="line">$ git remote</span><br><span class="line">    </span><br><span class="line">origin</span><br><span class="line">    </span><br><span class="line">$ git remote add pb git:<span class="comment">//github.com/paulboone/ticgit.git</span></span><br><span class="line"></span><br><span class="line">$ git remote -v</span><br><span class="line">    </span><br><span class="line">origin  git:<span class="comment">//github.com/schacon/ticgit.git</span></span><br><span class="line">pb  git:<span class="comment">//github.com/paulboone/ticgit.git</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*现在可以用字符串 pb 指代对应的仓库地址了。比如说，要抓取所有 Paul 有的，但本地仓库没有的信息，可以运行 git fetch pb：*/</span></span><br><span class="line"></span><br><span class="line">$ git fetch pb</span><br><span class="line">    </span><br><span class="line">remote: Counting objects: <span class="number">58</span>, done.</span><br><span class="line">remote: Compressing objects: <span class="number">100</span>% (<span class="number">41</span>/<span class="number">41</span>), done.</span><br><span class="line">remote: Total <span class="number">44</span> (delta <span class="number">24</span>), reused <span class="number">1</span> (delta <span class="number">0</span>)</span><br><span class="line">Unpacking objects: <span class="number">100</span>% (<span class="number">44</span>/<span class="number">44</span>), done.</span><br><span class="line">From git:<span class="comment">//github.com/paulboone/ticgit</span></span><br><span class="line"> * [<span class="keyword">new</span> <span class="title class_">branch</span>]      master     -&gt; pb/master</span><br><span class="line"> * [<span class="keyword">new</span> <span class="title class_">branch</span>]      ticgit     -&gt; pb/ticgit</span><br><span class="line">     </span><br><span class="line"><span class="comment">/*现在，Paul 的主干分支（master）已经完全可以在本地访问了，对应的名字是 pb/master，你可以将它合并到自己的某个分支，或者切换到这个分支。*/</span></span><br></pre></td></tr></table></figure><h3 id="从远程仓库抓取数据"><a href="#从远程仓库抓取数据" class="headerlink" title="从远程仓库抓取数据"></a>从远程仓库抓取数据</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*可以用下面的命令从远程仓库抓取数据到本地：*/</span></span><br><span class="line"></span><br><span class="line">$ git fetch [remote-name]</span><br><span class="line"></span><br><span class="line"><span class="comment">/*此命令会到远程仓库中拉取所有你本地仓库中还没有的数据。运行完成后，你就可以在本地访问该远程仓库中的所有分支，将其中某个分支合并到本地，或者只是取出某个分支，一探究竟。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果是克隆了一个仓库，此命令会自动将远程仓库归于 origin 名下。*/</span></span><br><span class="line"><span class="comment">/*所以，git fetch origin 会抓取从你上次克隆以来别人上传到此远程仓库中的所有更新（或是上次 fetch 以来别人提交的更新）。*/</span></span><br><span class="line"><span class="comment">/*有一点很重要，需要记住，fetch 命令只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支，只有当你确实准备好了，才能手工合并。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果设置了某个分支用于跟踪某个远端仓库的分支，可以使用git pull命令自动抓取数据下来，然后将远端分支自动合并到本地仓库中当前分支。*/</span></span><br><span class="line"><span class="comment">/*在日常工作中我们经常这么用，既快且好。实际上，默认情况下 git clone 命令本质上就是自动创建了本地的 master 分支用于跟踪远程仓库中的 master 分支（假设远程仓库确实有 master 分支）。所以一般我们运行 git pull，目的都是要从原始克隆的远端仓库中抓取数据后，合并到工作目录中的当前分支。*/</span></span><br></pre></td></tr></table></figure><h3 id="推送数据到远程仓库"><a href="#推送数据到远程仓库" class="headerlink" title="推送数据到远程仓库"></a>推送数据到远程仓库</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*项目进行到一个阶段，要同别人分享目前的成果，可以将本地仓库中的数据推送到远程仓库。*/</span></span><br><span class="line"><span class="comment">/*实现这个任务的命令很简单： git push [remote-name] [branch-name]。*/</span></span><br><span class="line"><span class="comment">/*如果要把本地的 master 分支推送到 origin 服务器上（再次说明下，克隆操作会自动使用默认的 master 和 origin 名字），可以运行下面的命令：*/</span></span><br><span class="line"></span><br><span class="line">$ git push origin master</span><br><span class="line"></span><br><span class="line"><span class="comment">/*只有在所克隆的服务器上有写权限，或者同一时刻没有其他人在推数据，这条命令才会如期完成任务。*/</span></span><br><span class="line"><span class="comment">/*如果在你推数据前，已经有其他人推送了若干更新，那你的推送操作就会被驳回。你必须先把他们的更新抓取到本地，合并到自己的项目中，然后才可以再次推送。*/</span></span><br></pre></td></tr></table></figure><h3 id="查看远程仓库信息"><a href="#查看远程仓库信息" class="headerlink" title="查看远程仓库信息"></a>查看远程仓库信息</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*可以通过命令 git remote show [remote-name] 查看某个远程仓库的详细信息，比如要看所克隆的 origin 仓库，可以运行：*/</span></span><br><span class="line"></span><br><span class="line">$ git remote show origin</span><br><span class="line">    </span><br><span class="line">* remote origin</span><br><span class="line">  URL: git:<span class="comment">//github.com/schacon/ticgit.git</span></span><br><span class="line">  Remote branch merged with <span class="string">&#x27;git pull&#x27;</span> <span class="keyword">while</span> on branch master</span><br><span class="line">    master</span><br><span class="line">  Tracked remote branches</span><br><span class="line">    master</span><br><span class="line">    ticgit</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*除了对应的克隆地址外，它还给出了许多额外的信息。它友善地告诉你如果是在 master 分支，就可以用 git pull 命令抓取数据合并到本地。另外还列出了所有处于跟踪状态中的远端分支。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*随着使用 Git 的深入，git remote show 给出的信息可能会像这样：*/</span></span><br><span class="line"></span><br><span class="line">$ git remote show origin</span><br><span class="line">      </span><br><span class="line">* remote origin</span><br><span class="line">  URL: git<span class="meta">@github</span>.com:defunkt/github.git</span><br><span class="line">  Remote branch merged with <span class="string">&#x27;git pull&#x27;</span> <span class="keyword">while</span> on branch issues</span><br><span class="line">    issues</span><br><span class="line">  Remote branch merged with <span class="string">&#x27;git pull&#x27;</span> <span class="keyword">while</span> on branch master</span><br><span class="line">    master</span><br><span class="line">  New remote <span class="title function_">branches</span> <span class="params">(next fetch will store in remotes/origin)</span></span><br><span class="line">    caching</span><br><span class="line">  Stale tracking <span class="title function_">branches</span> <span class="params">(use <span class="string">&#x27;git remote prune&#x27;</span>)</span></span><br><span class="line">    libwalker</span><br><span class="line">    walker2</span><br><span class="line">  Tracked remote branches</span><br><span class="line">    acl</span><br><span class="line">    apiv2</span><br><span class="line">    dashboard2</span><br><span class="line">    issues</span><br><span class="line">    master</span><br><span class="line">    postgres</span><br><span class="line">  Local branch pushed with <span class="string">&#x27;git push&#x27;</span></span><br><span class="line">    master:master</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*它告诉我们，运行 git push 时缺省推送的分支是什么（译注：最后两行）。*/</span></span><br><span class="line"><span class="comment">/*它还显示了有哪些远端分支还没有同步到本地（译注：第六行的 caching 分支），哪些已同步到本地的远端分支在远端服务器上已被删除（译注：Stale tracking branches下面的两个分支），以及运行 git pull 时将自动合并哪些分支（译注：前四行中列出的 issues 和 master 分支）。*/</span></span><br></pre></td></tr></table></figure><h3 id="远程仓库的删除和重命名"><a href="#远程仓库的删除和重命名" class="headerlink" title="远程仓库的删除和重命名"></a>远程仓库的删除和重命名</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*可以用 git remote rename命令修改某个远程仓库在本地的简称，比如想把 pb 改成 paul，可以这么运行：*/</span></span><br><span class="line"></span><br><span class="line">$ git remote rename pb paul</span><br><span class="line">$ git remote</span><br><span class="line">    </span><br><span class="line">origin</span><br><span class="line">paul</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*注意，对远程仓库的重命名，也会使对应的分支名称发生变化，原来的 pb/master 分支现在成了 paul/master。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*碰到远端仓库服务器迁移，或者原来的克隆镜像不再使用，又或者某个参与者不再贡献代码，那么需要移除对应的远端仓库，可以运行 git remote rm 命令：*/</span></span><br><span class="line"></span><br><span class="line">$ git remote rm paul</span><br><span class="line">$ git remote</span><br><span class="line">    </span><br><span class="line">origin</span><br></pre></td></tr></table></figure><h2 id="Git打标签"><a href="#Git打标签" class="headerlink" title="Git打标签"></a>Git打标签</h2><h3 id="列出已有标签"><a href="#列出已有标签" class="headerlink" title="列出已有标签"></a>列出已有标签</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line">v0<span class="number">.1</span></span><br><span class="line">v1<span class="number">.3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*显示的标签按字母顺序排列，所以标签的先后并不表示重要程度的轻重。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*我们可以用特定的搜索模式列出符合条件的标签。*/</span></span><br><span class="line"><span class="comment">/*在 Git 自身项目仓库中，有着超过 240 个标签，如果你只对 1.4.2 系列的版本感兴趣，可以运行下面的命令：*/</span></span><br><span class="line"></span><br><span class="line">$ git tag -l <span class="string">&#x27;v1.4.2.*&#x27;</span></span><br><span class="line">    </span><br><span class="line">v1<span class="number">.4</span><span class="number">.2</span><span class="number">.1</span></span><br><span class="line">v1<span class="number">.4</span><span class="number">.2</span><span class="number">.2</span></span><br><span class="line">v1<span class="number">.4</span><span class="number">.2</span><span class="number">.3</span></span><br><span class="line">v1<span class="number">.4</span><span class="number">.2</span><span class="number">.4</span></span><br></pre></td></tr></table></figure><h3 id="新建标签"><a href="#新建标签" class="headerlink" title="新建标签"></a>新建标签</h3><p>Git 使用的标签有两种类型：轻量级的（lightweight）和含附注的（annotated）。</p><p>轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用。</p><p>而含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证。</p><p>一般我们都建议使用含附注型的标签，以便保留相关信息；当然，如果只是临时性加注标签，或者不需要旁注额外信息，用轻量级标签也没问题。 </p><h3 id="含附注的标签"><a href="#含附注的标签" class="headerlink" title="含附注的标签"></a>含附注的标签</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*创建一个含附注类型的标签非常简单，用 -a （译注：取 annotated 的首字母）指定标签名字即可：*/</span></span><br><span class="line"></span><br><span class="line">$ git tag -a v1<span class="number">.4</span> -m <span class="string">&#x27;my version 1.4&#x27;</span></span><br><span class="line">$ git tag</span><br><span class="line">    </span><br><span class="line">v0<span class="number">.1</span></span><br><span class="line">v1<span class="number">.3</span></span><br><span class="line">v1<span class="number">.4</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*而 -m 选项则指定了对应的标签说明，Git 会将此说明一同保存在标签对象中。如果没有给出该选项，Git 会启动文本编辑软件供你输入标签说明。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*可以使用 git show 命令查看相应标签的版本信息，并连同显示打标签时的提交对象。*/</span></span><br><span class="line"></span><br><span class="line">$ git show v1<span class="number">.4</span></span><br><span class="line">    </span><br><span class="line">tag v1<span class="number">.4</span></span><br><span class="line">Tagger: Scott Chacon &lt;schacon<span class="meta">@gee</span>-mail.com&gt;</span><br><span class="line">Date:   Mon Feb <span class="number">9</span> <span class="number">14</span>:<span class="number">45</span>:<span class="number">11</span> <span class="number">2009</span> -0800</span><br><span class="line"></span><br><span class="line">my version <span class="number">1.4</span></span><br><span class="line"></span><br><span class="line">commit 15027957951b64cf874c3557a0f3547bd83b3ff6</span><br><span class="line">Merge: 4a447f7... a6b4c97...</span><br><span class="line">Author: Scott Chacon &lt;schacon<span class="meta">@gee</span>-mail.com&gt;</span><br><span class="line">Date:   Sun Feb <span class="number">8</span> <span class="number">19</span>:<span class="number">02</span>:<span class="number">46</span> <span class="number">2009</span> -0800</span><br><span class="line"></span><br><span class="line">    Merge branch <span class="string">&#x27;experiment&#x27;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*可以看到在提交对象信息上面，列出了此标签的提交者和提交时间，以及相应的标签说明。*/</span></span><br></pre></td></tr></table></figure><h3 id="签署标签"><a href="#签署标签" class="headerlink" title="签署标签"></a>签署标签</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*如果你有自己的私钥，还可以用 GPG 来签署标签，只需要把之前的 -a 改为 -s（译注： 取 signed 的首字母）即可：*/</span></span><br><span class="line"></span><br><span class="line">$ git tag -s v1<span class="number">.5</span> -m <span class="string">&#x27;my signed 1.5 tag&#x27;</span></span><br><span class="line"></span><br><span class="line">You need a passphrase to unlock the secret key <span class="keyword">for</span></span><br><span class="line">user: <span class="string">&quot;Scott Chacon &lt;schacon@gee-mail.com&gt;&quot;</span></span><br><span class="line"><span class="number">1024</span>-bit DSA key, ID F721C45A, created <span class="number">2009</span>-<span class="number">02</span>-09</span><br><span class="line"></span><br><span class="line"><span class="comment">/*现在再运行 git show 会看到对应的 GPG 签名也附在其内：*/</span></span><br><span class="line"></span><br><span class="line">$ git show v1<span class="number">.5</span></span><br><span class="line"></span><br><span class="line">tag v1<span class="number">.5</span></span><br><span class="line">Tagger: Scott Chacon &lt;schacon<span class="meta">@gee</span>-mail.com&gt;</span><br><span class="line">Date:   Mon Feb <span class="number">9</span> <span class="number">15</span>:<span class="number">22</span>:<span class="number">20</span> <span class="number">2009</span> -0800</span><br><span class="line"></span><br><span class="line">my signed <span class="number">1.5</span> tag</span><br><span class="line">-----BEGIN PGP SIGNATURE-----</span><br><span class="line">Version: GnuPG v1<span class="number">.4</span><span class="number">.8</span> (Darwin)</span><br><span class="line"></span><br><span class="line">iEYEABECAAYFAkmQurIACgkQON3DxfchxFr5cACeIMN+ZxLKggJQf0QYiQBwgySN</span><br><span class="line">Ki0An2JeAVUCAiJ7Ox6ZEtK+NvZAj82/</span><br><span class="line">=WryJ</span><br><span class="line">-----END PGP SIGNATURE-----</span><br><span class="line">commit 15027957951b64cf874c3557a0f3547bd83b3ff6</span><br><span class="line">Merge: 4a447f7... a6b4c97...</span><br><span class="line">Author: Scott Chacon &lt;schacon<span class="meta">@gee</span>-mail.com&gt;</span><br><span class="line">Date:   Sun Feb <span class="number">8</span> <span class="number">19</span>:<span class="number">02</span>:<span class="number">46</span> <span class="number">2009</span> -0800</span><br><span class="line"></span><br><span class="line">    Merge branch <span class="string">&#x27;experiment&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="轻量级标签"><a href="#轻量级标签" class="headerlink" title="轻量级标签"></a>轻量级标签</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*轻量级标签实际上就是一个保存着对应提交对象的校验和信息的文件。要创建这样的标签，一个 -a，-s 或 -m 选项都不用，直接给出标签名字即可：*/</span></span><br><span class="line"></span><br><span class="line">$ git tag v1<span class="number">.4</span>-lw</span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line">v0<span class="number">.1</span></span><br><span class="line">v1<span class="number">.3</span></span><br><span class="line">v1<span class="number">.4</span></span><br><span class="line">v1<span class="number">.4</span>-lw</span><br><span class="line">v1<span class="number">.5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*现在运行 git show 查看此标签信息，就只有相应的提交对象摘要：*/</span></span><br><span class="line"></span><br><span class="line">$ git show v1<span class="number">.4</span>-lw</span><br><span class="line"></span><br><span class="line">commit 15027957951b64cf874c3557a0f3547bd83b3ff6</span><br><span class="line">Merge: 4a447f7... a6b4c97...</span><br><span class="line">Author: Scott Chacon &lt;schacon<span class="meta">@gee</span>-mail.com&gt;</span><br><span class="line">Date:   Sun Feb <span class="number">8</span> <span class="number">19</span>:<span class="number">02</span>:<span class="number">46</span> <span class="number">2009</span> -0800</span><br><span class="line"></span><br><span class="line">    Merge branch <span class="string">&#x27;experiment&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="验证标签"><a href="#验证标签" class="headerlink" title="验证标签"></a>验证标签</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*可以使用 git tag -v [tag-name] （译注：取 verify 的首字母）的方式验证已经签署的标签。*/</span></span><br><span class="line"><span class="comment">/*此命令会调用 GPG 来验证签名，所以你需要有签署者的公钥，存放在 keyring 中，才能验证：*/</span></span><br><span class="line"></span><br><span class="line">$ git tag -v v1<span class="number">.4</span><span class="number">.2</span><span class="number">.1</span></span><br><span class="line"></span><br><span class="line">object 883653babd8ee7ea23e6a5c392bb739348b1eb61</span><br><span class="line">type commit</span><br><span class="line">tag v1<span class="number">.4</span><span class="number">.2</span><span class="number">.1</span></span><br><span class="line">tagger Junio C Hamano &lt;junkio<span class="meta">@cox</span>.net&gt; <span class="number">1158138501</span> -<span class="number">0700</span></span><br><span class="line"></span><br><span class="line">GIT <span class="number">1.4</span><span class="number">.2</span><span class="number">.1</span></span><br><span class="line"></span><br><span class="line">Minor fixes since <span class="number">1.4</span><span class="number">.2</span>, including git-mv and git-http with alternates.</span><br><span class="line">gpg: Signature made Wed Sep <span class="number">13</span> <span class="number">02</span>:08:<span class="number">25</span> <span class="number">2006</span> PDT using DSA key ID F3119B9A</span><br><span class="line">gpg: Good signature from <span class="string">&quot;Junio C Hamano &lt;junkio@cox.net&gt;&quot;</span></span><br><span class="line">gpg:                 aka <span class="string">&quot;[jpeg image of size 1513]&quot;</span></span><br><span class="line">Primary key fingerprint: <span class="number">3565</span> 2A26 <span class="number">2040</span> E066 C9A7  4A7D C0C6 D9A4 F311 9B9A</span><br><span class="line"></span><br><span class="line"><span class="comment">/*若是没有签署者的公钥，会报告类似下面这样的错误：*/</span></span><br><span class="line"></span><br><span class="line">gpg: Signature made Wed Sep <span class="number">13</span> <span class="number">02</span>:08:<span class="number">25</span> <span class="number">2006</span> PDT using DSA key ID F3119B9A</span><br><span class="line">gpg: Can<span class="string">&#x27;t check signature: public key not found</span></span><br><span class="line"><span class="string">error: could not verify the tag &#x27;</span>v1<span class="number">.4</span><span class="number">.2</span><span class="number">.1</span><span class="string">&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="后期加注标签"><a href="#后期加注标签" class="headerlink" title="后期加注标签"></a>后期加注标签</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*可以在后期对早先的某次提交加注标签。比如在下面展示的提交历史中：*/</span></span><br><span class="line"></span><br><span class="line">$ git log --pretty=oneline</span><br><span class="line"></span><br><span class="line">15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch <span class="string">&#x27;experiment&#x27;</span></span><br><span class="line">a6b4c97498bd301d84096da251c98a07c7723e65 beginning write support</span><br><span class="line">0d52aaab4479697da7686c15f77a3d64d9165190 one more thing</span><br><span class="line">6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch <span class="string">&#x27;experiment&#x27;</span></span><br><span class="line">0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function</span><br><span class="line">4682c3261057305bdd616e23b64b0857d832627b added a todo file</span><br><span class="line">166ae0c4d3f420721acbb115cc33848dfcc2121a started write support</span><br><span class="line">9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile</span><br><span class="line">964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo</span><br><span class="line">8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme</span><br><span class="line"></span><br><span class="line"><span class="comment">/*我们忘了在提交 “updated rakefile” 后为此项目打上版本号 v1.2，没关系，现在也能做。只要在打标签的时候跟上对应提交对象的校验和（或前几位字符）即可：*/</span></span><br><span class="line"></span><br><span class="line">$ git tag -a v1<span class="number">.2</span> 9fceb02</span><br><span class="line"></span><br><span class="line">可以看到我们已经补上了标签：</span><br><span class="line"></span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line">v0<span class="number">.1</span></span><br><span class="line">v1<span class="number">.2</span></span><br><span class="line">v1<span class="number">.3</span></span><br><span class="line">v1<span class="number">.4</span></span><br><span class="line">v1<span class="number">.4</span>-lw</span><br><span class="line">v1<span class="number">.5</span></span><br><span class="line"></span><br><span class="line">$ git show v1<span class="number">.2</span></span><br><span class="line"></span><br><span class="line">tag v1<span class="number">.2</span></span><br><span class="line">Tagger: Scott Chacon &lt;schacon<span class="meta">@gee</span>-mail.com&gt;</span><br><span class="line">Date:   Mon Feb <span class="number">9</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">16</span> <span class="number">2009</span> -0800</span><br><span class="line"></span><br><span class="line">version <span class="number">1.2</span></span><br><span class="line">commit 9fceb02d0ae598e95dc970b74767f19372d61af8</span><br><span class="line">Author: Magnus Chacon &lt;mchacon<span class="meta">@gee</span>-mail.com&gt;</span><br><span class="line">Date:   Sun Apr <span class="number">27</span> <span class="number">20</span>:<span class="number">43</span>:<span class="number">35</span> <span class="number">2008</span> -<span class="number">0700</span></span><br><span class="line"></span><br><span class="line">    updated rakefile</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="分享标签"><a href="#分享标签" class="headerlink" title="分享标签"></a>分享标签</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*默认情况下，git push 并不会把标签传送到远端服务器上，只有通过显式命令才能分享标签到远端仓库。*/</span></span><br><span class="line"><span class="comment">/*其命令格式如同推送分支，运行git push origin [tagname]即可：*/</span></span><br><span class="line"></span><br><span class="line">$ git push origin v1<span class="number">.5</span></span><br><span class="line">    </span><br><span class="line">Counting objects: <span class="number">50</span>, done.</span><br><span class="line">Compressing objects: <span class="number">100</span>% (<span class="number">38</span>/<span class="number">38</span>), done.</span><br><span class="line">Writing objects: <span class="number">100</span>% (<span class="number">44</span>/<span class="number">44</span>), <span class="number">4.56</span> KiB, done.</span><br><span class="line">Total <span class="number">44</span> (delta <span class="number">18</span>), reused <span class="number">8</span> (delta <span class="number">1</span>)</span><br><span class="line">To git<span class="meta">@github</span>.com:schacon/simplegit.git</span><br><span class="line">* [<span class="keyword">new</span> <span class="title class_">tag</span>]         v1<span class="number">.5</span> -&gt; v1<span class="number">.5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果要一次推送所有本地新增的标签上去，可以使用 --tags 选项：*/</span></span><br><span class="line"></span><br><span class="line">$ git push origin --tags</span><br><span class="line">    </span><br><span class="line">Counting objects: <span class="number">50</span>, done.</span><br><span class="line">Compressing objects: <span class="number">100</span>% (<span class="number">38</span>/<span class="number">38</span>), done.</span><br><span class="line">Writing objects: <span class="number">100</span>% (<span class="number">44</span>/<span class="number">44</span>), <span class="number">4.56</span> KiB, done.</span><br><span class="line">Total <span class="number">44</span> (delta <span class="number">18</span>), reused <span class="number">8</span> (delta <span class="number">1</span>)</span><br><span class="line">To git<span class="meta">@github</span>.com:schacon/simplegit.git</span><br><span class="line"> * [<span class="keyword">new</span> <span class="title class_">tag</span>]         v0<span class="number">.1</span> -&gt; v0<span class="number">.1</span></span><br><span class="line"> * [<span class="keyword">new</span> <span class="title class_">tag</span>]         v1<span class="number">.2</span> -&gt; v1<span class="number">.2</span></span><br><span class="line"> * [<span class="keyword">new</span> <span class="title class_">tag</span>]         v1<span class="number">.4</span> -&gt; v1<span class="number">.4</span></span><br><span class="line"> * [<span class="keyword">new</span> <span class="title class_">tag</span>]         v1<span class="number">.4</span>-lw -&gt; v1<span class="number">.4</span>-lw</span><br><span class="line"> * [<span class="keyword">new</span> <span class="title class_">tag</span>]         v1<span class="number">.5</span> -&gt; v1<span class="number">.5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*现在，其他人克隆共享仓库或拉取数据同步后，也会看到这些标签。*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客更新日志及踩坑经验总结</title>
      <link href="/FRank675.github.io/posts/6033a1afd5e7/"/>
      <url>/FRank675.github.io/posts/6033a1afd5e7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="Hexo博客更新日志及踩坑经验总结"><a href="#Hexo博客更新日志及踩坑经验总结" class="headerlink" title="Hexo博客更新日志及踩坑经验总结"></a>Hexo博客更新日志及踩坑经验总结</h1><h2 id="博客功能"><a href="#博客功能" class="headerlink" title="博客功能"></a>博客功能</h2><ul><li><input checked="" disabled="" type="checkbox"> 基本的Blog文章更新</li><li><input checked="" disabled="" type="checkbox"> 博客文章的分类、标签、归档</li><li><input checked="" disabled="" type="checkbox"> Blog界面优化</li><li><input checked="" disabled="" type="checkbox"> 本地搜索博客功能</li><li><input checked="" disabled="" type="checkbox"> 留言功能（有点问题QAQ待完善）</li><li><input checked="" disabled="" type="checkbox"> 侧边栏时钟</li><li><input checked="" disabled="" type="checkbox"> 音乐🎵功能，可以播放网易云的歌单啦</li><li><input checked="" disabled="" type="checkbox"> 解决上线后icon不显示的问题</li><li><input checked="" disabled="" type="checkbox"> 增加了看板娘（其实是可爱的小男生）</li><li><input disabled="" type="checkbox"> SEO优化</li><li><input disabled="" type="checkbox"> 页脚徽标</li><li><input disabled="" type="checkbox"> 字体样式修改</li><li><input disabled="" type="checkbox"> 滚动的副标题</li></ul><h2 id="一些于我有用的博主文章"><a href="#一些于我有用的博主文章" class="headerlink" title="一些于我有用的博主文章"></a>一些于我有用的博主文章</h2><p> <a href="https://guole.fun/posts/butterfly-custom/">我的Blog美化日记——Hexo+Butterfly | Guo Le’s Blog</a> </p><p> <a href="https://blog.csdn.net/qq_46435629/article/details/106295515?spm=1001.2101.3001.6650.4&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-4-106295515-blog-123481948.pc_relevant_antiscanv2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-4-106295515-blog-123481948.pc_relevant_antiscanv2&utm_relevant_index=6">如何在Hexo博客Butterfly主题开启Aplayer和“音乐”页面</a> </p><p> <a href="https://www.yyyzyyyz.cn/posts/2d51c9bd3490/">hexo-butterfly魔改记录大全 | Black Flies (yyyzyyyz.cn)</a> </p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欢迎来到舜桀BB的秘密基地！</title>
      <link href="/FRank675.github.io/posts/2fa1216955e2/"/>
      <url>/FRank675.github.io/posts/2fa1216955e2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>欢迎来到<strong>舜桀BB</strong>的秘密基地呀！<br>在这里你会看到我的日常分享，你也可以通过留言功能与我交流。<br>希望你我都能在这个复杂的世界找到一份专属于自己的喜乐！</p><img src="https://s3.bmp.ovh/imgs/2022/05/16/e5404ce657de463a.png" />]]></content>
      
      
      <categories>
          
          <category> 博客相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 欢迎 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
